{"id": 386797, "name": "Vampire number", "source": "Translate Ruby to C#: def factor_pairs n\n  first = n / (10 ** (n.to_s.size / 2) - 1)\n  (first .. n ** 0.5).map { |i| [i, n / i] if n % i == 0 }.compact\nend\n\ndef vampire_factors n\n  return [] if n.to_s.size.odd?\n  half = n.to_s.size / 2\n  factor_pairs(n).select do |a, b|\n    a.to_s.size == half && b.to_s.size == half &&\n    [a, b].count {|x| x%10 == 0} != 2          &&\n    \"\n  end\nend\n\ni = vamps = 0\nuntil vamps == 25\n  vf = vampire_factors(i += 1)\n  unless vf.empty?\n    puts \"\n    vamps += 1\n  end\nend\n\n[16758243290880, 24959017348650, 14593825548650].each do |n|\n  if (vf = vampire_factors n).empty?\n    puts \"\n  else\n    puts \"\n  end\nend\n", "target": "using System;\n\nnamespace RosettaVampireNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int i, j, n;\n            ulong x;\n            var f = new ulong[16];\n            var bigs = new ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };\n            ulong[] tens = new ulong[20];\n            tens[0] = 1;\n            for (i = 1; i < 20; i++)\n                tens[i] = tens[i - 1] * 10;\n            \n            for (x = 1, n = 0; n < 25; x++)\n            {\n                if ((j = fangs(x, f, tens)) == 0) continue;\n                Console.Write(++n + \": \");\n                show_fangs(x, f, j);\n            }\n\n            Console.WriteLine();\n            for (i = 0; bigs[i] > 0 ; i++)\n            {\n                if ((j = fangs(bigs[i], f, tens)) > 0)\n                    show_fangs(bigs[i], f, j);\n                else\n                    Console.WriteLine(bigs[i] + \" is not vampiric.\");\n            }\n            Console.ReadLine();\n        }\n\n        private static void show_fangs(ulong x, ulong[] f, int cnt)\n        {\n            Console.Write(x); \n            int i;\n            for (i = 0; i < cnt; i++)\n                Console.Write(\" =\u00a0\" + f[i] + \" * \" + (x / f[i]));\n            Console.WriteLine();\n        }\n\n        private static int fangs(ulong x, ulong[] f, ulong[] tens)\n        {\n            int n = 0;\n            int nd = ndigits(x);\n            if ((nd & 1) > 0) return 0;\n            nd /= 2;\n\n            ulong lo, hi;\n            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));\n            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));\n\n            ulong a, b, t = dtally(x);\n            for (a = lo; a <= hi; a++)\n            {\n                b = x / a;\n                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))\n                    f[n++] = a;\n            }\n\n            return n;\n        }\n\n        private static ulong dtally(ulong x)\n        {\n            ulong t = 0;\n            while (x > 0)\n            {\n                t += 1UL << (int)((x % 10) * 6);\n                x /= 10;\n            }\n\n            return t;\n        }\n\n        private static int ndigits(ulong x)\n        {\n            int n = 0;\n            while (x > 0)\n            {\n                n++;\n                x /= 10;\n            }\n            return n;\n        }\n    }\n}\n"}
{"id": 386798, "name": "Play recorded sounds", "source": "Translate Ruby to C#: require 'win32/sound'\ninclude Win32\n\nsound1 = ENV['WINDIR'] + '\\Media\\Windows XP Startup.wav' \nsound2 = ENV['WINDIR'] + '\\Media\\Windows XP Shutdown.wav' \n\nputs \"play the sounds sequentially\"\n[sound1, sound2].each do |s| \n  t1 = Time.now\n  Sound.play(s)\n  puts \"'\nend\n\nputs \"attempt to play the sounds simultaneously\"\n[sound1, sound2].each {|s| Sound.play(s, Sound::ASYNC)}\n\nputs <<END\nthe above only plays the second sound2 because the library only appears \nto be able to play one sound at a time.\nEND\n\nputs \"loop a sound for a few seconds\"\nputs Time.now\nSound.play(sound1, Sound::ASYNC + Sound::LOOP)\nsleep 10\nSound.stop\nputs Time.now\n\nputs \"manipulate the volume\"\nvol_left, vol_right = Sound.wave_volume\nSound.play(sound1, Sound::ASYNC)\nsleep 1\nputs \"right channel quiet\"\nSound.set_wave_volume(vol_left, 0)\nsleep 1\nputs \"left channel quiet\"\nSound.set_wave_volume(0, vol_right)\nsleep 1\nputs \"restore volume\"\nSound.set_wave_volume(vol_left, vol_right)\n\nsleep 1\nputs \"the asynchronous sound is cancelled when the program exits\"\n", "target": "using System;\nusing System.Threading;\nusing System.Media;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        SoundPlayer s1 = new SoundPlayer(); \n        s1.SoundLocation = file; \n\n        \n        s1.Play();     \n\n        \n        s1.Play();\n        Thread.Sleep(100);\n        s1.Stop();\n\n        \n        s1.PlayLooping();\n    }\n}\n"}
{"id": 386799, "name": "Poker hand analyser", "source": "Translate Ruby to C#: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class PokerHandAnalyzer\n{\n    private enum Hand {\n        Invalid, High_Card, One_Pair, Two_Pair, Three_Of_A_Kind, Straight,\n        Flush, Full_House, Four_Of_A_Kind, Straight_Flush, Five_Of_A_Kind\n    }\n\n    private const bool Y = true;\n    private const char C = '\u2663', D = '\u2666', H = '\u2665', S = '\u2660';\n    private const int rankMask = 0b11_1111_1111_1111;\n    private const int suitMask = 0b1111 << 14;\n    private static readonly string[] ranks = { \"a\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"j\", \"q\", \"k\" };\n    private static readonly string[] suits = { C + \"\", D + \"\", H + \"\", S + \"\" };\n    private static readonly Card[] deck = (from suit in Range(1, 4) from rank in Range(1, 13) select new Card(rank, suit)).ToArray();\n\n    public static void Main() {\n        string[] hands = {\n            \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\",\n            \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\",\n            \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\",\n            \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\",\n            \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\",\n            \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\",\n            \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\",\n            \"4\u2665 4\u2663 4\u2665 4\u2660 4\u2666\", \n            \"joker 2\u2666 2\u2660 k\u2660 q\u2666\",\n            \"joker 5\u2665 7\u2666 8\u2660 9\u2666\",\n            \"joker 2\u2666 3\u2660 4\u2660 5\u2660\",\n            \"joker 3\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 7\u2666 7\u2660 7\u2663\",\n            \"joker j\u2665 q\u2665 k\u2665 A\u2665\",\n            \"joker 4\u2663 k\u2663 5\u2666 10\u2660\",\n            \"joker k\u2663 7\u2663 6\u2663 4\u2663\",\n            \"joker 2\u2666 joker 4\u2660 5\u2660\",\n            \"joker Q\u2666 joker A\u2660 10\u2660\",\n            \"joker Q\u2666 joker A\u2666 10\u2666\",\n            \"joker 2\u2666 2\u2660 joker q\u2666\"\n        };\n        foreach (var h in hands) {\n            Console.WriteLine($\"{h}: {Analyze(h).Name()}\");\n        }\n    }\n\n    static string Name(this Hand hand) => string.Join('-', hand.ToString().Split('_')).ToLower();\n\n    static List<T> With<T>(this List<T> list, int index, T item) {\n        list[index] = item;\n        return list;\n    }\n\n    struct Card : IEquatable<Card>, IComparable<Card>\n    {\n        public static readonly Card Invalid = new Card(-1, -1);\n        public static readonly Card Joker = new Card(0, 0);\n\n        public Card(int rank, int suit) {\n            (Rank, Suit, Code) = (rank, suit) switch {\n                (_, -1) => (-1, -1, -1),\n                (-1, _) => (-1, -1, -1),\n                (0, _) => (0, 0, 0),\n                (1, _) => (rank, suit, (1 << (13 + suit)) | ((1 << 13) | 1)),\n                (_, _) => (rank, suit, (1 << (13 + suit)) | (1 << (rank - 1)))\n            };\n        }\n\n        public static implicit operator Card((int rank, int suit) tuple) => new Card(tuple.rank, tuple.suit);\n        public int Rank { get; }\n        public int Suit { get; }\n        public int Code { get; }\n\n        public override string ToString() => Rank switch {\n            -1 => \"invalid\",\n            0 => \"joker\",\n            _ => $\"{ranks[Rank-1]}{suits[Suit-1]}\"\n        };\n        \n        public override int GetHashCode() => Rank << 16 | Suit;\n        public bool Equals(Card other) => Rank == other.Rank && Suit == other.Suit;\n\n        public int CompareTo(Card other) {\n            int c = Rank.CompareTo(other.Rank);\n            if (c != 0) return c;\n            return Suit.CompareTo(other.Suit);\n        }\n    }\n\n    static Hand Analyze(string hand) {\n        var cards = ParseHand(hand);\n        if (cards.Count != 5) return Hand.Invalid; \n        cards.Sort();\n        if (cards[0].Equals(Card.Invalid)) return Hand.Invalid;\n        int jokers = cards.LastIndexOf(Card.Joker) + 1;\n        if (jokers > 2) return Hand.Invalid; \n        if (cards.Skip(jokers).Distinct().Count() + jokers != 5) return Hand.Invalid; \n\n        if (jokers == 2) return (from c0 in deck from c1 in deck select Evaluate(cards.With(0, c0).With(1, c1))).Max();\n        if (jokers == 1) return (from c0 in deck select Evaluate(cards.With(0, c0))).Max();\n        return Evaluate(cards);\n    }\n\n    static List<Card> ParseHand(string hand) =>\n        hand.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        .Select(card => ParseCard(card.ToLower())).ToList();\n\n    static Card ParseCard(string card) => (card.Length, card) switch {\n        (5, \"joker\") => Card.Joker,\n        (3, _) when card[..2] == \"10\" => (10, ParseSuit(card[2])),\n        (2, _) => (ParseRank(card[0]), ParseSuit(card[1])),\n        (_, _) => Card.Invalid\n    };\n\n    static int ParseRank(char rank) => rank switch {\n        'a' => 1,\n        'j' => 11,\n        'q' => 12,\n        'k' => 13,\n        _ when rank >= '2' && rank <= '9' => rank - '0',\n        _ => -1\n    };\n\n    static int ParseSuit(char suit) => suit switch {\n        C => 1, 'c' => 1,\n        D => 2, 'd' => 2,\n        H => 3, 'h' => 3,\n        S => 4, 's' => 4,\n        _ => -1\n    };\n\n    static Hand Evaluate(List<Card> hand) {\n        var frequencies = hand.GroupBy(c => c.Rank).Select(g => g.Count()).OrderByDescending(c => c).ToArray();\n        (int f0, int f1) = (frequencies[0], frequencies.Length > 1 ? frequencies[1] : 0);\n\n        return (IsFlush(), IsStraight(), f0, f1) switch {\n            (_, _, 5, _) => Hand.Five_Of_A_Kind,\n            (Y, Y, _, _) => Hand.Straight_Flush,\n            (_, _, 4, _) => Hand.Four_Of_A_Kind,\n            (_, _, 3, 2) => Hand.Full_House,\n            (Y, _, _, _) => Hand.Flush,\n            (_, Y, _, _) => Hand.Straight,\n            (_, _, 3, _) => Hand.Three_Of_A_Kind,\n            (_, _, 2, 2) => Hand.Two_Pair,\n            (_, _, 2, _) => Hand.One_Pair,\n                        _ => Hand.High_Card\n        };\n\n        bool IsFlush() => hand.Aggregate(suitMask, (r, c) => r & c.Code) > 0;\n\n        bool IsStraight() {\n            int r = hand.Aggregate(0, (r, c) => r | c.Code) & rankMask;\n            for (int i = 0; i < 4; i++) r &= r << 1;\n            return r > 0;\n        }\n    }\n    \n}\n"}
{"id": 386800, "name": "Poker hand analyser", "source": "Translate Ruby to C#: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class PokerHandAnalyzer\n{\n    private enum Hand {\n        Invalid, High_Card, One_Pair, Two_Pair, Three_Of_A_Kind, Straight,\n        Flush, Full_House, Four_Of_A_Kind, Straight_Flush, Five_Of_A_Kind\n    }\n\n    private const bool Y = true;\n    private const char C = '\u2663', D = '\u2666', H = '\u2665', S = '\u2660';\n    private const int rankMask = 0b11_1111_1111_1111;\n    private const int suitMask = 0b1111 << 14;\n    private static readonly string[] ranks = { \"a\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"j\", \"q\", \"k\" };\n    private static readonly string[] suits = { C + \"\", D + \"\", H + \"\", S + \"\" };\n    private static readonly Card[] deck = (from suit in Range(1, 4) from rank in Range(1, 13) select new Card(rank, suit)).ToArray();\n\n    public static void Main() {\n        string[] hands = {\n            \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\",\n            \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\",\n            \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\",\n            \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\",\n            \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\",\n            \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\",\n            \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\",\n            \"4\u2665 4\u2663 4\u2665 4\u2660 4\u2666\", \n            \"joker 2\u2666 2\u2660 k\u2660 q\u2666\",\n            \"joker 5\u2665 7\u2666 8\u2660 9\u2666\",\n            \"joker 2\u2666 3\u2660 4\u2660 5\u2660\",\n            \"joker 3\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 7\u2666 7\u2660 7\u2663\",\n            \"joker j\u2665 q\u2665 k\u2665 A\u2665\",\n            \"joker 4\u2663 k\u2663 5\u2666 10\u2660\",\n            \"joker k\u2663 7\u2663 6\u2663 4\u2663\",\n            \"joker 2\u2666 joker 4\u2660 5\u2660\",\n            \"joker Q\u2666 joker A\u2660 10\u2660\",\n            \"joker Q\u2666 joker A\u2666 10\u2666\",\n            \"joker 2\u2666 2\u2660 joker q\u2666\"\n        };\n        foreach (var h in hands) {\n            Console.WriteLine($\"{h}: {Analyze(h).Name()}\");\n        }\n    }\n\n    static string Name(this Hand hand) => string.Join('-', hand.ToString().Split('_')).ToLower();\n\n    static List<T> With<T>(this List<T> list, int index, T item) {\n        list[index] = item;\n        return list;\n    }\n\n    struct Card : IEquatable<Card>, IComparable<Card>\n    {\n        public static readonly Card Invalid = new Card(-1, -1);\n        public static readonly Card Joker = new Card(0, 0);\n\n        public Card(int rank, int suit) {\n            (Rank, Suit, Code) = (rank, suit) switch {\n                (_, -1) => (-1, -1, -1),\n                (-1, _) => (-1, -1, -1),\n                (0, _) => (0, 0, 0),\n                (1, _) => (rank, suit, (1 << (13 + suit)) | ((1 << 13) | 1)),\n                (_, _) => (rank, suit, (1 << (13 + suit)) | (1 << (rank - 1)))\n            };\n        }\n\n        public static implicit operator Card((int rank, int suit) tuple) => new Card(tuple.rank, tuple.suit);\n        public int Rank { get; }\n        public int Suit { get; }\n        public int Code { get; }\n\n        public override string ToString() => Rank switch {\n            -1 => \"invalid\",\n            0 => \"joker\",\n            _ => $\"{ranks[Rank-1]}{suits[Suit-1]}\"\n        };\n        \n        public override int GetHashCode() => Rank << 16 | Suit;\n        public bool Equals(Card other) => Rank == other.Rank && Suit == other.Suit;\n\n        public int CompareTo(Card other) {\n            int c = Rank.CompareTo(other.Rank);\n            if (c != 0) return c;\n            return Suit.CompareTo(other.Suit);\n        }\n    }\n\n    static Hand Analyze(string hand) {\n        var cards = ParseHand(hand);\n        if (cards.Count != 5) return Hand.Invalid; \n        cards.Sort();\n        if (cards[0].Equals(Card.Invalid)) return Hand.Invalid;\n        int jokers = cards.LastIndexOf(Card.Joker) + 1;\n        if (jokers > 2) return Hand.Invalid; \n        if (cards.Skip(jokers).Distinct().Count() + jokers != 5) return Hand.Invalid; \n\n        if (jokers == 2) return (from c0 in deck from c1 in deck select Evaluate(cards.With(0, c0).With(1, c1))).Max();\n        if (jokers == 1) return (from c0 in deck select Evaluate(cards.With(0, c0))).Max();\n        return Evaluate(cards);\n    }\n\n    static List<Card> ParseHand(string hand) =>\n        hand.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        .Select(card => ParseCard(card.ToLower())).ToList();\n\n    static Card ParseCard(string card) => (card.Length, card) switch {\n        (5, \"joker\") => Card.Joker,\n        (3, _) when card[..2] == \"10\" => (10, ParseSuit(card[2])),\n        (2, _) => (ParseRank(card[0]), ParseSuit(card[1])),\n        (_, _) => Card.Invalid\n    };\n\n    static int ParseRank(char rank) => rank switch {\n        'a' => 1,\n        'j' => 11,\n        'q' => 12,\n        'k' => 13,\n        _ when rank >= '2' && rank <= '9' => rank - '0',\n        _ => -1\n    };\n\n    static int ParseSuit(char suit) => suit switch {\n        C => 1, 'c' => 1,\n        D => 2, 'd' => 2,\n        H => 3, 'h' => 3,\n        S => 4, 's' => 4,\n        _ => -1\n    };\n\n    static Hand Evaluate(List<Card> hand) {\n        var frequencies = hand.GroupBy(c => c.Rank).Select(g => g.Count()).OrderByDescending(c => c).ToArray();\n        (int f0, int f1) = (frequencies[0], frequencies.Length > 1 ? frequencies[1] : 0);\n\n        return (IsFlush(), IsStraight(), f0, f1) switch {\n            (_, _, 5, _) => Hand.Five_Of_A_Kind,\n            (Y, Y, _, _) => Hand.Straight_Flush,\n            (_, _, 4, _) => Hand.Four_Of_A_Kind,\n            (_, _, 3, 2) => Hand.Full_House,\n            (Y, _, _, _) => Hand.Flush,\n            (_, Y, _, _) => Hand.Straight,\n            (_, _, 3, _) => Hand.Three_Of_A_Kind,\n            (_, _, 2, 2) => Hand.Two_Pair,\n            (_, _, 2, _) => Hand.One_Pair,\n                        _ => Hand.High_Card\n        };\n\n        bool IsFlush() => hand.Aggregate(suitMask, (r, c) => r & c.Code) > 0;\n\n        bool IsStraight() {\n            int r = hand.Aggregate(0, (r, c) => r | c.Code) & rankMask;\n            for (int i = 0; i < 4; i++) r &= r << 1;\n            return r > 0;\n        }\n    }\n    \n}\n"}
{"id": 386801, "name": "Penney's game", "source": "Translate Ruby to C#: Toss = [:Heads, :Tails]\n\ndef yourChoice\n  puts \"Enter your choice (H/T)\"\n  choice = []\n  3.times do\n    until (c = $stdin.getc.upcase) == \"H\" or c == \"T\"\n    end\n    choice << (c==\"H\" ? Toss[0] : Toss[1])\n  end\n  puts \"You chose \n  choice\nend\n\nloop do\n  puts \"\\n%s I start, %s you start ..... %s\" % [*Toss, coin = Toss.sample]\n  if coin == Toss[0]\n    myC = Toss.shuffle << Toss.sample\n    puts \"I chose \n    yC = yourChoice\n  else\n    yC = yourChoice\n    myC = Toss - [yC[1]] + yC.first(2)\n    puts \"I chose \n  end\n  \n  seq = Array.new(3){Toss.sample}\n  print seq.join(' ')\n  loop do\n    puts \"\\n I win!\" or break   if seq == myC\n    puts \"\\n You win!\" or break if seq == yC\n    seq.push(Toss.sample).shift\n    print \" \n  end\nend\n", "target": "using static System.Console;\nusing static System.Threading.Thread;\nusing System;\n\npublic static class PenneysGame\n{\n    const int pause = 500;\n    const int N = 3;\n    static Random rng = new Random();\n\n    static int Toss() => rng.Next(2);\n\n    static string AsString(this int sequence) {\n        string s = \"\";\n        for (int b = 0b100; b > 0; b >>= 1) {\n            s += (sequence & b) > 0 ? 'T' : 'H';\n        }\n        return s;\n    }\n\n    static int UserInput() {\n        while (true) {\n            switch (ReadKey().Key) {\n                case ConsoleKey.Escape: return -1;\n                case ConsoleKey.H: return 0;\n                case ConsoleKey.T: return 1;\n            }\n            Console.Write('\\b');\n        }\n    }\n\n    public static void Main2() {\n        int yourScore = 0, myScore = 0;\n        while (true) {\n            WriteLine($\"Your score: {yourScore}, My score: {myScore}\");\n            WriteLine(\"Determining who goes first...\");\n            Sleep(pause);\n            bool youStart = Toss() == 1;\n            WriteLine(youStart ? \"You go first.\" : \"I go first.\");\n            int yourSequence = 0, mySequence = 0;\n            if (youStart) {\n                WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                int userChoice;\n                for (int i = 0; i < N; i++) {\n                    if ((userChoice = UserInput()) < 0) return;\n                    yourSequence = (yourSequence << 1) + userChoice;\n                }\n                mySequence = ((~yourSequence << 1) & 0b100) | (yourSequence >> 1);\n            } else {\n                for (int i = 0; i < N; i++) {\n                    mySequence = (mySequence << 1) + Toss();\n                }\n\n                WriteLine(\"I chose \" + mySequence.AsString());\n                do {\n                    WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                    int choice;\n                    yourSequence = 0;\n                    for (int i = 0; i < N; i++) {\n                        if ((choice = UserInput()) < 0) return;\n                        yourSequence = (yourSequence << 1) + choice;\n                    }\n                    if (yourSequence == mySequence) {\n                        WriteLine();\n                        WriteLine(\"You cannot choose the same sequence.\");\n                    }\n                } while (yourSequence == mySequence);\n            }\n\n            WriteLine();\n            WriteLine($\"Your sequence: {yourSequence.AsString()}, My sequence: {mySequence.AsString()}\");\n            WriteLine(\"Tossing...\");\n            int sequence = 0;\n            for (int i = 0; i < N; i++) {\n                Sleep(pause);\n                int toss = Toss();\n                sequence = (sequence << 1) + toss;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            while (true) {\n                if (sequence == yourSequence) {\n                    WriteLine();\n                    WriteLine(\"You win!\");\n                    yourScore++;\n                    break;\n                } else if (sequence == mySequence) {\n                    WriteLine();\n                    WriteLine(\"I win!\");\n                    myScore++;\n                    break;\n                }\n                Sleep(pause);\n                int toss = Toss();\n                sequence = ((sequence << 1) + toss) & 0b111;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            WriteLine(\"Press a key.\");\n            ReadKey();\n            Clear();\n        }\n    }\n\n}\n"}
{"id": 386802, "name": "Nonoblock", "source": "Translate Ruby to C#: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 386803, "name": "Nonoblock", "source": "Translate Ruby to C#: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 386804, "name": "Eban numbers", "source": "Translate Ruby to C#: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 386805, "name": "Eban numbers", "source": "Translate Ruby to C#: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 386806, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to C#: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 386807, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to C#: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 386808, "name": "Active Directory_Connect", "source": "Translate Ruby to C#: require 'rubygems'\nrequire 'net/ldap'\nldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')\nldap.authenticate('bind_dn', 'bind_pass')\n", "target": "\nvar objDE = new System.DirectoryServices.DirectoryEntry(\"LDAP:\n"}
{"id": 386809, "name": "Knapsack problem_Bounded", "source": "Translate Ruby to C#: record Item, name : String, weight : Int32, value : Int32, count : Int32\n\nrecord Selection, mask : Array(Int32), cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    max_count = {candidate.count, remaining_weight // candidate.weight}.min\n    (0..max_count).reverse_each do |n|\n      mask = taken.mask.clone\n      mask[candidate_index] = n\n      knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + n*candidate.value), items, remaining_weight - n*candidate.weight\n    end\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    nothing = Selection.new(Array(Int32).new(items.size, 0), 0, 0)\n    @threshold_value = 0\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = Hash(Item, Int32).new(0)\n    selected.mask.each_with_index { |v, i| result[list[i]] = v if v > 0 }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150, 1),\n  Item.new(\"compass\", 13, 35, 1),\n  Item.new(\"water\", 153, 200, 2),\n  Item.new(\"sandwich\", 50, 60, 2),\n  Item.new(\"glucose\", 15, 60, 2),\n  Item.new(\"tin\", 68, 45, 3),\n  Item.new(\"banana\", 27, 60, 3),\n  Item.new(\"apple\", 39, 40, 3),\n  Item.new(\"cheese\", 23, 30, 1),\n  Item.new(\"beer\", 52, 10, 3),\n  Item.new(\"suntan cream\", 11, 70, 1),\n  Item.new(\"camera\", 32, 30, 1),\n  Item.new(\"T-shirt\", 24, 15, 2),\n  Item.new(\"trousers\", 48, 10, 2),\n  Item.new(\"umbrella\", 73, 40, 1),\n  Item.new(\"waterproof trousers\", 42, 70, 1),\n  Item.new(\"waterproof overclothes\", 43, 75, 1),\n  Item.new(\"note-case\", 22, 80, 1),\n  Item.new(\"sunglasses\", 7, 20, 1),\n  Item.new(\"towel\", 18, 12, 2),\n  Item.new(\"socks\", 4, 50, 1),\n  Item.new(\"book\", 30, 10, 2),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"total value \nputs \"checked nodes: \n", "target": "using System;  \nclass program\n{\n    static void Main()\n    {\n        knapSack(40);\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        Console.Write(knapSack(400) + \"\\n\" + sw.Elapsed);  \n        Console.Read();\n    }\n\n    static string knapSack(uint w1)\n    {\n        init(); change();\n        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];\n        for (uint vi, wi, w0, x, i = 0; i < n; i++)\n            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)\n            {\n                x = K[i, w0];\n                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);\n                K[i + 1, w0] = x;\n            }\n        string str = \"\";\n        for (uint v1 = K[n, w1]; v1 > 0; n--)\n            if (v1 != K[n - 1, w1])\n            {\n                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + \"\\n\";\n            }\n        return str;\n    }\n\n    static uint max(uint a, uint b) { return a > b ? a : b; }\n\n    static byte[] w, v; static string[] items;\n\n    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };\n\n    static void init()\n    {\n        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,\n                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };\n\n        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,\n                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };\n\n        items = new string[] {\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\n                              \"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\n                              \"camera\",\"T-shirt\",\"trousers\",\"umbrella\",\n                              \"waterproof trousers\",\"waterproof overclothes\",\n                              \"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\"};\n    }\n\n    static void change()\n    {\n        int n = w.Length, s = 0, i, j, k; byte xi;\n        for (i = 0; i < n; i++) s += p[i];\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            w = x;\n        }\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            v = x;\n        }\n        string[] pItems = new string[s]; string itemI;\n        for (k = i = 0; i < n; i++)\n            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;\n        items = pItems;\n    }\n}\n"}
{"id": 386810, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to C#: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386811, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to C#: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386812, "name": "Angles (geometric), normalization and conversion", "source": "Translate Ruby to C#: module Angles\n  BASES = {\"d\" => 360, \"g\" => 400, \"m\" => 6400, \"r\" => Math::PI*2 ,\"h\" => 24 }\n \n  def self.method_missing(meth, angle)\n    from, to = BASES.values_at(*meth.to_s.split(\"2\"))\n    raise NoMethodError, meth if (from.nil? or to.nil?)\n    mod = (angle.to_f * to / from) % to\n    angle < 0 ? mod - to : mod\n  end\n\nend\n\n\nnames = Angles::BASES.keys\nputs \" \" + \"%12s \"*names.size % names\ntest = [-2, -1, 0, 1, 2*Math::PI, 16, 360/(2*Math::PI), 360-1, 400-1, 6400-1, 1_000_000]\n\ntest.each do |n|\n  names.each do |first|\n    res = names.map{|last| Angles.send((first + \"2\" + last).to_sym, n)}\n    puts first + \"%12g \"*names.size % res\n  end\n  puts\nend\n", "target": "using System;\n\npublic static class Angles\n{\n    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);\n\n    public static void Print(params double[] angles) {\n        string[] names = { \"Degrees\", \"Gradians\", \"Mils\", \"Radians\" };\n        Func<double, double> rnd = a => Math.Round(a, 4);\n        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };\n\n        Func<double, double>[,] convert = {\n            { a => a, DegToGrad, DegToMil, DegToRad },\n            { GradToDeg, a => a, GradToMil, GradToRad },\n            { MilToDeg, MilToGrad, a => a, MilToRad },\n            { RadToDeg, RadToGrad, RadToMil, a => a }\n        };\n\n        Console.WriteLine($@\"{\"Angle\",-12}{\"Normalized\",-12}{\"Unit\",-12}{\n            \"Degrees\",-12}{\"Gradians\",-12}{\"Mils\",-12}{\"Radians\",-12}\");\n\n        foreach (double angle in angles) {\n            for (int i = 0; i < 4; i++) {\n                double nAngle = normal[i](angle);\n\n                Console.WriteLine($@\"{\n                    rnd(angle),-12}{\n                    rnd(nAngle),-12}{\n                    names[i],-12}{\n                    rnd(convert[i, 0](nAngle)),-12}{\n                    rnd(convert[i, 1](nAngle)),-12}{\n                    rnd(convert[i, 2](nAngle)),-12}{\n                    rnd(convert[i, 3](nAngle)),-12}\");\n            }\n        }\n    }\n\n    public static double NormalizeDeg(double angle) => Normalize(angle, 360);\n    public static double NormalizeGrad(double angle) => Normalize(angle, 400);\n    public static double NormalizeMil(double angle) => Normalize(angle, 6400);\n    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);\n\n    private static double Normalize(double angle, double N) {\n        while (angle <= -N) angle += N;\n        while (angle >= N) angle -= N;\n        return angle;\n    }\n\n    public static double DegToGrad(double angle) => angle * 10 / 9;\n    public static double DegToMil(double angle) => angle * 160 / 9;\n    public static double DegToRad(double angle) => angle * Math.PI / 180;\n    \n    public static double GradToDeg(double angle) => angle * 9 / 10;\n    public static double GradToMil(double angle) => angle * 16;\n    public static double GradToRad(double angle) => angle * Math.PI / 200;\n    \n    public static double MilToDeg(double angle) => angle * 9 / 160;\n    public static double MilToGrad(double angle) => angle / 16;\n    public static double MilToRad(double angle) => angle * Math.PI / 3200;\n    \n    public static double RadToDeg(double angle) => angle * 180 / Math.PI;\n    public static double RadToGrad(double angle) => angle * 200 / Math.PI;\n    public static double RadToMil(double angle) => angle * 3200 / Math.PI;\n}\n"}
{"id": 386813, "name": "XML_XPath", "source": "Translate Ruby to C#: \nrequire \"rexml/document\"\ninclude REXML\n\ndoc = Document.new(\n        %q@<inventory title=\"OmniCorp Store \n             ...\n           </inventory>\n          @\n                          )\n\ninvisibility = XPath.first( doc, \"//item\" ) \n\nXPath.each( doc, \"//price\") { |element| puts element.text }\n\nnames = XPath.match( doc, \"//name\" )\n", "target": "XmlReader XReader;\n \n\nXReader = XmlReader.Create(new StringReader(\"<inventory title=... </inventory>\"));\n \n\nXReader = XmlReader.Create(\"xmlfile.xml\");\n \n\n\nIXPathNavigable XDocument = new XPathDocument(XReader);\n \n\nXPathNavigator Nav = XDocument.CreateNavigator();\nNav = Nav.SelectSingleNode(\"\n \n\nif(Nav.MoveToFirst())\n{\n  Console.WriteLine(Nav.OuterXml); \n}\n \n\nXPathNodeIterator Iterator = XDocument.CreateNavigator().Select(\"\n \nwhile (Iterator.MoveNext())\n{\n  Console.WriteLine(Iterator.Current.Value);\n}\n \nIterator = XDocument.CreateNavigator().Select(\"\n \n\nList<string> NodesValues = new List<string>();\n \nwhile (Iterator.MoveNext())\n{\n  NodesValues.Add(Iterator.Current.Value);\n}\n \n\nConsole.WriteLine(NodesValues.ToArray().Length);\n"}
{"id": 386814, "name": "HTTPS_Authenticated", "source": "Translate Ruby to C#: require 'uri'\nrequire 'net/http'\n\nuri = URI.parse('https://www.example.com')\nresponse = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|\n  request = Net::HTTP::Get.new uri\n  request.basic_auth('username', 'password')\n  http.request request\nend\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var client = new WebClient();\n\n        \n        client.Credentials = CredentialCache.DefaultCredentials;\n        \n        client.Credentials = new NetworkCredential(\"User\", \"Password\");\n\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 386815, "name": "Ranking methods", "source": "Translate Ruby to C#: ar = \"44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\".lines.map{|line| line.split}\ngrouped = ar.group_by{|pair| pair.shift.to_i}\ns_rnk = 1\nm_rnk = o_rnk = 0\nputs \"stand.\\tmod.\\tdense\\tord.\\tfract.\"\n\ngrouped.each.with_index(1) do |(score, names), d_rnk|\n  m_rnk += names.flatten!.size\n  f_rnk = (s_rnk + m_rnk)/2.0\n  names.each do |name|\n    o_rnk += 1\n    puts \"\n  end\n  s_rnk += names.size\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RankingMethods {\n    class Program {\n        static void Main(string[] args) {\n            Dictionary<string, int> scores = new Dictionary<string, int> {\n                [\"Solomon\"] = 44,\n                [\"Jason\"] = 42,\n                [\"Errol\"] = 42,\n                [\"Gary\"] = 41,\n                [\"Bernard\"] = 41,\n                [\"Barry\"] = 41,\n                [\"Stephen\"] = 39,\n            };\n\n            StandardRank(scores);\n            ModifiedRank(scores);\n            DenseRank(scores);\n            OrdinalRank(scores);\n            FractionalRank(scores);\n        }\n\n        static void StandardRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Standard Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                int temp = rank;\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", temp, value, k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void ModifiedRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Modified Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                    }\n                }\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void DenseRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Dense Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n                rank++;\n            }\n\n            Console.WriteLine();\n        }\n\n        static void OrdinalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Ordinal Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void FractionalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Fractional Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                double avg = 0;\n                int cnt = 0;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                        cnt++;\n                        avg += rank;\n                    }\n                }\n                avg /= cnt;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0:F1} {1} {2}\", avg, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386816, "name": "Straddling checkerboard", "source": "Translate Ruby to C#: class StraddlingCheckerboard\n  EncodableChars = \"A-Z0-9.\"\n  SortedChars = \"  ./\" + [*\"A\"..\"Z\"].join\n  \n  def initialize(board = nil)\n    if board.nil?\n      \n      rest = \"BCDFGHJKLMPQUVWXYZ/.\".chars.shuffle\n      @board = [\"  ESTONIAR\".chars.shuffle, rest[0..9], rest[10..19]]\n    elsif board.chars.sort.join == SortedChars\n      @board = board.chars.each_slice(10).to_a\n    else\n      raise ArgumentError, \"invalid \n    end\n    \n    @row_labels = @board[0].each_with_index.select {|v, i| v == \" \"}.map {|v,i| i}\n    \n    @mapping = {}\n    @board[0].each_with_index {|char, idx| @mapping[char] = idx.to_s unless char == \" \"}\n    @board[1..2].each_with_index do |row, row_idx|\n      row.each_with_index do |char, idx|\n        @mapping[char] = \"%d%d\" % [@row_labels[row_idx], idx]\n      end\n    end\n  end\n  \n  def encode(message)\n    msg = message.upcase.delete(\"^\n    msg.chars.inject(\"\") do |crypt, char|\n      crypt << (char =~ /[0-9]/ ? @mapping[\"/\"] + char : @mapping[char])\n    end\n  end\n  \n  def decode(code)\n    msg = \"\"\n    tokens = code.chars\n    until tokens.empty?\n      token = tokens.shift\n      itoken = token.to_i\n      unless @row_labels.include?(itoken)\n        msg << @board[0][itoken]\n      else\n        token2 = tokens.shift\n        if @mapping[\"/\"] == token + token2\n          msg << tokens.shift\n        else\n          msg << @board[1+@row_labels.index(itoken)][token2.to_i]\n        end\n      end\n    end\n    msg\n  end\n  \n  def to_s\n    @board.inject(\"\") {|res, row| res << row.join}\n  end\n  \n  def inspect\n    \"\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace StraddlingCheckerboard\n{\n    class Program\n    {\n        public readonly static IReadOnlyDictionary<char, string> val2Key;\n        public readonly static IReadOnlyDictionary<string, char> key2Val;\n\n        static Program()\n        {\n            val2Key = new Dictionary<char, string> {\n                {'A',\"30\"},  {'B',\"31\"}, {'C',\"32\"},  {'D',\"33\"},  {'E',\"5\"},   {'F',\"34\"},  {'G',\"35\"},\n                {'H',\"0\"},   {'I',\"36\"}, {'J',\"37\"},  {'K',\"38\"},  {'L',\"2\"},   {'M',\"4\"},   {'.',\"78\"},\n                {'N',\"39\"},  {'/',\"79\"}, {'O',\"1\"},   {'0',\"790\"}, {'P',\"70\"},  {'1',\"791\"}, {'Q',\"71\"},\n                {'2',\"792\"}, {'R',\"8\"},  {'3',\"793\"}, {'S',\"6\"},   {'4',\"794\"}, {'T',\"9\"},   {'5',\"795\"},\n                {'U',\"72\"},  {'6',\"796\"},{'V',\"73\"},  {'7',\"797\"}, {'W',\"74\"},  {'8',\"798\"}, {'X',\"75\"},\n                {'9',\"799\"}, {'Y',\"76\"}, {'Z',\"77\"}};\n\n            key2Val = val2Key.ToDictionary(kv => kv.Value, kv => kv.Key);\n        }\n\n        public static string Encode(string s)\n        {\n            return string.Concat(s.ToUpper().ToCharArray()\n                .Where(c => val2Key.ContainsKey(c)).Select(c => val2Key[c]));\n        }\n\n        public static string Decode(string s)\n        {\n            return string.Concat(Regex.Matches(s, \"79.|7.|3.|.\").Cast<Match>()\n                .Where(m => key2Val.ContainsKey(m.Value)).Select(m => key2Val[m.Value]));\n        }\n\n        static void Main(string[] args)\n        {\n            var enc = Encode(\"One night-it was on the twentieth of March, 1888-I was returning\");\n            Console.WriteLine(enc);\n            Console.WriteLine(Decode(enc));\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 386817, "name": "I before E except after C", "source": "Translate Ruby to C#: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 386818, "name": "I before E except after C", "source": "Translate Ruby to C#: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 386819, "name": "Write to Windows event log", "source": "Translate Ruby to C#: require 'win32/eventlog'\nlogger = Win32::EventLog.new\nlogger.report_event(:event_type => Win32::EventLog::INFO, :data => \"a test event log entry\")\n", "target": "using System.Diagnostics;\n\nnamespace RC\n{\n  internal class Program\n  {\n    public static void Main()\n    {\n      string sSource  = \"Sample App\";\n      string sLog     = \"Application\";\n      string sEvent   = \"Hello from RC!\";\n\n      if (!EventLog.SourceExists(sSource))\n        EventLog.CreateEventSource(sSource, sLog);\n\n      EventLog.WriteEntry(sSource, sEvent);\n      EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information);\n    }\n  }\n}\n"}
{"id": 386820, "name": "Line circle intersection", "source": "Translate Ruby to C#: EPS = 1e-14\n\ndef sq(x)\n    return x * x\nend\n\ndef intersects(p1, p2, cp, r, segment)\n    res = []\n    (x0, y0) = cp\n    (x1, y1) = p1\n    (x2, y2) = p2\n    aa = y2 - y1\n    bb = x1 - x2\n    cc = x2 * y1 - x1 * y2\n    a = sq(aa) + sq(bb)\n    if bb.abs >= EPS then\n        b = 2 * (aa * cc + aa * bb * y0 - sq(bb) * x0)\n        c = sq(cc) + 2 * bb * cc * y0 - sq(bb) * (sq(r) - sq(x0) - sq(y0))\n        bnz = true\n    else\n        b = 2 * (bb * cc + aa * bb * x0 - sq(aa) * y0)\n        c = sq(cc) + 2 * aa * cc * x0 - sq(aa) * (sq(r) - sq(x0) - sq(y0))\n        bnz = false\n    end\n    d = sq(b) - 4 * a * c \n    if d < 0 then\n        return res\n    end\n\n    \n    within = ->(x, y) {\n        d1 = Math.sqrt(sq(x2 - x1) + sq(y2 - y1))   \n        d2 = Math.sqrt(sq(x - x1) + sq(y - y1))     \n        d3 = Math.sqrt(sq(x2 - x) + sq(y2 - y))     \n        delta = d1 - d2 - d3\n        return delta.abs < EPS                      \n    }\n\n    fx = ->(x) {\n        return -(aa * x + cc) / bb\n    }\n\n    fy = ->(y) {\n        return -(bb * y + cc) / aa\n    }\n\n    rxy = ->(x, y) {\n        if not segment or within.call(x, y) then\n            if x == 0.0 then\n                x = 0.0\n            end\n            if y == 0.0 then\n                y = 0.0\n            end\n            res << [x, y]\n        end\n    }\n\n    if d == 0.0 then\n        \n        if bnz then\n            x = -b / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n        else\n            y = -b / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n        end\n    else\n        \n        d = Math.sqrt(d)\n        if bnz then\n            x = (-b + d) / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n            x = (-b - d) / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n        else\n            y = (-b + d) / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n            y = (-b - d) / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n        end\n    end\n\n    return res\nend\n\ndef main\n    print \"The intersection points (if any) between:\\n\"\n\n    cp = [3.0, -5.0]\n    r = 3.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [-10.0, 11.0]\n    p2 = [10.0, -9.0]\n    print \"    a line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    p2 = [-10.0, 12.0]\n    print \"    a segment starting at %s and ending at %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\n\n    p1 = [3.0, -2.0]\n    p2 = [7.0, -2.0]\n    print \"    a horizontal line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    cp = [0.0, 0.0]\n    r = 4.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [0.0, -3.0]\n    p2 = [0.0, 6.0]\n    print \"    a vertical line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n    print \"    a vertical line segment containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\n\n    cp = [4.0, 2.0]\n    r = 5.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [6.0, 3.0]\n    p2 = [10.0, 7.0]\n    print \"    a line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    p1 = [7.0, 4.0]\n    p2 = [11.0, 8.0]\n    print \"    a segment starting at %s and ending at %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Circle circle = ((3, -5), 3);\n        Line[] lines = {\n            ((-10, 11), (10, -9)),\n            ((-10, 11), (-11, 12), true),\n            ((3, -2), (7, -2))\n        };\n        Print(circle, lines);\n        \n        circle = ((0, 0), 4);\n        lines = new Line[] {\n            ((0, -3), (0, 6)),\n            ((0, -3), (0, 6), true)\n        };\n        Print(circle, lines);\n        \n        circle = ((4, 2), 5);\n        lines = new Line[] {\n            ((6, 3), (10, 7)),\n            ((7, 4), (11, 8), true)\n        };\n        Print(circle, lines);\n    }\n    \n    static void Print(Circle circle, Line[] lines)\n    {\n        Console.WriteLine($\"Circle: {circle}\");\n        foreach (var line in lines) {\n            Console.WriteLine($\"\\t{(line.IsSegment\u00a0? \"Segment:\"\u00a0: \"Line:\")} {line}\");\n            var points = Intersection(circle, line).ToList();\n            Console.WriteLine(points.Count == 0 ? \"\\t\\tdo not intersect\" : \"\\t\\tintersect at \" + string.Join(\" and \", points));\n        }\n        Console.WriteLine();\n    }\n    \n    static IEnumerable<Point> Intersection(Circle circle, Line line)\n    {\n        var intersection = LineIntersection(circle, line);\n        return line.IsSegment\n            ? intersection.Where(p => p.CompareTo(line.P1) >= 0 && p.CompareTo(line.P2) <= 0)\n            : intersection;\n\n        static IEnumerable<Point> LineIntersection(Circle circle, Line line)\n        {\n            double x, y, A, B, C, D;\n            var (m, c) = (line.Slope, line.YIntercept);\n            var (p, q, r) = (circle.X, circle.Y, circle.Radius);\n\n            if (line.IsVertical) {\n                x = line.P1.X;\n                B = -2 * q;\n                C = p * p + q * q - r * r + x * x - 2 * p * x;\n                D = B * B - 4 * C;\n                if (D == 0) yield return (x, -q);\n                else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    yield return (x, (-B - D) / 2);\n                    yield return (x, (-B + D) / 2);\n                }\n            } else {\n                A = m * m + 1;\n                B = 2 * (m * c - m * q - p);\n                C = p * p + q * q - r * r + c * c - 2 * c * q;\n                D = B * B - 4 * A * C;\n                if (D == 0) {\n                    x = -B / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                } else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    x = (-B - D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                    x = (-B + D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                }\n            }\n        }\n\n    }\n    \n    readonly struct Point : IComparable<Point>\n    {\n        public Point(double x, double y) => (X, Y) = (x, y);\n        \n        public static implicit operator Point((double x, double y) p) => new Point(p.x, p.y);\n        \n        public double X { get; }\n        public double Y { get; }\n        \n        public int CompareTo(Point other)\n        {\n            int c = X.CompareTo(other.X);\n            if (c != 0) return c;\n            return Y.CompareTo(other.Y);\n        }\n        \n        public override string ToString() => $\"({X}, {Y})\";\n    }\n    \n    readonly struct Line\n    {\n        public Line(Point p1, Point p2, bool isSegment = false)\n        {\n            (P1, P2) = p2.CompareTo(p1) < 0 ? (p2, p1) : (p1, p2);\n            IsSegment = isSegment;\n            if (p1.X == p2.X) (Slope, YIntercept) = (double.PositiveInfinity, double.NaN);\n            else {\n                Slope = (P2.Y - P1.Y) / (P2.X - P1.X);\n                YIntercept = P2.Y - Slope * P2.X;\n            }\n        }\n        \n        public static implicit operator Line((Point p1, Point p2) l) => new Line(l.p1, l.p2);\n        public static implicit operator Line((Point p1, Point p2, bool isSegment) l) => new Line(l.p1, l.p2, l.isSegment);\n        \n        public Point P1 { get; }\n        public Point P2 { get; }\n        public double Slope { get; }\n        public double YIntercept { get; }\n        public bool IsSegment { get; }\n        public bool IsVertical => P1.X == P2.X;\n        \n        public override string ToString() => $\"[{P1}, {P2}]\";\n    }\n    \n    readonly struct Circle\n    {\n        public Circle(Point center, double radius) => (Center, Radius) = (center, radius);\n        \n        public static implicit operator Circle((Point center, double radius) c) => new Circle(c.center, c.radius);\n        \n        public Point Center { get; }\n        public double Radius { get; }\n        public double X => Center.X;\n        public double Y => Center.Y;\n        \n        public override string ToString() => $\"{{ C:{Center}, R:{Radius} }}\";\n    }   \n}\n"}
{"id": 386821, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hopidoMoves).Solve(false,\n            \".00.00.\",\n            \"0000000\",\n            \"0000000\",\n            \".00000.\",\n            \"..000..\",\n            \"...0...\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386822, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hopidoMoves).Solve(false,\n            \".00.00.\",\n            \"0000000\",\n            \"0000000\",\n            \".00000.\",\n            \"..000..\",\n            \"...0...\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386823, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386824, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to C#: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 386825, "name": "Respond to an unknown method call", "source": "Translate Ruby to C#: class Example\n    def foo\n        puts \"this is foo\"\n    end\n    def bar\n        puts \"this is bar\"\n    end\n    def method_missing(name, *args, &block)\n        puts \"tried to handle unknown method %s\" % name \n        unless args.empty?\n            puts \"it had arguments: %p\" % [args]\n        end\n    end\nend\n\nexample = Example.new\n\nexample.foo          \nexample.bar          \nexample.grill        \nexample.ding(\"dong\") \n                     \n", "target": "using System;\nusing System.Dynamic;\n\nclass Example : DynamicObject\n{\n    public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)\n    {\n        result = null;\n\n        Console.WriteLine(\"This is {0}.\", binder.Name);\n        return true;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        dynamic ex = new Example();\n\n        ex.Foo();\n        ex.Bar();\n    }\n}\n"}
{"id": 386826, "name": "Chemical calculator", "source": "Translate Ruby to C#: $atomicMass = {\n    \"H\"   =>  1.008,\n    \"He\"  =>  4.002602,\n    \"Li\"  =>  6.94,\n    \"Be\"  =>  9.0121831,\n    \"B\"   =>  10.81,\n    \"C\"   =>  12.011,\n    \"N\"   =>  14.007,\n    \"O\"   =>  15.999,\n    \"F\"   =>  18.998403163,\n    \"Ne\"  =>  20.1797,\n    \"Na\"  =>  22.98976928,\n    \"Mg\"  =>  24.305,\n    \"Al\"  =>  26.9815385,\n    \"Si\"  =>  28.085,\n    \"P\"   =>  30.973761998,\n    \"S\"   =>  32.06,\n    \"Cl\"  =>  35.45,\n    \"Ar\"  =>  39.948,\n    \"K\"   =>  39.0983,\n    \"Ca\"  =>  40.078,\n    \"Sc\"  =>  44.955908,\n    \"Ti\"  =>  47.867,\n    \"V\"   =>  50.9415,\n    \"Cr\"  =>  51.9961,\n    \"Mn\"  =>  54.938044,\n    \"Fe\"  =>  55.845,\n    \"Co\"  =>  58.933194,\n    \"Ni\"  =>  58.6934,\n    \"Cu\"  =>  63.546,\n    \"Zn\"  =>  65.38,\n    \"Ga\"  =>  69.723,\n    \"Ge\"  =>  72.630,\n    \"As\"  =>  74.921595,\n    \"Se\"  =>  78.971,\n    \"Br\"  =>  79.904,\n    \"Kr\"  =>  83.798,\n    \"Rb\"  =>  85.4678,\n    \"Sr\"  =>  87.62,\n    \"Y\"   =>  88.90584,\n    \"Zr\"  =>  91.224,\n    \"Nb\"  =>  92.90637,\n    \"Mo\"  =>  95.95,\n    \"Ru\"  =>  101.07,\n    \"Rh\"  =>  102.90550,\n    \"Pd\"  =>  106.42,\n    \"Ag\"  =>  107.8682,\n    \"Cd\"  =>  112.414,\n    \"In\"  =>  114.818,\n    \"Sn\"  =>  118.710,\n    \"Sb\"  =>  121.760,\n    \"Te\"  =>  127.60,\n    \"I\"   =>  126.90447,\n    \"Xe\"  =>  131.293,\n    \"Cs\"  =>  132.90545196,\n    \"Ba\"  =>  137.327,\n    \"La\"  =>  138.90547,\n    \"Ce\"  =>  140.116,\n    \"Pr\"  =>  140.90766,\n    \"Nd\"  =>  144.242,\n    \"Pm\"  =>  145,\n    \"Sm\"  =>  150.36,\n    \"Eu\"  =>  151.964,\n    \"Gd\"  =>  157.25,\n    \"Tb\"  =>  158.92535,\n    \"Dy\"  =>  162.500,\n    \"Ho\"  =>  164.93033,\n    \"Er\"  =>  167.259,\n    \"Tm\"  =>  168.93422,\n    \"Yb\"  =>  173.054,\n    \"Lu\"  =>  174.9668,\n    \"Hf\"  =>  178.49,\n    \"Ta\"  =>  180.94788,\n    \"W\"   =>  183.84,\n    \"Re\"  =>  186.207,\n    \"Os\"  =>  190.23,\n    \"Ir\"  =>  192.217,\n    \"Pt\"  =>  195.084,\n    \"Au\"  =>  196.966569,\n    \"Hg\"  =>  200.592,\n    \"Tl\"  =>  204.38,\n    \"Pb\"  =>  207.2,\n    \"Bi\"  =>  208.98040,\n    \"Po\"  =>  209,\n    \"At\"  =>  210,\n    \"Rn\"  =>  222,\n    \"Fr\"  =>  223,\n    \"Ra\"  =>  226,\n    \"Ac\"  =>  227,\n    \"Th\"  =>  232.0377,\n    \"Pa\"  =>  231.03588,\n    \"U\"   =>  238.02891,\n    \"Np\"  =>  237,\n    \"Pu\"  =>  244,\n    \"Am\"  =>  243,\n    \"Cm\"  =>  247,\n    \"Bk\"  =>  247,\n    \"Cf\"  =>  251,\n    \"Es\"  =>  252,\n    \"Fm\"  =>  257,\n    \"Uue\" =>  315,\n    \"Ubn\" =>  299,\n}\n\ndef evaluate(s)\n    s += \"[\" \n    sum = 0.0\n    i = 0\n    symbol = \"\"\n    number = \"\"\n    while i < s.length\n        c = s[i]\n        if '@' <= c and c <= '[' then\n            n = 1\n            if number != \"\" then\n                n = number.to_i\n            end\n            if symbol != \"\" then\n                mass = $atomicMass[symbol]\n                sum = sum + mass * n\n            end\n            if c == '[' then\n                break\n            end\n            symbol = c.to_s\n            number = \"\"\n        elsif 'a' <= c and c <= 'z' then\n            symbol = symbol + c\n        elsif '0' <= c and c <= '9' then\n            number = number + c\n        else\n            raise \"Unexpected symbol %c in molecule\" % [c]\n        end\n        i = i + 1\n    end\n    return sum\nend\n\ndef replaceParens(s)\n    letter = 'a'\n    while true\n        start = s.index '('\n        if start == nil then\n            break\n        end\n\n        i = start + 1\n        while i < s.length\n            if s[i] == ')' then\n                expr = s[start + 1 .. i - 1]\n                symbol = \"@%c\" % [letter]\n                r = s[start .. i + 0]\n                s = s.sub(r, symbol)\n                $atomicMass[symbol] = evaluate(expr)\n                letter = letter.next\n                break\n            end\n            if s[i] == '(' then\n                start = i\n            end\n\n            i = i + 1\n        end\n    end\n    return s\nend\n\ndef main\n    molecules = [\n        \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n        \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n    ]\n    for molecule in molecules\n        mass = evaluate(replaceParens(molecule))\n        print \"%17s -> %7.3f\\n\" % [molecule, mass]\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChemicalCalculator {\n    class Program {\n        static Dictionary<string, double> atomicMass = new Dictionary<string, double>() {\n            {\"H\",     1.008 },\n            {\"He\",    4.002602},\n            {\"Li\",    6.94},\n            {\"Be\",    9.0121831},\n            {\"B\",    10.81},\n            {\"C\",    12.011},\n            {\"N\",    14.007},\n            {\"O\",    15.999},\n            {\"F\",    18.998403163},\n            {\"Ne\",   20.1797},\n            {\"Na\",   22.98976928},\n            {\"Mg\",   24.305},\n            {\"Al\",   26.9815385},\n            {\"Si\",   28.085},\n            {\"P\",    30.973761998},\n            {\"S\",    32.06},\n            {\"Cl\",   35.45},\n            {\"Ar\",   39.948},\n            {\"K\",    39.0983},\n            {\"Ca\",   40.078},\n            {\"Sc\",   44.955908},\n            {\"Ti\",   47.867},\n            {\"V\",    50.9415},\n            {\"Cr\",   51.9961},\n            {\"Mn\",   54.938044},\n            {\"Fe\",   55.845},\n            {\"Co\",   58.933194},\n            {\"Ni\",   58.6934},\n            {\"Cu\",   63.546},\n            {\"Zn\",   65.38},\n            {\"Ga\",   69.723},\n            {\"Ge\",   72.630},\n            {\"As\",   74.921595},\n            {\"Se\",   78.971},\n            {\"Br\",   79.904},\n            {\"Kr\",   83.798},\n            {\"Rb\",   85.4678},\n            {\"Sr\",   87.62},\n            {\"Y\",    88.90584},\n            {\"Zr\",   91.224},\n            {\"Nb\",   92.90637},\n            {\"Mo\",   95.95},\n            {\"Ru\",  101.07},\n            {\"Rh\",  102.90550},\n            {\"Pd\",  106.42},\n            {\"Ag\",  107.8682},\n            {\"Cd\",  112.414},\n            {\"In\",  114.818},\n            {\"Sn\",  118.710},\n            {\"Sb\",  121.760},\n            {\"Te\",  127.60},\n            {\"I\",   126.90447},\n            {\"Xe\",  131.293},\n            {\"Cs\",  132.90545196},\n            {\"Ba\",  137.327},\n            {\"La\",  138.90547},\n            {\"Ce\",  140.116},\n            {\"Pr\",  140.90766},\n            {\"Nd\",  144.242},\n            {\"Pm\",  145},\n            {\"Sm\",  150.36},\n            {\"Eu\",  151.964},\n            {\"Gd\",  157.25},\n            {\"Tb\",  158.92535},\n            {\"Dy\",  162.500},\n            {\"Ho\",  164.93033},\n            {\"Er\",  167.259},\n            {\"Tm\",  168.93422},\n            {\"Yb\",  173.054},\n            {\"Lu\",  174.9668},\n            {\"Hf\",  178.49},\n            {\"Ta\",  180.94788},\n            {\"W\",   183.84},\n            {\"Re\",  186.207},\n            {\"Os\",  190.23},\n            {\"Ir\",  192.217},\n            {\"Pt\",  195.084},\n            {\"Au\",  196.966569},\n            {\"Hg\",  200.592},\n            {\"Tl\",  204.38},\n            {\"Pb\",  207.2},\n            {\"Bi\",  208.98040},\n            {\"Po\",  209},\n            {\"At\",  210},\n            {\"Rn\",  222},\n            {\"Fr\",  223},\n            {\"Ra\",  226},\n            {\"Ac\",  227},\n            {\"Th\",  232.0377},\n            {\"Pa\",  231.03588},\n            {\"U\",   238.02891},\n            {\"Np\",  237},\n            {\"Pu\",  244},\n            {\"Am\",  243},\n            {\"Cm\",  247},\n            {\"Bk\",  247},\n            {\"Cf\",  251},\n            {\"Es\",  252},\n            {\"Fm\",  257},\n            {\"Uue\", 315},\n            {\"Ubn\", 299},\n        };\n\n        static double Evaluate(string s) {\n            s += \"[\";\n            double sum = 0.0;\n            string symbol = \"\";\n            string number = \"\";\n            for (int i = 0; i < s.Length; ++i) {\n                var c = s[i];\n                if ('@' <= c && c <= '[') {\n                    \n                    int n = 1;\n                    if (number != \"\") {\n                        n = int.Parse(number);\n                    }\n                    if (symbol != \"\") {\n                        sum += atomicMass[symbol] * n;\n                    }\n                    if (c == '[') {\n                        break;\n                    }\n                    symbol = c.ToString();\n                    number = \"\";\n                } else if ('a' <= c && c <= 'z') {\n                    symbol += c;\n                } else if ('0' <= c && c <= '9') {\n                    number += c;\n                } else {\n                    throw new Exception(string.Format(\"Unexpected symbol {0} in molecule\", c));\n                }\n            }\n            return sum;\n        }\n\n        \n        static string ReplaceFirst(string text, string search, string replace) {\n            int pos = text.IndexOf(search);\n            if (pos < 0) {\n                return text;\n            }\n            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);\n        }\n\n        static string ReplaceParens(string s) {\n            char letter = 's';\n            while (true) {\n                var start = s.IndexOf('(');\n                if (start == -1) {\n                    break;\n                }\n\n                for (int i = start + 1; i < s.Length; ++i) {\n                    if (s[i] == ')') {\n                        var expr = s.Substring(start + 1, i - start - 1);\n                        var symbol = string.Format(\"@{0}\", letter);\n                        s = ReplaceFirst(s, s.Substring(start, i + 1 - start), symbol);\n                        atomicMass[symbol] = Evaluate(expr);\n                        letter++;\n                        break;\n                    }\n                    if (s[i] == '(') {\n                        start = i;\n                        continue;\n                    }\n                }\n            }\n            return s;\n        }\n\n        static void Main() {\n            var molecules = new string[]{\n                \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n                \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n            };\n            foreach (var molecule in molecules) {\n                var mass = Evaluate(ReplaceParens(molecule));\n                Console.WriteLine(\"{0,17} -> {1,7:0.000}\", molecule, mass);\n            }\n        }\n    }\n}\n"}
{"id": 386827, "name": "Snake and ladder", "source": "Translate Ruby to C#: NONE = 0; LADDER = 1; SNAKE = 2; STAY = 1; MOVE = 2; WIN = 3\nclass Cell\n    @type; @to; attr_reader :type, :to\n    def initialize; @type = NONE; @to = 0; end \n    def set( t, o ); @type = t; @to = o; end\nend\nclass Player\n    @pos; @name; attr_accessor :pos; attr_reader :name\n    def initialize( n ); @pos = 0; @name = n; end\n    def play( dice )\n        s = dice.roll; return s, STAY if @pos + s > 99\n        @pos += s; return s, WIN if @pos == 99\n        return s, MOVE\n    end\nend\nclass Die\n    @sides; def initialize( s = 6 ); @sides = s; end\n    def roll; return 1 + rand( @sides ); end\nend\ndef initBoard\n    @board = Array.new( 100 ); for i in 0 .. 99; @board[i] = Cell.new(); end\n    @board[3].set( LADDER, 13 ); @board[8].set( LADDER, 30 ); @board[19].set( LADDER, 37 );\n    @board[27].set( LADDER, 83 );@board[39].set( LADDER, 58 ); @board[50].set( LADDER, 66 );\n    @board[62].set( LADDER, 80 ); @board[70].set( LADDER, 90 ); @board[16].set( SNAKE, 6 );\n    @board[61].set( SNAKE, 18 ); @board[86].set( SNAKE, 23 ); @board[53].set( SNAKE, 33 );\n    @board[63].set( SNAKE, 59 ); @board[92].set( SNAKE, 72 ); @board[94].set( SNAKE, 74 ); \n    @board[98].set( SNAKE, 77 );\nend\ndef initPlayers\n    @players = Array.new( 4 );\n    for i in 0 .. @playersCount - 1; @players[i] = Player.new( \"player \" << i + 49 ); end\nend\ndef play\n    initBoard; initPlayers; @die = Die.new\n    while true\n        for p in 0 .. @playersCount - 1\n            puts; puts\n            if( 0 == p ) \n                print \"\n                \"Press [RETURN] to roll the die.\"\n                gets; np = @players[p].play( @die ); print \"You rolled a \n                if np[1] == WIN\n                    print \"You reached position \n                elsif np[1] == STAY; print \"Sorry, you cannot move!\\n\"\n                else print \"Your new position is cell \n                end\n            else\n                np = @players[p].play( @die ); print \"\n                if np[1] == WIN \n                     print \"He reached position \n                elsif np[1] == STAY; print \"But he cannot move....\\n\"\n                else print \"His new position is cell \n                end\n            end\n            s = @board[@players[p].pos].type\n            next if s == NONE\n            @players[p].pos = @board[@players[p].pos].to\n            case s\n                when SNAKE; print \"What a pitty, landed on a snake. \"\n                when LADDER; print \"Lucky move! Landed on a ladder. \"\n            end\n            print \"New position is cell \n        end\n    end\nend\n@playersCount = 4; @board; @players; @die\nplay\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SnakeAndLadder {\n    class Program {\n        private static Dictionary<int, int> snl = new Dictionary<int, int>() {\n            {4, 14},\n            {9, 31},\n            {17, 7},\n            {20, 38},\n            {28, 84},\n            {40, 59},\n            {51, 67},\n            {54, 34},\n            {62, 19},\n            {63, 81},\n            {64, 60},\n            {71, 91},\n            {87, 24},\n            {93, 73},\n            {95, 75},\n            {99, 78},\n        };\n        private static Random rand = new Random();\n        private const bool sixesThrowAgain = true;\n\n        static int Turn(int player, int square) {\n            while (true) {\n                int roll = rand.Next(1, 6);\n                Console.Write(\"Player {0}, on square {1}, rolls a {2}\", player, square, roll);\n                if (square + roll > 100) {\n                    Console.WriteLine(\" but cannot move.\");\n                } else {\n                    square += roll;\n                    Console.WriteLine(\" and moves to square {0}\", square);\n                    if (square == 100) return 100;\n                    int next = square;\n                    if (snl.ContainsKey(square)) {\n                        next = snl[square];\n                    }\n                    if (square < next) {\n                        Console.WriteLine(\"Yay! Landed on a ladder. Climb up to {0}.\", next);\n                        if (next == 100) return 100;\n                        square = next;\n                    } else if (square > next) {\n                        Console.WriteLine(\"Oops! Landed on a snake. Slither down to {0}.\", next);\n                    }\n                }\n                if (roll < 6 || !sixesThrowAgain) return square;\n                Console.WriteLine(\"Rolled a 6 so roll again.\");\n            }\n        }\n\n        static void Main(string[] args) {\n            \n            int[] players = { 1, 1, 1 };\n            while (true) {\n                for (int i = 0; i < players.Length; i++) {\n                    int ns = Turn(i + 1, players[i]);\n                    if (ns == 100) {\n                        Console.WriteLine(\"Player {0} wins!\", i + 1);\n                        return;\n                    }\n                    players[i] = ns;\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386828, "name": "Snake and ladder", "source": "Translate Ruby to C#: NONE = 0; LADDER = 1; SNAKE = 2; STAY = 1; MOVE = 2; WIN = 3\nclass Cell\n    @type; @to; attr_reader :type, :to\n    def initialize; @type = NONE; @to = 0; end \n    def set( t, o ); @type = t; @to = o; end\nend\nclass Player\n    @pos; @name; attr_accessor :pos; attr_reader :name\n    def initialize( n ); @pos = 0; @name = n; end\n    def play( dice )\n        s = dice.roll; return s, STAY if @pos + s > 99\n        @pos += s; return s, WIN if @pos == 99\n        return s, MOVE\n    end\nend\nclass Die\n    @sides; def initialize( s = 6 ); @sides = s; end\n    def roll; return 1 + rand( @sides ); end\nend\ndef initBoard\n    @board = Array.new( 100 ); for i in 0 .. 99; @board[i] = Cell.new(); end\n    @board[3].set( LADDER, 13 ); @board[8].set( LADDER, 30 ); @board[19].set( LADDER, 37 );\n    @board[27].set( LADDER, 83 );@board[39].set( LADDER, 58 ); @board[50].set( LADDER, 66 );\n    @board[62].set( LADDER, 80 ); @board[70].set( LADDER, 90 ); @board[16].set( SNAKE, 6 );\n    @board[61].set( SNAKE, 18 ); @board[86].set( SNAKE, 23 ); @board[53].set( SNAKE, 33 );\n    @board[63].set( SNAKE, 59 ); @board[92].set( SNAKE, 72 ); @board[94].set( SNAKE, 74 ); \n    @board[98].set( SNAKE, 77 );\nend\ndef initPlayers\n    @players = Array.new( 4 );\n    for i in 0 .. @playersCount - 1; @players[i] = Player.new( \"player \" << i + 49 ); end\nend\ndef play\n    initBoard; initPlayers; @die = Die.new\n    while true\n        for p in 0 .. @playersCount - 1\n            puts; puts\n            if( 0 == p ) \n                print \"\n                \"Press [RETURN] to roll the die.\"\n                gets; np = @players[p].play( @die ); print \"You rolled a \n                if np[1] == WIN\n                    print \"You reached position \n                elsif np[1] == STAY; print \"Sorry, you cannot move!\\n\"\n                else print \"Your new position is cell \n                end\n            else\n                np = @players[p].play( @die ); print \"\n                if np[1] == WIN \n                     print \"He reached position \n                elsif np[1] == STAY; print \"But he cannot move....\\n\"\n                else print \"His new position is cell \n                end\n            end\n            s = @board[@players[p].pos].type\n            next if s == NONE\n            @players[p].pos = @board[@players[p].pos].to\n            case s\n                when SNAKE; print \"What a pitty, landed on a snake. \"\n                when LADDER; print \"Lucky move! Landed on a ladder. \"\n            end\n            print \"New position is cell \n        end\n    end\nend\n@playersCount = 4; @board; @players; @die\nplay\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SnakeAndLadder {\n    class Program {\n        private static Dictionary<int, int> snl = new Dictionary<int, int>() {\n            {4, 14},\n            {9, 31},\n            {17, 7},\n            {20, 38},\n            {28, 84},\n            {40, 59},\n            {51, 67},\n            {54, 34},\n            {62, 19},\n            {63, 81},\n            {64, 60},\n            {71, 91},\n            {87, 24},\n            {93, 73},\n            {95, 75},\n            {99, 78},\n        };\n        private static Random rand = new Random();\n        private const bool sixesThrowAgain = true;\n\n        static int Turn(int player, int square) {\n            while (true) {\n                int roll = rand.Next(1, 6);\n                Console.Write(\"Player {0}, on square {1}, rolls a {2}\", player, square, roll);\n                if (square + roll > 100) {\n                    Console.WriteLine(\" but cannot move.\");\n                } else {\n                    square += roll;\n                    Console.WriteLine(\" and moves to square {0}\", square);\n                    if (square == 100) return 100;\n                    int next = square;\n                    if (snl.ContainsKey(square)) {\n                        next = snl[square];\n                    }\n                    if (square < next) {\n                        Console.WriteLine(\"Yay! Landed on a ladder. Climb up to {0}.\", next);\n                        if (next == 100) return 100;\n                        square = next;\n                    } else if (square > next) {\n                        Console.WriteLine(\"Oops! Landed on a snake. Slither down to {0}.\", next);\n                    }\n                }\n                if (roll < 6 || !sixesThrowAgain) return square;\n                Console.WriteLine(\"Rolled a 6 so roll again.\");\n            }\n        }\n\n        static void Main(string[] args) {\n            \n            int[] players = { 1, 1, 1 };\n            while (true) {\n                for (int i = 0; i < players.Length; i++) {\n                    int ns = Turn(i + 1, players[i]);\n                    if (ns == 100) {\n                        Console.WriteLine(\"Player {0} wins!\", i + 1);\n                        return;\n                    }\n                    players[i] = ns;\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386829, "name": "Naming conventions", "source": "Translate Ruby to C#: test_variable = [1, 9, 8, 3]\ntest_variable.sort    \ntest_variable         \ntest_variable.sort!   \ntest_variable         \n", "target": "public enum Planet {\n    Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\n[Flags]\npublic enum Days {\n    None = 0,\n    Sunday = 1,\n    Monday = 2,\n    Tuesday = 4,\n    Wednesday = 8,\n    Thursday = 16,\n    Friday = 32,\n    Saturday = 64,\n    Workdays = Monday | Tuesday | Wednesday | Thursday | Friday\n    AllWeek = Sunday | Saturday | Workdays\n}\n"}
{"id": 386830, "name": "Farey sequence", "source": "Translate Ruby to C#: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 386831, "name": "Farey sequence", "source": "Translate Ruby to C#: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 386832, "name": "Implicit type conversion", "source": "Translate Ruby to C#: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "byte aByte = 2;\nshort aShort = aByte;\nint anInt = aShort;\nlong aLong = anInt;\n\nfloat aFloat = 1.2f;\ndouble aDouble = aFloat;\n\nBigInteger b = 5;\nComplex c = 2.5; \n"}
{"id": 386833, "name": "Implicit type conversion", "source": "Translate Ruby to C#: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "byte aByte = 2;\nshort aShort = aByte;\nint anInt = aShort;\nlong aLong = anInt;\n\nfloat aFloat = 1.2f;\ndouble aDouble = aFloat;\n\nBigInteger b = 5;\nComplex c = 2.5; \n"}
{"id": 386834, "name": "Magnanimous numbers", "source": "Translate Ruby to C#: require \"prime\"\n\nmagnanimouses = Enumerator.new do |y|\n  (0..).each {|n| y << n if (1..n.digits.size-1).all? {|k| n.divmod(10**k).sum.prime?} }\nend\n\nputs \"First 45 magnanimous numbers:\"\nputs magnanimouses.first(45).join(' ')\n \nputs \"\\n241st through 250th magnanimous numbers:\"\nputs magnanimouses.first(250).last(10).join(' ')\n \nputs \"\\n391st through 400th magnanimous numbers:\"\nputs magnanimouses.first(400).last(10).join(' ')\n", "target": "using System; using static System.Console;\n\nclass Program {\n\n  static bool[] np; \n\n  static void ms(long lmt) { \n    np = new bool[lmt]; np[0] = np[1] = true;\n    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])\n        for (long k = n * n; k < lmt; k += n) np[k] = true; }\n\n  static bool is_Mag(long n) { long res, rem;\n    for (long p = 10; n >= p; p *= 10) {\n      res = Math.DivRem (n, p, out rem);\n      if (np[res + rem]) return false; } return true; }\n\n  static void Main(string[] args) { ms(100_009); string mn;\n    WriteLine(\"First 45{0}\", mn = \" magnanimous numbers:\");\n    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {\n      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)\n        Write(c <= 45 ? \"{0,4} \" : \"{0,8:n0} \", l);\n      if (c < 45 && c % 15 == 0) WriteLine();\n      if (c == 240) WriteLine (\"\\n\\n241st through 250th{0}\", mn);\n      if (c == 390) WriteLine (\"\\n\\n391st through 400th{0}\", mn); } }\n}\n"}
{"id": 386835, "name": "Mersenne primes", "source": "Translate Ruby to C#: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 386836, "name": "Mersenne primes", "source": "Translate Ruby to C#: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 386837, "name": "Taxicab numbers", "source": "Translate Ruby to C#: def taxicab_number(nmax=1200)\n  [*1..nmax].repeated_combination(2).group_by{|x,y| x**3 + y**3}.select{|k,v| v.size>1}.sort\nend\n\nt = [0] + taxicab_number\n\n[*1..25, *2000...2007].each do |i|\n  puts \"%4d: %10d\" % [i, t[i][0]] + t[i][1].map{|a| \" = %4d**3 + %4d**3\" % a}.join\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace TaxicabNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);\n            PrintTaxicabNumbers(taxicabNumbers);\n            Console.ReadKey();\n        }\n\n        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)\n        {\n            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();\n\n            for (int i = 1; i < int.MaxValue; i++)\n            {\n                for (int j = 1; j < int.MaxValue; j++)\n                {\n                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));\n\n                    if (!sumsOfTwoCubes.ContainsKey(sum))\n                    {\n                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());\n                    }\n\n                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));\n\n                    if (j >= i)\n                    {\n                        break;\n                    }\n                }\n\n                \n                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)\n                {\n                    break;\n                }\n            }\n\n            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)\n                .Take(2006)\n                .ToDictionary(u => u.Key, u => u.Value);\n\n            return values;\n        }\n\n        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)\n        {\n            int i = 1;\n\n            foreach (long taxicabNumber in values.Keys)\n            {\n                StringBuilder output = new StringBuilder().AppendFormat(\"{0,10}\\t{1,4}\", i, taxicabNumber);\n\n                foreach (Tuple<int, int> numbers in values[taxicabNumber])\n                {\n                    output.AppendFormat(\"\\t= {0}^3 + {1}^3\", numbers.Item1, numbers.Item2);\n                }\n\n                if (i <= 25 || (i >= 2000 && i <= 2006))\n                {\n                    Console.WriteLine(output.ToString());\n                }\n\n                i++;\n            }\n        }\n    }\n}\n"}
{"id": 386838, "name": "Strong and weak primes", "source": "Translate Ruby to C#: require 'prime'\n\nstrong_gen = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b<b} }\nweak_gen   = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b>b} }\n\nputs \"First 36 strong primes:\"\nputs strong_gen.take(36).join(\" \"), \"\\n\"\nputs \"First 37 weak primes:\"\nputs weak_gen.take(37).join(\" \"), \"\\n\"\n\n[1_000_000, 10_000_000].each do |limit|\n  strongs, weaks = 0, 0\n  Prime.each_cons(3) do |a,b,c|\n    strongs += 1 if b > a+c-b\n    weaks += 1 if b < a+c-b\n    break if c > limit\n  end\n  puts \"\nend\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\nusing System;\n\npublic static class StrongAndWeakPrimes\n{\n    public static void Main() {\n        var primes = PrimeGenerator(10_000_100).ToList();\n        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];\n        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];\n        WriteLine($\"First 36 strong primes: {string.Join(\", \", strongPrimes.Take(36))}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}\");\n        WriteLine($\"First 37 weak primes: {string.Join(\", \", weakPrimes.Take(37))}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n    }\n   \n}\n"}
{"id": 386839, "name": "Left factorials", "source": "Translate Ruby to C#: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 386840, "name": "Left factorials", "source": "Translate Ruby to C#: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 386841, "name": "Strange unique prime triplets", "source": "Translate Ruby to C#: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 386842, "name": "Strange unique prime triplets", "source": "Translate Ruby to C#: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 386843, "name": "Motzkin numbers", "source": "Translate Ruby to C#: require \"prime\"\n\nmotzkin = Enumerator.new do |y|\n  m = [1,1]\n  m.each{|m| y << m }\n  \n  2.step do |i| \n    m << (m.last*(2*i+1) + m[-2]*(3*i-3)) / (i+2)\n    m.unshift \n    y << m.last\n  end\nend\n\nmotzkin.take(42).each_with_index do |m, i|\n  puts \"\nend\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n  \n  static bool hmf(BI x) {\n    if (x < 4) return x == 1;\n    if ((x & 1) == 0 || x % 3 == 0) return true;\n    int l = (int)Math.Sqrt((double)x); \n    for (int j = 5, d = 4; j <= l; j += d = 6 - d)\n      if (x % j == 0) return x > j;\n    return false;\n  }\n \n  static void Main(string[] args) {\n    BI a = 0, b = 1, t;\n    int n = 1, s = 0, d = 1, c = 0, f = 1;\n    while (n <= 80)\n      Console.WriteLine(\"{0,46:n0} {1}\",\n        t = b / n++,\n        hmf(t) ? \"\" : \"is prime.\",\n        t = b,\n        b = ((c += d * 3 + 3) * a +\n             (f += d * 2 + 3) * b) /\n             (s += d += 2),\n        a = t);\n  }\n}\n"}
{"id": 386844, "name": "Magic squares of doubly even order", "source": "Translate Ruby to C#: def double_even_magic_square(n)\n  raise ArgumentError, \"Need multiple of four\" if n%4 > 0\n  block_size, max = n/4, n*n\n  pre_pat = [true, false, false, true,\n             false, true, true, false]\n  pre_pat += pre_pat.reverse\n  pattern = pre_pat.flat_map{|b| [b] * block_size} * block_size\n  flat_ar = pattern.each_with_index.map{|yes, num| yes ? num+1 : max-num}\n  flat_ar.each_slice(n).to_a\nend\n\ndef to_string(square)\n  n = square.size\n  fmt = \"%\n  square.inject(\"\"){|str,row| str << fmt % row << \"\\n\"}\nend\n\nputs to_string(double_even_magic_square(8))\n", "target": "using System;\n\nnamespace MagicSquareDoublyEven\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = 8;\n            var result = MagicSquareDoublyEven(n);\n            for (int i = 0; i < result.GetLength(0); i++)\n            {\n                for (int j = 0; j < result.GetLength(1); j++)\n                    Console.Write(\"{0,2} \", result[i, j]);\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMagic constant: {0} \", (n * n + 1) * n / 2);\n            Console.ReadLine();\n        }\n\n        private static int[,] MagicSquareDoublyEven(int n)\n        {\n            if (n < 4 || n % 4 != 0)\n                throw new ArgumentException(\"base must be a positive \"\n                        + \"multiple of 4\");\n\n            \n            int bits = 0b1001_0110_0110_1001;\n            int size = n * n;\n            int mult = n / 4;  \n\n            int[,] result = new int[n, n];\n\n            for (int r = 0, i = 0; r < n; r++)\n            {\n                for (int c = 0; c < n; c++, i++)\n                {\n                    int bitPos = c / mult + (r / mult) * 4;\n                    result[r, c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 386845, "name": "Self numbers", "source": "Translate Ruby to C#: func is_self_number(n) {\n\n    if (n < 30) {\n        return (((n < 10) && (n.is_odd)) || (n == 20))\n    }\n\n    var qd = (1 + n.ilog10)\n    var r  = (1 + (n-1)%9)\n    var h  = (r + 9*(r%2))/2\n    var ld = 10\n\n    while (h + 9*qd >= n%ld) {\n        ld *= 10\n    }\n\n    var vs = idiv(n, ld).sumdigits\n    n %= ld\n\n    0..qd -> none { |i|\n        vs + sumdigits(n - h - 9*i) == (h + 9*i)\n    }\n}\n\nsay is_self_number.first(50).join(' ')\n", "target": "using System;\nusing static System.Console;\n\nclass Program {\n\n  const int mc = 103 * 1000 * 10000 + 11 * 9 + 1;\n\n  static bool[] sv = new bool[mc + 1];\n\n  static void sieve() { int[] dS = new int[10000];\n    for (int a = 9, i = 9999; a >= 0; a--)\n      for (int b = 9; b >= 0; b--)\n        for (int c = 9, s = a + b; c >= 0; c--)\n          for (int d = 9, t = s + c; d >= 0; d--)\n            dS[i--] = t + d;\n    for (int a = 0, n = 0; a < 103; a++)\n      for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000)\n        for (int c = 0, s = d + dS[b] + n; c < 10000; c++)\n          sv[dS[c] + s++] = true; }\n\n  static void Main() { DateTime st = DateTime.Now; sieve();\n    WriteLine(\"Sieving took {0}s\", (DateTime.Now - st).TotalSeconds); \n    WriteLine(\"\\nThe first 50 self numbers are:\");\n    for (int i = 0, count = 0; count <= 50; i++) if (!sv[i]) {\n        count++; if (count <= 50) Write(\"{0} \", i);\n        else WriteLine(\"\\n\\n       Index     Self number\"); }\n    for (int i = 0, limit = 1, count = 0; i < mc; i++)\n      if (!sv[i]) if (++count == limit) {\n          WriteLine(\"{0,12:n0} \u00a0 {1,13:n0}\", count, i);\n          if (limit == 1e9) break; limit *= 10; }\n    WriteLine(\"\\nOverall took {0}s\", (DateTime.Now - st). TotalSeconds);\n  }\n}\n"}
{"id": 386846, "name": "Pythagorean quadruples", "source": "Translate Ruby to C#: n = 2200\nl_add, l = Hash(Int32, Bool).new(false), Hash(Int32, Bool).new(false)\n(1..n).each do |x|\n  x2 = x * x \n  (x..n).each { |y| l_add[x2 + y * y] = true } \nend\n\ns = 3\n(1..n).each do |x|\n  s1 = s\n  s += 2\n  s2 = s\n  ((x+1)..n).each do |y|\n    l[y] = true if l_add[s1]\n    s1 += s2\n    s2 += 2\n  end\nend\n\nputs (1..n).reject{ |x| l[x] }.join(\" \")\n", "target": "using System;\n\nnamespace PythagoreanQuadruples {\n    class Program {\n        const int MAX = 2200;\n        const int MAX2 = MAX * MAX * 2;\n\n        static void Main(string[] args) {\n            bool[] found = new bool[MAX + 1]; \n            bool[] a2b2 = new bool[MAX2 + 1]; \n            int s = 3;\n\n            for(int a = 1; a <= MAX; a++) {\n                int a2 = a * a;\n                for (int b=a; b<=MAX; b++) {\n                    a2b2[a2 + b * b] = true;\n                }\n            }\n\n            for (int c = 1; c <= MAX; c++) {\n                int s1 = s;\n                s += 2;\n                int s2 = s;\n                for (int d = c + 1; d <= MAX; d++) {\n                    if (a2b2[s1]) found[d] = true;\n                    s1 += s2;\n                    s2 += 2;\n                }\n            }\n\n            Console.WriteLine(\"The values of d <= {0} which can't be represented:\", MAX);\n            for (int d = 1; d < MAX; d++) {\n                if (!found[d]) Console.Write(\"{0}  \", d);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386847, "name": "Sum and product puzzle", "source": "Translate Ruby to C#: def add(x,y) x + y end\ndef mul(x,y) x * y end\n\ndef sumEq(s,p) s.select{|q| add(*p) == add(*q)} end\ndef mulEq(s,p) s.select{|q| mul(*p) == mul(*q)} end\n\ns1 = (a = *2...100).product(a).select{|x,y| x<y && x+y<100}\ns2 = s1.select{|p| sumEq(s1,p).all?{|q| mulEq(s1,q).size != 1} }\ns3 = s2.select{|p| (mulEq(s1,p) & s2).size == 1}\np    s3.select{|p| (sumEq(s1,p) & s3).size == 1}\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        const int maxSum = 100;\n        var pairs = (\n            from X in 2.To(maxSum / 2 - 1)\n            from Y in (X + 1).To(maxSum - 2).TakeWhile(y => X + y <= maxSum)\n            select new { X, Y, S = X + Y, P = X * Y }\n            ).ToHashSet();\n\n        Console.WriteLine(pairs.Count);\n        \n        var uniqueP = pairs.GroupBy(pair => pair.P).Where(g => g.Count() == 1).Select(g => g.Key).ToHashSet();\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Any(pair => uniqueP.Contains(pair.P))).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.P).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        foreach (var pair in pairs) Console.WriteLine(pair);\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i <= end; i++) yield return i;\n    }\n    \n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n}\n"}
{"id": 386848, "name": "Minimum primes", "source": "Translate Ruby to C#: require \"prime\"\nnumbers1 = [ 5, 45, 23, 21, 67]\nnumbers2 = [43, 22, 78, 46, 38]\nnumbers3 = [ 9, 98, 12, 54, 53]\n\np [numbers1, numbers2, numbers3].transpose.map{|ar| (ar.max..).find(&:prime?) }\n", "target": "using System;\nusing System.Linq;\nusing static System.Console;\n\nclass Program {\n\n  static int nxtPrime(int x) {\n    int j = 2; do {\n        if (x % j == 0) { j = 2; x++; }\n        else j += j < 3 ? 1 : 2;\n    } while (j * j <= x); return x; }\n\n  static void Main(string[] args) {\n    WriteLine(\"working...\");\n    int[] Num1 = new int[]{  5, 45, 23, 21, 67 },\n          Num2 = new int[]{ 43, 22, 78, 46, 38 },\n          Num3 = new int[]{  9, 98, 12, 54, 53 };\n    int n = Num1.Length; int[] Nums = new int[n];\n    for (int i = 0; i < n; i++)\n      Nums[i] = nxtPrime(new int[]{ Num1[i], Num2[i], Num3[i] }.Max());\n    WriteLine(\"The minimum prime numbers of three lists = [{0}]\", string.Join(\",\", Nums));\n    Write(\"done...\"); } }\n"}
{"id": 386849, "name": "Type detection", "source": "Translate Ruby to C#: def print_type(x)\n  puts \"Compile-time type of \n  puts \"    Actual runtime type is \nend\n\nprint_type 123\nprint_type 123.45\nprint_type  rand < 0.5 ? \"1\" : 0 \nprint_type rand < 1.5\nprint_type nil\nprint_type 'c'\nprint_type \"str\"\nprint_type [1,2]\nprint_type({ 2, \"two\" })\nprint_type({a: 1, b: 2})\nprint_type ->(x : Int32){ x+2 > 0 }\n", "target": "using System;\n\nnamespace TypeDetection {\n    class C { }\n    struct S { }\n    enum E {\n        NONE,\n    }\n\n    class Program {\n        static void ShowType<T>(T t) {\n            Console.WriteLine(\"The type of '{0}' is {1}\", t, t.GetType());\n        }\n\n        static void Main() {\n            ShowType(5);\n            ShowType(7.5);\n            ShowType('d');\n            ShowType(true);\n            ShowType(\"Rosetta\");\n            ShowType(new C());\n            ShowType(new S());\n            ShowType(E.NONE);\n            ShowType(new int[] { 1, 2, 3 });\n        }\n    }\n}\n"}
{"id": 386850, "name": "Primes which contain only one odd digit", "source": "Translate Ruby to C#: func primes_with_one_odd_digit(upto, base = 10) {\n\n    upto = prev_prime(upto+1)\n\n    var list = []\n    var digits = @(^base)\n\n    var even_digits = digits.grep { .is_even }\n    var odd_digits  = digits.grep { .is_odd && .is_coprime(base) }\n\n    list << digits.grep { .is_odd && .is_prime && !.is_coprime(base) }...\n\n    for k in (0 .. upto.ilog(base)) {\n        even_digits.variations_with_repetition(k, {|*a|\n            next if (a.last == 0)\n            var v = a.digits2num(base)\n            odd_digits.each {|d|\n                var n = (v*base + d)\n                list << n if (n.is_prime && (n <= upto))\n            }\n        })\n    }\n\n    list.sort\n}\n\nwith (1e3) {|n|\n    var list = primes_with_one_odd_digit(n)\n    say \"There are \n    list.each_slice(9, {|*a| say a.map { '%3s' % _ }.join(' ') })\n}\n\nsay ''\n\nfor k in (1..8) {\n    var count = primes_with_one_odd_digit(10**k).len\n    say \"There are \n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    \n    \n    static List<uint> sieve(uint max, bool ordinary = false)\n    {\n        uint k = ((max - 3) >> 1) + 1,\n           lmt = ((uint)(Math.Sqrt(max++) - 3) >> 1) + 1;\n        var pl = new List<uint> { };\n        var ic = new bool[k];\n        for (uint i = 0, p = 3; i < lmt; i++, p += 2) if (!ic[i])\n                for (uint j = (p * p - 3) >> 1; j < k; j += p) ic[j] = true;\n        if (ordinary)\n        {\n            pl.Add(2);\n            for (uint i = 0, j = 3; i < k; i++, j += 2)\n                if (!ic[i]) pl.Add(j);\n        }\n        else\n            for (uint i = 0, j = 3, t = j; i < k; i++, t = j += 2)\n                if (!ic[i])\n                {\n                    while ((t /= 10) > 0)\n                        if (((t % 10) & 1) == 1) goto skip;\n                    pl.Add(j);\n                skip:;\n                }\n        return pl;\n    }\n\n    static void Main(string[] args)\n    {\n        var pl = sieve((uint)1e9);\n        uint c = 0, l = 10, p = 1;\n        Console.WriteLine(\"List of one-odd-digit primes < 1,000:\");\n        for (int i = 0; pl[i] < 1000; i++)\n            Console.Write(\"{0,3}{1}\", pl[i], i % 9 == 8 ? \"\\n\" : \"  \");\n        string fmt = \"\\nFound {0:n0} one-odd-digit primes < 10^{1} ({2:n0})\";\n        foreach (var itm in pl)\n            if (itm < l) c++;\n            else Console.Write(fmt, c++, p++, l, l *= 10);\n        Console.Write(fmt, c++, p++, l);\n    }\n}\n"}
{"id": 386851, "name": "Primes which contain only one odd digit", "source": "Translate Ruby to C#: func primes_with_one_odd_digit(upto, base = 10) {\n\n    upto = prev_prime(upto+1)\n\n    var list = []\n    var digits = @(^base)\n\n    var even_digits = digits.grep { .is_even }\n    var odd_digits  = digits.grep { .is_odd && .is_coprime(base) }\n\n    list << digits.grep { .is_odd && .is_prime && !.is_coprime(base) }...\n\n    for k in (0 .. upto.ilog(base)) {\n        even_digits.variations_with_repetition(k, {|*a|\n            next if (a.last == 0)\n            var v = a.digits2num(base)\n            odd_digits.each {|d|\n                var n = (v*base + d)\n                list << n if (n.is_prime && (n <= upto))\n            }\n        })\n    }\n\n    list.sort\n}\n\nwith (1e3) {|n|\n    var list = primes_with_one_odd_digit(n)\n    say \"There are \n    list.each_slice(9, {|*a| say a.map { '%3s' % _ }.join(' ') })\n}\n\nsay ''\n\nfor k in (1..8) {\n    var count = primes_with_one_odd_digit(10**k).len\n    say \"There are \n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    \n    \n    static List<uint> sieve(uint max, bool ordinary = false)\n    {\n        uint k = ((max - 3) >> 1) + 1,\n           lmt = ((uint)(Math.Sqrt(max++) - 3) >> 1) + 1;\n        var pl = new List<uint> { };\n        var ic = new bool[k];\n        for (uint i = 0, p = 3; i < lmt; i++, p += 2) if (!ic[i])\n                for (uint j = (p * p - 3) >> 1; j < k; j += p) ic[j] = true;\n        if (ordinary)\n        {\n            pl.Add(2);\n            for (uint i = 0, j = 3; i < k; i++, j += 2)\n                if (!ic[i]) pl.Add(j);\n        }\n        else\n            for (uint i = 0, j = 3, t = j; i < k; i++, t = j += 2)\n                if (!ic[i])\n                {\n                    while ((t /= 10) > 0)\n                        if (((t % 10) & 1) == 1) goto skip;\n                    pl.Add(j);\n                skip:;\n                }\n        return pl;\n    }\n\n    static void Main(string[] args)\n    {\n        var pl = sieve((uint)1e9);\n        uint c = 0, l = 10, p = 1;\n        Console.WriteLine(\"List of one-odd-digit primes < 1,000:\");\n        for (int i = 0; pl[i] < 1000; i++)\n            Console.Write(\"{0,3}{1}\", pl[i], i % 9 == 8 ? \"\\n\" : \"  \");\n        string fmt = \"\\nFound {0:n0} one-odd-digit primes < 10^{1} ({2:n0})\";\n        foreach (var itm in pl)\n            if (itm < l) c++;\n            else Console.Write(fmt, c++, p++, l, l *= 10);\n        Console.Write(fmt, c++, p++, l);\n    }\n}\n"}
{"id": 386852, "name": "Safe primes and unsafe primes", "source": "Translate Ruby to C#: require \"prime\"\nclass Integer\n  def safe_prime? \n    ((self-1)/2).prime?\n  end\nend\n\ndef format_parts(n)\n  partitions = Prime.each(n).partition(&:safe_prime?).map(&:count)\n  \"There are %d safes and %d unsafes below \nend\n\nputs \"First 35 safe-primes:\"\np Prime.each.lazy.select(&:safe_prime?).take(35).to_a\nputs format_parts(1_000_000), \"\\n\" \n\nputs \"First 40 unsafe-primes:\"\np Prime.each.lazy.reject(&:safe_prime?).take(40).to_a\nputs format_parts(10_000_000)\n", "target": "using static System.Console;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class SafePrimes\n{\n    public static void Main() {\n        HashSet<int> primes = Primes(10_000_000).ToHashSet();\n        WriteLine(\"First 35 safe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsSafe).Take(35)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}\");\n        WriteLine(\"First 40 unsafe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsUnsafe).Take(40)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}\");\n\n        bool IsSafe(int prime) => primes.Contains(prime / 2);\n        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);\n    }\n\n    \n    static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n}\n"}
{"id": 386853, "name": "Hash join", "source": "Translate Ruby to C#: def hashJoin(table1, index1, table2, index2)\n  \n  h = table1.group_by {|s| s[index1]}\n  h.default = []\n  \n  table2.collect {|r|\n    h[r[index2]].collect {|s| [s, r]}\n  }.flatten(1)\nend\n\ntable1 = [[27, \"Jonah\"],\n          [18, \"Alan\"],\n          [28, \"Glory\"],\n          [18, \"Popeye\"],\n          [28, \"Alan\"]]\ntable2 = [[\"Jonah\", \"Whales\"],\n          [\"Jonah\", \"Spiders\"],\n          [\"Alan\", \"Ghosts\"],\n          [\"Alan\", \"Zombies\"],\n          [\"Glory\", \"Buffy\"]]\n\nhashJoin(table1, 1, table2, 0).each { |row| p row }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"id": 386854, "name": "Largest palindrome product", "source": "Translate Ruby to C#: func largest_palindrome_product (n) {\n\n    for k in ((10**n - 1) `downto` 10**(n-1)) {\n        var t = Num(\"\n\n        t.divisors.each {|d|\n            if ((d.len == n) && ((t/d).len == n)) {\n                return (d, t/d)\n            }\n        }\n    }\n}\n\nfor n in (2..9) {\n    var (a,b) = largest_palindrome_product(n)\n    say \"Largest palindromic product of two \n}\n", "target": "using System;\nclass Program {\n\n  static bool isPal(int n) {\n    int rev = 0, lr = -1, rem;\n    while (n > rev) {\n      n = Math.DivRem(n, 10, out rem);\n      if (lr < 0 && rem == 0) return false;\n      lr = rev; rev = 10 * rev + rem;\n      if (n == rev || n == lr) return true;\n    } return false; }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    int x = 900009, y = (int)Math.Sqrt(x), y10, max = 999, max9 = max - 9, z, p, bp = x, ld, c;\n    var a = new int[]{ 0,9,0,3,0,0,0,7,0,1 }; string bs = \"\";\n    y /= 11;\n    if ((y & 1) == 0) y--;\n    if (y % 5 == 0) y -= 2;\n    y *= 11;\n    while (y <= max) {\n      c = 0;\n      y10 = y * 10;\n      z = max9 + a[ld = y % 10];\n      p = y * z;\n      while (p >= bp) {\n        if (isPal(p)) {\n          if (p > bp) bp = p;\n          bs = string.Format(\"{0} x {1} = {2}\", y, z - c, bp);\n        }\n        p -= y10; c += 10;\n      }\n      y += ld == 3 ? 44 : 22;\n    }\n    sw.Stop();\n    Console.Write(\"{0} {1} \u03bcs\", bs, sw.Elapsed.TotalMilliseconds * 1000.0);\n  }\n}\n"}
{"id": 386855, "name": "Find largest left truncatable prime in a given base", "source": "Translate Ruby to C#: \n\n\n\n\nrequire 'prime'\nBASE = 3\nMAX = 500\nstems = Prime.each(BASE-1).to_a\n(1..MAX-1).each {|i|\n  print \"\n  t = []\n  b = BASE ** i\n  stems.each {|z|\n    (1..BASE-1).each {|n|\n      c = n*b+z\n      t.push(c) if c.prime?\n  }}\n  break if t.empty?\n  stems = t\n}\nputs \"The largest left truncatable prime \n", "target": "using Mpir.NET;  \nusing System;   \nusing System.Collections.Generic;\nclass MaxLftTrP_B   \n{\n    static void Main()\n    {\n        mpz_t p; var sw = System.Diagnostics.Stopwatch.StartNew(); L(3);\n        for (uint b = 3; b < 13; b++)\n        {\n            sw.Restart(); p = L(b);\n            Console.WriteLine(\"{0} {1,2} {2}\", sw.Elapsed, b, p);\n        }\n        Console.Read();\n    }\n\n    static mpz_t L(uint b)\n    {\n        var p = new List<mpz_t>(); mpz_t np = 0;\n        while ((np = nxtP(np)) < b) p.Add(np);\n        int i0 = 0, i = 0, i1 = p.Count - 1; mpz_t n0 = b, n, n1 = b * (b - 1);\n        for (; i < p.Count; n0 *= b, n1 *= b, i0 = i1 + 1, i1 = p.Count - 1)\n            for (n = n0; n <= n1; n += n0)\n                for (i = i0; i <= i1; i++)\n                    if (mpir.mpz_probab_prime_p(np = n + p[i], 15) > 0) p.Add(np);\n        return p[p.Count - 1];\n    }\n\n    static mpz_t nxtP(mpz_t n) { mpz_t p = 0; mpir.mpz_nextprime(p, n); return p; }\n}\n"}
{"id": 386856, "name": "Speech synthesis", "source": "Translate Ruby to C#: module OperatingSystem\n  require 'rbconfig'\n  module_function\n  def operating_system\n    case RbConfig::CONFIG[\"host_os\"]\n    when /linux/i\n      :linux\n    when /cygwin|mswin|mingw|windows/i\n      :windows\n    when /darwin/i\n      :mac\n    when /solaris/i\n      :solaris\n    else\n      nil\n    end\n  end\n  def linux?;   operating_system == :linux;   end\n  def windows?; operating_system == :windows; end\n  def mac?;     operating_system == :mac;     end\nend\n", "target": "using SpeechLib;\n\nnamespace Speaking_Computer\n{\n  public class Program\n  {\n    private static void Main()\n    {\n      var voice = new SpVoice();\n      voice.Speak(\"This is an example of speech synthesis.\");\n    }\n  }\n}\n"}
{"id": 386857, "name": "Tonelli-Shanks algorithm", "source": "Translate Ruby to C#: func tonelli(n, p) {\n    legendre(n, p) == 1 || die \"not a square (mod p)\"\n    var q = p-1\n    var s = valuation(q, 2)\n    s == 1 ? return(powmod(n, (p + 1) >> 2, p)) : (q >>= s)\n    var c = powmod(2 ..^ p -> first {|z| legendre(z, p) == -1}, q, p)\n    var r = powmod(n, (q + 1) >> 1, p)\n    var t = powmod(n, q, p)\n    var m = s\n    var t2 = 0\n    while (!p.divides(t - 1)) {\n        t2 = ((t * t) % p)\n        var b\n        for i in (1 ..^ m) {\n            if (p.divides(t2 - 1)) {\n                b = powmod(c, 1 << (m - i - 1), p)\n                m = i\n                break\n            }\n            t2 = ((t2 * t2) % p)\n        }\n\n        r = ((r * b) % p)\n        c = ((b * b) % p)\n        t = ((t * c) % p)\n    }\n    return r\n}\n\nvar tests = [\n    [10, 13], [56, 101], [1030, 10009], [44402, 100049],\n    [665820697, 1000000009], [881398088036, 1000000000039],\n    [41660815127637347468140745042827704103445750172002, 10**50 + 577],\n]\n\nfor n,p in tests {\n    var r = tonelli(n, p)\n    assert((r*r - n) % p == 0)\n    say \"Roots of \n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 386858, "name": "Tonelli-Shanks algorithm", "source": "Translate Ruby to C#: func tonelli(n, p) {\n    legendre(n, p) == 1 || die \"not a square (mod p)\"\n    var q = p-1\n    var s = valuation(q, 2)\n    s == 1 ? return(powmod(n, (p + 1) >> 2, p)) : (q >>= s)\n    var c = powmod(2 ..^ p -> first {|z| legendre(z, p) == -1}, q, p)\n    var r = powmod(n, (q + 1) >> 1, p)\n    var t = powmod(n, q, p)\n    var m = s\n    var t2 = 0\n    while (!p.divides(t - 1)) {\n        t2 = ((t * t) % p)\n        var b\n        for i in (1 ..^ m) {\n            if (p.divides(t2 - 1)) {\n                b = powmod(c, 1 << (m - i - 1), p)\n                m = i\n                break\n            }\n            t2 = ((t2 * t2) % p)\n        }\n\n        r = ((r * b) % p)\n        c = ((b * b) % p)\n        t = ((t * c) % p)\n    }\n    return r\n}\n\nvar tests = [\n    [10, 13], [56, 101], [1030, 10009], [44402, 100049],\n    [665820697, 1000000009], [881398088036, 1000000000039],\n    [41660815127637347468140745042827704103445750172002, 10**50 + 577],\n]\n\nfor n,p in tests {\n    var r = tonelli(n, p)\n    assert((r*r - n) % p == 0)\n    say \"Roots of \n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 386859, "name": "Truth table", "source": "Translate Ruby to C#: loop do\n  print \"\\ninput a boolean expression (e.g. 'a & b'): \"\n  expr = gets.strip.downcase \n  break if expr.empty?\n\n  vars = expr.scan(/\\p{Alpha}+/)\n  if vars.empty?\n    puts \"no variables detected in your boolean expression\"\n    next\n  end\n\n  vars.each {|v| print \"\n  puts \"| \n\n  prefix = []\n  suffix = []\n  vars.each do |v|\n    prefix << \"[false, true].each do |\n    suffix << \"end\"\n  end\n\n  body = vars.inject(\"puts \") {|str, v| str + \"\n  body += '\"| \" + eval(expr).to_s'\n\n  eval (prefix + [body] + suffix).join(\"\\n\")\nend\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TruthTable\n{\n    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }\n\n    readonly char trueConstant, falseConstant;\n    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();\n\n    public TruthTable(char falseConstant, char trueConstant)\n    {\n        this.trueConstant = trueConstant;\n        this.falseConstant = falseConstant;\n        Operators = new OperatorCollection(operators);\n    }\n\n    public OperatorCollection Operators { get; }\n\n    public void PrintTruthTable(string expression, bool isPostfix = false)\n    {\n        try {\n            foreach (string line in GetTruthTable(expression, isPostfix)) {\n                Console.WriteLine(line);\n            }\n        } catch (ArgumentException ex) {\n            Console.WriteLine(expression + \"   \" + ex.Message);\n        }\n    }\n\n    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)\n    {\n        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(\"Invalid expression.\");\n        \n        \n        var parameters = expression\n            .Where(c => TypeOf(c) == TokenType.Operand)\n            .Distinct()\n            .Reverse()\n            .Select((c, i) => (symbol: c, index: i))\n            .ToDictionary(p => p.symbol, p => p.index);\n\n        int count = parameters.Count;\n        if (count > 32) throw new ArgumentException(\"Cannot have more than 32 parameters.\");\n        string header = count == 0 ? expression : string.Join(\" \",\n            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + \" \" + expression;\n\n        if (!isPostfix) expression = ConvertToPostfix(expression);\n\n        var values = default(BitSet);\n        var stack = new Stack<char>(expression.Length);\n        for (int loop = 1 << count; loop > 0; loop--) {\n            foreach (char token in expression) stack.Push(token);\n            bool result = Evaluate(stack, values, parameters);\n            if (header != null) {\n                if (stack.Count > 0) throw new ArgumentException(\"Invalid expression.\");\n                yield return header;\n                header = null;\n            }\n            string line = (count == 0 ? \"\" : \" \") + (result ? trueConstant : falseConstant);\n            line = string.Join(\" \", Enumerable.Range(0, count)\n                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;\n            yield return line;\n            values++;\n        }\n    }\n\n    public string ConvertToPostfix(string infix)\n    {\n        var stack = new Stack<char>();\n        var postfix = new StringBuilder();\n        foreach (char c in infix) {\n            switch (TypeOf(c)) {\n            case TokenType.WhiteSpace:\n                continue;\n            case TokenType.Constant:\n            case TokenType.Operand:\n                postfix.Append(c);\n                break;\n            case TokenType.Operator:\n                int precedence = Precedence(c);\n                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {\n                    postfix.Append(stack.Pop());\n                }\n                stack.Push(c);\n                break;\n            case TokenType.LeftParenthesis:\n                stack.Push(c);\n                break;\n            case TokenType.RightParenthesis:\n                char top = default(char);\n                while (stack.Count > 0) {\n                    top = stack.Pop();\n                    if (top == '(') break;\n                    else postfix.Append(top);\n                }\n                if (top != '(') throw new ArgumentException(\"No matching left parenthesis.\");\n                break;\n            default:\n                throw new ArgumentException(\"Invalid character: \" + c);\n            }\n        }\n        while (stack.Count > 0) {\n            char top = stack.Pop();\n            if (top == '(') throw new ArgumentException(\"No matching right parenthesis.\");\n            postfix.Append(top);\n        }\n        return postfix.ToString();\n    }\n\n    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)\n    {\n        if (expression.Count == 0) throw new ArgumentException(\"Invalid expression.\");\n        char c = expression.Pop();\n        TokenType type = TypeOf(c);\n        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());\n        switch (type) {\n        case TokenType.Constant:\n            return c == trueConstant;\n        case TokenType.Operand:\n            return values[parameters[c]];\n        case TokenType.Operator:\n            bool right = Evaluate(expression, values, parameters);\n            Operator op = operators[c];\n            if (op.Arity == 1) return op.Function(right, right);\n            bool left = Evaluate(expression, values, parameters);\n            return op.Function(left, right);\n        default:\n            throw new ArgumentException(\"Invalid character: \" + c);\n        }\n    }\n\n    private TokenType TypeOf(char c)\n    {\n        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;\n        if (c == '(') return TokenType.LeftParenthesis;\n        if (c == ')') return TokenType.RightParenthesis;\n        if (c == trueConstant || c == falseConstant) return TokenType.Constant;\n        if (operators.ContainsKey(c)) return TokenType.Operator;\n        if (char.IsLetter(c)) return TokenType.Operand;\n        return TokenType.Unknown;\n    }\n\n    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;\n}\n\nstruct Operator\n{\n    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }\n\n    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }\n\n    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()\n    {\n        Symbol = symbol;\n        Precedence = precedence;\n        Arity = arity;\n        Function = function;\n    }\n\n    public char Symbol { get; }\n    public int Precedence { get; }\n    public int Arity { get; }\n    public Func<bool, bool, bool> Function { get; }\n}\n\npublic class OperatorCollection : IEnumerable\n{\n    readonly IDictionary<char, Operator> operators;\n\n    internal OperatorCollection(IDictionary<char, Operator> operators) {\n        this.operators = operators;\n    }\n\n    public void Add(char symbol, int precedence, Func<bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n\n    public void Remove(char symbol) => operators.Remove(symbol);\n\n    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();\n}\n\nstruct BitSet\n{\n    private int bits;\n\n    private BitSet(int bits) { this.bits = bits; }\n\n    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);\n\n    public bool this[int index] => (bits & (1 << index)) != 0;\n}\n\nclass Program\n{\n    public static void Main() {\n        TruthTable tt = new TruthTable('F', 'T') {\n            Operators = {\n                { '!', 6, r => !r },\n                { '&', 5, (l, r) => l && r },\n                { '^', 4, (l, r) => l ^ r },\n                { '|', 3, (l, r) => l || r }\n            }\n        };\n        \n        var rng = new Random();\n        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);\n        string[] expressions = {\n            \"!!!T\",\n            \"?T\",\n            \"F & x | T\",\n            \"F & (x | T\",\n            \"F & x | T)\",\n            \"a\u00a0! (a & a)\",\n            \"a | (a * a)\",\n            \"a ^ T & (b & !c)\",\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n\n        \n        tt = new TruthTable('0', '1') {\n            Operators = {\n                { '-', 6, r => !r },\n                { '^', 5, (l, r) => l && r },\n                { 'v', 3, (l, r) => l || r },\n                { '>', 2, (l, r) => !l || r },\n                { '=', 1, (l, r) => l == r },\n            }\n        };\n        expressions = new[] {\n            \"-X v 0 = X ^ 1\",\n            \"(H > M) ^ (S > H) > (S > M)\"\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386860, "name": "Truth table", "source": "Translate Ruby to C#: loop do\n  print \"\\ninput a boolean expression (e.g. 'a & b'): \"\n  expr = gets.strip.downcase \n  break if expr.empty?\n\n  vars = expr.scan(/\\p{Alpha}+/)\n  if vars.empty?\n    puts \"no variables detected in your boolean expression\"\n    next\n  end\n\n  vars.each {|v| print \"\n  puts \"| \n\n  prefix = []\n  suffix = []\n  vars.each do |v|\n    prefix << \"[false, true].each do |\n    suffix << \"end\"\n  end\n\n  body = vars.inject(\"puts \") {|str, v| str + \"\n  body += '\"| \" + eval(expr).to_s'\n\n  eval (prefix + [body] + suffix).join(\"\\n\")\nend\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TruthTable\n{\n    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }\n\n    readonly char trueConstant, falseConstant;\n    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();\n\n    public TruthTable(char falseConstant, char trueConstant)\n    {\n        this.trueConstant = trueConstant;\n        this.falseConstant = falseConstant;\n        Operators = new OperatorCollection(operators);\n    }\n\n    public OperatorCollection Operators { get; }\n\n    public void PrintTruthTable(string expression, bool isPostfix = false)\n    {\n        try {\n            foreach (string line in GetTruthTable(expression, isPostfix)) {\n                Console.WriteLine(line);\n            }\n        } catch (ArgumentException ex) {\n            Console.WriteLine(expression + \"   \" + ex.Message);\n        }\n    }\n\n    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)\n    {\n        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(\"Invalid expression.\");\n        \n        \n        var parameters = expression\n            .Where(c => TypeOf(c) == TokenType.Operand)\n            .Distinct()\n            .Reverse()\n            .Select((c, i) => (symbol: c, index: i))\n            .ToDictionary(p => p.symbol, p => p.index);\n\n        int count = parameters.Count;\n        if (count > 32) throw new ArgumentException(\"Cannot have more than 32 parameters.\");\n        string header = count == 0 ? expression : string.Join(\" \",\n            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + \" \" + expression;\n\n        if (!isPostfix) expression = ConvertToPostfix(expression);\n\n        var values = default(BitSet);\n        var stack = new Stack<char>(expression.Length);\n        for (int loop = 1 << count; loop > 0; loop--) {\n            foreach (char token in expression) stack.Push(token);\n            bool result = Evaluate(stack, values, parameters);\n            if (header != null) {\n                if (stack.Count > 0) throw new ArgumentException(\"Invalid expression.\");\n                yield return header;\n                header = null;\n            }\n            string line = (count == 0 ? \"\" : \" \") + (result ? trueConstant : falseConstant);\n            line = string.Join(\" \", Enumerable.Range(0, count)\n                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;\n            yield return line;\n            values++;\n        }\n    }\n\n    public string ConvertToPostfix(string infix)\n    {\n        var stack = new Stack<char>();\n        var postfix = new StringBuilder();\n        foreach (char c in infix) {\n            switch (TypeOf(c)) {\n            case TokenType.WhiteSpace:\n                continue;\n            case TokenType.Constant:\n            case TokenType.Operand:\n                postfix.Append(c);\n                break;\n            case TokenType.Operator:\n                int precedence = Precedence(c);\n                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {\n                    postfix.Append(stack.Pop());\n                }\n                stack.Push(c);\n                break;\n            case TokenType.LeftParenthesis:\n                stack.Push(c);\n                break;\n            case TokenType.RightParenthesis:\n                char top = default(char);\n                while (stack.Count > 0) {\n                    top = stack.Pop();\n                    if (top == '(') break;\n                    else postfix.Append(top);\n                }\n                if (top != '(') throw new ArgumentException(\"No matching left parenthesis.\");\n                break;\n            default:\n                throw new ArgumentException(\"Invalid character: \" + c);\n            }\n        }\n        while (stack.Count > 0) {\n            char top = stack.Pop();\n            if (top == '(') throw new ArgumentException(\"No matching right parenthesis.\");\n            postfix.Append(top);\n        }\n        return postfix.ToString();\n    }\n\n    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)\n    {\n        if (expression.Count == 0) throw new ArgumentException(\"Invalid expression.\");\n        char c = expression.Pop();\n        TokenType type = TypeOf(c);\n        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());\n        switch (type) {\n        case TokenType.Constant:\n            return c == trueConstant;\n        case TokenType.Operand:\n            return values[parameters[c]];\n        case TokenType.Operator:\n            bool right = Evaluate(expression, values, parameters);\n            Operator op = operators[c];\n            if (op.Arity == 1) return op.Function(right, right);\n            bool left = Evaluate(expression, values, parameters);\n            return op.Function(left, right);\n        default:\n            throw new ArgumentException(\"Invalid character: \" + c);\n        }\n    }\n\n    private TokenType TypeOf(char c)\n    {\n        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;\n        if (c == '(') return TokenType.LeftParenthesis;\n        if (c == ')') return TokenType.RightParenthesis;\n        if (c == trueConstant || c == falseConstant) return TokenType.Constant;\n        if (operators.ContainsKey(c)) return TokenType.Operator;\n        if (char.IsLetter(c)) return TokenType.Operand;\n        return TokenType.Unknown;\n    }\n\n    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;\n}\n\nstruct Operator\n{\n    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }\n\n    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }\n\n    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()\n    {\n        Symbol = symbol;\n        Precedence = precedence;\n        Arity = arity;\n        Function = function;\n    }\n\n    public char Symbol { get; }\n    public int Precedence { get; }\n    public int Arity { get; }\n    public Func<bool, bool, bool> Function { get; }\n}\n\npublic class OperatorCollection : IEnumerable\n{\n    readonly IDictionary<char, Operator> operators;\n\n    internal OperatorCollection(IDictionary<char, Operator> operators) {\n        this.operators = operators;\n    }\n\n    public void Add(char symbol, int precedence, Func<bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n\n    public void Remove(char symbol) => operators.Remove(symbol);\n\n    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();\n}\n\nstruct BitSet\n{\n    private int bits;\n\n    private BitSet(int bits) { this.bits = bits; }\n\n    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);\n\n    public bool this[int index] => (bits & (1 << index)) != 0;\n}\n\nclass Program\n{\n    public static void Main() {\n        TruthTable tt = new TruthTable('F', 'T') {\n            Operators = {\n                { '!', 6, r => !r },\n                { '&', 5, (l, r) => l && r },\n                { '^', 4, (l, r) => l ^ r },\n                { '|', 3, (l, r) => l || r }\n            }\n        };\n        \n        var rng = new Random();\n        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);\n        string[] expressions = {\n            \"!!!T\",\n            \"?T\",\n            \"F & x | T\",\n            \"F & (x | T\",\n            \"F & x | T)\",\n            \"a\u00a0! (a & a)\",\n            \"a | (a * a)\",\n            \"a ^ T & (b & !c)\",\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n\n        \n        tt = new TruthTable('0', '1') {\n            Operators = {\n                { '-', 6, r => !r },\n                { '^', 5, (l, r) => l && r },\n                { 'v', 3, (l, r) => l || r },\n                { '>', 2, (l, r) => !l || r },\n                { '=', 1, (l, r) => l == r },\n            }\n        };\n        expressions = new[] {\n            \"-X v 0 = X ^ 1\",\n            \"(H > M) ^ (S > H) > (S > M)\"\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386861, "name": "Set of real numbers", "source": "Translate Ruby to C#: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 386862, "name": "Set of real numbers", "source": "Translate Ruby to C#: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 386863, "name": "Super-d numbers", "source": "Translate Ruby to C#: (2..8).each do |d|\n  rep = d.to_s * d\n  print \"\n  puts (2..).lazy.select{|n| (d * n**d).to_s.include?(rep) }.first(10).join(\", \")\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 386864, "name": "Super-d numbers", "source": "Translate Ruby to C#: (2..8).each do |d|\n  rep = d.to_s * d\n  print \"\n  puts (2..).lazy.select{|n| (d * n**d).to_s.include?(rep) }.first(10).join(\", \")\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 386865, "name": "Monads_Maybe monad", "source": "Translate Ruby to C#: class Maybe\n  def initialize(value)\n    @value = value\n  end\n\n  def map\n    if @value.nil?\n      self\n    else\n      Maybe.new(yield @value)\n    end\n  end\nend\n\nMaybe.new(3).map { |n| 2*n }.map { |n| n+1 }\n\n\nMaybe.new(nil).map { |n| 2*n }.map { |n| n+1 }\n\n\nMaybe.new(3).map { |n| nil }.map { |n| n+1 }\n\n\n\n\nclass Maybe\n  class << self\n    alias :unit :new\n  end\n  \n  def initialize(value)\n    @value = value\n  end\n\n  def bind\n    if @value.nil?\n      self\n    else\n      yield @value\n    end\n  end\nend\n\nMaybe.unit(3).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }\n\n\nMaybe.unit(nil).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }\n\n", "target": "using System;\n\nnamespace RosettaMaybe\n{\n    \n    public abstract class Maybe<T>\n    {\n        public sealed class Some : Maybe<T>\n        {\n            public Some(T value) => Value = value;\n            public T Value { get; }\n        }\n        public sealed class None : Maybe<T> { }\n    }\n\n    class Program\n    {\n        static Maybe<double> MonadicSquareRoot(double x)\n        {\n            if (x >= 0)\n            {\n                return new Maybe<double>.Some(Math.Sqrt(x));\n            }\n            else\n            {\n                return new Maybe<double>.None();\n            }\n        }\n        static void Main(string[] args)\n        {\n            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })\n            {\n                Maybe<double> maybe = MonadicSquareRoot(x);\n                if (maybe is Maybe<double>.Some some)\n                {\n                    Console.WriteLine($\"The square root of {x} is \" + some.Value);\n                }\n                else\n                {\n                    Console.WriteLine($\"Square root of {x} is undefined.\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386866, "name": "Minesweeper game", "source": "Translate Ruby to C#: puts <<EOS\n    Minesweeper game.\n\n    There is an n by m grid that has a random number of between 20% to 60%\n    of randomly hidden mines that need to be found. \n\n    Positions in the grid are modified by entering their coordinates\n    where the first coordinate is horizontal in the grid and the second\n    vertical. The top left of the grid is position 1,1; the bottom right is\n    at n,m.\n\n    * The total number of mines to be found is shown at the beginning of the\n    game.\n    * Each mine occupies a single grid point, and its position is initially\n    unknown to the player\n    * The grid is shown as a rectangle of characters between moves.\n    * You are initially shown all grids as obscured, by a single dot '.'\n    * You may mark what you think is the position of a mine which will show\n    as a '?'\n    * You can mark what you think is free space by entering its coordinates.\n   \u00a0:*  If the point is free space then it is cleared, as are any adjacent\n    points that are also free space- this is repeated recursively for\n    subsequent adjacent free points unless that point is marked as a mine\n    or is a mine.\n   \u00a0::*   Points marked as a mine show as a '?'.\n   \u00a0::*   Other free points show as an integer count of the number of adjacent\n    true mines in its immediate neighbourhood, or as a single space ' ' if the\n    free point is not adjacent to any true mines.\n    * Of course you loose if you try to clear space that starts on a mine.\n    * You win when you have correctly identified all mines.\n\n\n    When prompted you may:\n        Toggle where you think a mine is at position x, y:\n          m <x> <y>\n        Clear the grid starting at position x, y (and print the result):\n          c <x> <y>\n        Print the grid so far:\n          p\n        Quit\n          q\n    Resigning will first show the grid with an 'N' for unfound true mines, a\n    'Y' for found true mines and a '?' for where you marked clear space as a\n    mine\nEOS\n\nWIDTH, HEIGHT = 6, 4\nPCT = 0.15\nNUM_MINES = (WIDTH * HEIGHT * PCT).round\n\ndef create_mines sx, sy\n  arr = Array.new(WIDTH) { Array.new(HEIGHT, false) }\n  NUM_MINES.times do\n    x, y = rand(WIDTH), rand(HEIGHT)\n    \n    redo if arr[x][y] or (x == sx and y == sy)\n    arr[x][y] = true\n  end\n  arr\nend\n\ndef num_marks\n  $screen.inject(0) { |sum, row| sum + row.count(\"?\") }\nend\n\ndef show_grid revealed = false\n  if revealed\n    puts $mines.transpose.map { |row| row.map { |cell| cell ? \"*\" : \" \" }.join(\" \") }\n  else\n    puts \"Grid has \n    puts $screen.transpose.map{ |row| row.join(\" \") }\n  end\nend\n\nSURROUND = [-1,0,1].product([-1,0,1]) - [[0,0]]     \ndef surrounding x, y\n  \n  SURROUND.each do |dx, dy|\n    \n    yield(x+dx, y+dy) if (0...WIDTH).cover?(x+dx) and (0...HEIGHT).cover?(y+dy)\n  end\nend\n\ndef clear_space x, y\n  return unless $screen[x][y] == \".\"\n  \n  count = 0\n  surrounding(x, y) { |px, py| count += 1 if $mines[px][py] }\n  if count == 0\n    $screen[x][y] = \" \"\n    surrounding(x, y) { |px, py| clear_space px, py }\n  else\n    $screen[x][y] = count.to_s\n  end\nend\n\ndef victory?\n  return false if $mines.nil?  \n  return false if num_marks != NUM_MINES\n  mines_left = NUM_MINES\n  WIDTH.times do |x|\n    HEIGHT.times do |y|\n      mines_left -= 1 if $mines[x][y] and $screen[x][y] == \"?\"\n    end\n  end\n  \n  mines_left == 0\nend\n\ndef check_input x, y\n  x, y = x.to_i - 1, y.to_i - 1\n  [x, y] if (0...WIDTH).cover?(x) and (0...HEIGHT).cover?(y)\nend\n\n$mines = nil\n$screen = Array.new(WIDTH) { Array.new(HEIGHT, \".\") }\n\nputs \"Welcome to Minesweeper!\"\nshow_grid\n\nloop do\n  print \"> \"\n  action = gets.chomp.downcase\n  \n  case action\n  when \"quit\", \"exit\", \"x\", \"q\"\n    puts \"Bye!\"\n    break\n  when /^m (\\d+) (\\d+)$/\n    \n    x, y = check_input $1, $2\n    next unless x\n    if $screen[x][y] == \".\"\n      \n      $screen[x][y] = \"?\"\n      if victory?\n        show_grid\n        puts \"You win!\"\n        break\n      end\n    elsif $screen[x][y] == \"?\"\n      \n      $screen[x][y] = \".\"\n    end\n    show_grid\n  when /^c (\\d+) (\\d+)$/\n    x, y = check_input $1, $2\n    next unless x\n    $mines ||= create_mines(x, y)\n    if $mines[x][y]\n      puts \"You hit a mine!\"\n      show_grid true\n      break\n    else\n      clear_space x, y\n      show_grid\n      if victory?\n        puts \"You win!\"\n        break\n      end\n    end\n  when \"p\"\n    show_grid\n  end\nend\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass MineFieldModel\n{\n    public int RemainingMinesCount{\n        get{\n            var count = 0;\n            ForEachCell((i,j)=>{\n                if (Mines[i,j] && !Marked[i,j])\n                    count++;\n            });\n            return count;\n        }\n    }\n\n    public bool[,] Mines{get; private set;}\n    public bool[,] Opened{get;private set;}\n    public bool[,] Marked{get; private set;}\n    public int[,] Values{get;private set; }\n    public int Width{ get{return Mines.GetLength(1);} } \n    public int Height{ get{return Mines.GetLength(0);} }\n\n    public MineFieldModel(bool[,] mines)\n    {\n        this.Mines = mines;\n        this.Opened = new bool[Height, Width]; \n        this.Marked = new bool[Height, Width];\n        this.Values = CalculateValues();\n    }\n    \n    private int[,] CalculateValues()\n    {\n        int[,] values = new int[Height, Width];\n        ForEachCell((i,j) =>{\n            var value = 0;\n            ForEachNeighbor(i,j, (i1,j1)=>{\n                if (Mines[i1,j1])\n                    value++;\n            });\n            values[i,j] = value;\n        });\n        return values;\n    }\n\n    \n    public void ForEachCell(Action<int,int> action)\n    {\n        for (var i = 0; i < Height; i++)\n        for (var j = 0; j < Width; j++)\n            action(i,j);\n    }\n\n    \n    public void ForEachNeighbor(int i, int j, Action<int,int> action)\n    {\n        for (var i1 = i-1; i1 <= i+1; i1++)\n        for (var j1 = j-1; j1 <= j+1; j1++)               \n            if (InBounds(j1, i1) && !(i1==i && j1 ==j))\n                action(i1, j1);\n    }\n\n    private bool InBounds(int x, int y)\n    {\n        return y >= 0 && y < Height && x >=0 && x < Width;\n    }\n\n    public event Action Exploded = delegate{};\n    public event Action Win = delegate{};\n    public event Action Updated = delegate{};\n\n    public void OpenCell(int i, int j){\n        if(!Opened[i,j]){\n            if (Mines[i,j])\n                Exploded();\n            else{\n                OpenCellsStartingFrom(i,j);\n                Updated();\n                CheckForVictory();\n            }\n        }\n    }\n\n    void OpenCellsStartingFrom(int i, int j)\n    {\n            Opened[i,j] = true;\n            ForEachNeighbor(i,j, (i1,j1)=>{\n                if (!Mines[i1,j1] && !Opened[i1,j1] && !Marked[i1,j1])\n                    OpenCellsStartingFrom(i1, j1);\n            });\n    }\n    \n    void CheckForVictory(){\n        int notMarked = 0;\n        int wrongMarked = 0;\n        ForEachCell((i,j)=>{\n            if (Mines[i,j] && !Marked[i,j])\n                notMarked++;\n            if (!Mines[i,j] && Marked[i,j])\n                wrongMarked++;\n        }); \n        if (notMarked == 0 && wrongMarked == 0)\n            Win();\n    }\n\n    public void Mark(int i, int j){\n        if (!Opened[i,j])\n            Marked[i,j] = true;\n            Updated();\n            CheckForVictory();\n    }\n}\n\nclass MineFieldView: UserControl{\n    public const int CellSize = 40;\n\n    MineFieldModel _model;\n    public MineFieldModel Model{\n        get{ return _model; }\n        set\n        { \n            _model = value; \n            this.Size = new Size(_model.Width * CellSize+1, _model.Height * CellSize+2);\n        }\n    }\n    \n    public MineFieldView(){\n        \n        this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.DoubleBuffer,true);\n        this.Font = new Font(FontFamily.GenericSansSerif, 14, FontStyle.Bold);\n\n        this.MouseUp += (o,e)=>{\n            Point cellCoords = GetCell(e.Location);\n            if (Model != null)\n            {\n                if (e.Button == MouseButtons.Left)\n                    Model.OpenCell(cellCoords.Y, cellCoords.X);\n                else if (e.Button == MouseButtons.Right)\n                    Model.Mark(cellCoords.Y, cellCoords.X);\n            }\n        };\n    }\n\n    Point GetCell(Point coords)\n    {\n        var rgn = ClientRectangle;\n        var x = (coords.X - rgn.X)/CellSize;\n        var y = (coords.Y - rgn.Y)/CellSize;\n        return new Point(x,y);\n    }\n         \n    static readonly Brush MarkBrush = new SolidBrush(Color.Blue);\n    static readonly Brush ValueBrush = new SolidBrush(Color.Black);\n    static readonly Brush UnexploredBrush = new SolidBrush(SystemColors.Control);\n    static readonly Brush OpenBrush = new SolidBrush(SystemColors.ControlDark);\n\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        var g = e.Graphics;\n        if (Model != null)\n        {\n            Model.ForEachCell((i,j)=>\n            {\n                var bounds = new Rectangle(j * CellSize, i * CellSize, CellSize, CellSize);\n                if (Model.Opened[i,j])\n                {\n                    g.FillRectangle(OpenBrush, bounds);\n                    if (Model.Values[i,j] > 0)\n                    {\n                        DrawStringInCenter(g, Model.Values[i,j].ToString(), ValueBrush, bounds);\n                    }\n                } \n                else \n                {\n                    g.FillRectangle(UnexploredBrush, bounds);\n                    if (Model.Marked[i,j])\n                    {\n                        DrawStringInCenter(g, \"?\", MarkBrush, bounds);\n                    }\n                    var outlineOffset = 1;\n                    var outline = new Rectangle(bounds.X+outlineOffset, bounds.Y+outlineOffset, bounds.Width-2*outlineOffset, bounds.Height-2*outlineOffset);\n                    g.DrawRectangle(Pens.Gray, outline);\n                }\n                g.DrawRectangle(Pens.Black, bounds);\n            });\n        }\n\n    }\n\n    static readonly StringFormat FormatCenter = new StringFormat\n                            {\n                                LineAlignment = StringAlignment.Center,\n                                Alignment=StringAlignment.Center\n                            };\n\n    void DrawStringInCenter(Graphics g, string s, Brush brush, Rectangle bounds)\n    {\n        PointF center = new PointF(bounds.X + bounds.Width/2, bounds.Y + bounds.Height/2);\n        g.DrawString(s, this.Font, brush, center, FormatCenter);\n    }\n\n}\n\nclass MineSweepForm: Form\n{\n\n    MineFieldModel CreateField(int width, int height)\n{\n        var field = new bool[height, width];\n        int mineCount = (int)(0.2 * height * width);\n        var rnd = new Random();\n        while(mineCount > 0)\n        {\n            var x = rnd.Next(width);\n            var y = rnd.Next(height);\n            if (!field[y,x])\n            {\n                field[y,x] = true;\n                mineCount--;\n            }\n        }\n        return new MineFieldModel(field);\n    }\n\n    public MineSweepForm()\n    {\n        var model = CreateField(6, 4);\n        var counter = new Label{ };\n        counter.Text = model.RemainingMinesCount.ToString();\n        var view = new MineFieldView\n                        { \n                            Model = model, BorderStyle = BorderStyle.FixedSingle,\n                        };\n        var stackPanel = new FlowLayoutPanel\n                        {\n                            Dock = DockStyle.Fill,\n                            FlowDirection = FlowDirection.TopDown,\n                            Controls = {counter, view}\n                        };\n        this.Controls.Add(stackPanel);\n        model.Updated += delegate{\n            view.Invalidate();\n            counter.Text = model.RemainingMinesCount.ToString();\n        };\n        model.Exploded += delegate {\n            MessageBox.Show(\"FAIL!\");\n            Close();\n        };\n        model.Win += delegate {\n            MessageBox.Show(\"WIN!\");\n            view.Enabled = false;\n        };\n\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Application.Run(new MineSweepForm());\n    }\n}\n"}
{"id": 386867, "name": "Church numerals", "source": "Translate Ruby to C#: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 386868, "name": "Church numerals", "source": "Translate Ruby to C#: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 386869, "name": "Reflection_List methods", "source": "Translate Ruby to C#: \nclass Super\n  CLASSNAME = 'super'\n  \n  def initialize(name)\n    @name = name\n    def self.superOwn\n      'super owned'\n    end\n  end\n  \n  def to_s\n    \"Super(\n  end\n  \n  def doSup\n    'did super stuff'\n  end\n  \n  def self.superClassStuff\n    'did super class stuff'\n  end\n  \n  protected\n  def protSup\n    \"Super's protected\"\n  end\n  \n  private\n  def privSup\n    \"Super's private\"\n  end\nend\n\nmodule Other\n  def otherStuff\n    'did other stuff'\n  end\nend\n\nclass Sub < Super\n  CLASSNAME = 'sub'\n  attr_reader :dynamic\n  \n  include Other\n  \n  def initialize(name, *args)\n    super(name)\n    @rest = args;\n    @dynamic = {}\n    def self.subOwn\n      'sub owned'\n    end\n  end\n  \n  def methods(regular=true)\n    super + @dynamic.keys\n  end\n  \n  def method_missing(name, *args, &block)\n    return super unless @dynamic.member?(name)\n    method = @dynamic[name]\n    if method.arity > 0\n      if method.parameters[0][1] == :self\n        args.unshift(self)\n      end\n      if method.lambda?\n        \n        args += args + [nil] * [method.arity - args.length, 0].max\n        \n        if method.parameters[-1][0] != :rest\n          args = args[0,method.arity]\n        end\n      end\n      method.call(*args)\n    else\n      method.call\n    end\n  end\n  \n  def public_methods(all=true)\n    super + @dynamic.keys\n  end\n  \n  def respond_to?(symbol, include_all=false)\n    @dynamic.member?(symbol) || super\n  end\n  \n  def to_s\n    \"Sub(\n  end\n  \n  def doSub\n    'did sub stuff'\n  end\n  \n  def self.subClassStuff\n    'did sub class stuff'\n  end\n  \n  protected\n  def protSub\n    \"Sub's protected\"\n  end\n  \n  private\n  def privSub\n    \"Sub's private\"\n  end\nend\n\nsup = Super.new('sup')\nsub = Sub.new('sub', 0, 'I', 'two')\nsub.dynamic[:incr] = proc {|i| i+1}\n\np sub.public_methods(false)\n\n\np sub.methods - Object.methods\n\n\np sub.public_methods - Object.public_methods\n\n\np sub.methods - sup.methods\n\n\n\np sub.methods(false)\n\np sub.singleton_methods\n\n", "target": "using System;\nusing System.Reflection;\n\npublic class Rosetta\n{\n    public static void Main()\n    {\n        \n        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static\n            | BindingFlags.Public | BindingFlags.NonPublic\n            | BindingFlags.DeclaredOnly;\n\n        foreach (var method in typeof(TestForMethodReflection).GetMethods(flags))\n            Console.WriteLine(method);\n    }\n    \n    class TestForMethodReflection\n    {\n        public void MyPublicMethod() {}\n        private void MyPrivateMethod() {}\n        \n        public static void MyPublicStaticMethod() {}\n        private static void MyPrivateStaticMethod() {}\n    }\n    \n}\n"}
{"id": 386870, "name": "Send an unknown method call", "source": "Translate Ruby to C#: class Example\n  def foo\n    42\n  end\n  def bar(arg1, arg2, &block)\n    block.call arg1, arg2\n  end\nend\n\nsymbol = :foo\nExample.new.send symbol                         \nExample.new.send( :bar, 1, 2 ) { |x,y| x+y }    \nargs = [1, 2]\nExample.new.send( \"bar\", *args ) { |x,y| x+y }  \n", "target": "using System;\n\nclass Example\n{\n    public int foo(int x)\n    {\n        return 42 + x;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var example = new Example();\n        var method = \"foo\";\n        \n        var result = (int)example.GetType().GetMethod(method).Invoke(example, new object[]{ 5 });\n        Console.WriteLine(\"{0}(5) = {1}\", method, result);\n    }\n}\n"}
{"id": 386871, "name": "Canonicalize CIDR", "source": "Translate Ruby to C#: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 386872, "name": "Canonicalize CIDR", "source": "Translate Ruby to C#: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 386873, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to C#: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 386874, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to C#: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 386875, "name": "Long primes", "source": "Translate Ruby to C#: require \"big\"\n\ndef prime?(n)                     \n  return n | 1 == 3 if n < 5      \n  return false if n.gcd(6) != 1   \n  pc = typeof(n).new(5)           \n  until pc*pc > n\n    return false if n % pc == 0 || n % (pc + 2) == 0  \n    pc += 6                       \n  end\n  true\nend\n\n\n\ndef long_prime?(p)\n  return false unless prime? p\n  (2...p).each do |d|\n    return d == (p - 1) if (p - 1) % d == 0 && (10.to_big_i ** d) % p == 1\n  end \n  false\nend\n\nstart = Time.monotonic  \nputs \"Long primes \u2264 500:\"\n(2..500).each { |pc| print \"\nputs \n[500, 1000, 2000, 4000, 8000, 16000, 32000, 64000].each do |n|\n  puts \"Number of long primes \u2264 \nend\nputs \"\\nTime: \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LongPrimes\n{\n    public static void Main() {\n        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);\n        Console.WriteLine(string.Join(\" \", primes.TakeWhile(p => p <= 500)));\n        int count = 0, limit = 500;\n        foreach (int prime in primes) {\n            if (prime > limit) {\n                Console.WriteLine($\"There are {count} long primes below {limit}\");\n                limit *= 2;\n            }\n            count++;\n        }\n\n        int Period(int n) {\n            int r = 1, rr;\n            for (int i = 0; i <= n; i++) r = 10 * r % n;\n            rr = r;\n            for (int period = 1;; period++) {\n                r = (10 * r) % n;\n                if (r == rr) return period;\n            }\n        }\n    }\n\n}\n\nstatic class SomePrimeGenerator {\n\n    public static IEnumerable<int> Primes(int lim) {\n        bool [] flags = new bool[lim + 1]; int j = 2;\n        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n            if (!flags[j]) {\n                yield return j; for (int k = sq; k <= lim; k += j)\n                    flags[k] = true;\n            }\n        for (; j<= lim; j++) if (!flags[j]) yield return j;\n    }\n}\n"}
{"id": 386876, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to C#: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 386877, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to C#: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 386878, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Ruby to C#: func legendre_pair((1), x) { (x, 1) }\nfunc legendre_pair( n,  x) {\n    var (m1, m2) = legendre_pair(n - 1, x)\n    var u = (1 - 1/n)\n    ((1 + u)*x*m1 - u*m2, m1)\n}\n\nfunc legendre((0), _) { 1 }\nfunc legendre( n,  x) { [legendre_pair(n, x)][0] }\n\nfunc legendre_prime({ .is_zero }, _) { 0 }\nfunc legendre_prime({ .is_one  }, _) { 1 }\n\nfunc legendre_prime(n, x) {\n    var (m0, m1) = legendre_pair(n, x)\n    (m1 - x*m0) * n / (1 - x**2)\n}\n\nfunc approximate_legendre_root(n, k) {\n    \n    var t = ((4*k - 1) / (4*n + 2))\n    (1 - ((n - 1)/(8 * n**3))) * cos(Num.pi * t)\n}\n\nfunc newton_raphson(f, f_prime, r, eps = 2e-16) {\n    loop {\n        var dr = (-f(r) / f_prime(r))\n        dr.abs >= eps || break\n        r += dr\n    }\n    return r\n}\n\nfunc legendre_root(n, k) {\n    newton_raphson(legendre.method(:call, n), legendre_prime.method(:call, n),\n                   approximate_legendre_root(n, k))\n}\n\nfunc weight(n, r) { 2 / ((1 - r**2) * legendre_prime(n, r)**2) }\n\nfunc nodes(n) {\n    gather {\n        take(Pair(0, weight(n, 0))) if n.is_odd\n        { |i|\n            var r = legendre_root(n, i)\n            var w = weight(n, r)\n            take(Pair(r, w), Pair(-r, w))\n        }.each(1 .. (n >> 1))\n    }\n}\n\nfunc quadrature(n, f, a, b, nds = nodes(n)) {\n    func scale(x) { (x*(b - a) + a + b) / 2 }\n    (b - a) / 2 * nds.sum { .second * f(scale(.first)) }\n}\n\n[(5..10)..., 20].each { |i|\n    printf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.15f\\n\",\n        i, quadrature(i, {.exp}, -3, +3))\n}\n", "target": "using System;\n\n\n                    \npublic class Program {\n\n    public static double[][] legeCoef(int N) {\n        \n        double[][] lcoef = new double[N+1][];\n        for (int i=0; i < lcoef.Length; ++i) \n            lcoef[i] = new double[N+1];\n\n\n        lcoef[0][0] = lcoef[1][1] = 1;\n        for (int n = 2; n <= N; n++) {\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n            for (int i = 1; i <= n; i++) \n                lcoef[n][i] = ((2*n - 1) * lcoef[n-1][i-1] \n                               - (n-1) * lcoef[n-2][i] ) / n;\n        }\n        return lcoef;\n    }\n\n\n    static double legeEval(double[][] lcoef, int N, double x) {\n        double s = lcoef[N][N];\n        for (int i = N; i > 0; --i)\n            s = s * x + lcoef[N][i-1];\n        return s;\n    }\n\n    static double legeDiff(double[][] lcoef, int N, double x) {\n        return N * (x * legeEval(lcoef, N, x) - legeEval(lcoef, N-1, x)) / (x*x - 1);\n    }\n\n    static void legeRoots(double[][] lcoef, int N, out double[] lroots,  out double[] weight) {\n        lroots = new double[N];\n        weight = new double[N];\n\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = Math.Cos(Math.PI * (i - 0.25) / (N + 0.5));\n            do { \n                x1 = x;\n                x -= legeEval(lcoef, N, x) / legeDiff(lcoef, N, x);\n            } \n            while (x != x1);\n            lroots[i-1] = x;\n\n            x1 = legeDiff(lcoef, N, x);\n            weight[i-1] = 2 / ((1 - x*x) * x1*x1);\n        }\n    }\n    \n    \n\n    static double legeInte(Func<Double, Double> f, int N, double[] weights, double[] lroots, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weights[i] * f.Invoke(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n    \n    \n    public static string Combine(double[] arrayD) {\n        return string.Join(\", \", arrayD);\t\n    }\n\n    public static void Main() {\n        int N = 5;\n        \n        var lcoeff = legeCoef(N);\n        \n        double[] roots;\n        double[] weights;\n        legeRoots(lcoeff, N, out roots, out weights);\n        \n        var integrateResult = legeInte(x=>Math.Exp(x), N, weights, roots, -3, 3);\n        \n        Console.WriteLine(\"Roots:   \" + Combine(roots));\n        Console.WriteLine(\"Weights: \" + Combine(weights)+ \"\\n\" );\n        Console.WriteLine(\"integral: \" + integrateResult );\n        Console.WriteLine(\"actual:   \" + (Math.Exp(3)-Math.Exp(-3)) );\n    }\n\n\n}\n"}
{"id": 386879, "name": "Cuban primes", "source": "Translate Ruby to C#: require \"openssl\"\n \nRE = /(\\d)(?=(\\d\\d\\d)+(?!\\d))/ \ncuban_primes = Enumerator.new do |y|\n  (1..).each do |n|\n    cand = 3*n*(n+1) + 1\n    y << cand if OpenSSL::BN.new(cand).prime?\n  end\nend\n \ndef commatize(num)\n  num.to_s.gsub(RE, \"\\\\1,\")\nend\n \ncbs = cuban_primes.take(200)\nformatted = cbs.map{|cb| commatize(cb).rjust(10) }\nputs formatted.each_slice(10).map(&:join)\n \nt0 = Time.now \nputs \"\n100_000th cuban prime is \nwhich took \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program\n{\n    static List<long> primes = new List<long>() { 3, 5 };\n\n     static void Main(string[] args)\n    {\n        const int cutOff = 200;\n        const int bigUn = 100000;\n        const int chunks = 50;\n        const int little = bigUn / chunks;\n        const string tn = \" cuban prime\";\n        Console.WriteLine(\"The first {0:n0}{1}s:\", cutOff, tn);\n        int c = 0;\n        bool showEach = true;\n        long u = 0, v = 1;\n        DateTime st = DateTime.Now;\n        for (long i = 1; i <= long.MaxValue; i++)\n        {\n            bool found = false;\n            int mx = System.Convert.ToInt32(Math.Ceiling(Math.Sqrt(v += (u += 6))));\n            foreach (long item in primes)\n            {\n                if (item > mx) break;\n                if (v % item == 0) { found = true; break; }\n            }\n            if (!found)\n            {\n                c += 1; if (showEach)\n                {\n                    for (var z = primes.Last() + 2; z <= v - 2; z += 2)\n                    {\n                        bool fnd = false;\n                        foreach (long item in primes)\n                        {\n                            if (item > mx) break;\n                            if (z % item == 0) { fnd = true; break; }\n                        }\n                        if (!fnd) primes.Add(z);\n                    }\n                    primes.Add(v); Console.Write(\"{0,11:n0}\", v);\n                    if (c % 10 == 0) Console.WriteLine();\n                    if (c == cutOff)\n                    {\n                        showEach = false;\n                        Console.Write(\"\\nProgress to the {0:n0}th{1}: \", bigUn, tn);\n                    }\n                }\n                if (c % little == 0) { Console.Write(\".\"); if (c == bigUn) break; }\n            }\n        }\n        Console.WriteLine(\"\\nThe {1:n0}th{2} is {0,17:n0}\", v, c, tn);\n        Console.WriteLine(\"Computation time was {0} seconds\", (DateTime.Now - st).TotalSeconds);\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 386880, "name": "Chaos game", "source": "Translate Ruby to C#: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 386881, "name": "Chaos game", "source": "Translate Ruby to C#: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 386882, "name": "World Cup group stage", "source": "Translate Ruby to C#: teams = [:a, :b, :c, :d]\nmatches = teams.combination(2).to_a\noutcomes = [:win, :draw, :loss]\ngains = {win:[3,0], draw:[1,1], loss:[0,3]}\nplaces_histogram = Array.new(4) {Array.new(10,0)}\n\n\n\noutcomes.repeated_permutation(6).each do |outcome|\n  results = Hash.new(0)\n  \n  \n  outcome.zip(matches).each do |decision, (team1, team2)|\n    results[team1] += gains[decision][0]\n    results[team2] += gains[decision][1]\n  end \n  \n  \n  results.values.sort.reverse.each_with_index do |points, place|\n    places_histogram[place][points] += 1\n  end\nend\n\nfmt = \"%s\u00a0:\" + \"%4s\"*10\nputs fmt % [\" \", *0..9]\nputs fmt % [\"-\", *[\"---\"]*10]\nplaces_histogram.each.with_index(1) {|hist,place| puts fmt % [place, *hist]}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace WorldCupGroupStage\n{\n    public static class WorldCupGroupStage\n    {\n        static int[][] _histogram;\n\n        static WorldCupGroupStage()\n        {\n            int[] scoring = new[] { 0, 1, 3 };\n\n            _histogram = Repeat<Func<int[]>>(()=>new int[10], 4).Select(f=>f()).ToArray();\n\n            var teamCombos = Range(0, 4).Combinations(2).Select(t2=>t2.ToArray()).ToList();\n\n            foreach (var results in Range(0, 3).CartesianProduct(6))\n            {\n                var points = new int[4]; \n\n                foreach (var (result, teams) in results.Zip(teamCombos, (r, t) => (r, t)))\n                {\n                    points[teams[0]] += scoring[result];\n                    points[teams[1]] += scoring[2 - result];\n                }\n\n                foreach(var (p,i) in points.OrderByDescending(a => a).Select((p,i)=>(p,i)))\n                    _histogram[i][p]++;\n            }\n        }\n      \n       \n       \n       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> seqs) => \n            seqs.Aggregate(Empty<T>().ToSingleton(), (acc, sq) => acc.SelectMany(a => sq.Select(s => a.Append(s))));\n        \n       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<T> seq, int repeat = 1) => \n            Repeat(seq, repeat).CartesianProduct();\n\n       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) => \n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) => \n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        private static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n\n        static new string ToString()\n        {\n            var sb = new StringBuilder();\n\n            var range = String.Concat(Range(0, 10).Select(i => $\"{i,-3} \"));\n            sb.AppendLine($\"Points     \u00a0: {range}\");\n\n            var u = String.Concat(Repeat(\"\u2500\", 40+13));\n            sb.AppendLine($\"{u}\");\n\n            var places = new[] { \"First\", \"Second\", \"Third\", \"Fourth\" };\n            foreach (var row in _histogram.Select((r, i) => (r, i)))\n            {\n                sb.Append($\"{places[row.i],-6} place: \");\n                foreach (var standing in row.r)\n                    sb.Append($\"{standing,-3} \");\n                sb.Append(\"\\n\");\n            }\n\n            return sb.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            Write(ToString());\n            Read();\n        }\n    }\n}\n"}
{"id": 386883, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Ruby to C#: rpn = RPNExpression.from_infix(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 386884, "name": "A_ search algorithm", "source": "Translate Ruby to C#: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 386885, "name": "A_ search algorithm", "source": "Translate Ruby to C#: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 386886, "name": "Almkvist-Giullera formula for pi", "source": "Translate Ruby to C#: func almkvist_giullera(n) {\n    (32 * (14*n * (38*n + 9) + 9) * (6*n)!) / (3 * n!**6)\n}\n\nfunc almkvist_giullera_pi(prec = 70) {\n\n    local Num!PREC = (4*(prec+1)).numify\n\n    var sum = 0\n    var target = -1\n\n    for n in (0..Inf) {\n        sum += (almkvist_giullera(n) / (10**(6*n + 3)))\n        var curr = (sum**-.5).as_dec\n        return target if (target == curr)\n        target = curr\n    }\n}\n\nsay 'First 10 integer portions: '\n\n10.of {|n|\n    say \"\n}\n\nwith(70) {|n|\n    say \"\u03c0 to \n    say almkvist_giullera_pi(n)\n}\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 386887, "name": "Almkvist-Giullera formula for pi", "source": "Translate Ruby to C#: func almkvist_giullera(n) {\n    (32 * (14*n * (38*n + 9) + 9) * (6*n)!) / (3 * n!**6)\n}\n\nfunc almkvist_giullera_pi(prec = 70) {\n\n    local Num!PREC = (4*(prec+1)).numify\n\n    var sum = 0\n    var target = -1\n\n    for n in (0..Inf) {\n        sum += (almkvist_giullera(n) / (10**(6*n + 3)))\n        var curr = (sum**-.5).as_dec\n        return target if (target == curr)\n        target = curr\n    }\n}\n\nsay 'First 10 integer portions: '\n\n10.of {|n|\n    say \"\n}\n\nwith(70) {|n|\n    say \"\u03c0 to \n    say almkvist_giullera_pi(n)\n}\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 386888, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to C#: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 386889, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to C#: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 386890, "name": "Cipolla's algorithm", "source": "Translate Ruby to C#: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace CipollaAlgorithm {\n    class Program {\n        static readonly BigInteger BIG = BigInteger.Pow(10, 50) + 151;\n\n        private static Tuple<BigInteger, BigInteger, bool> C(string ns, string ps) {\n            BigInteger n = BigInteger.Parse(ns);\n            BigInteger p = ps.Length > 0 ? BigInteger.Parse(ps) : BIG;\n\n            \n            BigInteger ls(BigInteger a0) => BigInteger.ModPow(a0, (p - 1) / 2, p);\n\n            \n            if (ls(n) != 1) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            BigInteger a = 0;\n            BigInteger omega2;\n            while (true) {\n                omega2 = (a * a + p - n) % p;\n                if (ls(omega2) == p - 1) {\n                    break;\n                }\n                a += 1;\n            }\n\n            \n            BigInteger finalOmega = omega2;\n            Tuple<BigInteger, BigInteger> mul(Tuple<BigInteger, BigInteger> aa, Tuple<BigInteger, BigInteger> bb) {\n                return new Tuple<BigInteger, BigInteger>(\n                    (aa.Item1 * bb.Item1 + aa.Item2 * bb.Item2 * finalOmega) % p,\n                    (aa.Item1 * bb.Item2 + bb.Item1 * aa.Item2) % p\n                );\n            }\n\n            \n            Tuple<BigInteger, BigInteger> r = new Tuple<BigInteger, BigInteger>(1, 0);\n            Tuple<BigInteger, BigInteger> s = new Tuple<BigInteger, BigInteger>(a, 1);\n            BigInteger nn = ((p + 1) >> 1) % p;\n            while (nn > 0) {\n                if ((nn & 1) == 1) {\n                    r = mul(r, s);\n                }\n                s = mul(s, s);\n                nn >>= 1;\n            }\n\n            \n            if (r.Item2 != 0) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            if (r.Item1 * r.Item1 % p != n) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            return new Tuple<BigInteger, BigInteger, bool>(r.Item1, p - r.Item1, true);\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(C(\"10\", \"13\"));\n            Console.WriteLine(C(\"56\", \"101\"));\n            Console.WriteLine(C(\"8218\", \"10007\"));\n            Console.WriteLine(C(\"8219\", \"10007\"));\n            Console.WriteLine(C(\"331575\", \"1000003\"));\n            Console.WriteLine(C(\"665165880\", \"1000000007\"));\n            Console.WriteLine(C(\"881398088036\", \"1000000000039\"));\n            Console.WriteLine(C(\"34035243914635549601583369544560650254325084643201\", \"\"));\n        }\n    }\n}\n"}
{"id": 386891, "name": "Cipolla's algorithm", "source": "Translate Ruby to C#: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace CipollaAlgorithm {\n    class Program {\n        static readonly BigInteger BIG = BigInteger.Pow(10, 50) + 151;\n\n        private static Tuple<BigInteger, BigInteger, bool> C(string ns, string ps) {\n            BigInteger n = BigInteger.Parse(ns);\n            BigInteger p = ps.Length > 0 ? BigInteger.Parse(ps) : BIG;\n\n            \n            BigInteger ls(BigInteger a0) => BigInteger.ModPow(a0, (p - 1) / 2, p);\n\n            \n            if (ls(n) != 1) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            BigInteger a = 0;\n            BigInteger omega2;\n            while (true) {\n                omega2 = (a * a + p - n) % p;\n                if (ls(omega2) == p - 1) {\n                    break;\n                }\n                a += 1;\n            }\n\n            \n            BigInteger finalOmega = omega2;\n            Tuple<BigInteger, BigInteger> mul(Tuple<BigInteger, BigInteger> aa, Tuple<BigInteger, BigInteger> bb) {\n                return new Tuple<BigInteger, BigInteger>(\n                    (aa.Item1 * bb.Item1 + aa.Item2 * bb.Item2 * finalOmega) % p,\n                    (aa.Item1 * bb.Item2 + bb.Item1 * aa.Item2) % p\n                );\n            }\n\n            \n            Tuple<BigInteger, BigInteger> r = new Tuple<BigInteger, BigInteger>(1, 0);\n            Tuple<BigInteger, BigInteger> s = new Tuple<BigInteger, BigInteger>(a, 1);\n            BigInteger nn = ((p + 1) >> 1) % p;\n            while (nn > 0) {\n                if ((nn & 1) == 1) {\n                    r = mul(r, s);\n                }\n                s = mul(s, s);\n                nn >>= 1;\n            }\n\n            \n            if (r.Item2 != 0) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            if (r.Item1 * r.Item1 % p != n) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            return new Tuple<BigInteger, BigInteger, bool>(r.Item1, p - r.Item1, true);\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(C(\"10\", \"13\"));\n            Console.WriteLine(C(\"56\", \"101\"));\n            Console.WriteLine(C(\"8218\", \"10007\"));\n            Console.WriteLine(C(\"8219\", \"10007\"));\n            Console.WriteLine(C(\"331575\", \"1000003\"));\n            Console.WriteLine(C(\"665165880\", \"1000000007\"));\n            Console.WriteLine(C(\"881398088036\", \"1000000000039\"));\n            Console.WriteLine(C(\"34035243914635549601583369544560650254325084643201\", \"\"));\n        }\n    }\n}\n"}
{"id": 386892, "name": "Pierpont primes", "source": "Translate Ruby to C#: require 'gmp'\n\ndef  smooth_generator(ar)\n  return to_enum(__method__, ar) unless block_given?\n  next_smooth = 1\n  queues = ar.map{|num| [num, []] }\n  loop do\n    yield next_smooth\n    queues.each {|m, queue| queue << next_smooth * m}\n    next_smooth = queues.collect{|m, queue| queue.first}.min\n    queues.each{|m, queue| queue.shift if queue.first == next_smooth }\n  end\nend\n  \ndef pierpont(num = 1)\n    return to_enum(__method__, num) unless block_given?\n    smooth_generator([2,3]).each{|smooth| yield smooth+num if GMP::Z(smooth + num).probab_prime? > 0}\nend\n\ndef puts_cols(ar, n=10)\n  ar.each_slice(n).map{|slice|puts  slice.map{|n| n.to_s.rjust(10)}.join }\nend\n\nn, m = 50, 250\nputs \"First \nputs_cols(pierpont.take(n))\nputs \"\nputs \"First \nputs_cols(pierpont(-1).take(n))\nputs \"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace PierpontPrimes {\n    public static class Helper {\n        private static readonly Random rand = new Random();\n        private static readonly List<int> primeList = new List<int>() {\n              2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43, 47,\n             53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\n            199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\n            383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\n            577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\n            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\n        };\n\n        public static BigInteger GetRandom(BigInteger min, BigInteger max) {\n            var bytes = max.ToByteArray();\n            BigInteger r;\n\n            do {\n                rand.NextBytes(bytes);\n                bytes[bytes.Length - 1] &= (byte)0x7F; \n                r = new BigInteger(bytes);\n            } while (r < min || r >= max);\n\n            return r;\n        }\n\n        \n        public static bool IsProbablePrime(this BigInteger n) {\n            if (n == 0 || n == 1) {\n                return false;\n            }\n\n            bool Check(BigInteger num) {\n                foreach (var prime in primeList) {\n                    if (num == prime) {\n                        return true;\n                    }\n                    if (num % prime == 0) {\n                        return false;\n                    }\n                    if (prime * prime > num) {\n                        return true;\n                    }\n                }\n\n                return true;\n            }\n\n            if (Check(n)) {\n                var large = primeList[primeList.Count - 1];\n                if (n <= large) {\n                    return true;\n                }\n            }\n\n            var s = 0;\n            var d = n - 1;\n            while (d.IsEven) {\n                d >>= 1;\n                s++;\n            }\n\n            bool TrialComposite(BigInteger a) {\n                if (BigInteger.ModPow(a, d, n) == 1) {\n                    return false;\n                }\n                for (int i = 0; i < s; i++) {\n                    var t = BigInteger.Pow(2, i);\n                    if (BigInteger.ModPow(a, t * d, n) == n - 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            for (int i = 0; i < 8; i++) {\n                var a = GetRandom(2, n);\n                if (TrialComposite(a)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program {\n        static List<List<BigInteger>> Pierpont(int n) {\n            var p = new List<List<BigInteger>> {\n                new List<BigInteger>(),\n                new List<BigInteger>()\n            };\n            for (int i = 0; i < n; i++) {\n                p[0].Add(0);\n                p[1].Add(0);\n            }\n            p[0][0] = 2;\n\n            var count = 0;\n            var count1 = 1;\n            var count2 = 0;\n            List<BigInteger> s = new List<BigInteger> { 1 };\n            var i2 = 0;\n            var i3 = 0;\n            var k = 1;\n            BigInteger n2;\n            BigInteger n3;\n            BigInteger t;\n\n            while (count < n) {\n                n2 = s[i2] * 2;\n                n3 = s[i3] * 3;\n                if (n2 < n3) {\n                    t = n2;\n                    i2++;\n                } else {\n                    t = n3;\n                    i3++;\n                }\n                if (t > s[k - 1]) {\n                    s.Add(t);\n                    k++;\n                    t += 1;\n                    if (count1 < n && t.IsProbablePrime()) {\n                        p[0][count1] = t;\n                        count1++;\n                    }\n                    t -= 2;\n                    if (count2 < n && t.IsProbablePrime()) {\n                        p[1][count2] = t;\n                        count2++;\n                    }\n                    count = Math.Min(count1, count2);\n                }\n            }\n\n            return p;\n        }\n\n        static void Main() {\n            var p = Pierpont(250);\n\n            Console.WriteLine(\"First 50 Pierpont primes of the first kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[0][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"First 50 Pierpont primes of the second kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[1][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"250th Pierpont prime of the first kind: {0}\", p[0][249]);\n            Console.WriteLine(\"250th Pierpont prime of the second kind: {0}\", p[1][249]);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386893, "name": "N-smooth numbers", "source": "Translate Ruby to C#: require \"big\"\n\ndef prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt_n = Math.isqrt(n)  \n  pc = typeof(n).new(5)\n  while pc <= sqrt_n\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\ndef gen_primes(a, b)\n    (a..b).select { |pc| pc if prime? pc }\nend\n\ndef nsmooth(n, limit)\n    raise \"Exception(n or limit)\" if n < 2 || n > 521 || limit < 1\n    raise \"Exception(must be a prime number: n)\" unless prime? n\n    \n    primes = gen_primes(2, n)\n    ns = [0.to_big_i] * limit\n    ns[0] = 1.to_big_i\n    nextp = primes[0..primes.index(n)].map { |prm| prm.to_big_i }\n\n    indices = [0] * nextp.size\n    (1...limit).each do |m|\n        ns[m] = nextp.min\n        (0...indices.size).each do |i|\n            if ns[m] == nextp[i]\n                indices[i] += 1\n                nextp[i] = primes[i] * ns[indices[i]]\n            end\n        end\n    end\n    ns\nend\n\ngen_primes(2, 29).each do |prime|\n    print \"The first 25 \n    print nsmooth(prime, 25)\n    puts\nend\nputs\ngen_primes(3, 29).each do |prime|\n    print \"The 3000 to 3202 \n    print nsmooth(prime, 3002)[2999..]\n    puts\nend\nputs\ngen_primes(503, 521).each do |prime|\n    print \"The 30,000 to 30,019 \n    print nsmooth(prime, 30019)[29999..]\n    puts\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NSmooth {\n    class Program {\n        static readonly List<BigInteger> primes = new List<BigInteger>();\n        static readonly List<int> smallPrimes = new List<int>();\n\n        static Program() {\n            primes.Add(2);\n            smallPrimes.Add(2);\n\n            BigInteger i = 3;\n            while (i <= 521) {\n                if (IsPrime(i)) {\n                    primes.Add(i);\n                    if (i <= 29) {\n                        smallPrimes.Add((int)i);\n                    }\n                }\n                i += 2;\n            }\n        }\n\n        static bool IsPrime(BigInteger value) {\n            if (value < 2) return false;\n\n            if (value % 2 == 0) return value == 2;\n            if (value % 3 == 0) return value == 3;\n\n            if (value % 5 == 0) return value == 5;\n            if (value % 7 == 0) return value == 7;\n\n            if (value % 11 == 0) return value == 11;\n            if (value % 13 == 0) return value == 13;\n\n            if (value % 17 == 0) return value == 17;\n            if (value % 19 == 0) return value == 19;\n\n            if (value % 23 == 0) return value == 23;\n\n            BigInteger t = 29;\n            while (t * t < value) {\n                if (value % t == 0) return false;\n                value += 2;\n\n                if (value % t == 0) return false;\n                value += 4;\n            }\n\n            return true;\n        }\n\n        static List<BigInteger> NSmooth(int n, int size) {\n            if (n < 2 || n > 521) {\n                throw new ArgumentOutOfRangeException(\"n\");\n            }\n            if (size < 1) {\n                throw new ArgumentOutOfRangeException(\"size\");\n            }\n\n            BigInteger bn = n;\n            bool ok = false;\n            foreach (var prime in primes) {\n                if (bn == prime) {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                throw new ArgumentException(\"must be a prime number\", \"n\");\n            }\n\n            BigInteger[] ns = new BigInteger[size];\n            ns[0] = 1;\n            for (int i = 1; i < size; i++) {\n                ns[i] = 0;\n            }\n\n            List<BigInteger> next = new List<BigInteger>();\n            foreach (var prime in primes) {\n                if (prime > bn) {\n                    break;\n                }\n                next.Add(prime);\n            }\n\n            int[] indices = new int[next.Count];\n            for (int i = 0; i < indices.Length; i++) {\n                indices[i] = 0;\n            }\n            for (int m = 1; m < size; m++) {\n                ns[m] = next.Min();\n                for (int i = 0; i < indices.Length; i++) {\n                    if (ns[m] == next[i]) {\n                        indices[i]++;\n                        next[i] = primes[i] * ns[indices[i]];\n                    }\n                }\n            }\n\n            return ns.ToList();\n        }\n\n        static void Println<T>(IEnumerable<T> nums) {\n            Console.Write('[');\n\n            var it = nums.GetEnumerator();\n            if (it.MoveNext()) {\n                Console.Write(it.Current);\n            }\n            while (it.MoveNext()) {\n                Console.Write(\", \");\n                Console.Write(it.Current);\n            }\n\n            Console.WriteLine(']');\n        }\n\n        static void Main() {\n            foreach (var i in smallPrimes) {\n                Console.WriteLine(\"The first {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 25));\n                Console.WriteLine();\n            }\n            foreach (var i in smallPrimes.Skip(1)) {\n                Console.WriteLine(\"The 3,000 to 3,202 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 3_002).Skip(2_999));\n                Console.WriteLine();\n            }\n            foreach (var i in new int[] { 503, 509, 521 }) {\n                Console.WriteLine(\"The 30,000 to 3,019 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 30_019).Skip(29_999));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386894, "name": "Partition an integer x into n primes", "source": "Translate Ruby to C#: require \"prime\"\n\ndef prime_partition(x, n)\n  Prime.each(x).to_a.combination(n).detect{|primes| primes.sum == x}\nend\n\nTESTCASES = [[99809, 1], [18, 2], [19, 3], [20, 4], [2017, 24], \n             [22699, 1], [22699, 2], [22699, 3], [22699, 4], [40355, 3]]\n\nTESTCASES.each do |prime, num|\n  res = prime_partition(prime, num) \n  str = res.nil? ? \"no solution\" : res.join(\" + \")\n  puts  \"Partitioned \nend\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Rosetta\n{\n    static void Main()\n    {\n        foreach ((int x, int n) in new [] {\n            (99809, 1),\n            (18, 2),\n            (19, 3),\n            (20, 4),\n            (2017, 24),\n            (22699, 1),\n            (22699, 2),\n            (22699, 3),\n            (22699, 4),\n            (40355, 3)\n        }) {\n            Console.WriteLine(Partition(x, n));\n        }\n    }\n\n    public static string Partition(int x, int n) {\n        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(\"Parameters must be positive.\");\n        string header = $\"{x} with {n} {(n == 1\u00a0? \"prime\"\u00a0: \"primes\")}: \";\n        int[] primes = SievePrimes(x).ToArray();\n        if (primes.Length < n) return header + \"not enough primes\";\n        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);\n        return header + (solution == null ? \"not possible\" : string.Join(\"+\", solution);\n    }\n\n    static IEnumerable<int> SievePrimes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {\n        T[] result = new T[count];\n        foreach (int[] indices in Combinations(input.Length, count)) {\n            for (int i = 0; i < count; i++) result[i] = input[indices[i]];\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int[]> Combinations(int n, int k) {\n        var result = new int[k];\n        var stack = new Stack<int>();\n        stack.Push(0);\n        while (stack.Count > 0) {\n            int index = stack.Count - 1;\n            int value = stack.Pop();\n            while (value < n) {\n                result[index++] = value++;\n                stack.Push(value);\n                if (index == k) {\n                    yield return result;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 386895, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to C#: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 386896, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to C#: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 386897, "name": "Bilinear interpolation", "source": "Translate Ruby to C#: require('Imager')\n\nfunc scale(img, scaleX, scaleY) {\n    var (width, height) = (img.getwidth, img.getheight)\n    var (newWidth, newHeight) = (int(width*scaleX), int(height*scaleY))\n\n    var out = %O<Imager>.new(xsize => newWidth, ysize => newHeight)\n\n    var lerp = { |s, e, t|\n        s + t*(e-s)\n    }\n\n    var blerp = { |c00, c10, c01, c11, tx, ty|\n        lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty)\n    }\n\n    for x,y in (^newWidth ~X ^newHeight) {\n        var gxf = (x/newWidth  * (width  - 1))\n        var gyf = (y/newHeight * (height - 1))\n\n        var gx = gxf.int\n        var gy = gyf.int\n\n        var *c00 = img.getpixel(x => gx,   y => gy  ).rgba\n        var *c10 = img.getpixel(x => gx+1, y => gy  ).rgba\n        var *c01 = img.getpixel(x => gx,   y => gy+1).rgba\n        var *c11 = img.getpixel(x => gx+1, y => gy+1).rgba\n\n        var rgb = 3.of { |i|\n            blerp(c00[i], c10[i], c01[i], c11[i], gxf - gx, gyf - gy).int\n        }\n\n        out.setpixel(x => x, y => y, color => rgb)\n    }\n\n    return out\n}\n\nvar img = %O<Imager>.new(file => \"input.png\")\nvar out = scale(img, 1.6, 1.6)\nout.write(file => \"output.png\")\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BilinearInterpolation {\n    class Program {\n        private static float Lerp(float s, float e, float t) {\n            return s + (e - s) * t;\n        }\n\n        private static float Blerp(float c00, float c10, float c01, float c11, float tx, float ty) {\n            return Lerp(Lerp(c00, c10, tx), Lerp(c01, c11, tx), ty);\n        }\n\n        private static Image Scale(Bitmap self, float scaleX, float scaleY) {\n            int newWidth = (int)(self.Width * scaleX);\n            int newHeight = (int)(self.Height * scaleY);\n            Bitmap newImage = new Bitmap(newWidth, newHeight, self.PixelFormat);\n\n            for (int x = 0; x < newWidth; x++) {\n                for (int y = 0; y < newHeight; y++) {\n                    float gx = ((float)x) / newWidth * (self.Width - 1);\n                    float gy = ((float)y) / newHeight * (self.Height - 1);\n                    int gxi = (int)gx;\n                    int gyi = (int)gy;\n                    Color c00 = self.GetPixel(gxi, gyi);\n                    Color c10 = self.GetPixel(gxi + 1, gyi);\n                    Color c01 = self.GetPixel(gxi, gyi + 1);\n                    Color c11 = self.GetPixel(gxi + 1, gyi + 1);\n\n                    int red = (int)Blerp(c00.R, c10.R, c01.R, c11.R, gx - gxi, gy - gyi);\n                    int green = (int)Blerp(c00.G, c10.G, c01.G, c11.G, gx - gxi, gy - gyi);\n                    int blue = (int)Blerp(c00.B, c10.B, c01.B, c11.B, gx - gxi, gy - gyi);\n                    Color rgb = Color.FromArgb(red, green, blue);\n                    newImage.SetPixel(x, y, rgb);\n                }\n            }\n\n            return newImage;\n        }\n\n        static void Main(string[] args) {\n            Image newImage = Image.FromFile(\"Lenna100.jpg\");\n            if (newImage is Bitmap oi) {\n                Image result = Scale(oi, 1.6f, 1.6f);\n                result.Save(\"Lenna100_larger.jpg\");\n            } else {\n                Console.WriteLine(\"Could not open the source file.\");\n            }\n        }\n    }\n}\n"}
{"id": 386898, "name": "Bilinear interpolation", "source": "Translate Ruby to C#: require('Imager')\n\nfunc scale(img, scaleX, scaleY) {\n    var (width, height) = (img.getwidth, img.getheight)\n    var (newWidth, newHeight) = (int(width*scaleX), int(height*scaleY))\n\n    var out = %O<Imager>.new(xsize => newWidth, ysize => newHeight)\n\n    var lerp = { |s, e, t|\n        s + t*(e-s)\n    }\n\n    var blerp = { |c00, c10, c01, c11, tx, ty|\n        lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty)\n    }\n\n    for x,y in (^newWidth ~X ^newHeight) {\n        var gxf = (x/newWidth  * (width  - 1))\n        var gyf = (y/newHeight * (height - 1))\n\n        var gx = gxf.int\n        var gy = gyf.int\n\n        var *c00 = img.getpixel(x => gx,   y => gy  ).rgba\n        var *c10 = img.getpixel(x => gx+1, y => gy  ).rgba\n        var *c01 = img.getpixel(x => gx,   y => gy+1).rgba\n        var *c11 = img.getpixel(x => gx+1, y => gy+1).rgba\n\n        var rgb = 3.of { |i|\n            blerp(c00[i], c10[i], c01[i], c11[i], gxf - gx, gyf - gy).int\n        }\n\n        out.setpixel(x => x, y => y, color => rgb)\n    }\n\n    return out\n}\n\nvar img = %O<Imager>.new(file => \"input.png\")\nvar out = scale(img, 1.6, 1.6)\nout.write(file => \"output.png\")\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BilinearInterpolation {\n    class Program {\n        private static float Lerp(float s, float e, float t) {\n            return s + (e - s) * t;\n        }\n\n        private static float Blerp(float c00, float c10, float c01, float c11, float tx, float ty) {\n            return Lerp(Lerp(c00, c10, tx), Lerp(c01, c11, tx), ty);\n        }\n\n        private static Image Scale(Bitmap self, float scaleX, float scaleY) {\n            int newWidth = (int)(self.Width * scaleX);\n            int newHeight = (int)(self.Height * scaleY);\n            Bitmap newImage = new Bitmap(newWidth, newHeight, self.PixelFormat);\n\n            for (int x = 0; x < newWidth; x++) {\n                for (int y = 0; y < newHeight; y++) {\n                    float gx = ((float)x) / newWidth * (self.Width - 1);\n                    float gy = ((float)y) / newHeight * (self.Height - 1);\n                    int gxi = (int)gx;\n                    int gyi = (int)gy;\n                    Color c00 = self.GetPixel(gxi, gyi);\n                    Color c10 = self.GetPixel(gxi + 1, gyi);\n                    Color c01 = self.GetPixel(gxi, gyi + 1);\n                    Color c11 = self.GetPixel(gxi + 1, gyi + 1);\n\n                    int red = (int)Blerp(c00.R, c10.R, c01.R, c11.R, gx - gxi, gy - gyi);\n                    int green = (int)Blerp(c00.G, c10.G, c01.G, c11.G, gx - gxi, gy - gyi);\n                    int blue = (int)Blerp(c00.B, c10.B, c01.B, c11.B, gx - gxi, gy - gyi);\n                    Color rgb = Color.FromArgb(red, green, blue);\n                    newImage.SetPixel(x, y, rgb);\n                }\n            }\n\n            return newImage;\n        }\n\n        static void Main(string[] args) {\n            Image newImage = Image.FromFile(\"Lenna100.jpg\");\n            if (newImage is Bitmap oi) {\n                Image result = Scale(oi, 1.6f, 1.6f);\n                result.Save(\"Lenna100_larger.jpg\");\n            } else {\n                Console.WriteLine(\"Could not open the source file.\");\n            }\n        }\n    }\n}\n"}
{"id": 386899, "name": "Vector", "source": "Translate Ruby to C#: class Vector\n  def self.polar(r, angle=0)\n    new(r*Math.cos(angle), r*Math.sin(angle))\n  end\n  \n  attr_reader :x, :y\n  \n  def initialize(x, y)\n    raise TypeError unless x.is_a?(Numeric) and y.is_a?(Numeric)\n    @x, @y = x, y\n  end\n  \n  def +(other)\n    raise TypeError if self.class != other.class\n    self.class.new(@x + other.x, @y + other.y)\n  end\n  \n  def -@;       self.class.new(-@x, -@y)        end\n  def -(other)  self + (-other)                 end\n  \n  def *(scalar)\n    raise TypeError unless scalar.is_a?(Numeric)\n    self.class.new(@x * scalar, @y * scalar)\n  end\n  \n  def /(scalar)\n    raise TypeError unless scalar.is_a?(Numeric) and scalar.nonzero?\n    self.class.new(@x / scalar, @y / scalar)\n  end\n  \n  def r;        @r     ||= Math.hypot(@x, @y)   end\n  def angle;    @angle ||= Math.atan2(@y, @x)   end\n  def polar;    [r, angle]                      end\n  def rect;     [@x, @y]                        end\n  def to_s;     \"\n  alias inspect to_s\nend\n\np v = Vector.new(1,1)                   \np w = Vector.new(3,4)                   \np v + w                                 \np v - w                                 \np -v                                    \np w * 5                                 \np w / 2.0                               \np w.x                                   \np w.y                                   \np v.polar                               \np w.polar                               \np z = Vector.polar(1, Math::PI/2)       \np z.rect                                \np z.polar                               \np z = Vector.polar(-2, Math::PI/4)      \np z.polar                               \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaVectors\n{\n    public class Vector\n    {\n        public double[] store;\n        public Vector(IEnumerable<double> init)\n        {\n            store = init.ToArray();\n        }\n        public Vector(double x, double y)\n        {\n            store = new double[] { x, y };\n        }\n        static public Vector operator+(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a + b));\n        }\n        static public Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a - b));\n        }\n        static public Vector operator *(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x * scalar));\n        }\n        static public Vector operator /(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x / scalar));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"[{0}]\", string.Join(\",\", store));\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var v1 = new Vector(5, 7);\n            var v2 = new Vector(2, 3);\n            Console.WriteLine(v1 + v2);\n            Console.WriteLine(v1 - v2);\n            Console.WriteLine(v1 * 11);\n            Console.WriteLine(v1 / 2);\n            \n            var lostVector = new Vector(new double[] { 4, 8, 15, 16, 23, 42 });\n            Console.WriteLine(lostVector * 7);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 386900, "name": "Chebyshev coefficients", "source": "Translate Ruby to C#: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 386901, "name": "Chebyshev coefficients", "source": "Translate Ruby to C#: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 386902, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to C#: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386903, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to C#: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386904, "name": "Card shuffles", "source": "Translate Ruby to C#: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CardShuffles {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            sb.Append(string.Join(\", \", c));\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        private static Random rand = new Random();\n\n        public static List<T> riffleShuffle<T>(ICollection<T> list, int flips) {\n            List<T> newList = new List<T>(list);\n\n            for (int n = 0; n < flips; n++) {\n                \n                int cutPoint = newList.Count / 2\n                    + (rand.Next(0, 2) == 0 ? -1 : 1) * rand.Next((int)(newList.Count * 0.1));\n\n                \n                List<T> left = new List<T>(newList.Take(cutPoint));\n                List<T> right = new List<T>(newList.Skip(cutPoint));\n\n                newList.Clear();\n\n                while (left.Count > 0 && right.Count > 0) {\n                    \n                    \n                    \n                    if (rand.NextDouble() >= ((double)left.Count / right.Count) / 2) {\n                        newList.Add(right.First());\n                        right.RemoveAt(0);\n                    }\n                    else {\n                        newList.Add(left.First());\n                        left.RemoveAt(0);\n                    }\n                }\n\n                \n                if (left.Count > 0) newList.AddRange(left);\n                if (right.Count > 0) newList.AddRange(right);\n            }\n\n            return newList;\n        }\n\n        public static List<T> overhandShuffle<T>(List<T> list, int passes) {\n            List<T> mainHand = new List<T>(list);\n\n            for (int n = 0; n < passes; n++) {\n                List<T> otherHand = new List<T>();\n\n                while (mainHand.Count>0) {\n                    \n                    int cutSize = rand.Next((int)(list.Count * 0.2)) + 1;\n\n                    List<T> temp = new List<T>();\n\n                    \n                    for (int i = 0; i < cutSize && mainHand.Count > 0; i++) {\n                        temp.Add(mainHand.First());\n                        mainHand.RemoveAt(0);\n                    }\n\n                    \n                    if (rand.NextDouble()>=0.1) {\n                        \n                        temp.AddRange(otherHand);\n                        otherHand = temp;\n                    }\n                    else {\n                        \n                        otherHand.AddRange(temp);\n                    }\n                }\n\n                \n                mainHand = otherHand;\n            }\n\n            return mainHand;\n        }\n\n        static void Main(string[] args) {\n            List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386905, "name": "Card shuffles", "source": "Translate Ruby to C#: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CardShuffles {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            sb.Append(string.Join(\", \", c));\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        private static Random rand = new Random();\n\n        public static List<T> riffleShuffle<T>(ICollection<T> list, int flips) {\n            List<T> newList = new List<T>(list);\n\n            for (int n = 0; n < flips; n++) {\n                \n                int cutPoint = newList.Count / 2\n                    + (rand.Next(0, 2) == 0 ? -1 : 1) * rand.Next((int)(newList.Count * 0.1));\n\n                \n                List<T> left = new List<T>(newList.Take(cutPoint));\n                List<T> right = new List<T>(newList.Skip(cutPoint));\n\n                newList.Clear();\n\n                while (left.Count > 0 && right.Count > 0) {\n                    \n                    \n                    \n                    if (rand.NextDouble() >= ((double)left.Count / right.Count) / 2) {\n                        newList.Add(right.First());\n                        right.RemoveAt(0);\n                    }\n                    else {\n                        newList.Add(left.First());\n                        left.RemoveAt(0);\n                    }\n                }\n\n                \n                if (left.Count > 0) newList.AddRange(left);\n                if (right.Count > 0) newList.AddRange(right);\n            }\n\n            return newList;\n        }\n\n        public static List<T> overhandShuffle<T>(List<T> list, int passes) {\n            List<T> mainHand = new List<T>(list);\n\n            for (int n = 0; n < passes; n++) {\n                List<T> otherHand = new List<T>();\n\n                while (mainHand.Count>0) {\n                    \n                    int cutSize = rand.Next((int)(list.Count * 0.2)) + 1;\n\n                    List<T> temp = new List<T>();\n\n                    \n                    for (int i = 0; i < cutSize && mainHand.Count > 0; i++) {\n                        temp.Add(mainHand.First());\n                        mainHand.RemoveAt(0);\n                    }\n\n                    \n                    if (rand.NextDouble()>=0.1) {\n                        \n                        temp.AddRange(otherHand);\n                        otherHand = temp;\n                    }\n                    else {\n                        \n                        otherHand.AddRange(temp);\n                    }\n                }\n\n                \n                mainHand = otherHand;\n            }\n\n            return mainHand;\n        }\n\n        static void Main(string[] args) {\n            List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386906, "name": "Faulhaber's triangle", "source": "Translate Ruby to C#: class Frac\n    attr_accessor:num\n    attr_accessor:denom\n\n    def initialize(n,d)\n        if d == 0 then\n            raise ArgumentError.new('d cannot be zero')\n        end\n\n        nn = n\n        dd = d\n        if nn == 0 then\n            dd = 1\n        elsif dd < 0 then\n            nn = -nn\n            dd = -dd\n        end\n\n        g = nn.abs.gcd(dd.abs)\n        if g > 1 then\n            nn = nn / g\n            dd = dd / g\n        end\n\n        @num = nn\n        @denom = dd\n    end\n\n    def to_s\n        if self.denom == 1 then\n            return self.num.to_s\n        else\n            return \"%d/%d\" % [self.num, self.denom]\n        end\n    end\n\n    def -@\n        return Frac.new(-self.num, self.denom)\n    end\n\n    def +(rhs)\n        return Frac.new(self.num * rhs.denom + self.denom * rhs.num, rhs.denom * self.denom)\n    end\n    def -(rhs)\n        return Frac.new(self.num * rhs.denom - self.denom * rhs.num, rhs.denom * self.denom)\n    end\n\n    def *(rhs)\n        return Frac.new(self.num * rhs.num, rhs.denom * self.denom)\n    end\nend\n\nFRAC_ZERO = Frac.new(0, 1)\nFRAC_ONE  = Frac.new(1, 1)\n\ndef bernoulli(n)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n\n    a = Array.new(n + 1)\n    a[0] = FRAC_ZERO\n\n    for m in 0 .. n do\n        a[m] = Frac.new(1, m + 1)\n        m.downto(1) do |j|\n            a[j - 1] = (a[j - 1] - a[j]) * Frac.new(j, 1)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef binomial(n, k)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n    if k < 0 then\n        raise ArgumentError.new('k cannot be negative')\n    end\n    if n < k then\n        raise ArgumentError.new('n cannot be less than k')\n    end\n\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k + 1 .. n do\n        num = num * i\n    end\n\n    den = 1\n    for i in 2 .. n - k do\n        den = den * i\n    end\n\n    return num / den\nend\n\ndef faulhaberTriangle(p)\n    coeffs = Array.new(p + 1)\n    coeffs[0] = FRAC_ZERO\n    q = Frac.new(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -sign\n        coeffs[p - j] = q * Frac.new(sign, 1) * Frac.new(binomial(p + 1, j), 1) * bernoulli(j)\n    end\n    return coeffs\nend\n\ndef main\n    for i in 0 .. 9 do\n        coeffs = faulhaberTriangle(i)\n        coeffs.each do |coeff|\n            print \"%5s  \" % [coeff]\n        end\n        puts\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace FaulhabersTriangle {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static Frac[] FaulhaberTriangle(int p) {\n            Frac[] coeffs = new Frac[p + 1];\n            for (int i = 0; i < p + 1; i++) {\n                coeffs[i] = Frac.ZERO;\n            }\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                coeffs[p - j] = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n            }\n            return coeffs;\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Frac[] coeffs = FaulhaberTriangle(i);\n                foreach (Frac coeff in coeffs) {\n                    Console.Write(\"{0,5}  \", coeff);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386907, "name": "Faulhaber's formula", "source": "Translate Ruby to C#: def binomial(n,k)\n    if n < 0 or k < 0 or n < k then\n        return -1\n    end\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k+1 .. n do\n        num = num * i\n    end\n\n    denom = 1\n    for i in 2 .. n-k do\n        denom = denom * i\n    end\n\n    return num / denom\nend\n\ndef bernoulli(n)\n    if n < 0 then\n        raise \"n cannot be less than zero\"\n    end\n\n    a = Array.new(16)\n    for m in 0 .. n do\n        a[m] = Rational(1, m + 1)\n        for j in m.downto(1) do\n            a[j-1] = (a[j-1] - a[j]) * Rational(j)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef faulhaber(p)\n    print(\"%d\u00a0: \" % [p])\n    q = Rational(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -1 * sign\n        coeff = q * Rational(sign) * Rational(binomial(p+1, j)) * bernoulli(j)\n        if coeff == 0 then\n            next\n        end\n        if j == 0 then\n            if coeff != 1 then\n                if coeff == -1 then\n                    print \"-\"\n                else\n                    print coeff\n                end\n            end\n        else\n            if coeff == 1 then\n                print \" + \"\n            elsif coeff == -1 then\n                print \" - \"\n            elsif 0 < coeff then\n                print \" + \"\n                print coeff\n            else\n                print \" - \"\n                print -coeff\n            end\n        end\n        pwr = p + 1 - j\n        if pwr > 1 then\n            print \"n^%d\" % [pwr]\n        else\n            print \"n\"\n        end\n    end\n    print \"\\n\"\nend\n\ndef main\n    for i in 0 .. 9 do\n        faulhaber(i)\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace FaulhabersFormula {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static void Faulhaber(int p) {\n            Console.Write(\"{0}\u00a0: \", p);\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                Frac coeff = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n                if (Frac.ZERO == coeff) continue;\n                if (j == 0) {\n                    if (Frac.ONE != coeff) {\n                        if (-Frac.ONE == coeff) {\n                            Console.Write(\"-\");\n                        }\n                        else {\n                            Console.Write(coeff);\n                        }\n                    }\n                }\n                else {\n                    if (Frac.ONE == coeff) {\n                        Console.Write(\" + \");\n                    }\n                    else if (-Frac.ONE == coeff) {\n                        Console.Write(\" - \");\n                    }\n                    else if (Frac.ZERO < coeff) {\n                        Console.Write(\" + {0}\", coeff);\n                    }\n                    else {\n                        Console.Write(\" - {0}\", -coeff);\n                    }\n                }\n                int pwr = p + 1 - j;\n                if (pwr > 1) {\n                    Console.Write(\"n^{0}\", pwr);\n                }\n                else {\n                    Console.Write(\"n\");\n                }\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Faulhaber(i);\n            }\n        }\n    }\n}\n"}
{"id": 386908, "name": "Prime conspiracy", "source": "Translate Ruby to C#: require \"prime\"\n\ndef prime_conspiracy(m)\n  conspiracy = Hash.new(0)\n  Prime.take(m).map{|n| n%10}.each_cons(2){|a,b| conspiracy[[a,b]] += 1}\n  puts \"\n  conspiracy.sort.each do |(a,b),v|\n    puts \"%d \u2192 %d count:%10d frequency:%7.4f\u00a0%\" % [a, b, v, 100.0*v/m]\n  end\nend\n\nprime_conspiracy(1_000_000)\n", "target": "using System;\n\nnamespace PrimeConspiracy {\n    class Program {\n        static void Main(string[] args) {\n            const int limit = 1_000_000;\n            const int sieveLimit = 15_500_000;\n\n            int[,] buckets = new int[10, 10];\n            int prevDigit = 2;\n            bool[] notPrime = Sieve(sieveLimit);\n\n            for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n                if (notPrime[n]) continue;\n\n                int digit = n % 10;\n                buckets[prevDigit, digit]++;\n                prevDigit = digit;\n                primeCount++;\n            }\n\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (buckets[i, j] != 0) {\n                        Console.WriteLine(\"{0} -> {1}  count: {2,5:d}  frequency\u00a0: {3,6:0.00%}\", i, j, buckets[i, j], 1.0 * buckets[i, j] / limit);\n                    }\n                }\n            }\n        }\n\n        public static bool[] Sieve(int limit) {\n            bool[] composite = new bool[limit];\n            composite[0] = composite[1] = true;\n\n            int max = (int)Math.Sqrt(limit);\n            for (int n = 2; n <= max; n++) {\n                if (!composite[n]) {\n                    for (int k = n * n; k < limit; k += n) {\n                        composite[k] = true;\n                    }\n                }\n            }\n\n            return composite;\n        }\n    }\n}\n"}
{"id": 386909, "name": "Imaginary base numbers", "source": "Translate Ruby to C#: \n\ndef base2i_decode(qi)\n  return 0 if qi == '0'\n  md = qi.match(/^(?<int>[0-3]+)(?:\\.(?<frc>[0-3]+))?$/)\n  raise 'ill-formed quarter-imaginary base value' if !md\n  ls_pow = md[:frc] ? -(md[:frc].length) : 0\n  value = 0\n  (md[:int] + (md[:frc] ? md[:frc] : '')).reverse.each_char.with_index do |dig, inx|\n    value += dig.to_i * (2i)**(inx + ls_pow)\n  end\n  return value\nend\n\n\n\ndef base2i_encode(gi)\n  odd = gi.imag.to_i.odd?\n  frac = (gi.imag.to_i != 0)\n  real = gi.real.to_i\n  imag = (gi.imag.to_i + 1) / 2\n  value = ''\n  phase_real = true\n  while (real != 0) || (imag != 0)\n    if phase_real\n      real, rem = real.divmod(4)\n      real = -real\n    else\n      imag, rem = imag.divmod(4)\n      imag = -imag\n    end\n    value.prepend(rem.to_s)\n    phase_real = !phase_real\n  end\n  value = '0' if value == ''\n  value.concat(odd ? '.2' : '.0') if frac\n  return value\nend\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ImaginaryBaseNumbers {\n    class Complex {\n        private double real, imag;\n\n        public Complex(int r, int i) {\n            real = r;\n            imag = i;\n        }\n\n        public Complex(double r, double i) {\n            real = r;\n            imag = i;\n        }\n\n        public static Complex operator -(Complex self) =>\n            new Complex(-self.real, -self.imag);\n\n        public static Complex operator +(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real + lhs.real, rhs.imag + lhs.imag);\n\n        public static Complex operator -(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real - lhs.real, rhs.imag - lhs.imag);\n\n        public static Complex operator *(Complex rhs, Complex lhs) =>\n            new Complex(\n                rhs.real * lhs.real - rhs.imag * lhs.imag,\n                rhs.real * lhs.imag + rhs.imag * lhs.real\n                );\n\n        public static Complex operator *(Complex rhs, double lhs) =>\n             new Complex(rhs.real * lhs, rhs.imag * lhs);\n\n        public static Complex operator /(Complex rhs, Complex lhs) =>\n            rhs * lhs.Inv();\n\n        public Complex Inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(real / denom, -imag / denom);\n        }\n\n        public QuaterImaginary ToQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = (int)real;\n            int im = (int)imag;\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem = 4 + rem;\n                    re++;\n                }\n                sb.Append(rem);\n                sb.Append(0);\n            }\n            if (im != 0) {\n                double f = (new Complex(0.0, imag) / new Complex(0.0, 2.0)).real;\n                im = (int)Math.Ceiling(f);\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem = 4 + rem;\n                        im++;\n                    }\n                    if (index < sb.Length) {\n                        sb[index] = (char)(rem + 48);\n                    } else {\n                        sb.Append(0);\n                        sb.Append(rem);\n                    }\n                    index += 2;\n                }\n                fi = (int)f;\n            }\n            string reverse = new string(sb.ToString().Reverse().ToArray());\n            sb.Length = 0;\n            sb.Append(reverse);\n            if (fi != -1) sb.AppendFormat(\".{0}\", fi);\n            string s = sb.ToString().TrimStart('0');\n            if (s[0] == '.') s = \"0\" + s;\n            return new QuaterImaginary(s);\n        }\n\n        public override string ToString() {\n            double real2 = (real == -0.0) ? 0.0 : real;  \n            double imag2 = (imag == -0.0) ? 0.0 : imag;  \n            if (imag2 == 0.0) {\n                return string.Format(\"{0}\", real2);\n            }\n            if (real2 == 0.0) {\n                return string.Format(\"{0}i\", imag2);\n            }\n            if (imag2 > 0.0) {\n                return string.Format(\"{0} + {1}i\", real2, imag2);\n            }\n            return string.Format(\"{0} - {1}i\", real2, -imag2);\n        }\n    }\n\n    class QuaterImaginary {\n        internal static Complex twoI = new Complex(0.0, 2.0);\n        internal static Complex invTwoI = twoI.Inv();\n\n        private string b2i;\n\n        public QuaterImaginary(string b2i) {\n            if (b2i == \"\" || !b2i.All(c => \"0123.\".IndexOf(c) > -1) || b2i.Count(c => c == '.') > 1) {\n                throw new Exception(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex ToComplex() {\n            int pointPos = b2i.IndexOf(\".\");\n            int posLen = (pointPos != -1) ? pointPos : b2i.Length;\n            Complex sum = new Complex(0.0, 0.0);\n            Complex prod = new Complex(1.0, 0.0);\n            for (int j = 0; j < posLen; j++) {\n                double k = (b2i[posLen - 1 - j] - '0');\n                if (k > 0.0) {\n                    sum += prod * k;\n                }\n                prod *= twoI;\n            }\n            if (pointPos != -1) {\n                prod = invTwoI;\n                for (int j = posLen + 1; j < b2i.Length; j++) {\n                    double k = (b2i[j] - '0');\n                    if (k > 0.0) {\n                        sum += prod * k;\n                    }\n                    prod *= invTwoI;\n                }\n            }\n\n            return sum;\n        }\n\n        public override string ToString() {\n            return b2i;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(i, 0);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n            Console.WriteLine();\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(0, i);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n        }\n    }\n}\n"}
{"id": 386910, "name": "Statistics_Normal distribution", "source": "Translate Ruby to C#: \n\n\nclass NormalFromUniform\n  \n  def initialize()\n    @next = nil\n  end\n  \n  def rand()\n    if @next\n      retval, @next = @next, nil\n      return retval\n    else\n      u = v = s = nil\n      loop do\n        u = Random.rand(-1.0..1.0)\n        v = Random.rand(-1.0..1.0)\n        s = u**2 + v**2\n        break if (s > 0.0) && (s <= 1.0)\n      end\n      f = Math.sqrt(-2.0 * Math.log(s) / s)\n      @next = v * f\n      return u * f\n    end\n  end\nend\n", "target": "using System;\nusing MathNet.Numerics.Distributions;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void RunNormal(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var norm = new Normal(new Random());\n        norm.Samples(X);\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        RunNormal(100);\n        RunNormal(1000);\n        RunNormal(10000);\n    }\n}\n"}
{"id": 386911, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Ruby to C#: def mod(m, n)\n    result = m % n\n    if result < 0 then\n        result = result + n\n    end\n    return result\nend\n\ndef getA004290(n)\n    if n == 1 then\n        return 1\n    end\n    arr = Array.new(n) { Array.new(n, 0) }\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while true\n        m = m + 1\n        if arr[m - 1][mod(-10 ** m, n)] == 1 then\n            break\n        end\n        arr[m][0] = 1\n        for k in 1 .. n - 1\n            arr[m][k] = [arr[m - 1][k], arr[m - 1][mod(k - 10 ** m, n)]].max\n        end\n    end\n    r = 10 ** m\n    k = mod(-r, n)\n    (m - 1).downto(1) { |j|\n        if arr[j - 1][k] == 0 then\n            r = r + 10 ** j\n            k = mod(k - 10 ** j, n)\n        end\n    }\n    if k == 1 then\n        r = r + 1\n    end\n    return r\nend\n\ntestCases = Array(1 .. 10)\ntestCases.concat(Array(95 .. 105))\ntestCases.concat([297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878])\nfor n in testCases\n    result = getA004290(n)\n    print \"A004290(%d) = %d = %d * %d\\n\" % [n, result, n, result / n]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\n \nclass Program {\n \n  static string B10(int n) {\n    int[] pow = new int[n + 1], val = new int[29];\n    for (int count = 0, ten = 1, x = 1; x <= n; x++) {\n      val[x] = ten;\n      for (int j = 0, t; j <= n; j++)\n        if (pow[j] != 0 && pow[j] != x && pow[t = (j + ten) % n] == 0)\n          pow[t] = x;\n      if (pow[ten] == 0) pow[ten] = x;\n      ten = (10 * ten) % n;\n      if (pow[0] != 0) {\n        x = n;\n        string s = \"\"; \n        while (x != 0) {\n          int p = pow[x % n];\n          if (count > p) s += new string('0', count - p);\n          count = p - 1;\n          s += \"1\";\n          x = (n + x - val[p]) % n;\n        }\n        if (count > 0) s += new string('0', count);\n        return s;\n      }\n    } \n    return \"1\";\n  }\n \n  static void Main(string[] args) {\n    string fmt = \"{0,4} * {1,24} = {2,-28}\\n\";\n    int[] m = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n      95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,\n      297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878 };\n    string[] r = new string[m.Length]; \n    WriteLine(fmt + new string('-', 62), \"n\", \"multiplier\", \"B10\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    for (int i = 0; i < m.Length; i++) r[i] = B10(m[i]);\n    sw.Stop();\n    for (int i = 0; i < m.Length; i++) Write(fmt, m[i], decimal.Parse(r[i]) / m[i], r[i]);\n    Write(\"\\nTook {0}ms\", sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 386912, "name": "Weird numbers", "source": "Translate Ruby to C#: def divisors(n : Int32) : Array(Int32)\n  divs = [1]\n  divs2 = [] of Int32\n\n  i = 2\n  while i * i < n\n    if n % i == 0\n      j = n // i\n      divs << i\n      divs2 << j if i != j\n    end\n\n    i += 1\n  end\n\n  i = divs.size - 1\n\n  \n  while i >= 0\n    divs2 << divs[i]\n    i -= 1\n  end\n\n  divs2\nend\n\ndef abundant(n : Int32, divs : Array(Int32)) : Bool\n  divs.sum > n\nend\n\ndef semiperfect(n : Int32, divs : Array(Int32)) : Bool\n  if divs.size > 0\n    h = divs[0]\n    t = divs[1..]\n\n    return n < h ? semiperfect(n, t) : n == h || semiperfect(n - h, t) || semiperfect(n, t)\n  end\n\n  return false\nend\n\ndef sieve(limit : Int32) : Array(Bool)\n  \n  \n\n  w = Array(Bool).new(limit, false) \n\n  i = 2\n  while i < limit\n    if !w[i]\n      divs = divisors i\n\n      if !abundant(i, divs)\n        w[i] = true\n      elsif semiperfect(i, divs)\n        j = i\n        while j < limit\n          w[j] = true\n          j += i\n        end\n      end\n    end\n\n    i += 2\n  end\n\n  w\nend\n\ndef main\n  w = sieve 17000\n  count = 0\n  max = 25\n\n  print \"The first 25 weird numbers are: \"\n\n  n = 2\n  while count < max\n    if !w[n]\n      print \"\n      count += 1\n    end\n\n    n += 2\n  end\n\n  puts \"\\n\"\nend\n\nrequire \"benchmark\"\nputs Benchmark.measure { main }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WeirdNumbers {\n    class Program {\n        static List<int> Divisors(int n) {\n            List<int> divs = new List<int> { 1 };\n            List<int> divs2 = new List<int>();\n\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs2.Add(j);\n                    }\n                }\n            }\n\n            divs.Reverse();\n            divs2.AddRange(divs);\n            return divs2;\n        }\n\n        static bool Abundant(int n, List<int> divs) {\n            return divs.Sum() > n;\n        }\n\n        static bool Semiperfect(int n, List<int> divs) {\n            if (divs.Count > 0) {\n                var h = divs[0];\n                var t = divs.Skip(1).ToList();\n                if (n < h) {\n                    return Semiperfect(n, t);\n                } else {\n                    return n == h\n                        || Semiperfect(n - h, t)\n                        || Semiperfect(n, t);\n                }\n            } else {\n                return false;\n            }\n        }\n\n        static List<bool> Sieve(int limit) {\n            \n            \n            bool[] w = new bool[limit];\n            for (int i = 2; i < limit; i += 2) {\n                if (w[i]) continue;\n                var divs = Divisors(i);\n                if (!Abundant(i, divs)) {\n                    w[i] = true;\n                } else if (Semiperfect(i, divs)) {\n                    for (int j = i; j < limit; j += i) {\n                        w[j] = true;\n                    }\n                }\n            }\n            return w.ToList();\n        }\n\n        static void Main() {\n            var w = Sieve(17_000);\n            int count = 0;\n            int max = 25;\n            Console.WriteLine(\"The first 25 weird numbers:\");\n            for (int n = 2; count < max; n += 2) {\n                if (!w[n]) {\n                    Console.Write(\"{0} \", n);\n                    count++;\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 386913, "name": "Peaceful chess queen armies", "source": "Translate Ruby to C#: class Position\n    attr_reader :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def ==(other)\n        self.x == other.x &&\n        self.y == other.y\n    end\n\n    def to_s\n        '(%d, %d)' % [@x, @y]\n    end\n\n    def to_str\n        to_s\n    end\nend\n\ndef isAttacking(queen, pos)\n    return queen.x == pos.x ||\n           queen.y == pos.y ||\n           (queen.x - pos.x).abs() == (queen.y - pos.y).abs()\nend\n\ndef place(m, n, blackQueens, whiteQueens)\n    if m == 0 then\n        return true\n    end\n    placingBlack = true\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            catch :inner do\n                pos = Position.new(i, j)\n                for queen in blackQueens\n                    if pos == queen || !placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                for queen in whiteQueens\n                    if pos == queen || placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                if placingBlack then\n                    blackQueens << pos\n                    placingBlack = false\n                else\n                    whiteQueens << pos\n                    if place(m - 1, n, blackQueens, whiteQueens) then\n                        return true\n                    end\n                    blackQueens.pop\n                    whiteQueens.pop\n                    placingBlack = true\n                end\n            end\n        end\n    end\n    if !placingBlack then\n        blackQueens.pop\n    end\n    return false\nend\n\ndef printBoard(n, blackQueens, whiteQueens)\n    \n    board = Array.new(n) { Array.new(n) { ' ' } }\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            if i % 2 == j % 2 then\n                board[i][j] = '\u2022'\n            else\n                board[i][j] = '\u25e6'\n            end\n        end\n    end\n\n    \n    for queen in blackQueens\n        board[queen.y][queen.x] = 'B'\n    end\n    for queen in whiteQueens\n        board[queen.y][queen.x] = 'W'\n    end\n\n    \n    for row in board\n        for cell in row\n            print cell, ' '\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\nnms = [\n    [2, 1],\n    [3, 1], [3, 2],\n    [4, 1], [4, 2], [4, 3],\n    [5, 1], [5, 2], [5, 3], [5, 4], [5, 5],\n    [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6],\n    [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7]\n]\nfor nm in nms\n    m = nm[1]\n    n = nm[0]\n    print \"%d black and %d white queens on a %d x %d board:\\n\" % [m, m, n, n]\n\n    blackQueens = []\n    whiteQueens = []\n    if place(m, n, blackQueens, whiteQueens) then\n        printBoard(n, blackQueens, whiteQueens)\n    else\n        print \"No solution exists.\\n\\n\"\n    end\nend\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PeacefulChessQueenArmies {\n    using Position = Tuple<int, int>;\n\n    enum Piece {\n        Empty,\n        Black,\n        White\n    }\n\n    class Program {\n        static bool IsAttacking(Position queen, Position pos) {\n            return queen.Item1 == pos.Item1\n                || queen.Item2 == pos.Item2\n                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);\n        }\n\n        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n            if (m == 0) {\n                return true;\n            }\n            bool placingBlack = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    var pos = new Position(i, j);\n                    foreach (var queen in pBlackQueens) {\n                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    foreach (var queen in pWhiteQueens) {\n                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    if (placingBlack) {\n                        pBlackQueens.Add(pos);\n                        placingBlack = false;\n                    } else {\n                        pWhiteQueens.Add(pos);\n                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                            return true;\n                        }\n                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);\n                        placingBlack = true;\n                    }\n                inner: { }\n                }\n            }\n            if (!placingBlack) {\n                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n            }\n            return false;\n        }\n\n        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n            var board = new Piece[n * n];\n\n            foreach (var queen in blackQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.Black;\n            }\n            foreach (var queen in whiteQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.White;\n            }\n\n            for (int i = 0; i < board.Length; i++) {\n                if (i != 0 && i % n == 0) {\n                    Console.WriteLine();\n                }\n                switch (board[i]) {\n                    case Piece.Black:\n                        Console.Write(\"B \");\n                        break;\n                    case Piece.White:\n                        Console.Write(\"W \");\n                        break;\n                    case Piece.Empty:\n                        int j = i / n;\n                        int k = i - j * n;\n                        if (j % 2 == k % 2) {\n                            Console.Write(\"  \");\n                        } else {\n                            Console.Write(\"# \");\n                        }\n                        break;\n                }\n            }\n\n            Console.WriteLine(\"\\n\");\n        }\n\n        static void Main() {\n            var nms = new int[,] {\n                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n            };\n            for (int i = 0; i < nms.GetLength(0); i++) {\n                Console.WriteLine(\"{0} black and {0} white queens on a {1} x {1} board:\", nms[i, 1], nms[i, 0]);\n                List<Position> blackQueens = new List<Position>();\n                List<Position> whiteQueens = new List<Position>();\n                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {\n                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);\n                } else {\n                    Console.WriteLine(\"No solution exists.\\n\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386914, "name": "Readline interface", "source": "Translate Ruby to C#: require \"readline\"\nrequire \"abbrev\"\n\ncommands = %w[search download open help history quit url prev past]\nReadline.completion_proc = commands.abbrev.to_proc\n\nwhile buf = Readline.readline(\">\", true) \n  exit if buf.strip == \"quit\"\n  p buf\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\nnamespace ReadlineInterface {\n    class Program {\n        static LinkedList<string> histArr = new LinkedList<string>();\n\n        static void AppendHistory([CallerMemberName] string name = \"unknown\") {\n            histArr.AddLast(name);\n        }\n\n        static void Hist() {\n            if (histArr.Count == 0) {\n                Console.WriteLine(\"No history\");\n            }\n            else {\n                foreach (string cmd in histArr) {\n                    Console.WriteLine(\" - {0}\", cmd);\n                }\n            }\n            AppendHistory();\n        }\n\n        static void Hello() {\n            Console.WriteLine(\"Hello World!\");\n            AppendHistory();\n        }\n\n        static void Help() {\n            Console.WriteLine(\"Available commands:\");\n            Console.WriteLine(\"  hello\");\n            Console.WriteLine(\"  hist\");\n            Console.WriteLine(\"  exit\");\n            Console.WriteLine(\"  help\");\n            AppendHistory();\n        }\n\n        static void Main(string[] args) {\n            Dictionary<string, Action> cmdDict = new Dictionary<string, Action>();\n            cmdDict.Add(\"help\", Help);\n            cmdDict.Add(\"hist\", Hist);\n            cmdDict.Add(\"hello\", Hello);\n\n            Console.WriteLine(\"Enter a command, type help for a listing.\");\n            while (true) {\n                Console.Write(\">\");\n                string line = Console.ReadLine();\n                if (line==\"exit\") {\n                    break;\n                }\n\n                Action action;\n                if (cmdDict.TryGetValue(line, out action)) {\n                    action.Invoke();\n                } else {\n                    Help();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386915, "name": "Addition chains", "source": "Translate Ruby to C#: def check_seq(pos, seq, n, min_len)\n    if pos > min_len or seq[0] > n then\n        return min_len, 0\n    elsif seq[0] == n then\n        return pos, 1\n    elsif pos < min_len then\n        return try_perm(0, pos, seq, n, min_len)\n    else\n        return min_len, 0\n    end\nend\n\ndef try_perm(i, pos, seq, n, min_len)\n    if i > pos then\n        return min_len, 0\n    end\n\n    res11, res12 = check_seq(pos + 1, [seq[0] + seq[i]] + seq, n, min_len)\n    res21, res22 = try_perm(i + 1, pos, seq, n, res11)\n\n    if res21 < res11 then\n        return res21, res22\n    elsif res21 == res11 then\n        return res21, res12 + res22\n    else\n        raise \"try_perm exception\"\n    end\nend\n\ndef init_try_perm(x)\n    return try_perm(0, 0, [1], x, 12)\nend\n\ndef find_brauer(num)\n    actualMin, brauer = init_try_perm(num)\n    puts\n    print \"N = \", num, \"\\n\"\n    print \"Minimum length of chains: L(n)= \", actualMin, \"\\n\"\n    print \"Number of minimum length Brauer chains: \", brauer, \"\\n\"\nend\n\ndef main\n    nums = [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]\n    for i in nums do\n        find_brauer(i)\n    end\nend\n\nmain()\n", "target": "using System;\n\nnamespace AdditionChains {\n    class Program {\n        static int[] Prepend(int n, int[] seq) {\n            int[] result = new int[seq.Length + 1];\n            Array.Copy(seq, 0, result, 1, seq.Length);\n            result[0] = n;\n            return result;\n        }\n\n        static Tuple<int, int> CheckSeq(int pos, int[] seq, int n, int min_len) {\n            if (pos > min_len || seq[0] > n) return new Tuple<int, int>(min_len, 0);\n            if (seq[0] == n) return new Tuple<int, int>(pos, 1);\n            if (pos < min_len) return TryPerm(0, pos, seq, n, min_len);\n            return new Tuple<int, int>(min_len, 0);\n        }\n\n        static Tuple<int, int> TryPerm(int i, int pos, int[] seq, int n, int min_len) {\n            if (i > pos) return new Tuple<int, int>(min_len, 0);\n\n            Tuple<int, int> res1 = CheckSeq(pos + 1, Prepend(seq[0] + seq[i], seq), n, min_len);\n            Tuple<int, int> res2 = TryPerm(i + 1, pos, seq, n, res1.Item1);\n\n            if (res2.Item1 < res1.Item1) return res2;\n            if (res2.Item1 == res1.Item1) return new Tuple<int, int>(res2.Item1, res1.Item2 + res2.Item2);\n\n            throw new Exception(\"TryPerm exception\");\n        }\n\n        static Tuple<int, int> InitTryPerm(int x) {\n            return TryPerm(0, 0, new int[] { 1 }, x, 12);\n        }\n\n        static void FindBrauer(int num) {\n            Tuple<int, int> res = InitTryPerm(num);\n            Console.WriteLine();\n            Console.WriteLine(\"N = {0}\", num);\n            Console.WriteLine(\"Minimum length of chains: L(n)= {0}\", res.Item1);\n            Console.WriteLine(\"Number of minimum length Brauer chains: {0}\", res.Item2);\n        }\n\n        static void Main(string[] args) {\n            int[] nums = new int[] { 7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379 };\n            Array.ForEach(nums, n => FindBrauer(n));\n        }\n    }\n}\n"}
{"id": 386916, "name": "Montgomery reduction", "source": "Translate Ruby to C#: func montgomeryReduce(m, a) {\n    {\n        a += m if a.is_odd\n        a >>= 1\n    } * m.as_bin.len\n\n    a % m\n}\n\nvar m  = 750791094644726559640638407699\nvar t1 = 323165824550862327179367294465482435542970161392400401329100\n\nvar r1 = 440160025148131680164261562101\nvar r2 = 435362628198191204145287283255\n\nvar x1 = 540019781128412936473322405310\nvar x2 = 515692107665463680305819378593\n\nsay(\"Original x1:        \", x1)\nsay(\"Recovererd from r1: \", montgomeryReduce(m, r1))\nsay(\"Original x2:        \", x2)\nsay(\"Recovererd from r2: \", montgomeryReduce(m, r2))\n\nprint(\"\\nMontgomery computation of x1^x2 mod m:    \")\nvar prod = montgomeryReduce(m, t1/x1)\nvar base = montgomeryReduce(m, t1)\n\nfor (var exponent = x2; exponent ; exponent >>= 1) {\n    prod = montgomeryReduce(m, prod * base) if exponent.is_odd\n    base = montgomeryReduce(m, base * base)\n}\n\nsay(montgomeryReduce(m, prod))\nsay(\"Library-based computation of x1^x2 mod m: \", x1.powmod(x2, m))\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MontgomeryReduction {\n    public static class Helper {\n        public static int BitLength(this BigInteger v) {\n            if (v < 0) {\n                v *= -1;\n            }\n\n            int result = 0;\n            while (v > 0) {\n                v >>= 1;\n                result++;\n            }\n\n            return result;\n        }\n    }\n\n    struct Montgomery {\n        public static readonly int BASE = 2;\n\n        public BigInteger m;\n        public BigInteger rrm;\n        public int n;\n\n        public Montgomery(BigInteger m) {\n            if (m < 0 || m.IsEven) throw new ArgumentException();\n\n            this.m = m;\n            n = m.BitLength();\n            rrm = (BigInteger.One << (n * 2)) % m;\n        }\n\n        public BigInteger Reduce(BigInteger t) {\n            var a = t;\n\n            for (int i = 0; i < n; i++) {\n                if (!a.IsEven) a += m;\n                a = a >> 1;\n            }\n            if (a >= m) a -= m;\n            return a;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            var m = BigInteger.Parse(\"750791094644726559640638407699\");\n            var x1 = BigInteger.Parse(\"540019781128412936473322405310\");\n            var x2 = BigInteger.Parse(\"515692107665463680305819378593\");\n\n            var mont = new Montgomery(m);\n            var t1 = x1 * mont.rrm;\n            var t2 = x2 * mont.rrm;\n\n            var r1 = mont.Reduce(t1);\n            var r2 = mont.Reduce(t2);\n            var r = BigInteger.One << mont.n;\n\n            Console.WriteLine(\"b\u00a0:  {0}\", Montgomery.BASE);\n            Console.WriteLine(\"n\u00a0:  {0}\", mont.n);\n            Console.WriteLine(\"r\u00a0:  {0}\", r);\n            Console.WriteLine(\"m\u00a0:  {0}\", mont.m);\n            Console.WriteLine(\"t1:  {0}\", t1);\n            Console.WriteLine(\"t2:  {0}\", t2);\n            Console.WriteLine(\"r1:  {0}\", r1);\n            Console.WriteLine(\"r2:  {0}\", r2);\n            Console.WriteLine();\n            Console.WriteLine(\"Original x1      \u00a0: {0}\", x1);\n            Console.WriteLine(\"Recovered from r1\u00a0: {0}\", mont.Reduce(r1));\n            Console.WriteLine(\"Original x2      \u00a0: {0}\", x2);\n            Console.WriteLine(\"Recovered from r2\u00a0: {0}\", mont.Reduce(r2));\n\n            Console.WriteLine();\n            Console.WriteLine(\"Montgomery computation of x1 ^ x2 mod m\u00a0:\");\n            var prod = mont.Reduce(mont.rrm);\n            var @base = mont.Reduce(x1 * mont.rrm);\n            var exp = x2;\n            while (exp.BitLength() > 0) {\n                if (!exp.IsEven) prod = mont.Reduce(prod * @base);\n                exp >>= 1;\n                @base = mont.Reduce(@base * @base);\n            }\n            Console.WriteLine(mont.Reduce(prod));\n            Console.WriteLine();\n            Console.WriteLine(\"Alternate computation of x1 ^ x2 mod m\u00a0:\");\n            Console.WriteLine(BigInteger.ModPow(x1, x2, m));\n        }\n    }\n}\n"}
{"id": 386917, "name": "Sokoban", "source": "Translate Ruby to C#: require 'set'\n\nclass Sokoban\n  def initialize(level)\n    board = level.each_line.map(&:rstrip)\n    @nrows = board.map(&:size).max\n    board.map!{|line| line.ljust(@nrows)}\n    board.each_with_index do |row, r|\n      row.each_char.with_index do |ch, c|\n        @px, @py = c, r  if ch == '@' or ch == '+'\n      end\n    end\n    @goal = board.join.tr(' .@\n                 .each_char.with_index.select{|ch, c| ch == '.'}\n                 .map(&:last)\n    @board = board.join.tr(' .@\n  end\n  \n  def pos(x, y)\n    y * @nrows + x\n  end\n  \n  def push(x, y, dx, dy, board)         \n    return  if board[pos(x+2*dx, y+2*dy)] != ' '\n    board[pos(x     , y     )] = ' '\n    board[pos(x + dx, y + dy)] = '@'\n    board[pos(x+2*dx, y+2*dy)] = '$'\n  end\n  \n  def solved?(board)\n    @goal.all?{|i| board[i] == '$'}\n  end\n  \n  DIRS = [[0, -1, 'u', 'U'], [ 1, 0, 'r', 'R'], [0,  1, 'd', 'D'], [-1, 0, 'l', 'L']]\n  def solve\n    queue = [[@board, \"\", @px, @py]]\n    visited = Set[@board]\n    \n    until queue.empty?\n      current, csol, x, y = queue.shift\n      \n      for dx, dy, cmove, cpush in DIRS\n        work = current.dup\n        case work[pos(x+dx, y+dy)]      \n        when '$'\n          next  unless push(x, y, dx, dy, work)\n          next  unless visited.add?(work)\n          return csol+cpush  if solved?(work)\n          queue << [work, csol+cpush, x+dx, y+dy]\n        when ' '\n          work[pos(x, y)]       = ' '\n          work[pos(x+dx, y+dy)] = '@'\n          queue << [work, csol+cmove, x+dx, y+dy]  if visited.add?(work)\n        end\n      end\n    end\n    \"No solution\"\n  end\nend\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace SokobanSolver\n{\n    public class SokobanSolver\n    {\n        private class Board\n        {\n            public string Cur { get; internal set; }\n            public string Sol { get; internal set; }\n            public int X { get; internal set; }\n            public int Y { get; internal set; }\n\n            public Board(string cur, string sol, int x, int y)\n            {\n                Cur = cur;\n                Sol = sol;\n                X = x;\n                Y = y;\n            }\n        }\n\n        private string destBoard, currBoard;\n        private int playerX, playerY, nCols;\n\n        SokobanSolver(string[] board)\n        {\n            nCols = board[0].Length;\n            StringBuilder destBuf = new StringBuilder();\n            StringBuilder currBuf = new StringBuilder();\n\n            for (int r = 0; r < board.Length; r++)\n            {\n                for (int c = 0; c < nCols; c++)\n                {\n\n                    char ch = board[r][c];\n\n                    destBuf.Append(ch != '$' && ch != '@' ? ch : ' ');\n                    currBuf.Append(ch != '.' ? ch : ' ');\n\n                    if (ch == '@')\n                    {\n                        this.playerX = c;\n                        this.playerY = r;\n                    }\n                }\n            }\n            destBoard = destBuf.ToString();\n            currBoard = currBuf.ToString();\n        }\n\n        private string Move(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newPlayerPos = (y + dy) * nCols + x + dx;\n\n            if (trialBoard[newPlayerPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[newPlayerPos] = '@';\n\n            return new string(trial);\n        }\n\n        private string Push(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n            if (trialBoard[newBoxPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[(y + dy) * nCols + x + dx] = '@';\n            trial[newBoxPos] = '$';\n\n            return new string(trial);\n        }\n\n        private bool IsSolved(string trialBoard)\n        {\n            for (int i = 0; i < trialBoard.Length; i++)\n                if ((destBoard[i] == '.')\n                        != (trialBoard[i] == '$'))\n                    return false;\n            return true;\n        }\n\n        private string Solve()\n        {\n            char[,] dirLabels = { { 'u', 'U' }, { 'r', 'R' }, { 'd', 'D' }, { 'l', 'L' } };\n            int[,] dirs = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };\n            ISet<string> history = new HashSet<string>();\n            LinkedList<Board> open = new LinkedList<Board>();\n\n            history.Add(currBoard);\n            open.AddLast(new Board(currBoard, string.Empty, playerX, playerY));\n\n            while (!open.Count.Equals(0))\n            {\n                Board item = open.First();\n                open.RemoveFirst();\n                string cur = item.Cur;\n                string sol = item.Sol;\n                int x = item.X;\n                int y = item.Y;\n\n                for (int i = 0; i < dirs.GetLength(0); i++)\n                {\n                    string trial = cur;\n                    int dx = dirs[i, 0];\n                    int dy = dirs[i, 1];\n\n                    \n                    if (trial[(y + dy) * nCols + x + dx] == '$')\n                    {\n                        \n                        if ((trial = Push(x, y, dx, dy, trial)) != null)\n                        {\n                            \n                            if (!history.Contains(trial))\n                            {\n\n                                string newSol = sol + dirLabels[i, 1];\n\n                                if (IsSolved(trial))\n                                    return newSol;\n\n                                open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                                history.Add(trial);\n                            }\n                        }\n                        \n                    }\n                    else if ((trial = Move(x, y, dx, dy, trial)) != null)\n                    {\n                        if (!history.Contains(trial))\n                        {\n                            string newSol = sol + dirLabels[i, 0];\n                            open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                            history.Add(trial);\n                        }\n                    }\n                }\n            }\n            return \"No solution\";\n        }\n\n        public static void Main(string[] a)\n        {\n            string level = \"#######,\" +\n                           \"#     #,\" +\n                           \"#     #,\" +\n                           \"#. #  #,\" +\n                           \"#. $$ #,\" +\n                           \"#.$$  #,\" +\n                           \"#.#  @#,\" +\n                           \"#######\";\n            System.Console.WriteLine(\"Level:\\n\");\n            foreach (string line in level.Split(','))\n            {\n                System.Console.WriteLine(line);\n            }\n            System.Console.WriteLine(\"\\nSolution:\\n\");\n            System.Console.WriteLine(new SokobanSolver(level.Split(',')).Solve());\n        }\n    }\n}\n"}
{"id": 386918, "name": "Zumkeller numbers", "source": "Translate Ruby to C#: class Integer\n  \n  def divisors\n    res = [1, self]\n    (2..Integer.sqrt(self)).each do |n|\n      div, mod = divmod(n)\n      res << n << div if mod.zero?\n    end\n    res.uniq.sort\n  end\n  \n  def zumkeller?\n    divs = divisors\n    sum  = divs.sum\n    return false unless sum.even? && sum >= self*2\n    half = sum / 2\n    max_combi_size = divs.size / 2\n    1.upto(max_combi_size).any? do |combi_size|\n      divs.combination(combi_size).any?{|combi| combi.sum == half}\n    end\n  end\n  \nend\n\ndef p_enum(enum, cols = 10, col_width = 8)\n  enum.each_slice(cols) {|slice| puts \"%\nend\n\nputs \"\np_enum 1.step.lazy.select(&:zumkeller?).take(n), 14, 6\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select(&:zumkeller?).take(n)\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select{|x| x % 5 > 0 && x.zumkeller?}.take(n)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386919, "name": "Rare numbers", "source": "Translate Ruby to C#: Term = Struct.new(:coeff, :ix1, :ix2) do\nend\n\nMAX_DIGITS = 16\n\ndef toLong(digits, reverse)\n    sum = 0\n    if reverse then\n        i = digits.length - 1\n        while i >=0\n            sum = sum  *10 + digits[i]\n            i = i - 1\n        end\n    else\n        i = 0\n        while i < digits.length\n            sum = sum * 10 + digits[i]\n            i = i + 1\n        end\n    end\n    return sum\nend\n\ndef isSquare(n)\n    root = Math.sqrt(n).to_i\n    return root * root == n\nend\n\ndef seq(from, to, step)\n    res = []\n    i = from\n    while i <= to\n        res << i\n        i = i + step\n    end\n    return res\nend\n\ndef format_number(number)\n  number.to_s.reverse.gsub(/(\\d{3})(?=\\d)/, '\\\\1,').reverse\nend\n\ndef main\n    pow = 1\n    allTerms = []\n    for i in 0 .. MAX_DIGITS - 2\n        allTerms << []\n    end\n    for r in 2 .. MAX_DIGITS\n        terms = []\n        pow = pow * 10\n        pow1 = pow\n        pow2 = 1\n        i1 = 0\n        i2 = r - 1\n        while i1 < i2\n            terms << Term.new(pow1 - pow2, i1, i2)\n            pow1 = (pow1 / 10).to_i\n            pow2 = pow2 * 10\n            i1 = i1 + 1\n            i2 = i2 - 1\n        end\n        allTerms[r - 2] = terms\n    end\n    \n    fml = {\n        0 =>[[2, 2], [8, 8]],\n        1 =>[[6, 5], [8, 7]],\n        4 =>[[4, 0]],\n        6 =>[[6, 0], [8, 2]]\n    }\n    \n    dmd = {}\n    for i in 0 .. 99\n        a = [(i / 10).to_i, (i % 10)]\n        d = a[0] - a[1]\n        if dmd.include?(d) then\n            dmd[d] << a\n        else\n            dmd[d] = [a]\n        end\n    end\n    fl = [0, 1, 4, 6]\n    dl = seq(-9, 9, 1) \n    zl = [0]           \n    el = seq(-8, 8, 2) \n    ol = seq(-9, 9, 2) \n    il = seq(0, 9, 1)\n    rares = []\n    lists = []\n    for i in 0 .. 3\n        lists << []\n    end\n    fl.each_with_index { |f, i|\n        lists[i] = [[f]]\n    }\n    digits = []\n    count = 0\n\n    \n    \n    fnpr = lambda { |cand, di, dis, indices, nmr, nd, level|\n        if level == dis.length then\n            digits[indices[0][0]] = fml[cand[0]][di[0]][0]\n            digits[indices[0][1]] = fml[cand[0]][di[0]][1]\n            le = di.length\n            if nd % 2 == 1 then\n                le = le - 1\n                digits[(nd / 2).to_i] = di[le]\n            end\n            di[1 .. le - 1].each_with_index { |d, i|\n                digits[indices[i + 1][0]] = dmd[cand[i + 1]][d][0]\n                digits[indices[i + 1][1]] = dmd[cand[i + 1]][d][1]\n            }\n            r = toLong(digits, true)\n            npr = nmr + 2 * r\n            if not isSquare(npr) then\n                return\n            end\n            count = count + 1\n            print \"     R/N %2d:\" % [count]\n            n = toLong(digits, false)\n            print \"  (%s)\\n\" % [format_number(n)]\n            rares << n\n        else\n            for num in dis[level]\n                di[level] = num\n                fnpr.call(cand, di, dis, indices, nmr, nd, level + 1)\n            end\n        end\n    }\n\n    \n    fnmr = lambda { |cand, list, indices, nd, level|\n        if level == list.length then\n            nmr = 0\n            nmr2 = 0\n            allTerms[nd - 2].each_with_index { |t, i|\n                if cand[i] >= 0 then\n                    nmr = nmr + t.coeff * cand[i]\n                else\n                    nmr2 = nmr2 = t.coeff * -cand[i]\n                    if nmr >= nmr2 then\n                        nmr = nmr - nmr2\n                        nmr2 = 0\n                    else\n                        nmr2 = nmr2 - nmr\n                        nmr = 0\n                    end\n                end\n            }\n            if nmr2 >= nmr then\n                return\n            end\n            nmr = nmr - nmr2\n            if not isSquare(nmr) then\n                return\n            end\n            dis = []\n            dis << seq(0, fml[cand[0]].length - 1, 1)\n            for i in 1 .. cand.length - 1\n                dis << seq(0, dmd[cand[i]].length - 1, 1)\n            end\n            if nd % 2 == 1 then\n                dis << il.dup\n            end\n            di = []\n            for i in 0 .. dis.length - 1\n                di << 0\n            end\n            fnpr.call(cand, di, dis, indices, nmr, nd, 0)\n        else\n            for num in list[level]\n                cand[level] = num\n                fnmr.call(cand, list, indices, nd, level + 1)\n            end\n        end\n    }\n\n    \n    for nd in 2 .. 10\n        digits = []\n        for i in 0 .. nd - 1\n            digits << 0\n        end\n        if nd == 4 then\n            lists[0] << zl.dup\n            lists[1] << ol.dup\n            lists[2] << el.dup\n            lists[3] << ol.dup\n        elsif allTerms[nd - 2].length > lists[0].length then\n            for i in 0 .. 3\n                lists[i] << dl.dup\n            end\n        end\n        indices = []\n        for t in allTerms[nd - 2]\n            indices << [t.ix1, t.ix2]\n        end\n        for list in lists\n            cand = []\n            for i in 0 .. list.length - 1\n                cand << 0\n            end\n            fnmr.call(cand, list, indices, nd, 0)\n        end\n        print \"  %2d digits\\n\" % [nd]\n    end\n\n    rares.sort()\n    print \"\\nThe rare numbers with up to %d digits are:\\n\" % [MAX_DIGITS]\n    rares.each_with_index { |rare, i|\n        print \"  %2d:  %25s\\n\" % [i + 1, format_number(rare)]\n    }\nend\n\nmain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing UI = System.UInt64;\nusing LST = System.Collections.Generic.List<System.Collections.Generic.List<sbyte>>;\nusing Lst = System.Collections.Generic.List<sbyte>;\nusing DT = System.DateTime;\n\nclass Program {\n\n    const sbyte MxD = 19;\n\n    public struct term { public UI coeff; public sbyte a, b;\n        public term(UI c, int a_, int b_) { coeff = c; a = (sbyte)a_; b = (sbyte)b_; } }\n\n    static int[] digs;   static List<UI> res;   static sbyte count = 0;\n    static DT st; static List<List<term>> tLst; static List<LST> lists;\n    static Dictionary<int, LST> fml, dmd; static Lst dl, zl, el, ol, il;\n    static bool odd; static int nd, nd2; static LST ixs;\n    static int[] cnd, di; static LST dis; static UI Dif;\n\n    \n    static UI ToDif() { UI r = 0; for (int i = 0; i < digs.Length; i++)\n            r = r * 10 + (uint)digs[i]; return r; }\n    \n    \n    static UI ToSum() { UI r = 0; for (int i = digs.Length - 1; i >= 0; i--)\n            r = r * 10 + (uint)digs[i]; return Dif + (r << 1); }\n\n    \n    static bool IsSquare(UI nmbr) { if ((0x202021202030213 & (1 << (int)(nmbr & 63))) != 0)\n        { UI r = (UI)Math.Sqrt((double)nmbr); return r * r == nmbr; } return false; }\n\n    \n    static Lst Seq(sbyte from, int to, sbyte stp = 1) { Lst res = new Lst();\n        for (sbyte item = from; item <= to; item += stp) res.Add(item); return res; }\n\n    \n    static void Fnpr(int lev) { if (lev == dis.Count) { digs[ixs[0][0]] = fml[cnd[0]][di[0]][0];\n            digs[ixs[0][1]] = fml[cnd[0]][di[0]][1]; int le = di.Length, i = 1;\n            if (odd) digs[nd >> 1] = di[--le]; foreach (sbyte d in di.Skip(1).Take(le - 1)) {\n                digs[ixs[i][0]] = dmd[cnd[i]][d][0]; digs[ixs[i][1]] = dmd[cnd[i++]][d][1]; }\n            if (!IsSquare(ToSum())) return; res.Add(ToDif()); WriteLine(\"{0,16:n0}{1,4}   ({2:n0})\",\n                (DT.Now - st).TotalMilliseconds, ++count, res.Last()); }\n        else foreach (var n in dis[lev]) { di[lev] = n; Fnpr(lev + 1); } }\n\n    \n    static void Fnmr (LST list, int lev) { if (lev == list.Count) { Dif = 0; sbyte i = 0;\n            foreach (var t in tLst[nd2]) { if (cnd[i] < 0) Dif -= t.coeff * (UI)(-cnd[i++]);\n                else Dif += t.coeff * (UI)cnd[i++]; } if (Dif <= 0 || !IsSquare(Dif)) return;\n            dis = new LST { Seq(0, fml[cnd[0]].Count - 1) };\n            foreach (int ii in cnd.Skip(1)) dis.Add(Seq(0, dmd[ii].Count - 1));\n            if (odd) dis.Add(il); di = new int[dis.Count]; Fnpr(0);\n        } else foreach(sbyte n in list[lev]) { cnd[lev] = n; Fnmr(list, lev + 1); } }\n\n    static void init() { UI pow = 1;\n        \n        tLst = new List<List<term>>(); foreach (int r in Seq(2, MxD)) {\n            List<term> terms = new List<term>(); pow *= 10; UI p1 = pow, p2 = 1;\n            for (int i1 = 0, i2 = r - 1; i1 < i2; i1++, i2--) {\n                terms.Add(new term(p1 - p2, i1, i2)); p1 /= 10; p2 *= 10; }\n            tLst.Add(terms); }\n        \n        fml = new Dictionary<int, LST> {\n            [0] = new LST { new Lst { 2, 2 }, new Lst { 8, 8 } },\n            [1] = new LST { new Lst { 6, 5 }, new Lst { 8, 7 } },\n            [4] = new LST { new Lst { 4, 0 } },\n            [6] = new LST { new Lst { 6, 0 }, new Lst { 8, 2 } } };\n        \n        dmd = new Dictionary<int, LST>();\n        for (sbyte i = 0; i < 10; i++) for (sbyte j = 0, d = i; j < 10; j++, d--) {\n                if (dmd.ContainsKey(d)) dmd[d].Add(new Lst { i, j });\n                else dmd[d] = new LST { new Lst { i, j } }; }\n        dl = Seq(-9, 9);    \n        zl = Seq( 0, 0);    \n        el = Seq(-8, 8, 2); \n        ol = Seq(-9, 9, 2); \n        il = Seq( 0, 9); lists = new List<LST>();\n        foreach (sbyte f in fml.Keys) lists.Add(new LST { new Lst { f } }); }\n\n    static void Main(string[] args) { init(); res = new List<UI>(); st = DT.Now; count = 0;\n        WriteLine(\"{0,5}{1,12}{2,4}{3,14}\", \"digs\", \"elapsed(ms)\", \"R/N\", \"Unordered Rare Numbers\");\n        for (nd = 2, nd2 = 0, odd = false; nd <= MxD; nd++, nd2++, odd = !odd) { digs = new int[nd];\n            if (nd == 4) { lists[0].Add(zl); lists[1].Add(ol); lists[2].Add(el); lists[3].Add(ol); }\n            else if (tLst[nd2].Count > lists[0].Count) foreach (LST list in lists) list.Add(dl);\n            ixs = new LST(); \n            foreach (term t in tLst[nd2]) ixs.Add(new Lst { t.a, t.b });\n            foreach (LST list in lists) { cnd = new int[list.Count]; Fnmr(list, 0); }\n            WriteLine(\"  {0,2}  {1,10:n0}\", nd, (DT.Now - st).TotalMilliseconds); }\n        res.Sort();\n        WriteLine(\"\\nThe {0} rare numbers with up to {1} digits are:\", res.Count, MxD);\n        count = 0; foreach (var rare in res) WriteLine(\"{0,2}:{1,27:n0}\", ++count, rare);\n        if (System.Diagnostics.Debugger.IsAttached) ReadKey(); }\n}\n"}
{"id": 386920, "name": "Suffix tree", "source": "Translate Ruby to C#: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SuffixTree {\n    class Node {\n        public string sub;                     \n        public List<int> ch = new List<int>(); \n\n        public Node() {\n            sub = \"\";\n        }\n\n        public Node(string sub, params int[] children) {\n            this.sub = sub;\n            ch.AddRange(children);\n        }\n    }\n\n    class SuffixTree {\n        readonly List<Node> nodes = new List<Node>();\n\n        public SuffixTree(string str) {\n            nodes.Add(new Node());\n            for (int i = 0; i < str.Length; i++) {\n                AddSuffix(str.Substring(i));\n            }\n        }\n\n        public void Visualize() {\n            if (nodes.Count == 0) {\n                Console.WriteLine(\"<empty>\");\n                return;\n            }\n\n            void f(int n, string pre) {\n                var children = nodes[n].ch;\n                if (children.Count == 0) {\n                    Console.WriteLine(\"- {0}\", nodes[n].sub);\n                    return;\n                }\n                Console.WriteLine(\"+ {0}\", nodes[n].sub);\n\n                var it = children.GetEnumerator();\n                if (it.MoveNext()) {\n                    do {\n                        var cit = it;\n                        if (!cit.MoveNext()) break;\n\n                        Console.Write(\"{0}+-\", pre);\n                        f(it.Current, pre + \"| \");\n                    } while (it.MoveNext());\n                }\n\n                Console.Write(\"{0}+-\", pre);\n                f(children[children.Count-1], pre+\"  \");\n            }\n\n            f(0, \"\");\n        }\n\n        private void AddSuffix(string suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.Length) {\n                char b = suf[i];\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    var children = nodes[n].ch;\n                    if (x2 == children.Count) {\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(suf.Substring(i)));\n                        nodes[n].ch.Add(n2);\n                        return;\n                    }\n                    n2 = children[x2];\n                    if (nodes[n2].sub[0] == b) {\n                        break;\n                    }\n                    x2++;\n                }\n                \n                var sub2 = nodes[n2].sub;\n                int j = 0;\n                while (j < sub2.Length) {\n                    if (suf[i + j] != sub2[j]) {\n                        \n                        var n3 = n2;\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(sub2.Substring(0, j), n3));\n                        nodes[n3].sub = sub2.Substring(j); \n                        nodes[n].ch[x2] = n2;\n                        break; \n                    }\n                    j++;\n                }\n                i += j; \n                n = n2; \n            }\n        }\n    }\n\n    class Program {\n        static void Main() {\n            new SuffixTree(\"banana$\").Visualize();\n        }\n    }\n}\n"}
{"id": 386921, "name": "Suffix tree", "source": "Translate Ruby to C#: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SuffixTree {\n    class Node {\n        public string sub;                     \n        public List<int> ch = new List<int>(); \n\n        public Node() {\n            sub = \"\";\n        }\n\n        public Node(string sub, params int[] children) {\n            this.sub = sub;\n            ch.AddRange(children);\n        }\n    }\n\n    class SuffixTree {\n        readonly List<Node> nodes = new List<Node>();\n\n        public SuffixTree(string str) {\n            nodes.Add(new Node());\n            for (int i = 0; i < str.Length; i++) {\n                AddSuffix(str.Substring(i));\n            }\n        }\n\n        public void Visualize() {\n            if (nodes.Count == 0) {\n                Console.WriteLine(\"<empty>\");\n                return;\n            }\n\n            void f(int n, string pre) {\n                var children = nodes[n].ch;\n                if (children.Count == 0) {\n                    Console.WriteLine(\"- {0}\", nodes[n].sub);\n                    return;\n                }\n                Console.WriteLine(\"+ {0}\", nodes[n].sub);\n\n                var it = children.GetEnumerator();\n                if (it.MoveNext()) {\n                    do {\n                        var cit = it;\n                        if (!cit.MoveNext()) break;\n\n                        Console.Write(\"{0}+-\", pre);\n                        f(it.Current, pre + \"| \");\n                    } while (it.MoveNext());\n                }\n\n                Console.Write(\"{0}+-\", pre);\n                f(children[children.Count-1], pre+\"  \");\n            }\n\n            f(0, \"\");\n        }\n\n        private void AddSuffix(string suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.Length) {\n                char b = suf[i];\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    var children = nodes[n].ch;\n                    if (x2 == children.Count) {\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(suf.Substring(i)));\n                        nodes[n].ch.Add(n2);\n                        return;\n                    }\n                    n2 = children[x2];\n                    if (nodes[n2].sub[0] == b) {\n                        break;\n                    }\n                    x2++;\n                }\n                \n                var sub2 = nodes[n2].sub;\n                int j = 0;\n                while (j < sub2.Length) {\n                    if (suf[i + j] != sub2[j]) {\n                        \n                        var n3 = n2;\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(sub2.Substring(0, j), n3));\n                        nodes[n3].sub = sub2.Substring(j); \n                        nodes[n].ch[x2] = n2;\n                        break; \n                    }\n                    j++;\n                }\n                i += j; \n                n = n2; \n            }\n        }\n    }\n\n    class Program {\n        static void Main() {\n            new SuffixTree(\"banana$\").Visualize();\n        }\n    }\n}\n"}
{"id": 386922, "name": "Reflection_List properties", "source": "Translate Ruby to C#: class Foo\n  @@xyz = nil\n  def initialize(name, age)\n    @name, @age = name, age\n  end\n  def add_sex(sex)\n    @sex = sex\n  end\nend\n\np foo = Foo.new(\"Angel\", 18)            \np foo.instance_variables                \np foo.instance_variable_defined?(:@age) \np foo.instance_variable_get(:@age)      \np foo.instance_variable_set(:@age, 19)  \np foo                                   \nfoo.add_sex(:woman)\np foo.instance_variables                \np foo                                   \nfoo.instance_variable_set(:@bar, nil)\np foo.instance_variables                \n\np Foo.class_variables                   \np Foo.class_variable_defined?(:@@xyz)   \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@xyz, :xyz)  \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@abc, 123)   \np Foo.class_variables                   \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\npublic static class Reflection\n{\n    public static void Main() {\n        var t = new TestClass();\n        var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;\n        foreach (var prop in GetPropertyValues(t, flags)) {\n            Console.WriteLine(prop);\n        }\n        foreach (var field in GetFieldValues(t, flags)) {\n            Console.WriteLine(field);\n        }\n    }\n\n    public static IEnumerable<(string name, object value)> GetPropertyValues<T>(T obj, BindingFlags flags) =>\n        from p in typeof(T).GetProperties(flags)\n        where p.GetIndexParameters().Length == 0 \n        select (p.Name, p.GetValue(obj, null));\n    \n    public static IEnumerable<(string name, object value)> GetFieldValues<T>(T obj, BindingFlags flags) =>\n        typeof(T).GetFields(flags).Select(f => (f.Name, f.GetValue(obj)));\n    \n    class TestClass\n    {\n        private int privateField = 7;\n        public int PublicNumber { get; } = 4;\n        private int PrivateNumber { get; } = 2;\n    }\n\n}\n"}
{"id": 386923, "name": "Eertree", "source": "Translate Ruby to C#: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Eertree {\n    class Node {\n        public Node(int length) {\n            this.Length = length;\n            \n            this.Edges = new Dictionary<char, int>();\n        }\n\n        public Node(int length, Dictionary<char, int> edges, int suffix) {\n            this.Length = length;\n            this.Edges = edges;\n            this.Suffix = suffix;\n        }\n\n        public int Length { get; set; }\n        public Dictionary<char, int> Edges { get; set; }\n        public int Suffix { get; set; }\n    }\n\n    class Program {\n        const int EVEN_ROOT = 0;\n        const int ODD_ROOT = 1;\n\n        static List<Node> Eertree(string s) {\n            List<Node> tree = new List<Node> {\n                \n                new Node(0, new Dictionary<char, int>(), ODD_ROOT),\n                \n                new Node(-1, new Dictionary<char, int>(), ODD_ROOT)\n            };\n            int suffix = ODD_ROOT;\n            int n, k;\n            for (int i = 0; i < s.Length; i++) {\n                char c = s[i];\n                for (n = suffix; ; n = tree[n].Suffix) {\n                    k = tree[n].Length;\n                    int b = i - k - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                if (tree[n].Edges.ContainsKey(c)) {\n                    suffix = tree[n].Edges[c];\n                    continue;\n                }\n                suffix = tree.Count;\n                tree.Add(new Node(k + 2));\n                tree[n].Edges[c] = suffix;\n                if (tree[suffix].Length == 1) {\n                    tree[suffix].Suffix = 0;\n                    continue;\n                }\n                while (true) {\n                    n = tree[n].Suffix;\n                    int b = i - tree[n].Length - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                tree[suffix].Suffix = tree[n].Edges[c];\n            }\n            return tree;\n        }\n\n        static List<string> SubPalindromes(List<Node> tree) {\n            List<string> s = new List<string>();\n            SubPalindromes_children(0, \"\", tree, s);\n            foreach (var c in tree[1].Edges.Keys) {\n                int m = tree[1].Edges[c];\n                string ct = c.ToString();\n                s.Add(ct);\n                SubPalindromes_children(m, ct, tree, s);\n            }\n            return s;\n        }\n\n        static void SubPalindromes_children(int n, string p, List<Node> tree, List<string> s) {\n            foreach (var c in tree[n].Edges.Keys) {\n                int m = tree[n].Edges[c];\n                string p1 = c + p + c;\n                s.Add(p1);\n                SubPalindromes_children(m, p1, tree, s);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Node> tree = Eertree(\"eertree\");\n            List<string> result = SubPalindromes(tree);\n            string listStr = string.Join(\", \", result);\n            Console.WriteLine(\"[{0}]\", listStr);\n        }\n    }\n}\n"}
{"id": 386924, "name": "Eertree", "source": "Translate Ruby to C#: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Eertree {\n    class Node {\n        public Node(int length) {\n            this.Length = length;\n            \n            this.Edges = new Dictionary<char, int>();\n        }\n\n        public Node(int length, Dictionary<char, int> edges, int suffix) {\n            this.Length = length;\n            this.Edges = edges;\n            this.Suffix = suffix;\n        }\n\n        public int Length { get; set; }\n        public Dictionary<char, int> Edges { get; set; }\n        public int Suffix { get; set; }\n    }\n\n    class Program {\n        const int EVEN_ROOT = 0;\n        const int ODD_ROOT = 1;\n\n        static List<Node> Eertree(string s) {\n            List<Node> tree = new List<Node> {\n                \n                new Node(0, new Dictionary<char, int>(), ODD_ROOT),\n                \n                new Node(-1, new Dictionary<char, int>(), ODD_ROOT)\n            };\n            int suffix = ODD_ROOT;\n            int n, k;\n            for (int i = 0; i < s.Length; i++) {\n                char c = s[i];\n                for (n = suffix; ; n = tree[n].Suffix) {\n                    k = tree[n].Length;\n                    int b = i - k - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                if (tree[n].Edges.ContainsKey(c)) {\n                    suffix = tree[n].Edges[c];\n                    continue;\n                }\n                suffix = tree.Count;\n                tree.Add(new Node(k + 2));\n                tree[n].Edges[c] = suffix;\n                if (tree[suffix].Length == 1) {\n                    tree[suffix].Suffix = 0;\n                    continue;\n                }\n                while (true) {\n                    n = tree[n].Suffix;\n                    int b = i - tree[n].Length - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                tree[suffix].Suffix = tree[n].Edges[c];\n            }\n            return tree;\n        }\n\n        static List<string> SubPalindromes(List<Node> tree) {\n            List<string> s = new List<string>();\n            SubPalindromes_children(0, \"\", tree, s);\n            foreach (var c in tree[1].Edges.Keys) {\n                int m = tree[1].Edges[c];\n                string ct = c.ToString();\n                s.Add(ct);\n                SubPalindromes_children(m, ct, tree, s);\n            }\n            return s;\n        }\n\n        static void SubPalindromes_children(int n, string p, List<Node> tree, List<string> s) {\n            foreach (var c in tree[n].Edges.Keys) {\n                int m = tree[n].Edges[c];\n                string p1 = c + p + c;\n                s.Add(p1);\n                SubPalindromes_children(m, p1, tree, s);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Node> tree = Eertree(\"eertree\");\n            List<string> result = SubPalindromes(tree);\n            string listStr = string.Join(\", \", result);\n            Console.WriteLine(\"[{0}]\", listStr);\n        }\n    }\n}\n"}
{"id": 386925, "name": "Base58Check encoding", "source": "Translate Ruby to C#: ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nnums =  [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n\nputs nums.map{|n| n.digits(58).reverse.map{|i| ALPHABET[i]}.join}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 386926, "name": "Base58Check encoding", "source": "Translate Ruby to C#: ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nnums =  [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n\nputs nums.map{|n| n.digits(58).reverse.map{|i| ALPHABET[i]}.join}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 386927, "name": "Latin Squares in reduced form", "source": "Translate Ruby to C#: def printSquare(a)\n    for row in a\n        print row, \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndef dList(n, start)\n    start = start - 1 \n    a = Array.new(n) {|i| i}\n    a[0], a[start] = a[start], a[0]\n    a[1..] = a[1..].sort\n    first = a[1]\n\n    r = []\n    recurse = lambda {|last|\n        if last == first then\n            \n            \n            a[1..].each_with_index {|v, j|\n                if j + 1 == v then\n                    return \n                end\n            }\n            \n            b = a.map { |i| i + 1 }\n            r << b\n            return\n        end\n\n        i = last\n        while i >= 1 do\n            a[i], a[last] = a[last], a[i]\n            recurse.call(last - 1)\n            a[i], a[last] = a[last], a[i]\n            i = i - 1\n        end\n    }\n\n    recurse.call(n - 1)\n    return r\nend\n\ndef reducedLatinSquares(n, echo)\n    if n <= 0 then\n        if echo then\n            print \"[]\\n\\n\"\n        end\n        return 0\n    end\n    if n == 1 then\n        if echo then\n            print \"[1]\\n\\n\"\n        end\n        return 1\n    end\n\n    rlatin = Array.new(n) { Array.new(n, Float::NAN)}\n\n    \n    for j in 0 .. n - 1\n        rlatin[0][j] = j + 1\n    end\n\n    count = 0\n    recurse = lambda {|i|\n        rows = dList(n, i)\n\n        for r in 0 .. rows.length - 1\n            rlatin[i - 1] = rows[r].dup\n            catch (:outer) do\n                for k in 0 .. i - 2\n                    for j in 1 .. n - 1\n                        if rlatin[k][j] == rlatin[i - 1][j] then\n                            if r < rows.length - 1 then\n                                throw :outer\n                            end\n                            if i > 2 then\n                                return\n                            end\n                        end\n                    end\n                end\n                if i < n then\n                    recurse.call(i + 1)\n                else\n                    count = count + 1\n                    if echo then\n                        printSquare(rlatin)\n                    end\n                end\n            end\n        end\n    }\n\n    \n    recurse.call(2)\n    return count\nend\n\ndef factorial(n)\n    if n == 0 then\n        return 1\n    end\n    prod = 1\n    for i in 2 .. n\n        prod = prod * i\n    end\n    return prod\nend\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4, true)\n\nprint \"The size of the set of reduced latin squares for the following orders\\n\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in 1 .. 6\n    size = reducedLatinSquares(n, false)\n    f = factorial(n - 1)\n    f = f * f * n * size\n    print \"Order %d Size\u00a0%-4d x %d! x %d! => Total %d\\n\" % [n, size, n, n - 1, f]\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LatinSquares {\n    using matrix = List<List<int>>;\n\n    class Program {\n        static void Swap<T>(ref T a, ref T b) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        static matrix DList(int n, int start) {\n            start--; \n            var a = Enumerable.Range(0, n).ToArray();\n            a[start] = a[0];\n            a[0] = start;\n            Array.Sort(a, 1, a.Length - 1);\n            var first = a[1];\n            \n            matrix r = new matrix();\n            void recurse(int last) {\n                if (last == first) {\n                    \n                    \n                    for (int j = 1; j < a.Length; j++) {\n                        var v = a[j];\n                        if (j == v) {\n                            return; \n                        }\n                    }\n                    \n                    var b = a.Select(v => v + 1).ToArray();\n                    r.Add(b.ToList());\n                    return;\n                }\n                for (int i = last; i >= 1; i--) {\n                    Swap(ref a[i], ref a[last]);\n                    recurse(last - 1);\n                    Swap(ref a[i], ref a[last]);\n                }\n            }\n            recurse(n - 1);\n            return r;\n        }\n\n        static ulong ReducedLatinSquares(int n, bool echo) {\n            if (n <= 0) {\n                if (echo) {\n                    Console.WriteLine(\"[]\\n\");\n                }\n                return 0;\n            } else if (n == 1) {\n                if (echo) {\n                    Console.WriteLine(\"[1]\\n\");\n                }\n                return 1;\n            }\n\n            matrix rlatin = new matrix();\n            for (int i = 0; i < n; i++) {\n                rlatin.Add(new List<int>());\n                for (int j = 0; j < n; j++) {\n                    rlatin[i].Add(0);\n                }\n            }\n            \n            for (int j = 0; j < n; j++) {\n                rlatin[0][j] = j + 1;\n            }\n\n            ulong count = 0;\n            void recurse(int i) {\n                var rows = DList(n, i);\n\n                for (int r = 0; r < rows.Count; r++) {\n                    rlatin[i - 1] = rows[r];\n                    for (int k = 0; k < i - 1; k++) {\n                        for (int j = 1; j < n; j++) {\n                            if (rlatin[k][j] == rlatin[i - 1][j]) {\n                                if (r < rows.Count - 1) {\n                                    goto outer;\n                                }\n                                if (i > 2) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (i < n) {\n                        recurse(i + 1);\n                    } else {\n                        count++;\n                        if (echo) {\n                            PrintSquare(rlatin, n);\n                        }\n                    }\n                outer: { }\n                }\n            }\n\n            \n            recurse(2);\n            return count;\n        }\n\n        static void PrintSquare(matrix latin, int n) {\n            foreach (var row in latin) {\n                var it = row.GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", {0}\", it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n            Console.WriteLine();\n        }\n\n        static ulong Factorial(ulong n) {\n            if (n <= 0) {\n                return 1;\n            }\n            ulong prod = 1;\n            for (ulong i = 2; i < n + 1; i++) {\n                prod *= i;\n            }\n            return prod;\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The four reduced latin squares of order 4 are:\\n\");\n            ReducedLatinSquares(4, true);\n\n            Console.WriteLine(\"The size of the set of reduced latin squares for the following orders\");\n            Console.WriteLine(\"and hence the total number of latin squares of these orders are:\\n\");\n            for (int n = 1; n < 7; n++) {\n                ulong nu = (ulong)n;\n\n                var size = ReducedLatinSquares(n, false);\n                var f = Factorial(nu - 1);\n                f *= f * nu * size;\n                Console.WriteLine(\"Order {0}: Size {1} x {2}! x {3}! => Total {4}\", n, size, n, n - 1, f);\n            }\n        }\n    }\n}\n"}
{"id": 386928, "name": "Kosaraju", "source": "Translate Ruby to C#: func korasaju(Array g) {\n    \n    var vis = g.len.of(false)\n    var L   = []\n    var x   = g.end\n    var t   = g.len.of { [] }\n\n    \n    func visit(u) {\n        if (!vis[u]) {\n            vis[u] = true\n            g[u].each {|v|\n                visit(v)\n                t[v] << u\n            }\n            L[x--] = u\n        }\n    }\n\n    \n    g.range.each {|u|\n        visit(u)\n    }\n\n    var c = []\n\n    \n    func assign(u, root) {\n        if (vis[u]) {\n            vis[u] = false\n            c[u] = root\n            t[u].each {|v|\n                assign(v, root)\n            }\n        }\n    }\n\n    \n    L.each {|u|\n        assign(u, u)\n    }\n\n    return c\n}\n\nvar g = [[1], [2], [0], [1, 2, 4], [3, 5], [2, 6], [5], [4, 6, 7]]\nsay korasaju(g)\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n\tpublic enum Colors\n\t{\n\t\tBlack, White, Gray\n\t}\n\n\tpublic Colors color { get; set; }\n\tpublic int N { get; }\n\t\n\tpublic Node(int n)\n\t{\n\t\tN = n;\n\t\tcolor = Colors.White;\n\t}\n}\n\nclass Graph\n{\n\tpublic HashSet<Node> V { get; }\n\tpublic Dictionary<Node, HashSet<Node>> Adj { get; }\n\n\t\n\t\n\t\n\tpublic void Kosaraju()\n\t{\n\t\tvar L = new HashSet<Node>();\n\n\t\tAction<Node> Visit = null;\n\t\tVisit = (u) =>\n\t\t{\n\t\t\tif (u.color == Node.Colors.White)\n\t\t\t{\n\t\t\t\tu.color = Node.Colors.Gray;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tVisit(v);\n\n\t\t\t\tL.Add(u);\n\t\t\t}\n\t\t};\n\n\t\tAction<Node, Node> Assign = null;\n\t\tAssign = (u, root) =>\n\t\t{\n\t\t\tif (u.color != Node.Colors.Black)\n\t\t\t{\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.Write(\"SCC: \");\n\n\t\t\t\tConsole.Write(u.N + \" \");\n\t\t\t\tu.color = Node.Colors.Black;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tAssign(v, root);\n\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t};\n\n\t\tforeach (var u in V)\n\t\t\tVisit(u);\n\n\t\tforeach (var u in L)\n\t\t\tAssign(u, u);\n\t}\n}\n"}
{"id": 386929, "name": "Markov chain text generator", "source": "Translate Ruby to C#: class Markov(N)\n  @dictionary = Hash(StaticArray(String, N), Array(String)).new { [] of String }\n\n  def parse(filename : String)\n    File.open(filename) do |file|\n      parse(file)\n    end\n  end\n\n  private def prefix_from(array)\n    StaticArray(String, N).new { |i| array[-(N - i)] }\n  end\n\n  def parse(input : IO)\n    sequence = [] of String\n    loop do\n      word = input.gets(' ', true)\n      break unless word\n      if sequence.size == N\n        prefix = prefix_from(sequence)\n        @dictionary[prefix] = (@dictionary[prefix] << word)\n      end\n      sequence << word\n      sequence.shift if sequence.size > N\n    end\n  end\n\n  def generate(count)\n    prefix = @dictionary.keys.sample\n    result = Array(String).new(prefix.size) { |i| prefix[i] }\n    (count - N).times do\n      prefix = prefix_from(result)\n      values = @dictionary[prefix]\n      break if values.size == 0\n      result << values.sample\n    end\n    result.join(' ')\n  end\nend\n\nchain = Markov(3).new\nchain.parse(\"alice_oz.txt\")\nputs chain.generate(200)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace MarkovChainTextGenerator {\n    class Program {\n        static string Join(string a, string b) {\n            return a + \" \" + b;\n        }\n\n        static string Markov(string filePath, int keySize, int outputSize) {\n            if (keySize < 1) throw new ArgumentException(\"Key size can't be less than 1\");\n\n            string body;\n            using (StreamReader sr = new StreamReader(filePath)) {\n                body = sr.ReadToEnd();\n            }\n            var words = body.Split();\n            if (outputSize < keySize || words.Length < outputSize) {\n                throw new ArgumentException(\"Output size is out of range\");\n            }\n\n            Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\n            for (int i = 0; i < words.Length - keySize; i++) {\n                var key = words.Skip(i).Take(keySize).Aggregate(Join);\n                string value;\n                if (i + keySize < words.Length) {\n                    value = words[i + keySize];\n                } else {\n                    value = \"\";\n                }\n\n                if (dict.ContainsKey(key)) {\n                    dict[key].Add(value);\n                } else {\n                    dict.Add(key, new List<string>() { value });\n                }\n            }\n\n            Random rand = new Random();\n            List<string> output = new List<string>();\n            int n = 0;\n            int rn = rand.Next(dict.Count);\n            string prefix = dict.Keys.Skip(rn).Take(1).Single();\n            output.AddRange(prefix.Split());\n\n            while (true) {\n                var suffix = dict[prefix];\n                if (suffix.Count == 1) {\n                    if (suffix[0] == \"\") {\n                        return output.Aggregate(Join);\n                    }\n                    output.Add(suffix[0]);\n                } else {\n                    rn = rand.Next(suffix.Count);\n                    output.Add(suffix[rn]);\n                }\n                if (output.Count >= outputSize) {\n                    return output.Take(outputSize).Aggregate(Join);\n                }\n                n++;\n                prefix = output.Skip(n).Take(keySize).Aggregate(Join);\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(Markov(\"alice_oz.txt\", 3, 200));\n        }\n    }\n}\n"}
{"id": 386930, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Ruby to C#: def cumulative_freq(freq)\n  cf = {}\n  total = 0\n  freq.keys.sort.each do |b|\n    cf[b] = total\n    total += freq[b]\n  end\n  return cf\nend\n\ndef arithmethic_coding(bytes, radix)\n\n  \n  freq = Hash.new(0)\n  bytes.each { |b| freq[b] += 1 }\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  base = bytes.size\n\n  \n  lower = 0\n\n  \n  pf = 1\n\n  \n  \n  bytes.each do |b|\n    lower = lower*base + cf[b]*pf\n    pf *= freq[b]\n  end\n\n  \n  upper = lower+pf\n\n  pow = 0\n  loop do\n    pf /= radix\n    break if pf==0\n    pow += 1\n  end\n\n  enc = ((upper-1) / radix**pow)\n  [enc, pow, freq]\nend\n\ndef arithmethic_decoding(enc, radix, pow, freq)\n\n  \n  enc *= radix**pow;\n\n  \n  base = freq.values.reduce(:+)\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  dict = {}\n  cf.each_pair do |k,v|\n    dict[v] = k\n  end\n\n  \n  lchar = nil\n  (0...base).each do |i|\n    if dict.has_key?(i)\n      lchar = dict[i]\n    elsif lchar != nil\n      dict[i] = lchar\n    end\n  end\n\n  \n  decoded = []\n  (0...base).reverse_each do |i|\n    pow = base**i\n    div = enc/pow\n\n    c  = dict[div]\n    fv = freq[c]\n    cv = cf[c]\n\n    rem = ((enc - pow*cv) / fv)\n\n    enc = rem\n    decoded << c\n  end\n\n  \n  return decoded\nend\n\nradix = 10      \n\n%w(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT).each do |str|\n\n  enc, pow, freq = arithmethic_coding(str.bytes, radix)\n  dec = arithmethic_decoding(enc, radix, pow, freq).map{|b| b.chr }.join\n\n  printf(\"%-25s=> %19s * %d^%s\\n\", str, enc, radix, pow)\n\n  if str != dec\n    raise \"\\tHowever that is incorrect!\"\n  end\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\n\nnamespace AruthmeticCoding {\n    using Freq = Dictionary<char, long>;\n    using Triple = Tuple<BigInteger, int, Dictionary<char, long>>;\n\n    class Program {\n        static Freq CumulativeFreq(Freq freq) {\n            long total = 0;\n            Freq cf = new Freq();\n            for (int i = 0; i < 256; i++) {\n                char c = (char)i;\n                if (freq.ContainsKey(c)) {\n                    long v = freq[c];\n                    cf[c] = total;\n                    total += v;\n                }\n            }\n            return cf;\n        }\n\n        static Triple ArithmeticCoding(string str, long radix) {\n            \n            Freq freq = new Freq();\n            foreach (char c in str) {\n                if (freq.ContainsKey(c)) {\n                    freq[c] += 1;\n                } else {\n                    freq[c] = 1;\n                }\n            }\n\n            \n            Freq cf = CumulativeFreq(freq);\n\n            \n            BigInteger @base = str.Length;\n\n            \n            BigInteger lower = 0;\n\n            \n            BigInteger pf = 1;\n\n            \n            \n            foreach (char c in str) {\n                BigInteger x = cf[c];\n                lower = lower * @base + x * pf;\n                pf = pf * freq[c];\n            }\n\n            \n            BigInteger upper = lower + pf;\n\n            int powr = 0;\n            BigInteger bigRadix = radix;\n\n            while (true) {\n                pf = pf / bigRadix;\n                if (pf == 0) break;\n                powr++;\n            }\n\n            BigInteger diff = (upper - 1) / (BigInteger.Pow(bigRadix, powr));\n            return new Triple(diff, powr, freq);\n        }\n\n        static string ArithmeticDecoding(BigInteger num, long radix, int pwr, Freq freq) {\n            BigInteger powr = radix;\n            BigInteger enc = num * BigInteger.Pow(powr, pwr);\n            long @base = freq.Values.Sum();\n\n            \n            Freq cf = CumulativeFreq(freq);\n\n            \n            Dictionary<long, char> dict = new Dictionary<long, char>();\n            foreach (char key in cf.Keys) {\n                long value = cf[key];\n                dict[value] = key;\n            }\n\n            \n            long lchar = -1;\n            for (long i = 0; i < @base; i++) {\n                if (dict.ContainsKey(i)) {\n                    lchar = dict[i];\n                } else if (lchar != -1) {\n                    dict[i] = (char)lchar;\n                }\n            }\n\n            \n            StringBuilder decoded = new StringBuilder((int)@base);\n            BigInteger bigBase = @base;\n            for (long i = @base - 1; i >= 0; --i) {\n                BigInteger pow = BigInteger.Pow(bigBase, (int)i);\n                BigInteger div = enc / pow;\n                char c = dict[(long)div];\n                BigInteger fv = freq[c];\n                BigInteger cv = cf[c];\n                BigInteger diff = enc - pow * cv;\n                enc = diff / fv;\n                decoded.Append(c);\n            }\n\n            \n            return decoded.ToString();\n        }\n\n        static void Main(string[] args) {\n            long radix = 10;\n            string[] strings = { \"DABDDB\", \"DABDDBBDDBA\", \"ABRACADABRA\", \"TOBEORNOTTOBEORTOBEORNOT\" };\n            foreach (string str in strings) {\n                Triple encoded = ArithmeticCoding(str, radix);\n                string dec = ArithmeticDecoding(encoded.Item1, radix, encoded.Item2, encoded.Item3);\n                Console.WriteLine(\"{0,-25}=> {1,19} * {2}^{3}\", str, encoded.Item1, radix, encoded.Item2);\n                if (str != dec) {\n                    throw new Exception(\"\\tHowever that is incorrect!\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 386931, "name": "Free polyominoes enumeration", "source": "Translate Ruby to C#: require 'set'\n\ndef translate2origin(poly)\n  \n  minx = poly.map(&:first).min\n  miny = poly.map(&:last).min\n  poly.map{|x,y| [x - minx, y - miny]}.sort\nend\n\ndef rotate90(x,y) [y, -x] end\ndef reflect(x,y)  [-x, y] end\n\n\ndef rotations_and_reflections(poly)\n  [poly,\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| reflect(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n          poly.map{|x,y| rotate90(x,y)} ]\nend\n\ndef canonical(poly)\n  rotations_and_reflections(poly).map{|pl| translate2origin(pl)}\nend\n\n\ndef contiguous(x,y)\n  [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\nend\n\n\ndef new_points(poly)\n  points = []\n  poly.each{|x,y| contiguous(x,y).each{|point| points << point}}\n  (points - poly).uniq\nend\n\ndef new_polys(polys)\n  pattern = Set.new\n  polys.each_with_object([]) do |poly, polyomino|\n    new_points(poly).each do |point|\n      next if pattern.include?(pl = translate2origin(poly + [point]))\n      polyomino << canonical(pl).each{|p| pattern << p}.min\n    end\n  end\nend\n\n\ndef rank(n)\n  case n\n  when 0 then [[]]\n  when 1 then [[[0,0]]]\n  else        new_polys(rank(n-1))\n  end\nend\n\n\ndef text_representation(poly)\n  table = Hash.new(' ')\n  poly.each{|x,y| table[[x,y]] = '\n  maxx = poly.map(&:first).max\n  maxy = poly.map(&:last).max\n  (0..maxx).map{|x| (0..maxy).map{|y| table[[x,y]]}.join}\nend\n\np (0..10).map{|n| rank(n).size}\nn = ARGV[0] ? ARGV[0].to_i : 5\nputs \"\\nAll free polyominoes of rank %d:\" % n\nrank(n).sort.each{|poly| puts text_representation(poly),\"\"}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace cppfpe\n{\n    class Program\n    {\n        static int n, ns;               \n        static long[] AnyR;             \n        static long[] nFlip;            \n        static long[] Frees;            \n        static int[] fChk, fCkR;        \n        static int fSiz, fWid;          \n        static int[] dirs;              \n        static int[] rotO, rotX, rotY;  \n        static List<string> polys;      \n        static int target;              \n        static int clipAt;              \n\n        static int Main(string[] args)\n        {\n            polys = new List<string>();\n            n = 11; if (!(args.Length == 0)) int.TryParse(args[0], out n);\n            if (n < 1 || n > 24) return 1;\n            target = 5;\n            Console.WriteLine(\"Counting polyominoes to rank {0}...\", n);\n            clipAt = 120;\n            DateTime start = DateTime.Now;\n            CountEm();\n            TimeSpan ti = DateTime.Now - start;\n            if (polys.Count > 0)\n            {\n                Console.WriteLine(\"Displaying rank {0}:\", target);\n                Console.WriteLine(Assemble(polys));\n            }\n            Console.WriteLine(\"Displaying results:\");\n            Console.WriteLine(\" n      All Rotations     Non-Flipped      Free Polys\");\n            for (int i = 1; i <= n; i++)\n                Console.WriteLine(\"{0,2}\u00a0:{1,17}{2,16}{3,16}\", i, AnyR[i], nFlip[i], Frees[i]);\n            Console.WriteLine(string.Format(\"Elasped: {0,2}d {1,2}h {2,2}m {3:00}s {4:000}ms\",\n                              ti.Days, ti.Hours, ti.Minutes, ti.Seconds, ti.Milliseconds).Replace(\"  0d \", \"\")\n                              .Replace(\" 0h\", \"\").Replace(\" 0m\", \"\").Replace(\" 00s\", \"\"));\n            long ms = (long)ti.TotalMilliseconds, lim = int.MaxValue >> 2;\n            if (ms > 250)\n            {\n                Console.WriteLine(\"Estimated completion times:\");\n                for (int i = n + 1; i <= n + 10; i++)\n                {\n                    if (ms >= lim) break; ms += 44; ms <<= 2; ti = TimeSpan.FromMilliseconds(ms);\n                    Console.WriteLine(\"{0,2}\u00a0: {1,2}d {2,2}h {3,2}m {4:00}.{5:000}s\", i, \n                        ti.Days, ti.Hours, ti.Minutes, ti.Seconds, ti.Milliseconds);\n                }\n            }\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n            return 0;\n        }\n\n        static void CountEm()\n        {\n            ns = n * n;\n            AnyR = new long[n + 1];\n            nFlip = new long[n + 1];\n            Frees = new long[n + 1];\n            fWid = n * 2 - 2;\n            fSiz = (n - 1) * (n - 1) * 2 + 1;\n            int[] pnField = new int[fSiz];\n            int[] pnPutList = new int[fSiz];\n            fChk = new int[ns];\n            fCkR = new int[ns];\n            dirs = new int[] { 1, fWid, -1, -fWid };\n            rotO = new int[] { 0, n - 1, ns - 1, ns - n, n - 1, 0, ns - n, ns - 1 };\n            rotX = new int[] { 1, n, -1, -n, -1, n, 1, -n };\n            rotY = new int[] { n, -1, -n, 1, n, 1, -n, -1 };\n            Recurse(0, pnField, pnPutList, 0, 1);\n        }\n\n        static void Recurse(int lv, int[] field, int[] putlist, int putno, int putlast)\n        {\n            CheckIt(field, lv);\n            if (n == lv) return;\n            int pos;\n            for (int i = putno; i < putlast; i++)\n            {\n                field[pos = putlist[i]] |= 1;\n                int k = 0;\n                foreach (int dir in dirs)\n                {\n                    int pos2 = pos + dir;\n                    if (0 <= pos2 && pos2 < fSiz && (field[pos2] == 0))\n                    {\n                        field[pos2] = 2;\n                        putlist[putlast + k++] = pos2;\n                    }\n                }\n                Recurse(lv + 1, field, putlist, i + 1, putlast + k);\n                for (int j = 0; j < k; j++) field[putlist[putlast + j]] = 0;\n                field[pos] = 2;\n            }\n            for (int i = putno; i < putlast; i++) field[putlist[i]] &= -2;\n        }\n\n        static void CheckIt(int[] field, int lv)\n        {\n            AnyR[lv]++;\n            for (int i = 0; i < ns; i++) fChk[i] = 0;\n            int x, y;\n            for (x = n; x < fWid; x++)\n                for (y = 0; y + x < fSiz; y += fWid)\n                    if ((field[x + y] & 1) == 1) goto bail;\n            bail:\n            int x2 = n - x, t;\n            for (int i = 0; i < fSiz; i++)\n                if ((field[i] & 1) == 1) fChk[((t = (i + n - 2)) % fWid) + x2 + (t / fWid * n)] = 1;\n            int of1; for (of1 = 0; of1 < fChk.Length && (fChk[of1] == 0); of1++) ;\n            bool c = true; int r;\n            for (r = 1; r < 8 && c; r++)\n            {\n                for (x = 0; x < n; x++) for (y = 0; y < n; y++)\n                        fCkR[rotO[r] + rotX[r] * x + rotY[r] * y] = fChk[x + y * n];\n                int of2; for (of2 = 0; of2 < fCkR.Length && (fCkR[of2] == 0); of2++) ;\n                of2 -= of1;\n                for (int i = of1; i < ns - ((of2 > 0) ? of2 : 0); i++)\n                {\n                    if (fChk[i] > fCkR[i + of2]) break;\n                    if (fChk[i] < fCkR[i + of2]) { c = false; break; }\n                }\n            }\n            if (r > 4) nFlip[lv]++;\n            if (c)\n            {\n                if (lv == target) polys.Add(toStr(field.ToArray()));\n                Frees[lv]++;\n            }\n        }\n\n        static string toStr(int[] field) \n        {\n            char [] res = new string(' ', n * (fWid + 1) - 1).ToCharArray();\n            for (int i = fWid; i < res.Length; i += fWid+1) res[i] = '\\n';\n            for (int i = 0, j = n - 2; i < field.Length; i++, j++)\n            {\n                if ((field[i] & 1) == 1) res[j] = '#';\n                if (j % (fWid + 1) == fWid) i--;\n            }\n            List<string> t = new string(res).Split('\\n').ToList();\n            int nn = 100, m = 0, v, k = 0; \n            foreach (string s in t)\n            {\n                if ((v = s.IndexOf('#')) < nn) if (v >= 0) nn = v;\n                if ((v = s.LastIndexOf('#')) > m) if (v < fWid +1) m = v;\n                if (v < 0) break; k++;\n            }\n            m = m - nn + 1; \n            for (int i = t.Count - 1; i >= 0; i--)\n            {\n                if (i >= k) t.RemoveAt(i);\n                else t[i] = t[i].Substring(nn, m);\n            }\n            return String.Join(\"\\n\", t.ToArray());\n        }\n\n        \n        static string Assemble(List<string> p)\n        {\n            List<string> lines = new List<string>();\n            for (int i = 0; i < target; i++) lines.Add(string.Empty);\n            foreach (string poly in p)\n            {\n                List<string> t = poly.Split('\\n').ToList();\n                if (t.Count < t[0].Length) t = flipXY(t);\n                for (int i = 0; i < lines.Count; i++)\n                    lines[i] += (i < t.Count) ? ' ' + t[i] + ' ': new string(' ', t[0].Length + 2);\n            }\n            for (int i = lines.Count - 1; i > 0; i--)\n                if (lines[i].IndexOf('#') < 0) lines.RemoveAt(i);\n            if (lines[0].Length >= clipAt / 2-2) Wrap(lines, clipAt / 2-2);\n            lines = Cornered(string.Join(\"\\n\", lines.ToArray())).Split('\\n').ToList();\n            return String.Join(\"\\n\", lines.ToArray());\n        }\n\n        static List<string> flipXY(List<string> p)  \n        {\n            List<string> res = new List<string>();\n            for (int i = 0; i < p[0].Length; i++) res.Add(string.Empty);\n            for (int i = 0; i < res.Count; i++)\n                for(int j = 0; j < p.Count; j++) res[i] += p[j][i];\n            return res;\n        }\n\n        static string DW(string s)  \n        {\n            string t = string.Empty;\n            foreach (char c in s) t += string.Format(\"{0}{0}\",c);\n            return t;\n        }\n\n        static void Wrap(List<string> s, int w) \n        {\n            int last = 0;\n            while (s.Last().Length >= w)\n            {\n                int x = w, lim = s.Count; bool ok;\n                do\n                {\n                    ok = true;\n                    for (int i = last; i < lim; i++)\n                        if (s[i][x] != ' ')\n                        { ok = false; x--; break; }\n                } while (!ok);\n                for (int i = last; i < lim; i++)\n                    if (s[i].Length > x) { s.Add(s[i].Substring(x)); s[i] = s[i].Substring(0, x + 1); }\n                last = lim;\n            }\n            last = 0;\n            for (int i = s.Count - 1; i > 0; i--)\n                if ((last = (s[i].IndexOf('#') < 0) ? last + 1 : 0) > 1) s.RemoveAt(i + 1);\n        }\n\n        static string Cornered(string s)    \n        {\n            string[] lines = s.Split('\\n');\n            string res = string.Empty;\n            string line = DW(new string(' ', lines[0].Length)), last;\n            for (int i = 0; i < lines.Length; i++)\n            {\n                last = line; line = DW(lines[i]);\n                res += Puzzle(last, line) + '\\n';\n            }\n            res += Puzzle(line, DW(new string(' ', lines.Last().Length))) + '\\n';\n            return res;\n        }\n\n        static string Puzzle(string a, string b)    \n        {\n            string res = string.Empty;\n            if (a.Length > b.Length) b += new string(' ', a.Length - b.Length);\n            if (a.Length < b.Length) a += new string(' ', b.Length - a.Length);\n            for (int i = 0; i < a.Length - 1; i++)\n                res += \" 12\u25144\u2518\u2500\u25348\u2502\u250c\u251c\u2510\u2524\u252c\u253c\"[(a[i] == a[i + 1] ? 0 : 1) + \n                                          (b[i + 1] == a[i + 1] ? 0 : 2) +\n                                          (a[i] == b[i] ? 0 : 4) + \n                                          (b[i] == b[i + 1] ? 0 : 8)];\n            return res;\n        }\n    }\n}\n"}
{"id": 386932, "name": "Partition function P", "source": "Translate Ruby to C#: say partitions(6666)   \n", "target": "using System;\n\nclass Program {\n\n    const long Lm = (long)1e18;\n    const string Fm = \"D18\";\n\n    \n    struct LI { public long lo, ml, mh, hi, tp; }\n\n    static void inc(ref LI d, LI s) { \n        if ((d.lo += s.lo) >= Lm) { d.ml++; d.lo -= Lm; }\n        if ((d.ml += s.ml) >= Lm) { d.mh++; d.ml -= Lm; }\n        if ((d.mh += s.mh) >= Lm) { d.hi++; d.mh -= Lm; }\n        if ((d.hi += s.hi) >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n \n    static void dec(ref LI d, LI s) { \n        if ((d.lo -= s.lo) < 0) { d.ml--; d.lo += Lm; }\n        if ((d.ml -= s.ml) < 0) { d.mh--; d.ml += Lm; }\n        if ((d.mh -= s.mh) < 0) { d.hi--; d.mh += Lm; }\n        if ((d.hi -= s.hi) < 0) { d.tp--; d.hi += Lm; }\n        d.tp -= s.tp;\n    }\n\n    static LI set(long s) { LI d;\n      d.lo = s; d.ml = d.mh = d.hi = d.tp = 0; return d; }\n\n  static string fmt(LI x) { \n    if (x.tp > 0) return x.tp.ToString() + x.hi.ToString(Fm) + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.hi > 0) return x.hi.ToString() + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.mh > 0) return x.mh.ToString() + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.ml > 0) return x.ml.ToString() + x.lo.ToString(Fm);\n    return x.lo.ToString();\n  }\n\n  static LI partcount(int n) {\n    var P = new LI[n + 1]; P[0] = set(1);\n    for (int i = 1; i <= n; i++) {\n      int k = 0, d = -2, j = i;\n      LI x = set(0);\n      while (true) {\n        if ((j -= (d += 3) -k) >= 0) inc(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) inc(ref x, P[j]); else break;\n        if ((j -= (d += 3) -k) >= 0) dec(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) dec(ref x, P[j]); else break;\n      }\n      P[i] = x;\n    }\n    return P[n];\n  }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew ();\n    var res = partcount(6666); sw.Stop();\n    Console.Write(\"{0}  {1} ms\", fmt(res), sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 386933, "name": "Special divisors", "source": "Translate Ruby to C#: class Integer\n  def reverse \n    to_s.reverse.to_i\n  end\n  def divisors\n      res = []\n      (1..Integer.sqrt(self)).each do |cand|\n        div, mod = self.divmod(cand)\n        res << cand << div if mod == 0\n      end\n      res.uniq.sort\n  end\n  def special_divisors?\n    r = self.reverse\n    divisors.all?{|d| r % d.reverse == 0}\n  end\nend\n\np (1..200).select(&:special_divisors?)\n", "target": "using System;\n\nnamespace SpecialDivisors {\n    class Program {\n        static int Reverse(int n) {\n            int result = 0;\n            while (n > 0) {\n                result = 10 * result + n % 10;\n                n /= 10;\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int LIMIT = 200;\n\n            int row = 0;\n            int num = 0;\n\n            for (int n = 1; n < LIMIT; n++) {\n                bool flag = true;\n                int revNum = Reverse(n);\n\n                for (int m = 1; m < n / 2; m++) {\n                    int revDiv = Reverse(m);\n                    if (n % m == 0) {\n                        if (revNum % revDiv == 0) {\n                            flag = true;\n                        } else {\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (flag) {\n                    num++;\n                    row++;\n                    Console.Write(\"{0,4}\", n);\n                    if (row % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine();\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} special divisors N that reverse(D) divides reverse(N) for all divisors D of N, where N < 200\", num);\n        }\n    }\n}\n"}
{"id": 386934, "name": "Polynomial synthetic division", "source": "Translate Ruby to C#: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SyntheticDivision\n{\n    class Program\n    {\n        static (List<int>,List<int>) extendedSyntheticDivision(List<int> dividend, List<int> divisor)\n        {\n            List<int> output = dividend.ToList();\n            int normalizer = divisor[0];\n\n            for (int i = 0; i < dividend.Count() - (divisor.Count() - 1); i++)\n            {\n                output[i] /= normalizer;\n\n                int coef = output[i];\n                if (coef != 0)\n                {\n                    for (int j = 1; j < divisor.Count(); j++)\n                        output[i + j] += -divisor[j] * coef;\n                }\n            }\n\n            int separator = output.Count() - (divisor.Count() - 1);\n\n            return (\n                output.GetRange(0, separator),\n                output.GetRange(separator, output.Count() - separator)\n            );\n        }\n\n        static void Main(string[] args)\n        {\n            List<int> N = new List<int>{ 1, -12, 0, -42 };\n            List<int> D = new List<int> { 1, -3 };\n\n            var (quotient, remainder) = extendedSyntheticDivision(N, D);\n            Console.WriteLine(\"[ {0} ] / [ {1} ] = [ {2} ], remainder [ {3} ]\" ,\n                string.Join(\",\", N),\n                string.Join(\",\", D),\n                string.Join(\",\", quotient),\n                string.Join(\",\", remainder)\n            );\n        }\n    }\n}\n"}
{"id": 386935, "name": "Polynomial synthetic division", "source": "Translate Ruby to C#: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SyntheticDivision\n{\n    class Program\n    {\n        static (List<int>,List<int>) extendedSyntheticDivision(List<int> dividend, List<int> divisor)\n        {\n            List<int> output = dividend.ToList();\n            int normalizer = divisor[0];\n\n            for (int i = 0; i < dividend.Count() - (divisor.Count() - 1); i++)\n            {\n                output[i] /= normalizer;\n\n                int coef = output[i];\n                if (coef != 0)\n                {\n                    for (int j = 1; j < divisor.Count(); j++)\n                        output[i + j] += -divisor[j] * coef;\n                }\n            }\n\n            int separator = output.Count() - (divisor.Count() - 1);\n\n            return (\n                output.GetRange(0, separator),\n                output.GetRange(separator, output.Count() - separator)\n            );\n        }\n\n        static void Main(string[] args)\n        {\n            List<int> N = new List<int>{ 1, -12, 0, -42 };\n            List<int> D = new List<int> { 1, -3 };\n\n            var (quotient, remainder) = extendedSyntheticDivision(N, D);\n            Console.WriteLine(\"[ {0} ] / [ {1} ] = [ {2} ], remainder [ {3} ]\" ,\n                string.Join(\",\", N),\n                string.Join(\",\", D),\n                string.Join(\",\", quotient),\n                string.Join(\",\", remainder)\n            );\n        }\n    }\n}\n"}
{"id": 386936, "name": "Color wheel", "source": "Translate Ruby to C#: def settings\n  size(300, 300)\nend\n\ndef setup\n  sketch_title 'Color Wheel'\n  background(0)\n  radius = width / 2.0\n  center = width / 2\n  grid(width, height) do |x, y|\n    rx = x - center\n    ry = y - center\n    sat = Math.hypot(rx, ry) / radius\n    if sat <= 1.0\n      hue = ((Math.atan2(ry, rx) / PI) + 1) / 2.0\n      color_mode(HSB)\n      col = color((hue * 255).to_i, (sat * 255).to_i, 255)\n      set(x, y, col)\n    end\n  end\nend\n", "target": "\n\npublic MainWindow()\n{\n    InitializeComponent();\n    RenderOptions.SetBitmapScalingMode(imgMain, BitmapScalingMode.HighQuality);\n    imgMain.Source = new WriteableBitmap(480, 480, 96, 96, PixelFormats.Bgr32, null);\n    \n    DrawHue(100);\n}\n\nvoid DrawHue(int saturation)\n{\n    var bmp = (WriteableBitmap)imgMain.Source;\n\n    int centerX = (int)bmp.Width / 2;\n    int centerY = (int)bmp.Height / 2;\n    int radius = Math.Min(centerX, centerY);\n    int radius2 = radius - 40;\n\n    bmp.Lock();\n    unsafe{\n        var buf = bmp.BackBuffer;\n        IntPtr pixLineStart;\n        for(int y=0; y < bmp.Height; y++){\n            pixLineStart = buf + bmp.BackBufferStride * y;\n            double dy = (y - centerY);\n            for(int x=0; x < bmp.Width; x++){\n                double dx = (x - centerX);\n                double dist = Math.Sqrt(dx * dx + dy * dy);\n                if (radius2 <= dist && dist <= radius) {\n                    double theta = Math.Atan2(dy, dx);\n                    double hue = (theta + Math.PI) / (2.0 * Math.PI);\n                    *((int*)(pixLineStart + x * 4)) = HSB_to_RGB((int)(hue * 360), saturation, 100);\n                }\n            }\n        }\n    }\n    bmp.AddDirtyRect(new Int32Rect(0, 0, 480, 480));\n    bmp.Unlock();\n}\n\nstatic int HSB_to_RGB(int h, int s, int v)\n{\n    var rgb = new int[3];\n\n    var baseColor = (h + 60) % 360 / 120;\n    var shift = (h + 60) % 360 - (120 * baseColor + 60 );\n    var secondaryColor = (baseColor + (shift >= 0 ? 1 : -1) + 3) % 3;\n\n    \n    rgb[baseColor] = 255;\n    rgb[secondaryColor] = (int) ((Math.Abs(shift) / 60.0f) * 255.0f);\n\n    \n    for (var i = 0; i < 3; i++)\n        rgb[i] += (int) ((255 - rgb[i]) * ((100 - s) / 100.0f));\n\n    \n    for (var i = 0; i < 3; i++)\n        rgb[i] -= (int) (rgb[i] * (100-v) / 100.0f);\n\n    return RGB2int(rgb[0], rgb[1], rgb[2]);\n}\n\npublic static int RGB2int(int r, int g, int b) => r << 16 | g << 8 | b;\n"}
{"id": 386937, "name": "The sieve of Sundaram", "source": "Translate Ruby to C#: def sieve_of_sundaram(upto)\n  n = (2.4 * upto * Math.log(upto)) / 2\n  k = (n - 3) / 2 + 1\n  bools = [true] * k\n  (0..(Integer.sqrt(n) - 3) / 2 + 1).each do |i|\n    p = 2*i + 3\n    s = (p*p - 3) / 2\n    (s..k).step(p){|j| bools[j] = false}\n  end\n  bools.filter_map.each_with_index {|b, i| (i + 1) * 2 + 1 if b }\nend\n\np sieve_of_sundaram(100)\nn = 1_000_000\nputs \"\\nThe \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nclass Program\n{\n    static string fmt(int[] a)\n    {\n        var sb = new System.Text.StringBuilder();\n        for (int i = 0; i < a.Length; i++)\n            sb.Append(string.Format(\"{0,5}{1}\",\n              a[i], i % 10 == 9 ? \"\\n\" : \" \"));\n        return sb.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();\n        sw.Stop();\n        Write(\"The first 100 odd prime numbers:\\n{0}\\n\",\n          fmt(pr.Take(100).ToArray()));\n        Write(\"The millionth odd prime number: {0}\", pr.Last());\n        Write(\"\\n{0} ms\", sw.Elapsed.TotalMilliseconds);\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<int> Sundaram(int n)\n    {\n        \n        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;\n        var comps = new bool[k + 1];\n        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)\n            while ((t += d + 2) < k)\n                comps[t] = true;\n        for (; v < k; v++)\n            if (!comps[v])\n                yield return (v << 1) + 1;\n    }\n}\n"}
{"id": 386938, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Ruby to C#: require \"prime\"\nlimit = 1_000_000\n\nputs \"First found longest run of ascending prime gaps up to \np  Prime.each(limit).each_cons(2).chunk_while{|(i1,i2), (j1,j2)| j1-i1 < j2-i2 }.max_by(&:size).flatten.uniq\nputs  \"\\nFirst found longest run of descending prime gaps up to \np  Prime.each(limit).each_cons(2).chunk_while{|(i1,i2), (j1,j2)| j1-i1 > j2-i2 }.max_by(&:size).flatten.uniq\n", "target": "using System.Linq;\nusing System.Collections.Generic;\nusing TG = System.Tuple<int, int>;\nusing static System.Console;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int mil = (int)1e6;\n        foreach (var amt in new int[] { 1, 2, 6, 12, 18 })\n        {\n            int lmt = mil * amt, lg = 0, ng, d, ld = 0;\n            var desc = new string[] { \"A\", \"\", \"De\" };\n            int[] mx = new int[] { 0, 0, 0 },\n                  bi = new int[] { 0, 0, 0 },\n                   c = new int[] { 2, 2, 2 };\n            WriteLine(\"For primes up to {0:n0}:\", lmt);\n            var pr = PG.Primes(lmt).ToArray();\n            for (int i = 0; i < pr.Length; i++)\n            {\n                ng = pr[i].Item2; d = ng.CompareTo(lg) + 1;\n                if (ld == d)\n                    c[2 - d]++;\n                else\n                {\n                    if (c[d] > mx[d]) { mx[d] = c[d]; bi[d] = i - mx[d] - 1; }\n                    c[d] = 2;\n                }\n                ld = d; lg = ng;\n            }\n            for (int r = 0; r <= 2; r += 2)\n            {\n                Write(\"{0}scending, found run of {1} consecutive primes:\\n  {2} \",\n                    desc[r], mx[r] + 1, pr[bi[r]++].Item1);\n                foreach (var itm in pr.Skip(bi[r]).Take(mx[r]))\n                    Write(\"({0}) {1} \", itm.Item2, itm.Item1); WriteLine(r == 0 ? \"\" : \"\\n\");\n            }\n        }\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<TG> Primes(int lim)\n    {\n        bool[] flags = new bool[lim + 1];\n        int j = 3, lj = 2;\n        for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n                for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true;\n            }\n        for (; j <= lim; j += 2)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n            }\n    }\n}\n"}
{"id": 386939, "name": "XML validation", "source": "Translate Ruby to C#: require('XML::LibXML')\n\nfunc is_valid_xml(str, schema) {\n\n    var parser    = %O<XML::LibXML>.new\n    var xmlschema = %O<XML::LibXML::Schema>.new(string => schema)\n\n    try {\n        xmlschema.validate(parser.parse_string(str))\n        true\n    } catch {\n        false\n    }\n}\n\nvar good_xml = '<a>5</a>'\nvar bad_xml  = '<a>5<b>foobar</b></a>'\n\nvar xmlschema_markup = <<'END'\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\n[good_xml, bad_xml].each { |xml|\n    say \"is_valid_xml(\n}\n", "target": "using System;\nusing System.Xml;\nusing System.Xml.Schema;\nusing System.IO;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\t\n\t\tXmlSchemaSet sc = new XmlSchemaSet();\n\t\tsc.Add(null, \"http:\n\t\tXmlReaderSettings settings = new XmlReaderSettings();\n\t\tsettings.ValidationType = ValidationType.Schema;\n\t\tsettings.Schemas = sc;\n\t\tsettings.ValidationEventHandler += new ValidationEventHandler(ValidationCallBack);\n\t\t\n\t\tXmlReader reader = XmlReader.Create(\"http:\n\t\t\n\t\twhile (reader.Read()); \n\t\t\n\t\tConsole.WriteLine(\"The XML file is valid for the given xsd file\");\n\t}\n\t\n\t\n\tprivate static void ValidationCallBack(object sender, ValidationEventArgs e) {\n\t\tConsole.WriteLine(\"Validation Error: {0}\", e.Message);\n\t}\n}\n"}
{"id": 386940, "name": "Metallic ratios", "source": "Translate Ruby to C#: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "using static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n    static BI IntSqRoot(BI v, BI res) { \n        BI term = 0, d = 0, dl = 1; while (dl != d) { term = v / res; res = (res + term) >> 1;\n            dl = d; d = term - res; } return term; }\n \n    static string doOne(int b, int digs) { \n        int s = b * b + 4; BI g = (BI)(Sqrt((double)s) * Pow(10, ++digs)),\n            bs = IntSqRoot(s * BI.Parse('1' + new string('0', digs << 1)), g);\n        bs += b * BI.Parse('1' + new string('0', digs));\n        bs >>= 1; bs += 4; string st = bs.ToString();\n        return string.Format(\"{0}.{1}\", st[0], st.Substring(1, --digs)); }\n \n    static string divIt(BI a, BI b, int digs) { \n        int al = a.ToString().Length, bl = b.ToString().Length;\n        a *= BI.Pow(10, ++digs << 1); b *= BI.Pow(10, digs);\n        string s = (a / b + 5).ToString(); return s[0] + \".\" + s.Substring(1, --digs); }\n \n    \n    static string joined(BI[] x) { int[] wids = {1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n        string res = \"\"; for (int i = 0; i < x.Length; i++) res += \n            string.Format(\"{0,\" + (-wids[i]).ToString() + \"} \", x[i]); return res; }\n \n    static void Main(string[] args) { \n        WriteLine(\"Metal B Sq.Rt Iters /---- 32 decimal place value ----\\\\  Matches Sq.Rt Calc\");\n        int k; string lt, t = \"\"; BI n, nm1, on; for (int b = 0; b < 10; b++) {\n            BI[] lst = new BI[15]; lst[0] = lst[1] = 1;\n            for (int i = 2; i < 15; i++) lst[i] = b * lst[i - 1] + lst[i - 2];\n            \n            n = lst[14]; nm1 = lst[13]; k = 0; for (int j = 13; k == 0; j++) {\n                lt = t; if (lt == (t = divIt(n, nm1, 32))) k = b == 0 ? 1 : j;\n                on = n; n = b * n + nm1; nm1 = on; }\n            WriteLine(\"{0,4}  {1}   {2,2}    {3, 2}  {4}  {5}\\n{6,19} {7}\", \"Pt Au Ag CuSn Cu Ni Al Fe Sn Pb\"\n                .Split(' ')[b], b, b * b + 4, k, t, t == doOne(b, 32), \"\", joined(lst)); }\n        \n        n = nm1 =1; k = 0; for (int j = 1; k == 0; j++) {\n            lt = t; if (lt == (t = divIt(n, nm1, 256))) k = j;\n                on = n; n += nm1; nm1 = on; }\n        WriteLine(\"\\nAu to 256 digits:\"); WriteLine(t);\n        WriteLine(\"Iteration count: {0}  Matched Sq.Rt Calc: {1}\", k, t == doOne(1, 256)); }\n}\n"}
{"id": 386941, "name": "Metallic ratios", "source": "Translate Ruby to C#: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "using static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n    static BI IntSqRoot(BI v, BI res) { \n        BI term = 0, d = 0, dl = 1; while (dl != d) { term = v / res; res = (res + term) >> 1;\n            dl = d; d = term - res; } return term; }\n \n    static string doOne(int b, int digs) { \n        int s = b * b + 4; BI g = (BI)(Sqrt((double)s) * Pow(10, ++digs)),\n            bs = IntSqRoot(s * BI.Parse('1' + new string('0', digs << 1)), g);\n        bs += b * BI.Parse('1' + new string('0', digs));\n        bs >>= 1; bs += 4; string st = bs.ToString();\n        return string.Format(\"{0}.{1}\", st[0], st.Substring(1, --digs)); }\n \n    static string divIt(BI a, BI b, int digs) { \n        int al = a.ToString().Length, bl = b.ToString().Length;\n        a *= BI.Pow(10, ++digs << 1); b *= BI.Pow(10, digs);\n        string s = (a / b + 5).ToString(); return s[0] + \".\" + s.Substring(1, --digs); }\n \n    \n    static string joined(BI[] x) { int[] wids = {1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n        string res = \"\"; for (int i = 0; i < x.Length; i++) res += \n            string.Format(\"{0,\" + (-wids[i]).ToString() + \"} \", x[i]); return res; }\n \n    static void Main(string[] args) { \n        WriteLine(\"Metal B Sq.Rt Iters /---- 32 decimal place value ----\\\\  Matches Sq.Rt Calc\");\n        int k; string lt, t = \"\"; BI n, nm1, on; for (int b = 0; b < 10; b++) {\n            BI[] lst = new BI[15]; lst[0] = lst[1] = 1;\n            for (int i = 2; i < 15; i++) lst[i] = b * lst[i - 1] + lst[i - 2];\n            \n            n = lst[14]; nm1 = lst[13]; k = 0; for (int j = 13; k == 0; j++) {\n                lt = t; if (lt == (t = divIt(n, nm1, 32))) k = b == 0 ? 1 : j;\n                on = n; n = b * n + nm1; nm1 = on; }\n            WriteLine(\"{0,4}  {1}   {2,2}    {3, 2}  {4}  {5}\\n{6,19} {7}\", \"Pt Au Ag CuSn Cu Ni Al Fe Sn Pb\"\n                .Split(' ')[b], b, b * b + 4, k, t, t == doOne(b, 32), \"\", joined(lst)); }\n        \n        n = nm1 =1; k = 0; for (int j = 1; k == 0; j++) {\n            lt = t; if (lt == (t = divIt(n, nm1, 256))) k = j;\n                on = n; n += nm1; nm1 = on; }\n        WriteLine(\"\\nAu to 256 digits:\"); WriteLine(t);\n        WriteLine(\"Iteration count: {0}  Matched Sq.Rt Calc: {1}\", k, t == doOne(1, 256)); }\n}\n"}
{"id": 386942, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to C#: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386943, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to C#: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 386944, "name": "Pandigital prime", "source": "Translate Ruby to C#: require \"prime\"\n    \ndef find_pan(ar) = ar.permutation(ar.size).find{|perm| perm.join.to_i.prime? }.join.to_i\n  \ndigits = [7,6,5,4,3,2,1]\nputs find_pan(digits)\ndigits << 0\nputs find_pan(digits)\n", "target": "using System;\n \nclass Program {\n  \n \n  \n  \n \n  static void fun(char sp) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    \n    \n    \n \n    for (int x = sp == '1' ? 7654321 : 76543201; ; x -= 18) {\n \n      \n      \n      \n      var s = x.ToString();\n      for (var ch = sp; ch < '8'; ch++) if (s.IndexOf(ch) < 0) goto nxt;\n \n      \n      \n      if (x % 3 == 0) continue;\n      for (int i = 1; i * i < x; ) {\n        if (x % (i += 4) == 0) goto nxt;\n        if (x % (i += 2) == 0) goto nxt;\n      }\n      sw.Stop(); Console.WriteLine(\"{0}..7: {1,10:n0} {2} \u03bcs\", sp, x, sw.Elapsed.TotalMilliseconds * 1000); break;\n      nxt: ;\n    }\n  }\n\nstatic void Main(string[] args) {\n    fun('1');\n    fun('0');\n  }\n}\n"}
{"id": 386945, "name": "Pandigital prime", "source": "Translate Ruby to C#: require \"prime\"\n    \ndef find_pan(ar) = ar.permutation(ar.size).find{|perm| perm.join.to_i.prime? }.join.to_i\n  \ndigits = [7,6,5,4,3,2,1]\nputs find_pan(digits)\ndigits << 0\nputs find_pan(digits)\n", "target": "using System;\n \nclass Program {\n  \n \n  \n  \n \n  static void fun(char sp) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    \n    \n    \n \n    for (int x = sp == '1' ? 7654321 : 76543201; ; x -= 18) {\n \n      \n      \n      \n      var s = x.ToString();\n      for (var ch = sp; ch < '8'; ch++) if (s.IndexOf(ch) < 0) goto nxt;\n \n      \n      \n      if (x % 3 == 0) continue;\n      for (int i = 1; i * i < x; ) {\n        if (x % (i += 4) == 0) goto nxt;\n        if (x % (i += 2) == 0) goto nxt;\n      }\n      sw.Stop(); Console.WriteLine(\"{0}..7: {1,10:n0} {2} \u03bcs\", sp, x, sw.Elapsed.TotalMilliseconds * 1000); break;\n      nxt: ;\n    }\n  }\n\nstatic void Main(string[] args) {\n    fun('1');\n    fun('0');\n  }\n}\n"}
{"id": 386946, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to C#: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace Fibonacci {\n    class Program\n    {\n        private static readonly BigInteger[,] F = { { BigInteger.One, BigInteger.One }, { BigInteger.One, BigInteger.Zero } };\n        private static NumberFormatInfo nfi  = new NumberFormatInfo { NumberGroupSeparator = \"_\" };\n        private static BigInteger[,] Multiply(in BigInteger[,] A, in BigInteger[,] B)\n        {\n            if (A.GetLength(1) != B.GetLength(0))\n            {\n                throw new ArgumentException(\"Illegal matrix dimensions for multiplication.\");\n            }\n            var C = new BigInteger[A.GetLength(0), B.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < B.GetLength(1); ++j)\n                {\n                    for (int k = 0; k < A.GetLength(1); ++k)\n                    {\n                        C[i, j] +=  A[i, k] * B[k, j];\n                    }\n                }\n            }\n            return C;\n        }\n        private static BigInteger[,] Power(in BigInteger[,] A, ulong n)\n        {\n            if (A.GetLength(1) != A.GetLength(0))\n            {\n                throw new ArgumentException(\"Not a square matrix.\");\n            }\n            var C = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                C[i, i] = BigInteger.One;\n            }\n            if (0 == n) return C;\n            var S = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < A.GetLength(1); ++j)\n                {\n                    S[i, j] = A[i, j];\n                }\n            }\n            while (0 < n)\n            {\n                if (1 == n % 2) C = Multiply(C, S);\n                S = Multiply(S,S);\n                n /= 2;\n            }\n            return C;\n        }\n        public static BigInteger Fib(in ulong n)\n        {\n            var C = Power(F, n);\n            return C[0, 1];\n        }\n        public static void Task(in ulong p)\n        {\n            var ans = Fib(p).ToString();\n            var sp = p.ToString(\"N0\", nfi);\n            if (ans.Length <= 40)\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1}\", sp, ans);\n            }\n            else\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1} ... {2}\", sp, ans[0..19], ans[^20..]);\n            }\n        }\n        public static void Main()\n        {\n            Stopwatch stopWatch = new Stopwatch();\n            stopWatch.Start();\n            for (ulong p = 10; p <= 10_000_000; p *= 10) {\n                Task(p);\n            }\n            stopWatch.Stop();\n            TimeSpan ts = stopWatch.Elapsed;\n            string elapsedTime = String.Format(\"{0:00}:{1:00}:{2:00}.{3:00}\",\n                ts.Hours, ts.Minutes, ts.Seconds,\n                ts.Milliseconds / 10);\n            Console.WriteLine(\"Took \" + elapsedTime);\n        }\n    }\n}\n"}
{"id": 386947, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to C#: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace Fibonacci {\n    class Program\n    {\n        private static readonly BigInteger[,] F = { { BigInteger.One, BigInteger.One }, { BigInteger.One, BigInteger.Zero } };\n        private static NumberFormatInfo nfi  = new NumberFormatInfo { NumberGroupSeparator = \"_\" };\n        private static BigInteger[,] Multiply(in BigInteger[,] A, in BigInteger[,] B)\n        {\n            if (A.GetLength(1) != B.GetLength(0))\n            {\n                throw new ArgumentException(\"Illegal matrix dimensions for multiplication.\");\n            }\n            var C = new BigInteger[A.GetLength(0), B.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < B.GetLength(1); ++j)\n                {\n                    for (int k = 0; k < A.GetLength(1); ++k)\n                    {\n                        C[i, j] +=  A[i, k] * B[k, j];\n                    }\n                }\n            }\n            return C;\n        }\n        private static BigInteger[,] Power(in BigInteger[,] A, ulong n)\n        {\n            if (A.GetLength(1) != A.GetLength(0))\n            {\n                throw new ArgumentException(\"Not a square matrix.\");\n            }\n            var C = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                C[i, i] = BigInteger.One;\n            }\n            if (0 == n) return C;\n            var S = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < A.GetLength(1); ++j)\n                {\n                    S[i, j] = A[i, j];\n                }\n            }\n            while (0 < n)\n            {\n                if (1 == n % 2) C = Multiply(C, S);\n                S = Multiply(S,S);\n                n /= 2;\n            }\n            return C;\n        }\n        public static BigInteger Fib(in ulong n)\n        {\n            var C = Power(F, n);\n            return C[0, 1];\n        }\n        public static void Task(in ulong p)\n        {\n            var ans = Fib(p).ToString();\n            var sp = p.ToString(\"N0\", nfi);\n            if (ans.Length <= 40)\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1}\", sp, ans);\n            }\n            else\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1} ... {2}\", sp, ans[0..19], ans[^20..]);\n            }\n        }\n        public static void Main()\n        {\n            Stopwatch stopWatch = new Stopwatch();\n            stopWatch.Start();\n            for (ulong p = 10; p <= 10_000_000; p *= 10) {\n                Task(p);\n            }\n            stopWatch.Stop();\n            TimeSpan ts = stopWatch.Elapsed;\n            string elapsedTime = String.Format(\"{0:00}:{1:00}:{2:00}.{3:00}\",\n                ts.Hours, ts.Minutes, ts.Seconds,\n                ts.Milliseconds / 10);\n            Console.WriteLine(\"Took \" + elapsedTime);\n        }\n    }\n}\n"}
{"id": 386948, "name": "Cyclotomic polynomial", "source": "Translate Ruby to C#: say \"First 30 cyclotomic polynomials:\"\nfor k in (1..30) {\n    say (\"\u03a6(\n}\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\"\nfor n in (1..10) {  \n    var k = (1..Inf -> first {|k|\n        cyclotomic(k).coeffs.any { .tail.abs == n }\n    })\n    say \"\u03a6(\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 386949, "name": "Cyclotomic polynomial", "source": "Translate Ruby to C#: say \"First 30 cyclotomic polynomials:\"\nfor k in (1..30) {\n    say (\"\u03a6(\n}\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\"\nfor n in (1..10) {  \n    var k = (1..Inf -> first {|k|\n        cyclotomic(k).coeffs.any { .tail.abs == n }\n    })\n    say \"\u03a6(\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 386950, "name": "Practical numbers", "source": "Translate Ruby to C#: say is_practical(2**128 + 1)   \nsay is_practical(2**128 + 4)   \n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console;\n\nclass Program {\n\n    static bool soas(int n, IEnumerable<int> f) {\n        if (n <= 0) return false; if (f.Contains(n)) return true;\n        switch(n.CompareTo(f.Sum())) { case 1: return false; case 0: return true;\n            case -1: var rf = f.Reverse().ToList(); var d = n - rf[0]; rf.RemoveAt(0);\n                return soas(d, rf) || soas(n, rf); } return true; }\n\n    static bool ip(int n) { var f = Enumerable.Range(1, n >> 1).Where(d => n % d == 0).ToList();\n        return Enumerable.Range(1, n - 1).ToList().TrueForAll(i => soas(i, f));  }\n\n    static void Main() {\n        int c = 0, m = 333; for (int i = 1; i <= m; i += i == 1 ? 1 : 2)\n            if (ip(i) || i == 1) Write(\"{0,3} {1}\", i, ++c % 10 == 0 ? \"\\n\" : \"\"); \n        Write(\"\\nFound {0} practical numbers between 1 and {1} inclusive.\\n\", c, m);\n        do Write(\"\\n{0,5} is a{1}practical number.\",\n            m = m < 500 ? m << 1 : m * 10 + 6, ip(m) ? \" \" : \"n im\"); while (m < 1e4); } }\n"}
{"id": 386951, "name": "HTTPS_Client-authenticated", "source": "Translate Ruby to C#: require 'uri'\nrequire 'net/http'\n\nuri = URI.parse('https://www.example.com')\npem = File.read(\"/path/to/my.pem\")\ncert = OpenSSL::X509::Certificate.new(pem)\nkey = OpenSSL::PKey::RSA.new(pem)\nresponse = Net::HTTP.start(uri.host, uri.port, use_ssl: true,\n                           cert: cert, key: key) do |http|\n  request = Net::HTTP::Get.new uri\n  http.request request\nend\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    class MyWebClient : WebClient\n    {\n        protected override WebRequest GetWebRequest(Uri address)\n        {\n            HttpWebRequest request = (HttpWebRequest)base.GetWebRequest(address);\n            request.ClientCertificates.Add(new X509Certificate());\n            return request;\n        }\n    }\n    static void Main(string[] args)\n    {\n        var client = new MyWebClient();\n\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 386952, "name": "SQL-based authentication", "source": "Translate Ruby to C#: require 'mysql2'\nrequire 'securerandom'\nrequire 'digest'\n\ndef connect_db(host, port = nil, username, password, db)\n  Mysql2::Client.new(\n    host: host,\n    port: port,\n    username: username,\n    password: password,\n    database: db\n  )\nend\n\ndef create_user(client, username, password)\n  salt = SecureRandom.random_bytes(16)\n  password_md5 = Digest::MD5.hexdigest(salt + password)\n\n  statement = client.prepare('INSERT INTO users (username, pass_salt, pass_md5) VALUES (?,\u00a0?,\u00a0?)')\n  statement.execute(username, salt, password_md5)\n  statement.last_id\nend\n\ndef authenticate_user(client, username, password)\n  user_record = client.prepare(\"SELECT SELECT pass_salt, pass_md5 FROM users WHERE username = '\n  return false unless user_record\n\n  password_md5 = Digest::MD5.hexdigest(user_record['pass_salt'] + password)\n  password_md5 == user_record['pass_md5']\nend\n", "target": "using System.Security.Cryptography;\nusing System.Text;\n\nnamespace rosettaMySQL\n{\n    class Hasher\n    {\n        private static string _BytesToHex(byte[] input)\n        {\n            var strBuilder = new StringBuilder();\n            foreach (byte _byte in input)\n            {\n                strBuilder.Append(_byte.ToString(\"x2\"));\n            }\n            return strBuilder.ToString();\n        }\n\n        public static string Hash(string salt, string input)\n        {\n            using (MD5 md5 = new MD5CryptoServiceProvider())\n            {\n                var bytes = Encoding.Default.GetBytes(salt + input);\n                var data = md5.ComputeHash(bytes);\n                return _BytesToHex(data);\n            }\n        }\n\n        public static string GenSalt()\n        {\n            using (RandomNumberGenerator rng = new RNGCryptoServiceProvider())\n            {\n                var salt = new byte[16];\n                rng.GetBytes(salt);\n                return _BytesToHex(salt);\n            }\n        }\n    }\n}\n"}
{"id": 386953, "name": "Tarjan", "source": "Translate Ruby to C#: func tarjan (k) {\n\n    var(:onstack, :index, :lowlink, *stack, *connected)\n\n    func strong_connect (vertex, i=0) {\n\n         index{vertex}   = i\n         lowlink{vertex} = i+1\n         onstack{vertex} = true\n         stack << vertex\n\n         for connection in (k{vertex}) {\n             if (index{connection} == nil) {\n                 strong_connect(connection, i+1)\n                 lowlink{vertex} `min!` lowlink{connection}\n             }\n             elsif (onstack{connection}) {\n                 lowlink{vertex} `min!` index{connection}\n             }\n        }\n\n        if (lowlink{vertex} == index{vertex}) {\n            var *node\n            do {\n                node << stack.pop\n                onstack{node.tail} = false\n            } while (node.tail != vertex)\n            connected << node\n        }\n    }\n\n    { strong_connect(_) if !index{_} } << k.keys\n\n    return connected\n}\n\nvar tests = [\n    Hash(\n         0 => <1>,\n         1 => <2>,\n         2 => <0>,\n         3 => <1 2 4>,\n         4 => <3 5>,\n         5 => <2 6>,\n         6 => <5>,\n         7 => <4 6 7>,\n    ),\n    Hash(\n        :Andy => <Bart>,\n        :Bart => <Carl>,\n        :Carl => <Andy>,\n        :Dave => <Bart Carl Earl>,\n        :Earl => <Dave Fred>,\n        :Fred => <Carl Gary>,\n        :Gary => <Fred>,\n        :Hank => <Earl Gary Hank>,\n    )\n]\n\ntests.each {|t|\n    say (\"Strongly connected components: \", tarjan(t).map{.sort}.sort)\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n    public int LowLink { get; set; }\n    public int Index { get; set; }\n    public int N { get; }\n\n    public Node(int n)\n    {\n        N = n;\n        Index = -1;\n        LowLink = 0;\n    }\n}\n\nclass Graph\n{\n    public HashSet<Node> V { get; }\n    public Dictionary<Node, HashSet<Node>> Adj { get; }\n\n    \n    \n    \n    public void Tarjan()\n    {\n        var index = 0; \n        var S = new Stack<Node>();\n\n        Action<Node> StrongConnect = null;\n        StrongConnect = (v) =>\n        {\n            \n            v.Index = index;\n            v.LowLink = index;\n\n            index++;\n            S.Push(v);\n\n            \n            foreach (var w in Adj[v])\n                if (w.Index < 0)\n                {\n                    \n                    StrongConnect(w);\n                    v.LowLink = Math.Min(v.LowLink, w.LowLink);\n                }\n                else if (S.Contains(w))\n                    \n                    v.LowLink = Math.Min(v.LowLink, w.Index);\n\n            \n            if (v.LowLink == v.Index)\n            {\n                Console.Write(\"SCC: \");\n\n                Node w;\n                do\n                {\n                    w = S.Pop();\n                    Console.Write(w.N + \" \");\n                } while (w != v);\n\n                Console.WriteLine();\n            }\n        };\n\n        foreach (var v in V)\n            if (v.Index < 0)\n                StrongConnect(v);\n    }\n}\n"}
{"id": 389250, "name": "Jacobsthal numbers", "source": "Translate Ruby to Python: require 'prime'\n\ndef jacobsthal(n) = (2**n + n[0])/3\ndef jacobsthal_lucas(n) = 2**n + (-1)**n\ndef jacobsthal_oblong(n) = jacobsthal(n) * jacobsthal(n+1)\n\nputs \"First 30 Jacobsthal numbers:\"\nputs (0..29).map{|n| jacobsthal(n) }.join(\" \")\n\nputs \"\\nFirst 30 Jacobsthal-Lucas numbers: \"\nputs (0..29).map{|n| jacobsthal_lucas(n) }.join(\" \")\n\nputs \"\\nFirst 20 Jacobsthal-Oblong numbers: \"\nputs (0..19).map{|n| jacobsthal_oblong(n) }.join(\" \")\n\nputs \"\\nFirst 10 prime Jacobsthal numbers: \"\nres = (0..).lazy.filter_map do |i|\n  j = jacobsthal(i) \n  j if j.prime?\nend\nputs res.take(10).force.join(\" \")\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 389251, "name": "Successive prime differences", "source": "Translate Ruby to Python: require 'prime'\nPRIMES = Prime.each(1_000_000).to_a\ndifs = [[2], [1], [2,2], [2,4], [4,2], [6,4,2]]\n\ndifs.each do |ar|\n  res = PRIMES.each_cons(ar.size+1).select do |slice|\n    slice.each_cons(2).zip(ar).all? {|(a,b), c| a+c == b}\n  end\n  puts \"\nend\n", "target": "\nfrom sympy import Sieve\n\ndef nsuccprimes(count, mx):\n    \"return tuple of <count> successive primes <= mx (generator)\"\n    sieve = Sieve()\n    sieve.extend(mx)\n    primes = sieve._list\n    return zip(*(primes[n:] for n in range(count)))\n\ndef check_value_diffs(diffs, values):\n    \"Differences between successive values given by successive items in diffs?\"\n    return all(v[1] - v[0] == d \n               for d, v in zip(diffs, zip(values, values[1:])))\n\ndef successive_primes(offsets=(2, ), primes_max=1_000_000):\n    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) \n            if check_value_diffs(offsets, sp))\n\nif __name__ == '__main__':\n    for offsets, mx in [((2,),      1_000_000), \n                        ((1,),      1_000_000),\n                        ((2, 2),    1_000_000),\n                        ((2, 4),    1_000_000),\n                        ((4, 2),    1_000_000),\n                        ((6, 4, 2), 1_000_000),\n                       ]:\n        print(f\"\n              f\"SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}\")\n        for count, last in enumerate(successive_primes(offsets, mx), 1):\n            if count == 1:\n                first = last\n        print(\"  First group:\", str(first)[1:-1])\n        print(\"   Last group:\", str(last)[1:-1])\n        print(\"        Count:\", count)\n"}
{"id": 389252, "name": "Numbers whose binary and ternary digit sums are prime", "source": "Translate Ruby to Python: require 'prime'\n\np (1..200).select{|n| [2, 3].all?{|base| n.digits(base).sum.prime?} }\n", "target": "\n\n\n\ndef digitSumsPrime(n):\n    \n    def go(bases):\n        return all(\n            isPrime(digitSum(b)(n))\n            for b in bases\n        )\n    return go\n\n\n\ndef digitSum(base):\n    \n    def go(n):\n        q, r = divmod(n, base)\n        return go(q) + r if n else 0\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 200)\n        if digitSumsPrime(n)([2, 3])\n    ]\n    print(f'{len(xs)} matches in [1..199]\\n')\n    print(table(10)(xs))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389253, "name": "10001th prime", "source": "Translate Ruby to Python: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef prime(n: int) -> int:\n    if n == 1:\n        return 2\n    p = 3\n    pn = 1\n    while pn < n:\n        if isPrime(p):\n            pn += 1\n        p += 2\n    return p-2\n\nif __name__ == '__main__':\n    print(prime(10001))\n"}
{"id": 389254, "name": "10001th prime", "source": "Translate Ruby to Python: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef prime(n: int) -> int:\n    if n == 1:\n        return 2\n    p = 3\n    pn = 1\n    while pn < n:\n        if isPrime(p):\n            pn += 1\n        p += 2\n    return p-2\n\nif __name__ == '__main__':\n    print(prime(10001))\n"}
{"id": 389255, "name": "Summarize primes", "source": "Translate Ruby to Python: def isPrime(n)\n    if n < 2 then\n        return false\n    end\n\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n\n    i = 5\n    while i * i <= n\n        if n % i == 0 then\n            return false\n        end\n        i += 2\n\n        if n % i == 0 then\n            return false\n        end\n        i += 4\n    end\n    return true\nend\n\nSTART = 1\nSTOP = 1000\n\nsum = 0\ncount = 0\nsc = 0\n\nfor p in START .. STOP\n    if isPrime(p) then\n        count += 1\n        sum += p\n        if isPrime(sum) then\n            print \"The sum of %3d primes in [2, %3d] is %5d which is also prime\\n\" % [count, p, sum]\n            sc += 1\n        end\n    end\nend\nprint \"There are %d summerized primes in [%d, %d]\\n\" % [sc, START, STOP]\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389256, "name": "Summarize primes", "source": "Translate Ruby to Python: def isPrime(n)\n    if n < 2 then\n        return false\n    end\n\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n\n    i = 5\n    while i * i <= n\n        if n % i == 0 then\n            return false\n        end\n        i += 2\n\n        if n % i == 0 then\n            return false\n        end\n        i += 4\n    end\n    return true\nend\n\nSTART = 1\nSTOP = 1000\n\nsum = 0\ncount = 0\nsc = 0\n\nfor p in START .. STOP\n    if isPrime(p) then\n        count += 1\n        sum += p\n        if isPrime(sum) then\n            print \"The sum of %3d primes in [2, %3d] is %5d which is also prime\\n\" % [count, p, sum]\n            sc += 1\n        end\n    end\nend\nprint \"There are %d summerized primes in [%d, %d]\\n\" % [sc, START, STOP]\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389257, "name": "Terminal control_Dimensions", "source": "Translate Ruby to Python: def winsize\n  \n  require 'io/console'\n  IO.console.winsize\nrescue LoadError\n  \n  \n  [Integer(`tput li`), Integer(`tput co`)]\nend\n\nrows, cols = winsize\nprintf \"%d rows by %d columns\\n\", rows, cols\n", "target": "import os\n\ndef get_windows_terminal():\n    from ctypes import windll, create_string_buffer\n    h = windll.kernel32.GetStdHandle(-12)\n    csbi = create_string_buffer(22)\n    res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n\n    \n    if not res: return 80, 25 \n\n    import struct\n    (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy)\\\n    = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n    width = right - left + 1\n    height = bottom - top + 1\n\n    return width, height\n\ndef get_linux_terminal():\n    width = os.popen('tput cols', 'r').readline()\n    height = os.popen('tput lines', 'r').readline()\n\n    return int(width), int(height)\n\nprint get_linux_terminal() if os.name == 'posix' else get_windows_terminal()\n"}
{"id": 389258, "name": "Next special primes", "source": "Translate Ruby to Python: func special_primes(upto) {\n\n    var gap  = 0\n    var prev = 2\n    var list = [[prev, gap]]\n\n    loop {\n        var n = prev+gap\n        n = n.next_prime\n        break if (n > upto)\n        gap = n-prev\n        list << [n, gap]\n        prev = n\n    }\n\n    return list\n}\n\nspecial_primes(1050).each_2d {|p,gap|\n    say \"\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break\n"}
{"id": 389259, "name": "Next special primes", "source": "Translate Ruby to Python: func special_primes(upto) {\n\n    var gap  = 0\n    var prev = 2\n    var list = [[prev, gap]]\n\n    loop {\n        var n = prev+gap\n        n = n.next_prime\n        break if (n > upto)\n        gap = n-prev\n        list << [n, gap]\n        prev = n\n    }\n\n    return list\n}\n\nspecial_primes(1050).each_2d {|p,gap|\n    say \"\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break\n"}
{"id": 389260, "name": "Largest number divisible by its digits", "source": "Translate Ruby to Python: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389261, "name": "Largest number divisible by its digits", "source": "Translate Ruby to Python: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389262, "name": "Jacobi symbol", "source": "Translate Ruby to Python: def jacobi(a, n)\n  raise ArgumentError.new \"n must b positive and odd\" if n < 1 || n.even?\n  res = 1\n  until (a %= n) == 0\n    while a.even?\n      a >>= 1\n      res = -res if [3, 5].includes? n % 8\n    end\n    a, n = n, a\n    res = -res if a % 4 == n % 4 == 3\n  end\n  n == 1 ? res : 0\nend\n\nputs \"Jacobian symbols for jacobi(a, n)\"\nputs \"n\\\\a  0  1  2  3  4  5  6  7  8  9 10\"\nputs \"------------------------------------\"\n1.step(to: 17, by: 2) do |n|\n   printf(\"%2d \", n)\n   (0..10).each { |a| printf(\"\u00a0% 2d\", jacobi(a, n)) }\n   puts\nend\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 389263, "name": "Jacobi symbol", "source": "Translate Ruby to Python: def jacobi(a, n)\n  raise ArgumentError.new \"n must b positive and odd\" if n < 1 || n.even?\n  res = 1\n  until (a %= n) == 0\n    while a.even?\n      a >>= 1\n      res = -res if [3, 5].includes? n % 8\n    end\n    a, n = n, a\n    res = -res if a % 4 == n % 4 == 3\n  end\n  n == 1 ? res : 0\nend\n\nputs \"Jacobian symbols for jacobi(a, n)\"\nputs \"n\\\\a  0  1  2  3  4  5  6  7  8  9 10\"\nputs \"------------------------------------\"\n1.step(to: 17, by: 2) do |n|\n   printf(\"%2d \", n)\n   (0..10).each { |a| printf(\"\u00a0% 2d\", jacobi(a, n)) }\n   puts\nend\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 389264, "name": "Determinant and permanent", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  \n  def permanent\n    r = (0...row_count).to_a \n    r.permutation.inject(0) do |sum, sigma|\n       sum += sigma.zip(r).inject(1){|prod, (row, col)| prod *= self[row, col] }\n    end\n  end\nend\n\nm1 = Matrix[[1,2],[3,4]] \n\nm2 = Matrix[[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n\nm3 = Matrix[[0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9],\n            [10, 11, 12, 13, 14],\n            [15, 16, 17, 18, 19], \n            [20, 21, 22, 23, 24]]\n\n[m1, m2, m3].each do |m|\n  puts \"determinant:\\t \n  puts \nend\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 389265, "name": "Determinant and permanent", "source": "Translate Ruby to Python: require 'matrix'\n\nclass Matrix\n  \n  def permanent\n    r = (0...row_count).to_a \n    r.permutation.inject(0) do |sum, sigma|\n       sum += sigma.zip(r).inject(1){|prod, (row, col)| prod *= self[row, col] }\n    end\n  end\nend\n\nm1 = Matrix[[1,2],[3,4]] \n\nm2 = Matrix[[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n\nm3 = Matrix[[0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9],\n            [10, 11, 12, 13, 14],\n            [15, 16, 17, 18, 19], \n            [20, 21, 22, 23, 24]]\n\n[m1, m2, m3].each do |m|\n  puts \"determinant:\\t \n  puts \nend\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 389266, "name": "Deceptive numbers", "source": "Translate Ruby to Python: require 'prime'\n\ndeceptives = Enumerator.new do |y|\n  10.step(by: 10) do |n|\n    [1,3,7,9].each do |digit|\n      cand = n + digit\n      next if cand % 3 == 0 || cand.prime? \n      repunit = (\"1\"*(cand-1)).to_i\n      y << cand if (repunit % cand) == 0\n    end\n  end\nend\n\np deceptives.take(25).to_a\n", "target": "from itertools import count, islice\nfrom math import isqrt\n\ndef is_deceptive(n):\n    if n & 1 and n % 3 and n % 5 and pow(10, n - 1, n) == 1:\n        for d in range(7, isqrt(n) + 1, 6):\n            if not (n % d and n % (d + 4)): return True\n    return False\n\nprint(*islice(filter(is_deceptive, count()), 100))\n"}
{"id": 389267, "name": "Deceptive numbers", "source": "Translate Ruby to Python: require 'prime'\n\ndeceptives = Enumerator.new do |y|\n  10.step(by: 10) do |n|\n    [1,3,7,9].each do |digit|\n      cand = n + digit\n      next if cand % 3 == 0 || cand.prime? \n      repunit = (\"1\"*(cand-1)).to_i\n      y << cand if (repunit % cand) == 0\n    end\n  end\nend\n\np deceptives.take(25).to_a\n", "target": "from itertools import count, islice\nfrom math import isqrt\n\ndef is_deceptive(n):\n    if n & 1 and n % 3 and n % 5 and pow(10, n - 1, n) == 1:\n        for d in range(7, isqrt(n) + 1, 6):\n            if not (n % d and n % (d + 4)): return True\n    return False\n\nprint(*islice(filter(is_deceptive, count()), 100))\n"}
{"id": 389268, "name": "Sum of the digits of n is substring of n", "source": "Translate Ruby to Python: p (0...1000).select{|n| n.to_s.match? n.digits.sum.to_s}\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 389269, "name": "Sum of the digits of n is substring of n", "source": "Translate Ruby to Python: p (0...1000).select{|n| n.to_s.match? n.digits.sum.to_s}\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 389270, "name": "Sattolo cycle", "source": "Translate Ruby to Python: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 389271, "name": "Sattolo cycle", "source": "Translate Ruby to Python: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 389272, "name": "FTP", "source": "Translate Ruby to Python: require 'net/ftp'\n\nNet::FTP.open('ftp.ed.ac.uk', \"anonymous\",\"aaa@gmail.com\" ) do |ftp|\n  ftp.passive = true  \n  ftp.chdir('pub/courses')\n  puts ftp.list\n  ftp.getbinaryfile(\"make.notes.tar\")\nend\n", "target": "from ftplib import FTP\nftp = FTP('kernel.org')\nftp.login()\nftp.cwd('/pub/linux/kernel')\nftp.set_pasv(True) \nprint ftp.retrlines('LIST')\nprint ftp.retrbinary('RETR README', open('README', 'wb').write)\nftp.quit()\n"}
{"id": 389273, "name": "Table creation_Postal addresses", "source": "Translate Ruby to Python: require 'pstore'\nrequire 'set'\n\nAddress = Struct.new :id, :street, :city, :state, :zip\n\ndb = PStore.new(\"addresses.pstore\")\ndb.transaction do\n  db[:next] ||= 0       \n  db[:ids] ||= Set[]    \nend\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> conn.execute()\n<sqlite3.Cursor object at 0x013265C0>\n>>>\n"}
{"id": 389274, "name": "Sorting algorithms_Cycle sort", "source": "Translate Ruby to Python: def cycleSort!(array)\n  writes = 0\n  \n  \n  for cycleStart in 0 .. array.size-2\n    item = array[cycleStart]\n    \n    \n    pos = cycleStart\n    for i in cycleStart+1 ... array.size\n      pos += 1  if array[i] < item\n    end\n    \n    \n    next  if pos == cycleStart\n    \n    \n    pos += 1  while item == array[pos]\n    array[pos], item = item, array[pos]\n    writes += 1\n    \n    \n    while pos != cycleStart\n      \n      \n      pos = cycleStart\n      for i in cycleStart+1 ... array.size\n        pos += 1  if array[i] < item\n      end\n      \n      \n      pos += 1  while item == array[pos]\n      array[pos], item = item, array[pos]\n      writes += 1\n    end\n  end\n  writes\nend \n\np a = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\nputs \"writes\u00a0: \np a\n", "target": "def cycleSort(vector):\n    \"Sort a vector in place and return the number of writes.\"\n    writes = 0\n \n    \n    for cycleStart, item in enumerate(vector):\n \n        \n        pos = cycleStart\n        for item2 in vector[cycleStart + 1:]:\n            if item2 < item:\n                pos += 1\n \n        \n        if pos == cycleStart:\n            continue\n \n        \n        while item == vector[pos]:\n            pos += 1\n        vector[pos], item = item, vector[pos]\n        writes += 1\n \n        \n        while pos != cycleStart:\n \n            \n            pos = cycleStart\n            for item2 in vector[cycleStart + 1:]:\n                if item2 < item:\n                    pos += 1\n \n            \n            while item == vector[pos]:\n                pos += 1\n            vector[pos], item = item, vector[pos]\n            writes += 1\n \n    return writes\n\n\nif __name__ == '__main__':\n    x = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\n    xcopy = x[::]\n    writes = cycleSort(xcopy)\n    if xcopy != sorted(x):\n        print('Wrong order!')\n    else:\n        print('%r\\nIs correctly sorted using cycleSort to'\n              '\\n%r\\nUsing %i writes.' % (x, xcopy, writes))\n"}
{"id": 389275, "name": "Sorting algorithms_Cycle sort", "source": "Translate Ruby to Python: def cycleSort!(array)\n  writes = 0\n  \n  \n  for cycleStart in 0 .. array.size-2\n    item = array[cycleStart]\n    \n    \n    pos = cycleStart\n    for i in cycleStart+1 ... array.size\n      pos += 1  if array[i] < item\n    end\n    \n    \n    next  if pos == cycleStart\n    \n    \n    pos += 1  while item == array[pos]\n    array[pos], item = item, array[pos]\n    writes += 1\n    \n    \n    while pos != cycleStart\n      \n      \n      pos = cycleStart\n      for i in cycleStart+1 ... array.size\n        pos += 1  if array[i] < item\n      end\n      \n      \n      pos += 1  while item == array[pos]\n      array[pos], item = item, array[pos]\n      writes += 1\n    end\n  end\n  writes\nend \n\np a = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\nputs \"writes\u00a0: \np a\n", "target": "def cycleSort(vector):\n    \"Sort a vector in place and return the number of writes.\"\n    writes = 0\n \n    \n    for cycleStart, item in enumerate(vector):\n \n        \n        pos = cycleStart\n        for item2 in vector[cycleStart + 1:]:\n            if item2 < item:\n                pos += 1\n \n        \n        if pos == cycleStart:\n            continue\n \n        \n        while item == vector[pos]:\n            pos += 1\n        vector[pos], item = item, vector[pos]\n        writes += 1\n \n        \n        while pos != cycleStart:\n \n            \n            pos = cycleStart\n            for item2 in vector[cycleStart + 1:]:\n                if item2 < item:\n                    pos += 1\n \n            \n            while item == vector[pos]:\n                pos += 1\n            vector[pos], item = item, vector[pos]\n            writes += 1\n \n    return writes\n\n\nif __name__ == '__main__':\n    x = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\n    xcopy = x[::]\n    writes = cycleSort(xcopy)\n    if xcopy != sorted(x):\n        print('Wrong order!')\n    else:\n        print('%r\\nIs correctly sorted using cycleSort to'\n              '\\n%r\\nUsing %i writes.' % (x, xcopy, writes))\n"}
{"id": 389276, "name": "Twin primes", "source": "Translate Ruby to Python: require 'prime'\n\n(1..8).each do |n|\n  count = Prime.each(10**n).each_cons(2).count{|p1, p2| p2-p1 == 2}\n  puts \"Twin primes below 10**\nend\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19]\n\n\ndef count_twin_primes(limit: int) -> int:\n    global primes\n    if limit > primes[-1]:\n        ram_limit = primes[-1] + 90000000 - len(primes)\n        reasonable_limit = min(limit, primes[-1] ** 2, ram_limit) - 1\n\n        while reasonable_limit < limit:\n            ram_limit = primes[-1] + 90000000 - len(primes)\n            if ram_limit > primes[-1]:\n                reasonable_limit = min(limit, primes[-1] ** 2, ram_limit)\n            else:\n                reasonable_limit = min(limit, primes[-1] ** 2)\n\n            sieve = list({x for prime in primes for x in\n                          range(primes[-1] + prime - (primes[-1] % prime), reasonable_limit, prime)})\n            primes += [x - 1 for i, x in enumerate(sieve) if i and x - 1 != sieve[i - 1] and x - 1 < limit]\n\n    count = len([(x, y) for (x, y) in zip(primes, primes[1:]) if x + 2 == y])\n\n    return count\n\n\ndef test(limit: int):\n    count = count_twin_primes(limit)\n    print(f\"Number of twin prime pairs less than {limit} is {count}\\n\")\n\n\ntest(10)\ntest(100)\ntest(1000)\ntest(10000)\ntest(100000)\ntest(1000000)\ntest(10000000)\ntest(100000000)\n"}
{"id": 389277, "name": "Brazilian numbers", "source": "Translate Ruby to Python: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389278, "name": "Brazilian numbers", "source": "Translate Ruby to Python: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389279, "name": "Create a file on magnetic tape", "source": "Translate Ruby to Python: filename = {% if flag?(:win32) %}\n    \"TAPE.FILE\"\n  {% else\u00a0%}   \n    \"/dev/tape\"\n  {% end %}        \nFile.write filename, \"howdy, planet!\"\n", "target": ">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\\n')\n... \n>>>\n"}
{"id": 389280, "name": "Recaman's sequence", "source": "Translate Ruby to Python: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 389281, "name": "Recaman's sequence", "source": "Translate Ruby to Python: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 389282, "name": "Y combinator", "source": "Translate Ruby to Python: y = lambda do |f|\n  lambda {|g| g[g]}[lambda do |g|\n      f[lambda {|*args| g[g][*args]}]\n    end]\nend\n\nfac = lambda{|f| lambda{|n| n < 2 ? 1 : n * f[n-1]}}\np Array.new(10) {|i| y[fac][i]}   \n\nfib = lambda{|f| lambda{|n| n < 2 ? n : f[n-1] + f[n-2]}}\np Array.new(10) {|i| y[fib][i]}   \n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))\n>>> [ Y(fac)(i) for i in range(10) ]\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))\n>>> [ Y(fib)(i) for i in range(10) ]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 389283, "name": "Total circles area", "source": "Translate Ruby to Python: circles = [\n  [ 1.6417233788,  1.6121789534, 0.0848270516],\n  [-1.4944608174,  1.2077959613, 1.1039549836],\n  [ 0.6110294452, -0.6907087527, 0.9089162485],\n  [ 0.3844862411,  0.2923344616, 0.2375743054],\n  [-0.2495892950, -0.3832854473, 1.0845181219],\n  [ 1.7813504266,  1.6178237031, 0.8162655711],\n  [-0.1985249206, -0.8343333301, 0.0538864941],\n  [-1.7011985145, -0.1263820964, 0.4776976918],\n  [-0.4319462812,  1.4104420482, 0.7886291537],\n  [ 0.2178372997, -0.9499557344, 0.0357871187],\n  [-0.6294854565, -1.3078893852, 0.7653357688],\n  [ 1.7952608455,  0.6281269104, 0.2727652452],\n  [ 1.4168575317,  1.0683357171, 1.1016025378],\n  [ 1.4637371396,  0.9463877418, 1.1846214562],\n  [-0.5263668798,  1.7315156631, 1.4428514068],\n  [-1.2197352481,  0.9144146579, 1.0727263474],\n  [-0.1389358881,  0.1092805780, 0.7350208828],\n  [ 1.5293954595,  0.0030278255, 1.2472867347],\n  [-0.5258728625,  1.3782633069, 1.3495508831],\n  [-0.1403562064,  0.2437382535, 1.3804956588],\n  [ 0.8055826339, -0.0482092025, 0.3327165165],\n  [-0.6311979224,  0.7184578971, 0.2491045282],\n  [ 1.4685857879, -0.8347049536, 1.3670667538],\n  [-0.6855727502,  1.6465021616, 1.0593087096],\n  [ 0.0152957411,  0.0638919221, 0.9771215985],\n]\n\ndef minmax_circle(circles)\n  xmin = circles.map {|xc, yc, radius| xc - radius}.min\n  xmax = circles.map {|xc, yc, radius| xc + radius}.max\n  ymin = circles.map {|xc, yc, radius| yc - radius}.min\n  ymax = circles.map {|xc, yc, radius| yc + radius}.max\n  [xmin, xmax, ymin, ymax]\nend\n\n\ndef select_circle(circles)\n  circles = circles.sort_by{|cx,cy,r| -r}\n  size = circles.size\n  select = [*0...size]\n  for i in 0...size-1\n    xi,yi,ri = circles[i].to_a\n    for j in i+1...size\n      xj,yj,rj = circles[j].to_a\n      select -= [j]  if (xi-xj)**2 + (yi-yj)**2 <= (ri-rj)**2\n    end\n  end\n  circles.values_at(*select)\nend\ncircles = select_circle(circles)\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 389284, "name": "Total circles area", "source": "Translate Ruby to Python: circles = [\n  [ 1.6417233788,  1.6121789534, 0.0848270516],\n  [-1.4944608174,  1.2077959613, 1.1039549836],\n  [ 0.6110294452, -0.6907087527, 0.9089162485],\n  [ 0.3844862411,  0.2923344616, 0.2375743054],\n  [-0.2495892950, -0.3832854473, 1.0845181219],\n  [ 1.7813504266,  1.6178237031, 0.8162655711],\n  [-0.1985249206, -0.8343333301, 0.0538864941],\n  [-1.7011985145, -0.1263820964, 0.4776976918],\n  [-0.4319462812,  1.4104420482, 0.7886291537],\n  [ 0.2178372997, -0.9499557344, 0.0357871187],\n  [-0.6294854565, -1.3078893852, 0.7653357688],\n  [ 1.7952608455,  0.6281269104, 0.2727652452],\n  [ 1.4168575317,  1.0683357171, 1.1016025378],\n  [ 1.4637371396,  0.9463877418, 1.1846214562],\n  [-0.5263668798,  1.7315156631, 1.4428514068],\n  [-1.2197352481,  0.9144146579, 1.0727263474],\n  [-0.1389358881,  0.1092805780, 0.7350208828],\n  [ 1.5293954595,  0.0030278255, 1.2472867347],\n  [-0.5258728625,  1.3782633069, 1.3495508831],\n  [-0.1403562064,  0.2437382535, 1.3804956588],\n  [ 0.8055826339, -0.0482092025, 0.3327165165],\n  [-0.6311979224,  0.7184578971, 0.2491045282],\n  [ 1.4685857879, -0.8347049536, 1.3670667538],\n  [-0.6855727502,  1.6465021616, 1.0593087096],\n  [ 0.0152957411,  0.0638919221, 0.9771215985],\n]\n\ndef minmax_circle(circles)\n  xmin = circles.map {|xc, yc, radius| xc - radius}.min\n  xmax = circles.map {|xc, yc, radius| xc + radius}.max\n  ymin = circles.map {|xc, yc, radius| yc - radius}.min\n  ymax = circles.map {|xc, yc, radius| yc + radius}.max\n  [xmin, xmax, ymin, ymax]\nend\n\n\ndef select_circle(circles)\n  circles = circles.sort_by{|cx,cy,r| -r}\n  size = circles.size\n  select = [*0...size]\n  for i in 0...size-1\n    xi,yi,ri = circles[i].to_a\n    for j in i+1...size\n      xj,yj,rj = circles[j].to_a\n      select -= [j]  if (xi-xj)**2 + (yi-yj)**2 <= (ri-rj)**2\n    end\n  end\n  circles.values_at(*select)\nend\ncircles = select_circle(circles)\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 389285, "name": "Factorions", "source": "Translate Ruby to Python: def factorion?(n, base)\n  n.digits(base).sum{|digit| (1..digit).inject(1, :*)} == n \nend\n\n(9..12).each do |base|\n  puts \"Base \nend\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 389286, "name": "Factorions", "source": "Translate Ruby to Python: def factorion?(n, base)\n  n.digits(base).sum{|digit| (1..digit).inject(1, :*)} == n \nend\n\n(9..12).each do |base|\n  puts \"Base \nend\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 389287, "name": "Sum of divisors", "source": "Translate Ruby to Python: def divisor_sum(n)\n    total = 1\n    power = 2\n    \n    while (n & 1) == 0\n        total = total + power\n\n        power = power << 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n\n        sum = 1\n\n        power = p\n        while n % p == 0\n            sum = sum + power\n\n            power = power * p\n            n = (n / p).floor\n        end\n        total = total * sum\n\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * (n + 1)\n    end\n    return total\nend\n\nLIMIT = 100\nprint \"Sum of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%4d\" % [divisor_sum(n)]\n    if n % 10 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 389288, "name": "Sum of divisors", "source": "Translate Ruby to Python: def divisor_sum(n)\n    total = 1\n    power = 2\n    \n    while (n & 1) == 0\n        total = total + power\n\n        power = power << 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n\n        sum = 1\n\n        power = p\n        while n % p == 0\n            sum = sum + power\n\n            power = power * p\n            n = (n / p).floor\n        end\n        total = total * sum\n\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * (n + 1)\n    end\n    return total\nend\n\nLIMIT = 100\nprint \"Sum of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%4d\" % [divisor_sum(n)]\n    if n % 10 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 389289, "name": "Order by pair comparisons", "source": "Translate Ruby to Python: items = [\"violet\", \"red\", \"green\", \"indigo\", \"blue\", \"yellow\", \"orange\"]\ncount = 0\nsortedItems = []\nitems.each {|item|\n  puts \"Inserting '\n  spotToInsert = sortedItems.bsearch_index{|x|\n    count += 1\n    print \"(\n    gets.start_with?('y')\n  } || sortedItems.length \n  sortedItems.insert(spotToInsert, item)\n}\np sortedItems\n", "target": "def _insort_right(a, x, q):\n    \n\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        q += 1\n        less = input(f\"{q:2}: IS {x:>6} LESS-THAN {a[mid]:>6}\u00a0? y/n: \").strip().lower() == 'y'\n        if less: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n    return q\n\ndef order(items):\n    ordered, q = [], 0\n    for item in items:\n        q = _insort_right(ordered, item, q)\n    return ordered, q\n\nif __name__ == '__main__':\n    items = 'violet red green indigo blue yellow orange'.split()\n    ans, questions = order(items)\n    print('\\n' + ' '.join(ans))\n"}
{"id": 389290, "name": "Fermat numbers", "source": "Translate Ruby to Python: require \"big\"\n\ndef factors(n)\n    factors = `factor \n    factors.group_by(&.itself).map { |prime, exp| [prime, exp.size] }\nend\n\ndef fermat(n); (1.to_big_i << (1 << n)) | 1 end\n\nputs \"Value for each Fermat Number F0 .. F9.\"\n(0..9).each { |n| puts \"F\nputs\nputs \"Factors for each Fermat Number F0 .. F8.\"\n(0..8).each { |n| puts \"F\n", "target": "def factors(x):\n    factors = []\n    i = 2\n    s = int(x ** 0.5)\n    while i < s:\n        if x % i == 0:\n            factors.append(i)\n            x = int(x / i)\n            s = int(x ** 0.5)\n        i += 1\n    factors.append(x)\n    return factors\n\nprint(\"First 10 Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    print(\"F{} = {}\".format(chr(i + 0x2080) , fermat))\n\nprint(\"\\nFactors of first few Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    fac = factors(fermat)\n    if len(fac) == 1:\n        print(\"F{} -> IS PRIME\".format(chr(i + 0x2080)))\n    else:\n        print(\"F{} -> FACTORS: {}\".format(chr(i + 0x2080), fac))\n"}
{"id": 389291, "name": "Sorting algorithms_Bead sort", "source": "Translate Ruby to Python: class Array\n  def beadsort\n    map {|e| [1] * e}.columns.columns.map(&:length)\n  end\n  \n  def columns\n    y = length\n    x = map(&:length).max\n    Array.new(x) do |row|\n      Array.new(y) { |column| self[column][row] }.compact \n    end\n  end\nend\n\n\np [5,3,1,7,4,1,1].beadsort\n", "target": "\nfrom itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))\n"}
{"id": 389292, "name": "Casting out nines", "source": "Translate Ruby to Python: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 389293, "name": "Casting out nines", "source": "Translate Ruby to Python: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 389294, "name": "Simple database", "source": "Translate Ruby to Python: require 'date'\nrequire 'json'\nrequire 'securerandom'\n\nclass SimpleDatabase\n  def initialize(dbname, *fields)\n    @dbname = dbname\n    @filename = @dbname + \".dat\"\n    @fields = fields\n    @maxl = @fields.collect {|f| f.length}.max\n    @data = {\n      'fields' => fields,\n      'items' => {},\n      'history' => [],\n      'tags' => {},\n    }\n  end\n  attr_reader :dbname, :fields\n\n  def self.open(dbname)\n    db = new(dbname)\n    db.read\n    db\n  end\n\n  def read()\n    if not File.exists?(@filename)\n      raise ArgumentError, \"Database \n    end\n    @data = JSON.parse(File.read(@filename))\n    @fields = @data['fields']\n    @maxl = @fields.collect {|f| f.length}.max\n  end\n\n  def write()\n    File.open(@filename, 'w') {|f| f.write(JSON.generate(@data))}\n  end\n\n  def add(*values)\n    id = SecureRandom.uuid\n    @data['items'][id] = Hash[ @fields.zip(values) ]\n    @data['history'] << [Time.now.to_f, id]\n    id\n  end\n\n  def tag(id, *tags)\n    tags.each do |tag|\n      if @data['tags'][tag].nil?\n        @data['tags'][tag] = [id]\n      else\n        @data['tags'][tag] << id\n      end\n    end\n    id\n  end\n\n  def latest\n    @data['history'].sort_by {|val| val[0]}.last.last\n  end\n\n  def get_item(id)\n    @data['items'][id]\n  end\n\n  def tags()\n    @data['tags'].keys.sort\n  end\n\n  def ids_for_tag(tag)\n    @data['tags'][tag]\n  end\n\n  def tags_for_id(id)\n    @data['tags'].keys.inject([]) do |tags, tag| \n      tags << tag if @data['tags'][tag].include?(id)\n      tags\n    end\n  end\n\n  def display(id)\n    item = get_item(id)\n    fmt = \"%\n    puts fmt % ['id', id]\n    @fields.each {|f| print fmt % [f, item[f]]}\n    puts fmt % ['tags', tags_for_id(id).join(',')]\n    added = @data['history'].find {|x| x[1] == id}.first\n    puts fmt % ['date added', Time.at(added).ctime]\n    puts \"\"\n  end\n\n  def each()\n    @data['history'].each {|time, id| yield id}\n  end\n\n  def each_item_with_tag(tag)\n    @data['tags'][tag].each {|id| yield id}\n  end\nend\ndef usage()\n  puts <<END\nusage: \n\ncommands:\n  help \n  create dbname field ...\n  fields dbname\n  add dbname value ...\n  tag dbname id tag ...\n  tags dbname\n  list dbname [tag ...]\n  latest dbname\n  latest_by_tag dbname\nEND\nend\n\ndef open_database(args)\n  dbname = args.shift\n  begin\n    SimpleDatabase.open(dbname)\n  rescue ArgumentError => e\n    STDERR.puts e.message\n    exit 1\n  end\nend\n\ndef process_command_line(command, *args)\n  case command\n  when 'help'\n    usage\n\n  when 'create'\n    db = SimpleDatabase.new(*args)\n    db.write\n    puts \"Database \n\n  when 'fields'\n    db = open_database(args)\n    puts \"Database \n    puts db.fields.join(',')\n\n  when 'add'\n    db = open_database(args)\n    id = db.add(*args)\n    db.write\n    puts \"Database \n\n  when 'tag'\n    db = open_database(args)\n    id = args.shift\n    db.tag(id, *args)\n    db.write\n    db.display(id)\n    \n  when 'tags'\n    db = open_database(args)\n    puts \"Database \n    puts db.tags.join(',')\n\n  when 'list'\n    db = open_database(args)\n    if args.empty?\n      db.each {|id| db.display(id)}\n    else\n      args.each do |tag| \n        puts \"Items tagged \n        db.each_item_with_tag(tag) {|id| db.display(id)}\n      end\n    end\n\n  when 'latest'\n    db = open_database(args)\n    db.display(db.latest)\n\n  when 'latest_by_tag'\n    db = open_database(args)\n    db.tags.each do |tag|\n      puts tag\n      db.display(db.ids_for_tag(tag).last)\n    end\n\n  else\n    puts \"Error: unknown command '\n    usage\n  end\nend\n\nprocess_command_line *ARGV\n", "target": "\n\n\n\nimport argparse\nfrom argparse import Namespace\nimport datetime\nimport shlex\n\n\ndef parse_args():\n    'Set up, parse, and return arguments'\n    \n    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])\n\n    parser.add_argument('command', choices='add pl plc pa'.split(),\n                        help=)\n    parser.add_argument('-d', '--description',\n                        help='A description of the item. (e.g., title, name)')\n    parser.add_argument('-t', '--tag',\n                        help=(\n                              ))\n    parser.add_argument('-f', '--field', nargs=2, action='append', \n                        help='Other optional fields with value (can be repeated)')\n\n    return parser\n\ndef do_add(args, dbname):\n    'Add a new entry'\n    if args.description is None:\n        args.description = ''\n    if args.tag is None:\n        args.tag = ''\n    del args.command\n    print('Writing record to %s' % dbname)\n    with open(dbname, 'a') as db:\n        db.write('%r\\n' % args)\n    \ndef do_pl(args, dbname):\n    'Print the latest entry'\n    print('Getting last record from %s' % dbname)\n    with open(dbname, 'r') as db:\n        for line in db: pass\n    record = eval(line)\n    del record._date\n    print(str(record))\n    \ndef do_plc(args, dbname):\n    'Print the latest entry for each category/tag'\n    print('Getting latest record for each tag from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    tags = set(record.tag for record in records)\n    records.reverse()\n    for record in records:\n        if record.tag in tags:\n            del record._date\n            print(str(record))\n            tags.discard(record.tag)\n            if not tags: break\n\ndef do_pa(args, dbname):\n    'Print all entries sorted by a date'\n    print('Getting all records by date from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    for record in records:\n        del record._date\n        print(str(record))\n\ndef test():\n    import time\n    parser = parse_args()\n    for cmdline in [\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    ]:\n        args = parser.parse_args(shlex.split(cmdline))\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n        time.sleep(0.5)\n\n\n    \ndo_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)\ndbname = '_simple_db_db.py'\n\n\nif __name__ == '__main__':\n    if 0:\n        test()\n    else:\n        parser = parse_args()\n        args = parser.parse_args()\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n"}
{"id": 389295, "name": "Keyboard macros", "source": "Translate Ruby to Python: Shoes.app do\n  @info = para \"NO KEY is PRESSED.\"\n  keypress do |k|\n    @info.replace \"\n  end\nend\n", "target": "\nimport curses\n\ndef print_message():\n    stdscr.addstr('This is the message.\\n')\n\nstdscr = curses.initscr()\ncurses.noecho()\ncurses.cbreak()\nstdscr.keypad(1)\n\nstdscr.addstr('CTRL+P for message or q to quit.\\n')\nwhile True:\n    c = stdscr.getch()\n    if c == 16: print_message()\n    elif c == ord('q'): break\n\ncurses.nocbreak()\nstdscr.keypad(0)\ncurses.echo()\ncurses.endwin()\n"}
{"id": 389296, "name": "Tau function", "source": "Translate Ruby to Python: require 'prime'\n\ndef tau(n) = n.prime_division.inject(1){|res, (d, exp)| res *= exp + 1}\n\n(1..100).map{|n| tau(n).to_s.rjust(3) }.each_slice(20){|ar| puts ar.join}\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 389297, "name": "Tau function", "source": "Translate Ruby to Python: require 'prime'\n\ndef tau(n) = n.prime_division.inject(1){|res, (d, exp)| res *= exp + 1}\n\n(1..100).map{|n| tau(n).to_s.rjust(3) }.each_slice(20){|ar| puts ar.join}\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 389298, "name": "M\u00f6bius function", "source": "Translate Ruby to Python: require 'prime'\n\ndef \u03bc(n)\n  pd = n.prime_division\n  return 0 unless pd.map(&:last).all?(1)\n  pd.size.even? ? 1 : -1\nend\n\n([\"  \"] + (1..199).map{|n|\"%2s\" % \u03bc(n)}).each_slice(20){|line| puts line.join(\" \") }\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\ndef isPrime(n) :\n \n    if (n < 2) :\n        return False\n    for i in range(2, n + 1) :\n        if (i * i <= n and n % i == 0) :\n            return False\n    return True\n \ndef mobius(N) :\n     \n    \n    if (N == 1) :\n        return 1\n \n    \n    \n    \n    p = 0\n    for i in range(1, N + 1) :\n        if (N % i == 0 and\n                isPrime(i)) :\n \n            \n            \n            if (N % (i * i) == 0) :\n                return 0\n            else :\n \n                \n                \n                p = p + 1\n \n    \n    \n    \n    \n    if(p % 2 != 0) :\n        return -1\n    else :\n        return 1\n \n\nprint(\"Mobius numbers from 1..99:\")\n      \nfor i in range(1, 100):\n  print(f\"{mobius(i):>4}\", end = '')\n\n  if i % 20 == 0: print()\n\n\n"}
{"id": 389299, "name": "Coprime triplets", "source": "Translate Ruby to Python: list = [1, 2]\navailable = (1..50).to_a - list\n\nloop do\n  i = available.index{|a| list.last(2).all?{|b| a.gcd(b) == 1}}\n  break if i.nil?\n  list << available.delete_at(i)\nend\n\nputs list.join(\" \")\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 389300, "name": "Coprime triplets", "source": "Translate Ruby to Python: list = [1, 2]\navailable = (1..50).to_a - list\n\nloop do\n  i = available.index{|a| list.last(2).all?{|b| a.gcd(b) == 1}}\n  break if i.nil?\n  list << available.delete_at(i)\nend\n\nputs list.join(\" \")\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 389301, "name": "Curzon numbers", "source": "Translate Ruby to Python: def curzons(k)\n  Enumerator.new do |y|\n    (1..).each do |n|\n      r = k * n\n      y << n if k.pow(n, r + 1) == r\n    end\n  end\nend\n\n[2,4,6,8,10].each do |base|\n  puts \"Curzon numbers with k = \n  puts curzons(base).take(50).join(\", \")\n  puts \"Thousandth Curzon with k = \nend\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 389302, "name": "Curzon numbers", "source": "Translate Ruby to Python: def curzons(k)\n  Enumerator.new do |y|\n    (1..).each do |n|\n      r = k * n\n      y << n if k.pow(n, r + 1) == r\n    end\n  end\nend\n\n[2,4,6,8,10].each do |base|\n  puts \"Curzon numbers with k = \n  puts curzons(base).take(50).join(\", \")\n  puts \"Thousandth Curzon with k = \nend\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 389303, "name": "Mertens function", "source": "Translate Ruby to Python: require 'prime'\n\ndef \u03bc(n)\n  return 1 if self == 1\n  pd = n.prime_division\n  return 0 unless pd.map(&:last).all?(1)\n  pd.size.even? ? 1 : -1\nend\n\ndef M(n)\n  (1..n).sum{|n| \u03bc(n)}\nend\n\n([\"  \"] + (1..199).map{|n|\"%2s\" % M(n)}).each_slice(20){|line| puts line.join(\" \") }\n\nar = (1..1000).map{|n| M(n)}\nputs \"\\nThe Mertens function is zero \nputs \"it crosses zero \n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 389304, "name": "Product of divisors", "source": "Translate Ruby to Python: def divisor_count(n)\n    total = 1\n    \n    while n % 2 == 0 do\n        total = total + 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n do\n        count = 1\n        while n % p == 0 do\n            count = count + 1\n            n = n / p\n        end\n        total = total * count\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * 2\n    end\n    return total\nend\n\ndef divisor_product(n)\n    return (n ** (divisor_count(n) / 2.0)).floor\nend\n\nLIMIT = 50\nprint \"Product of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%11d\" % [divisor_product(n)]\n    if n % 5 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 389305, "name": "Product of divisors", "source": "Translate Ruby to Python: def divisor_count(n)\n    total = 1\n    \n    while n % 2 == 0 do\n        total = total + 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n do\n        count = 1\n        while n % p == 0 do\n            count = count + 1\n            n = n / p\n        end\n        total = total * count\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * 2\n    end\n    return total\nend\n\ndef divisor_product(n)\n    return (n ** (divisor_count(n) / 2.0)).floor\nend\n\nLIMIT = 50\nprint \"Product of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%11d\" % [divisor_product(n)]\n    if n % 5 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 389306, "name": "Playing cards", "source": "Translate Ruby to Python: class Card\n  \n  SUITS = %i[ Clubs Hearts Spades Diamonds ]\n  PIPS  = %i[ 2 3 4 5 6 7 8 9 10 Jack Queen King Ace ]\n  \n  \n  @@suit_value = Hash[ SUITS.each_with_index.to_a ]\n  @@pip_value  = Hash[ PIPS.each_with_index.to_a ]\n  \n  attr_reader :pip, :suit\n  \n  def initialize(pip,suit)\n    @pip = pip\n    @suit = suit\n  end\n  \n  def to_s\n    \"\n  end\n  \n  \n  def <=>(other)\n    (@@suit_value[@suit] <=> @@suit_value[other.suit]).nonzero? or\n    @@pip_value[@pip] <=> @@pip_value[other.pip]\n  end\nend\n\nclass Deck\n  def initialize\n    @deck = Card::SUITS.product(Card::PIPS).map{|suit,pip| Card.new(pip,suit)}\n  end\n  \n  def to_s\n    @deck.inspect\n  end\n  \n  def shuffle!\n    @deck.shuffle!\n    self\n  end\n  \n  def deal(*args)\n    @deck.shift(*args)\n  end\nend\n\ndeck = Deck.new.shuffle!\nputs card = deck.deal\nhand = deck.deal(5)\nputs hand.join(\", \")\nputs hand.sort.join(\", \")\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 389307, "name": "Code Golf_ Code Golf", "source": "Translate Ruby to Python: $><<\"Code Golf\"        \nputs\n\n$><<['436F646520476F6C66'].pack('H*')  \n", "target": "print(end=\"Code Golf\")\n"}
{"id": 389308, "name": "Code Golf_ Code Golf", "source": "Translate Ruby to Python: $><<\"Code Golf\"        \nputs\n\n$><<['436F646520476F6C66'].pack('H*')  \n", "target": "print(end=\"Code Golf\")\n"}
{"id": 389309, "name": "Coprimes", "source": "Translate Ruby to Python: pairs = [[21,15],[17,23],[36,12],[18,29],[60,15]]\npairs.select{|p, q| p.gcd(q) == 1}.each{|pair| p pair}\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389310, "name": "Coprimes", "source": "Translate Ruby to Python: pairs = [[21,15],[17,23],[36,12],[18,29],[60,15]]\npairs.select{|p, q| p.gcd(q) == 1}.each{|pair| p pair}\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389311, "name": "Perfect totient numbers", "source": "Translate Ruby to Python: require \"prime\"\n\nclass Integer \n\n  def \u03c6\n    prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \n  end\n\n  def perfect_totient?\n    f, sum = self, 0\n    until f == 1 do\n      f = f.\u03c6\n      sum += f\n    end\n    self == sum\n  end\n\nend\n\nputs (1..).lazy.select(&:perfect_totient?).first(20).join(\", \")\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 389312, "name": "Perfect totient numbers", "source": "Translate Ruby to Python: require \"prime\"\n\nclass Integer \n\n  def \u03c6\n    prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \n  end\n\n  def perfect_totient?\n    f, sum = self, 0\n    until f == 1 do\n      f = f.\u03c6\n      sum += f\n    end\n    self == sum\n  end\n\nend\n\nputs (1..).lazy.select(&:perfect_totient?).first(20).join(\", \")\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 389313, "name": "Lah numbers", "source": "Translate Ruby to Python: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389314, "name": "Lah numbers", "source": "Translate Ruby to Python: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389315, "name": "Two sum", "source": "Translate Ruby to Python: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 389316, "name": "Two sum", "source": "Translate Ruby to Python: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 389317, "name": "Terminal control_Unicode output", "source": "Translate Ruby to Python: \n\nif ENV.values_at(\"LC_ALL\",\"LC_CTYPE\",\"LANG\").compact.first.include?(\"UTF-8\")\n  puts \"\u25b3\"\nelse\n  raise \"Terminal can't handle UTF-8\"\nend\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 389318, "name": "Terminal control_Unicode output", "source": "Translate Ruby to Python: \n\nif ENV.values_at(\"LC_ALL\",\"LC_CTYPE\",\"LANG\").compact.first.include?(\"UTF-8\")\n  puts \"\u25b3\"\nelse\n  raise \"Terminal can't handle UTF-8\"\nend\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 389319, "name": "Unprimeable numbers", "source": "Translate Ruby to Python: require 'prime'\n\ndef unprimable?(n)\n  digits = %w(0 1 2 3 4 5 6 7 8 9)\n  s = n.to_s\n  size = s.size\n  (size-1).downto(0) do |i|\n    digits.each do |d|\n      cand = s.dup\n      cand[i]=d\n      return false if cand.to_i.prime?\n    end\n  end\n  true\nend\nups = Enumerator.new {|y| (1..).each{|n| y << n if unprimable?(n)} }\n\nar = ups.first(600)\nputs \"First 35 unprimables:\", ar[0,35].join(\" \")\nputs \"\\n600th unprimable:\", ar.last, \"\"\n(0..9).each do |d|\n  print \"First unprimeable with last digit \n  puts (1..).detect{|k| unprimable?(k*10+d)}*10 + d\nend\n", "target": "from itertools import count, islice\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n, _seen={0: False, 1: False}):\n    def _isprime(n):\n        for p in primes():\n            if p*p > n:\n                return True\n            if n%p == 0:\n                return False\n\n    if n not in _seen:\n        _seen[n] = _isprime(n)\n    return _seen[n]\n\ndef unprime():\n    for a in count(1):\n        d = 1\n        while d <= a:\n            base = (a//(d*10))*(d*10) + (a%d) \n            if any(isprime(y) for y in range(base, base + d*10, d)):\n                break\n            d *= 10\n        else:\n            yield a\n\n\nprint('First 35:')\nprint(' '.join(str(i) for i in islice(unprime(), 35)))\n\nprint('\\nThe 600-th:')\nprint(list(islice(unprime(), 599, 600))[0])\nprint()\n\nfirst, need = [False]*10, 10\nfor p in unprime():\n    i = p%10\n    if first[i]: continue\n\n    first[i] = p\n    need -= 1\n    if not need:\n        break\n\nfor i,v in enumerate(first):\n    print(f'{i} ending: {v}')\n"}
{"id": 389320, "name": "Tau number", "source": "Translate Ruby to Python: require 'prime'\n\ntaus = Enumerator.new do |y|\n  (1..).each do |n|\n    num_divisors = n.prime_division.inject(1){|prod, n| prod *= n[1] + 1 }\n    y << n if n % num_divisors == 0\n  end\nend\n\np taus.take(100)\n", "target": "def tau(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans, i, j = 0, 1, 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans += 1\n            j = n//i\n            if j != i:\n                ans += 1\n        i += 1\n    return ans\n\ndef is_tau_number(n):\n    assert(isinstance(n, int))\n    if n <= 0:\n        return False\n    return 0 == n%tau(n)\n\nif __name__ == \"__main__\":\n    n = 1\n    ans = []\n    while len(ans) < 100:\n        if is_tau_number(n):\n            ans.append(n)\n        n += 1\n    print(ans)\n"}
{"id": 389321, "name": "Primes whose sum of digits is 25", "source": "Translate Ruby to Python: require 'prime'\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum += n % 10\n        n /= 10\n    end\n    return sum\nend\n\nfor p in Prime.take_while { |p| p < 5000 }\n    if digitSum(p) == 25 then\n        print p, \"  \"\n    end\nend\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389322, "name": "Primes whose sum of digits is 25", "source": "Translate Ruby to Python: require 'prime'\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum += n % 10\n        n /= 10\n    end\n    return sum\nend\n\nfor p in Prime.take_while { |p| p < 5000 }\n    if digitSum(p) == 25 then\n        print p, \"  \"\n    end\nend\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389323, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to Python: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 389324, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to Python: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 389325, "name": "Deepcopy", "source": "Translate Ruby to Python: \norig = { :num => 1, :ary => [2, 3] }\norig[:cycle] = orig\t\n\n\ncopy = Marshal.load(Marshal.dump orig)\n\n\n\norig[:ary] << 4\norig[:rng] = (5..6)\n\n\n\np orig\t\np copy\t\n\n\n\np [(orig.equal? orig[:cycle]),\n   (copy.equal? copy[:cycle]),\n   (not orig.equal? copy)]\t\n", "target": "import copy\ndeepcopy_of_obj = copy.deepcopy(obj)\n"}
{"id": 389326, "name": "Deepcopy", "source": "Translate Ruby to Python: \norig = { :num => 1, :ary => [2, 3] }\norig[:cycle] = orig\t\n\n\ncopy = Marshal.load(Marshal.dump orig)\n\n\n\norig[:ary] << 4\norig[:rng] = (5..6)\n\n\n\np orig\t\np copy\t\n\n\n\np [(orig.equal? orig[:cycle]),\n   (copy.equal? copy[:cycle]),\n   (not orig.equal? copy)]\t\n", "target": "import copy\ndeepcopy_of_obj = copy.deepcopy(obj)\n"}
{"id": 389327, "name": "Circular primes", "source": "Translate Ruby to Python: require 'gmp'\nrequire 'prime'\ncandidate_primes = Enumerator.new do |y|\n  DIGS = [1,3,7,9]\n  [2,3,5,7].each{|n| y << n.to_s}\n  (2..).each do |size|\n    DIGS.repeated_permutation(size) do |perm|\n      y << perm.join if (perm == min_rotation(perm)) && GMP::Z(perm.join).probab_prime? > 0\n    end\n  end\nend\n\ndef min_rotation(ar) = Array.new(ar.size){|n| ar.rotate(n)}.min\n\ndef circular?(num_str)\n  chars = num_str.chars\n  return GMP::Z(num_str).probab_prime? > 0 if chars.all?(\"1\")\n  chars.size.times.all? do \n   GMP::Z(chars.rotate!.join).probab_prime? > 0\n   \n  end\nend\n\nputs \"First 19 circular primes:\"\nputs candidate_primes.lazy.select{|cand| circular?(cand)}.take(19).to_a.join(\", \"),\"\"\nputs \"First 5 prime repunits:\"\nreps = Prime.each.lazy.select{|pr| circular?(\"1\"*pr)}.take(5).to_a\nputs  reps.map{|r| \"R\" + r.to_s}.join(\", \"), \"\"\n[5003, 9887, 15073, 25031].each {|rep| puts \"R\n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True\n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef isPrime(n: int) -> bool:\n    \n    \n    if (n <= 1) :\n        return False\n    if (n <= 3) :\n        return True\n    \n    \n    if (n % 2 == 0 or n % 3 == 0) :\n        return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\ndef rotations(n: int)-> set((int,)):\n    \n    a = str(n)\n    return set(int(a[i:] + a[:i]) for i in range(len(a)))\n\ndef isCircular(n: int) -> bool:\n    \n    return all(isPrime(int(o)) for o in rotations(n))\n\nfrom itertools import product\n\ndef main():\n    result = [2, 3, 5, 7]\n    first = '137'\n    latter = '1379'\n    for i in range(1, 6):\n        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))\n        while s:\n            a = s.pop()\n            b = rotations(a)\n            if isCircular(a):\n                result.append(min(b))\n            s -= b\n    result.sort()\n    return result\n\nassert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()\n\n\nrepunit = lambda n: int('1' * n)\n\ndef repmain(n: int) -> list:\n    \n    result = []\n    i = 2\n    while len(result) < n:\n        if is_Prime(repunit(i)):\n            result.append(i)\n        i += 1\n    return result\n\nassert [2, 19, 23, 317, 1031] == repmain(5)\n\n\n"}
{"id": 389328, "name": "Frobenius numbers", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 389329, "name": "Frobenius numbers", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 389330, "name": "Sorting algorithms_Permutation sort", "source": "Translate Ruby to Python: class Array\n  def permutationsort\n    permutation.each{|perm| return perm if perm.sorted?}\n  end\n  \n  def sorted?\n    each_cons(2).all? {|a, b| a <= b}\n  end\nend\n", "target": "from itertools import permutations\n\nin_order = lambda s: all(x <= s[i+1] for i,x in enumerate(s[:-1]))\nperm_sort = lambda s: (p for p in permutations(s) if in_order(p)).next()\n"}
{"id": 389331, "name": "Integer roots", "source": "Translate Ruby to Python: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 389332, "name": "Integer roots", "source": "Translate Ruby to Python: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 389333, "name": "Fortunate numbers", "source": "Translate Ruby to Python: require \"gmp\"\n\nprimorials = Enumerator.new do |y|\n  cur = prod = 1\n  loop {y << prod *= (cur = GMP::Z(cur).nextprime)}\nend\n\nlimit = 50\nfortunates = []\nwhile fortunates.size < limit*2 do\n  prim = primorials.next\n  fortunates << (GMP::Z(prim+2).nextprime - prim)\n  fortunates = fortunates.uniq.sort\nend\n  \np fortunates[0, limit]\n", "target": "from sympy.ntheory.generate import primorial\nfrom sympy.ntheory import isprime\n\ndef fortunate_number(n):\n    \n    \n    \n    i = 3\n    primorial_ = primorial(n)\n    while True:\n        if isprime(primorial_ + i):\n            return i\n        i += 2\n\nfortunate_numbers = set()\nfor i in range(1, 76):\n    fortunate_numbers.add(fortunate_number(i))\n\n\nfirst50 = sorted(list(fortunate_numbers))[:50]\n\nprint('The first 50 fortunate numbers:')\nprint(('{:<3} ' * 10).format(*(first50[:10])))\nprint(('{:<3} ' * 10).format(*(first50[10:20])))\nprint(('{:<3} ' * 10).format(*(first50[20:30])))\nprint(('{:<3} ' * 10).format(*(first50[30:40])))\nprint(('{:<3} ' * 10).format(*(first50[40:])))\n"}
{"id": 389334, "name": "Modulinos", "source": "Translate Ruby to Python: \n\ndef meaning_of_life\n  42\nend\n\nif __FILE__ == $0\n  puts \"Main: The meaning of life is \nend\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 389335, "name": "Modulinos", "source": "Translate Ruby to Python: \n\ndef meaning_of_life\n  42\nend\n\nif __FILE__ == $0\n  puts \"Main: The meaning of life is \nend\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 389336, "name": "Function frequency", "source": "Translate Ruby to Python: func foo { }\nfunc bar { }\n\nfoo(); foo(); foo()\nbar(); bar();\n\nvar data = Perl.to_sidef(Parser{:vars}{:main}).flatten\n\ndata.sort_by { |v| -v{:count} }.first(10).each { |entry|\n    if (entry{:type} == :func) {\n        say (\"Function `\n             \" \n    }\n}\n", "target": "import ast\n\nclass CallCountingVisitor(ast.NodeVisitor):\n\n    def __init__(self):\n        self.calls = {}\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name):\n            fun_name = node.func.id\n            call_count = self.calls.get(fun_name, 0)\n            self.calls[fun_name] = call_count + 1\n        self.generic_visit(node)\n\nfilename = input('Enter a filename to parse: ')\nwith open(filename, encoding='utf-8') as f:\n    contents = f.read()\nroot = ast.parse(contents, filename=filename) \nvisitor = CallCountingVisitor()\nvisitor.visit(root)\ntop10 = sorted(visitor.calls.items(), key=lambda x: x[1], reverse=True)[:10]\nfor name, count in top10:\n    print(name,'called',count,'times')\n"}
{"id": 389337, "name": "Table creation", "source": "Translate Ruby to Python: require 'pstore'\ndb = PStore.new \"filename.pstore\"\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> c = conn.cursor()\n>>> c.execute()\n<sqlite3.Cursor object at 0x013263B0>\n>>> \nc.execute()\n\n<sqlite3.Cursor object at 0x013263B0>\n>>> for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n         ]:\n\tc.execute('insert into stocks values (?,?,?,?,?)', t)\n\n\t\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n>>> \n>>> c = conn.cursor()\n>>> c.execute('select * from stocks order by price')\n<sqlite3.Cursor object at 0x01326530>\n>>> for row in c:\n\tprint row\n\n\t\n(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)\n(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)\n(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)\n(u'2006-04-05', u'BUY', u'MSOFT', 1000.0, 72.0)\n>>>\n"}
{"id": 389338, "name": "Table creation", "source": "Translate Ruby to Python: require 'pstore'\ndb = PStore.new \"filename.pstore\"\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> c = conn.cursor()\n>>> c.execute()\n<sqlite3.Cursor object at 0x013263B0>\n>>> \nc.execute()\n\n<sqlite3.Cursor object at 0x013263B0>\n>>> for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n         ]:\n\tc.execute('insert into stocks values (?,?,?,?,?)', t)\n\n\t\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n>>> \n>>> c = conn.cursor()\n>>> c.execute('select * from stocks order by price')\n<sqlite3.Cursor object at 0x01326530>\n>>> for row in c:\n\tprint row\n\n\t\n(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)\n(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)\n(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)\n(u'2006-04-05', u'BUY', u'MSOFT', 1000.0, 72.0)\n>>>\n"}
{"id": 389339, "name": "Nice primes", "source": "Translate Ruby to Python: require 'prime'\n\nclass Integer\n  def dig_root = (1+(self-1).remainder(9))\n  def nice? = prime? && dig_root.prime?\nend\n\np (500..1000).select(&:nice?)\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 389340, "name": "Nice primes", "source": "Translate Ruby to Python: require 'prime'\n\nclass Integer\n  def dig_root = (1+(self-1).remainder(9))\n  def nice? = prime? && dig_root.prime?\nend\n\np (500..1000).select(&:nice?)\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 389341, "name": "Find the last Sunday of each month", "source": "Translate Ruby to Python: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 389342, "name": "Find the last Sunday of each month", "source": "Translate Ruby to Python: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 389343, "name": "Random Latin squares", "source": "Translate Ruby to Python: N = 5\n\ndef generate_square\n  perms  =  (1..N).to_a.permutation(N).to_a.shuffle\n  square = []\n  N.times do\n    square << perms.pop\n    perms.reject!{|perm| perm.zip(square.last).any?{|el1, el2| el1 == el2} }\n  end\n  square\nend\n\ndef print_square(square)\n  cell_size = N.digits.size + 1\n  strings = square.map!{|row| row.map!{|el| el.to_s.rjust(cell_size)}.join }\n  puts strings, \"\\n\"\nend\n\n2.times{print_square( generate_square)}\n", "target": "from random import choice, shuffle\nfrom copy import deepcopy\n\ndef rls(n):\n    if n <= 0:\n        return []\n    else:\n        symbols = list(range(n))\n        square = _rls(symbols)\n        return _shuffle_transpose_shuffle(square)\n\n\ndef _shuffle_transpose_shuffle(matrix):\n    square = deepcopy(matrix)\n    shuffle(square)\n    trans = list(zip(*square))\n    shuffle(trans)\n    return trans\n\n\ndef _rls(symbols):\n    n = len(symbols)\n    if n == 1:\n        return [symbols]\n    else:\n        sym = choice(symbols)\n        symbols.remove(sym)\n        square = _rls(symbols)\n        square.append(square[0].copy())\n        for i in range(n):\n            square[i].insert(i, sym)\n        return square\n\ndef _to_text(square):\n    if square:\n        width = max(len(str(sym)) for row in square for sym in row)\n        txt = '\\n'.join(' '.join(f\"{sym:>{width}}\" for sym in row)\n                        for row in square)\n    else:\n        txt = ''\n    return txt\n\ndef _check(square):\n    transpose = list(zip(*square))\n    assert _check_rows(square) and _check_rows(transpose), \\\n        \"Not a Latin square\"\n\ndef _check_rows(square):\n    if not square:\n        return True\n    set_row0 = set(square[0])\n    return all(len(row) == len(set(row)) and set(row) == set_row0\n               for row in square)\n\n\nif __name__ == '__main__':\n    for i in [3, 3,  5, 5, 12]:\n        square = rls(i)\n        print(_to_text(square))\n        _check(square)\n        print()\n"}
{"id": 389344, "name": "Teacup rim text", "source": "Translate Ruby to Python: lists = [\"unixdict.txt\", \"wordlist.10000\", \"woordenlijst.txt\"]\n\nlists.each do |list|\n  words = open(list).readlines( chomp: true).reject{|w| w.size < 3 }\n  grouped_by_size = words.group_by(&:size)\n  tea_words = words.filter_map do |word|\n    chars = word.chars\n    next unless chars.none?{|c| c < chars.first }\n    next if chars.uniq.size == 1\n    rotations = word.size.times.map {|i| chars.rotate(i).join }\n    rotations if rotations.all?{|rot| grouped_by_size[rot.size].include? rot }\n  end\n  puts \"\", list + \":\"\n  tea_words.uniq(&:to_set).each{|ar| puts ar.join(\", \") }\nend\n", "target": "\n\nfrom itertools import chain, groupby\nfrom os.path import expanduser\nfrom functools import reduce\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        concatMap(circularGroup)(\n            anagrams(3)(\n                \n                lines(readFile('~/mitWords.txt'))\n            )\n        )\n    ))\n\n\n\ndef anagrams(n):\n    \n    def go(ws):\n        def f(xs):\n            return [\n                [snd(x) for x in xs]\n            ] if n <= len(xs) >= len(xs[0][0]) else []\n        return concatMap(f)(groupBy(fst)(sorted(\n            [(''.join(sorted(w)), w) for w in ws],\n            key=fst\n        )))\n    return go\n\n\n\ndef circularGroup(ws):\n    \n    lex = set(ws)\n    iLast = len(ws) - 1\n    \n    \n    (i, blnCircular) = until(\n        lambda tpl: tpl[1] or (tpl[0] > iLast)\n    )(\n        lambda tpl: (1 + tpl[0], isCircular(lex)(ws[tpl[0]]))\n    )(\n        (0, False)\n    )\n    return [' -> '.join(allRotations(ws[i]))] if blnCircular else []\n\n\n\ndef isCircular(lexicon):\n    \n    def go(w):\n        def f(tpl):\n            (i, _, x) = tpl\n            return (1 + i, x in lexicon, rotated(x))\n\n        iLast = len(w) - 1\n        return until(\n            lambda tpl: iLast < tpl[0] or (not tpl[1])\n        )(f)(\n            (0, True, rotated(w))\n        )[1]\n    return go\n\n\n\ndef allRotations(w):\n    \n    return takeIterate(len(w) - 1)(\n        rotated\n    )(w)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef groupBy(f):\n    \n    def go(xs):\n        return [\n            list(x[1]) for x in groupby(xs, key=f)\n        ]\n    return go\n\n\n\ndef lines(s):\n    \n    return s.splitlines()\n\n\n\ndef mapAccumL(f):\n    \n    def go(a, x):\n        tpl = f(a[0], x)\n        return (tpl[0], a[1] + [tpl[1]])\n    return lambda acc: lambda xs: (\n        reduce(go, xs, (acc, []))\n    )\n\n\n\ndef readFile(fp):\n    \n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\ndef rotated(s):\n    \n    return s[1:] + s[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef takeIterate(n):\n    \n    def go(f):\n        def g(x):\n            def h(a, i):\n                v = f(a) if i else x\n                return (v, v)\n            return mapAccumL(h)(x)(\n                range(0, 1 + n)\n            )[1]\n        return g\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389345, "name": "Fairshare between two and more", "source": "Translate Ruby to Python: def turn(base, n)\n    sum = 0\n    while n != 0 do\n        rem = n % base\n        n = n / base\n        sum = sum + rem\n    end\n    return sum % base\nend\n\ndef fairshare(base, count)\n    print \"Base %2d: \" % [base]\n    for i in 0 .. count - 1 do\n        t = turn(base, i)\n        print \" %2d\" % [t]\n    end\n    print \"\\n\"\nend\n\ndef turnCount(base, count)\n    cnt = Array.new(base, 0)\n\n    for i in 0 .. count - 1 do\n        t = turn(base, i)\n        cnt[t] = cnt[t] + 1\n    end\n\n    minTurn = base * count\n    maxTurn = -1\n    portion = 0\n    for i in 0 .. base - 1 do\n        if cnt[i] > 0 then\n            portion = portion + 1\n        end\n        if cnt[i] < minTurn then\n            minTurn = cnt[i]\n        end\n        if cnt[i] > maxTurn then\n            maxTurn = cnt[i]\n        end\n    end\n\n    print \"  With %d people: \" % [base]\n    if 0 == minTurn then\n        print \"Only %d have a turn\\n\" % portion\n    elsif minTurn == maxTurn then\n        print \"%d\\n\" % [minTurn]\n    else\n        print \"%d or %d\\n\" % [minTurn, maxTurn]\n    end\nend\n\ndef main\n    fairshare(2, 25)\n    fairshare(3, 25)\n    fairshare(5, 25)\n    fairshare(11, 25)\n\n    puts \"How many times does each get a turn in 50000 iterations?\"\n    turnCount(191, 50000)\n    turnCount(1377, 50000)\n    turnCount(49999, 50000)\n    turnCount(50000, 50000)\n    turnCount(50001, 50000)\nend\n\nmain()\n", "target": "from itertools import count, islice\n\ndef _basechange_int(num, b):\n    \n    if num == 0:\n        return [0]\n    result = []\n    while num != 0:\n        num, d = divmod(num, b)\n        result.append(d)\n    return result[::-1]\n\ndef fairshare(b=2):\n    for i in count():\n        yield sum(_basechange_int(i, b)) % b\n\nif __name__ == '__main__':\n    for b in (2, 3, 5, 11):\n        print(f\"{b:>2}: {str(list(islice(fairshare(b), 25)))[1:-1]}\")\n"}
{"id": 389346, "name": "Esthetic numbers", "source": "Translate Ruby to Python: def isEsthetic(n, b)\n    if n == 0 then\n        return false\n    end\n\n    i = n % b\n    n2 = (n / b).floor\n    while n2 > 0\n        j = n2 % b\n        if (i - j).abs != 1 then\n            return false\n        end\n        n2 = n2 / b\n        i = j\n    end\n    return true\nend\n\ndef listEsths(n, n2, m, m2, perLine, all)\n    esths = Array.new\n    dfs = lambda {|n, m, i|\n        if n <= i and i <= m then\n            esths << i\n        end\n        if i == 0 or i > m then\n            return\n        end\n        d = i % 10\n        i1 = i * 10 + d - 1\n        i2 = i1 + 2\n        if d == 0 then\n            dfs[n, m, i2]\n        elsif d == 9 then\n            dfs[n, m, i1]\n        else\n            dfs[n, m, i1]\n            dfs[n, m, i2]\n        end\n    }\n\n    for i in 0..9\n        dfs[n2, m2, i]\n    end\n\n    le = esths.length\n    print \"Base 10: %d esthetic numbers between %d and %d:\\n\" % [le, n, m]\n    if all then\n        esths.each_with_index { |esth, idx|\n            print \"%d \" % [esth]\n            if (idx + 1) % perLine == 0 then\n                print \"\\n\"\n            end\n        }\n        print \"\\n\"\n    else\n        for i in 0 .. perLine - 1\n            print \"%d \" % [esths[i]]\n        end\n        print \"\\n............\\n\"\n        for i in le - perLine .. le - 1\n            print \"%d \" % [esths[i]]\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndef main\n    for b in 2..16\n        print \"Base %d: %dth to %dth esthetic numbers:\\n\" % [b, 4 * b, 6 * b]\n        n = 1\n        c = 0\n        while c < 6 * b\n            if isEsthetic(n, b) then\n                c = c + 1\n                if c >= 4 * b then\n                    print \"%s \" % [n.to_s(b)]\n                end\n            end\n            n = n + 1\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\n\n    listEsths(1000, 1010, 9999, 9898, 16, true)\n    listEsths(1e8, 101010101, 13 * 1e7, 123456789, 9, true)\n    listEsths(1e11, 101010101010, 13 * 1e10, 123456789898, 7, false)\n    listEsths(1e14, 101010101010101, 13 * 1e13, 123456789898989, 5, false)\n    listEsths(1e17, 101010101010101010, 13 * 1e16, 123456789898989898, 4, false)\nend\n\nmain()\n", "target": "from collections import deque\nfrom itertools import dropwhile, islice, takewhile\nfrom textwrap import wrap\nfrom typing import Iterable, Iterator\n\n\nDigits = str  \n\n\ndef esthetic_nums(base: int) -> Iterator[int]:\n    \n    queue: deque[tuple[int, int]] = deque()\n    queue.extendleft((d, d) for d in range(1, base))\n    while True:\n        num, lsd = queue.pop()\n        yield num\n        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)\n        num *= base  \n        queue.extendleft((num + d, d) for d in new_lsds)\n\n\ndef to_digits(num: int, base: int) -> Digits:\n    \n    digits: list[str] = []\n    while num:\n        num, d = divmod(num, base)\n        digits.append(\"0123456789abcdef\"[d])\n    return \"\".join(reversed(digits)) if digits else \"0\"\n\n\ndef pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:\n    \n    joined = \", \".join(it)\n    lines = wrap(joined, width=width - indent)\n    for line in lines:\n        print(f\"{indent*' '}{line}\")\n    print()\n\n\ndef task_2() -> None:\n    nums: Iterator[int]\n    for base in range(2, 16 + 1):\n        start, stop = 4 * base, 6 * base\n        nums = esthetic_nums(base)\n        nums = islice(nums, start - 1, stop)  \n        print(\n            f\"Base-{base} esthetic numbers from \"\n            f\"index {start} through index {stop} inclusive:\\n\"\n        )\n        pprint_it(to_digits(num, base) for num in nums)\n\n\ndef task_3(lower: int, upper: int, base: int = 10) -> None:\n    nums: Iterator[int] = esthetic_nums(base)\n    nums = dropwhile(lambda num: num < lower, nums)\n    nums = takewhile(lambda num: num <= upper, nums)\n    print(\n        f\"Base-{base} esthetic numbers with \"\n        f\"magnitude between {lower:,} and {upper:,}:\\n\"\n    )\n    pprint_it(to_digits(num, base) for num in nums)\n\n\nif __name__ == \"__main__\":\n    print(\"======\\nTask 2\\n======\\n\")\n    task_2()\n\n    print(\"======\\nTask 3\\n======\\n\")\n    task_3(1_000, 9_999)\n\n    print(\"======\\nTask 4\\n======\\n\")\n    task_3(100_000_000, 130_000_000)\n"}
{"id": 389347, "name": "Descending primes", "source": "Translate Ruby to Python: require 'prime'\n\ndigits = [9,8,7,6,5,4,3,2,1].to_a\nres = 1.upto(digits.size).flat_map do |n|\n   digits.combination(n).filter_map do |set|\n      candidate = set.join.to_i\n      candidate if candidate.prime?\n   end.reverse\n end\n\n puts res.join(\",\")\n", "target": "from sympy import isprime\n\ndef descending(xs=range(10)):\n    for x in xs:\n        yield x\n        yield from descending(x*10 + d for d in range(x%10))\n\nfor i, p in enumerate(sorted(filter(isprime, descending()))):\n    print(f'{p:9d}', end=' ' if (1 + i)%8 else '\\n')\n\nprint()\n"}
{"id": 389348, "name": "Unicode strings", "source": "Translate Ruby to Python: str = \"\u4f60\u597d\"\nstr.include?(\"\u597d\") \n", "target": "\n\n\nu = 'abcd\u00e9'\nprint(ord(u[-1]))\n"}
{"id": 389349, "name": "Permutations by swapping", "source": "Translate Ruby to Python: def perms(n)\n  p = Array.new(n+1){|i| -i}\n  s = 1\n  loop do\n    yield p[1..-1].map(&:abs), s\n    k = 0\n    for i in 2..n\n      k = i if p[i] < 0 and p[i].abs > p[i-1].abs and p[i].abs > p[k].abs\n    end\n    for i in 1...n\n      k = i if p[i] > 0 and p[i].abs > p[i+1].abs and  p[i].abs > p[k].abs\n    end\n    break if k.zero?\n    for i in 1..n\n      p[i] *= -1 if p[i].abs > p[k].abs\n    end\n    i = k + (p[k] <=> 0)\n    p[k], p[i] = p[i], p[k]\n    s = -s\n  end\nend\n\nfor i in 3..4\n  perms(i){|perm, sign| puts \"Perm: \n  puts\nend\n", "target": "from operator import itemgetter\n \nDEBUG = False \n \ndef spermutations(n):\n    \n    sign = 1\n    p = [[i, 0 if i == 0 else -1] \n         for i in range(n)]\n \n    if DEBUG: print ' \n    yield tuple(pp[0] for pp in p), sign\n \n    while any(pp[1] for pp in p): \n        i1, (n1, d1) = max(((i, pp) for i, pp in enumerate(p) if pp[1]),\n                           key=itemgetter(1))\n        sign *= -1\n        if d1 == -1:\n            \n            i2 = i1 - 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == 0 or p[i2 - 1][0] > n1:\n                \n                p[i2][1] = 0\n        elif d1 == 1:\n            \n            i2 = i1 + 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == n - 1 or p[i2 + 1][0] > n1:\n                \n                p[i2][1] = 0\n        if DEBUG: print ' \n        yield tuple(pp[0] for pp in p), sign\n \n        for i3, pp in enumerate(p):\n            n3, d3 = pp\n            if n3 > n1:\n                pp[1] = 1 if i3 < i2 else -1\n                if DEBUG: print ' \n \n \nif __name__ == '__main__':\n    from itertools import permutations\n \n    for n in (3, 4):\n        print '\\nPermutations and sign of %i items' % n\n        sp = set()\n        for i in spermutations(n):\n            sp.add(i[0])\n            print('Perm: %r Sign: %2i' % i)\n            \n        \n        p = set(permutations(range(n)))\n        assert sp == p, 'Two methods of generating permutations do not agree'\n"}
{"id": 389350, "name": "RPG attributes generator", "source": "Translate Ruby to Python: def roll_stat\n  dices = Array(Int32).new(4) { rand(1..6) }\n  dices.sum - dices.min\nend\n\ndef roll_character\n  loop do\n    stats = Array(Int32).new(6) { roll_stat }\n    return stats if stats.sum >= 75 && stats.count(&.>=(15)) >= 2\n  end\nend\n\n10.times do\n  stats = roll_character\n  puts \"stats: \nend\n", "target": "import random\nrandom.seed()\nattributes_total = 0\ncount = 0\n\nwhile attributes_total < 75 or count < 2:\n    attributes = []\n\n    for attribute in range(0, 6):\n        rolls = []\n        \n        for roll in range(0, 4):\n            result = random.randint(1, 6)\n            rolls.append(result)\n        \n        sorted_rolls = sorted(rolls)\n        largest_3 = sorted_rolls[1:]\n        rolls_total = sum(largest_3)\n        \n        if rolls_total >= 15:\n            count += 1\n        \n        attributes.append(rolls_total)\n\n    attributes_total = sum(attributes)\n    \nprint(attributes_total, attributes)\n"}
{"id": 389351, "name": "Kolakoski sequence", "source": "Translate Ruby to Python: def create_generator(ar)\n  Enumerator.new do |y|\n    cycle = ar.cycle\n    s = []\n    loop do\n      t = cycle.next\n      s.push(t)\n      v = s.shift\n      y << v\n      (v-1).times{s.push(t)}\n    end\n  end\nend\n\ndef rle(ar)\n  ar.slice_when{|a,b| a != b}.map(&:size)\nend\n\n[[20, [1,2]], \n [20, [2,1]], \n [30, [1,3,1,2]],\n [30, [1,3,2,1]]].each do |num,ar|\n  puts \"\\nFirst \n  p res = create_generator(ar).take(num)\n  puts \"Possible Kolakoski sequence? \nend\n", "target": "import itertools\n\ndef cycler(start_items):\n\treturn itertools.cycle(start_items).__next__\n\ndef _kolakoski_gen(start_items):\n    s, k = [], 0\n    c = cycler(start_items)\n    while True:\n        c_next = c()\n        s.append(c_next)\n        sk = s[k]\n        yield sk\n        if sk > 1:\n            s += [c_next] * (sk - 1)\n        k += 1\n\ndef kolakoski(start_items=(1, 2), length=20):\n    return list(itertools.islice(_kolakoski_gen(start_items), length))\n\ndef _run_len_encoding(truncated_series):\n    return [len(list(group)) for grouper, group in itertools.groupby(truncated_series)][:-1]\n\ndef is_series_eq_its_rle(series):\n    rle = _run_len_encoding(series)\n    return (series[:len(rle)] == rle) if rle else not series\n\nif __name__ == '__main__':\n    for start_items, length in [((1, 2), 20), ((2, 1), 20), \n                                ((1, 3, 1, 2), 30), ((1, 3, 2, 1), 30)]:\n        print(f'\\n\n        s = kolakoski(start_items, length)\n        print(f'  {s}')\n        ans = 'YES' if is_series_eq_its_rle(s) else 'NO'\n        print(f'  Does it look like a Kolakoski sequence: {ans}')\n"}
{"id": 389352, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Ruby to Python: require 'prime'\n \ndef num_divisors(n)\n  n.prime_division.inject(1){|prod, (_p,n)| prod *= (n + 1) } \nend\n\ndef first_with_num_divs(n)\n  (1..).detect{|i| num_divisors(i) == n }\nend\n\np (1..15).map{|n| first_with_num_divs(n) }\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    n = 0\n    while True:\n        n += 1\n        ii = 0\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 389353, "name": "Sparkline in unicode", "source": "Translate Ruby to Python: bar = ('\u2581'..'\u2588').to_a \nloop {print 'Numbers please separated by space/commas: '\n  numbers = gets.split(/[\\s,]+/).map(&:to_f)\n  min, max = numbers.minmax\n  puts \"min: %5f; max: %5f\"% [min, max]\n  div = (max - min) / (bar.size - 1)\n  puts min == max ? bar.last*numbers.size : numbers.map{|num| bar[((num - min) / div).to_i]}.join\n}\n", "target": "\n\n\nbar = '\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588'\nbarcount = len(bar)\n\ndef sparkline(numbers):\n    mn, mx = min(numbers), max(numbers)\n    extent = mx - mn\n    sparkline = ''.join(bar[min([barcount - 1,\n                                 int((n - mn) / extent * barcount)])]\n                        for n in numbers)\n    return mn, mx, sparkline\n\nif __name__ == '__main__':\n    import re\n    \n    for line in (\"0 0 1 1; 0 1 19 20; 0 999 4000 4999 7000 7999;\"\n                 \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1;\"\n                 \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 \").split(';'):\n        print(\"\\nNumbers:\", line)\n        numbers = [float(n) for n in re.split(r'[\\s,]+', line.strip())]\n        mn, mx, sp = sparkline(numbers)\n        print('  min: %5f; max: %5f' % (mn, mx))\n        print(\"  \" + sp)\n"}
{"id": 389354, "name": "Levenshtein distance_Alignment", "source": "Translate Ruby to Python: require 'lcs'\n\ndef levenshtein_align(a, b)\n  apos, bpos = LCS.new(a, b).backtrack2\n  \n  c = \"\"\n  d = \"\"\n  x0 = y0 = -1\n  dx = dy = 0\n  apos.zip(bpos) do |x,y|\n    diff = x + dx - y - dy\n    if diff < 0\n      dx -= diff\n      c += \"-\" * (-diff)\n    elsif diff > 0\n      dy += diff\n      d += \"-\" * diff\n    end\n    c += a[x0+1..x]\n    x0 = x\n    d += b[y0+1..y]\n    y0 = y\n  end\n  \n  c += a[x0+1..-1]\n  d += b[y0+1..-1]\n  diff = a.length + y0 - b.length - x0\n  if diff < 0\n    c += \"-\" * (-diff)\n  elsif diff > 0\n    d += \"-\" * diff\n  end\n  [c, d]\nend\n\nputs levenshtein_align(\"rosettacode\", \"raisethysword\")\n", "target": "from difflib import ndiff\n\ndef levenshtein(str1, str2):\n    result = \"\"\n    pos, removed = 0, 0\n    for x in ndiff(str1, str2):\n        if pos<len(str1) and str1[pos] == x[2]:\n          pos += 1\n          result += x[2]\n          if x[0] == \"-\":\n              removed += 1\n          continue\n        else:\n          if removed > 0:\n            removed -=1\n          else:\n            result += \"-\"\n    print(result)\n\nlevenshtein(\"place\",\"palace\")\nlevenshtein(\"rosettacode\",\"raisethysword\")\n"}
{"id": 389355, "name": "Longest increasing subsequence", "source": "Translate Ruby to Python: Node = Struct.new(:val, :back)\n\ndef lis(n)\n  pileTops = []\n  \n  for x in n\n    \n    low, high = 0, pileTops.size-1\n    while low <= high\n      mid = low + (high - low) / 2\n      if pileTops[mid].val >= x\n        high = mid - 1\n      else\n        low = mid + 1\n      end\n    end\n    i = low\n    node = Node.new(x)\n    node.back = pileTops[i-1]  if i > 0\n    pileTops[i] = node\n  end\n  \n  result = []\n  node = pileTops.last\n  while node\n    result.unshift(node.val)\n    node = node.back\n  end\n  result\nend\n\np lis([3, 2, 6, 4, 5, 1])\np lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])\n", "target": "def longest_increasing_subsequence(X):\n    \n    N = len(X)\n    P = [0] * N\n    M = [0] * (N+1)\n    L = 0\n    for i in range(N):\n       lo = 1\n       hi = L\n       while lo <= hi:\n           mid = (lo+hi)//2\n           if (X[M[mid]] < X[i]):\n               lo = mid+1\n           else:\n               hi = mid-1\n    \n       newL = lo\n       P[i] = M[newL-1]\n       M[newL] = i\n    \n       if (newL > L):\n           L = newL\n    \n    S = []\n    k = M[L]\n    for i in range(L-1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return S[::-1]\n\nif __name__ == '__main__':\n    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:\n        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))\n"}
{"id": 389356, "name": "Metaprogramming", "source": "Translate Ruby to Python: class IDVictim\n  \n  \n  attr_accessor :name, :birthday, :gender, :hometown\n  \n  \n  \n  def self.new_element(element)\n    attr_accessor element\n  end\n  \nend\n", "target": "from macropy.core.macros import *\nfrom macropy.core.quotes import macros, q, ast, u\n\nmacros = Macros()\n\n@macros.expr\ndef expand(tree, **kw):\n    addition = 10\n    return q[lambda x: x * ast[tree] + u[addition]]\n"}
{"id": 389357, "name": "Odd and square numbers", "source": "Translate Ruby to Python: lo, hi = 100, 1000\n(Integer.sqrt(lo)..Integer.sqrt(hi)).each{|n| puts n*n if n.odd?}\n", "target": "import math\nszamok=[]\nlimit = 1000\n\nfor i in range(1,int(math.ceil(math.sqrt(limit))),2):\n    num = i*i\n    if (num < 1000 and num > 99):\n        szamok.append(num)\n\nprint(szamok)\n"}
{"id": 389358, "name": "Words from neighbour ones", "source": "Translate Ruby to Python: new_word_size = 9\nwell_sized  = File.readlines(\"unixdict.txt\", chomp: true).reject{|word| word.size < new_word_size}\nlist = well_sized.each_cons(new_word_size).filter_map do |slice|\n  candidate = (0...new_word_size).inject(\"\"){|res, idx| res << slice[idx][idx] }\n  candidate if well_sized.include?(candidate)\nend\nputs list.uniq\n", "target": "\n\nimport urllib.request\nfrom collections import Counter\n \nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n \ndictionary = open(\"unixdict.txt\",\"r\")\n \nwordList = dictionary.read().split('\\n')\n \ndictionary.close()\n \nfilteredWords = [chosenWord for chosenWord in wordList if len(chosenWord)>=9]\n\nfor word in filteredWords[:-9]:\n  position = filteredWords.index(word)\n  newWord = \"\".join([filteredWords[position+i][i] for i in range(0,9)])\n  if newWord in filteredWords:\n   print(newWord)\n"}
{"id": 389359, "name": "Sum of square and cube digits of an integer are primes", "source": "Translate Ruby to Python: require 'prime'\n\np (1..100).select{|n|(n*n).digits.sum.prime? && (n**3).digits.sum.prime?}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef digSum(n, b):\n    s = 0\n    while n:\n        s += (n % b)\n        n = n // b\n    return s\n\nif __name__ == '__main__':\n    for n in range(11, 99):\n        if isPrime(digSum(n**3, 10)) and isPrime(digSum(n**2, 10)):\n            print(n, end = \"  \")\n"}
{"id": 389360, "name": "Dynamic variable names", "source": "Translate Ruby to Python: p \"Enter a variable name\"\nx = \"@\" + gets.chomp!\ninstance_variable_set x, 42\np \"The value of \n", "target": ">>> name = raw_input(\"Enter a variable name: \")\nEnter a variable name: X\n>>> globals()[name] = 42\n>>> X\n42\n"}
{"id": 389361, "name": "Odd squarefree semiprimes", "source": "Translate Ruby to Python: func odd_squarefree_almost_primes(upto, k=2) {\n    k.squarefree_almost_primes(upto).grep{.is_odd}\n}\n\nwith (1e3) {|n|\n    var list = odd_squarefree_almost_primes(n, 2)\n    say \"Found \n    say (list.first(10).join(', '), ', ..., ', list.last(10).join(', '))\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    for p in range(3, 999):\n        if not isPrime(p):            \n            continue\n        for q in range(p+1, 1000//p):\n            if not isPrime(q):\n                continue\n            print(p*q, end = \" \");\n"}
{"id": 389362, "name": "Odd squarefree semiprimes", "source": "Translate Ruby to Python: func odd_squarefree_almost_primes(upto, k=2) {\n    k.squarefree_almost_primes(upto).grep{.is_odd}\n}\n\nwith (1e3) {|n|\n    var list = odd_squarefree_almost_primes(n, 2)\n    say \"Found \n    say (list.first(10).join(', '), ', ..., ', list.last(10).join(', '))\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    for p in range(3, 999):\n        if not isPrime(p):            \n            continue\n        for q in range(p+1, 1000//p):\n            if not isPrime(q):\n                continue\n            print(p*q, end = \" \");\n"}
{"id": 389363, "name": "Primes with digits in nondecreasing order", "source": "Translate Ruby to Python: require 'prime'\n\nbase = 10\nupto = 1000\n\nres = Prime.each(upto).select do |pr|\n   pr.digits(base).each_cons(2).all?{|p1, p2| p1 >= p2}\nend\n\nputs \"There are \nputs res.join(\", \")\n", "target": "\n\nfrom operator import le\nfrom itertools import takewhile\n\n\n\ndef monotonicDigits(base):\n    \n    def go(n):\n        return monotonic(le)(\n            showIntAtBase(base)(digitFromInt)(n)('')\n        )\n    return go\n\n\n\ndef monotonic(op):\n    \n    def go(xs):\n        return all(map(op, xs, xs[1:]))\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in takewhile(\n            lambda n: 1000 > n,\n            filter(monotonicDigits(10), primes())\n        )\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matches for base 10:\\n')\n    print('\\n'.join(\n        ' '.join(row) for row in chunksOf(10)([\n            x.rjust(w, ' ') for x in xs\n        ])\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitFromInt(n):\n    \n    return '0123456789abcdefghijklmnopqrstuvwxyz'[n] if (\n        0 <= n < 36\n    ) else '?'\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389364, "name": "Primes with digits in nondecreasing order", "source": "Translate Ruby to Python: require 'prime'\n\nbase = 10\nupto = 1000\n\nres = Prime.each(upto).select do |pr|\n   pr.digits(base).each_cons(2).all?{|p1, p2| p1 >= p2}\nend\n\nputs \"There are \nputs res.join(\", \")\n", "target": "\n\nfrom operator import le\nfrom itertools import takewhile\n\n\n\ndef monotonicDigits(base):\n    \n    def go(n):\n        return monotonic(le)(\n            showIntAtBase(base)(digitFromInt)(n)('')\n        )\n    return go\n\n\n\ndef monotonic(op):\n    \n    def go(xs):\n        return all(map(op, xs, xs[1:]))\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in takewhile(\n            lambda n: 1000 > n,\n            filter(monotonicDigits(10), primes())\n        )\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matches for base 10:\\n')\n    print('\\n'.join(\n        ' '.join(row) for row in chunksOf(10)([\n            x.rjust(w, ' ') for x in xs\n        ])\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitFromInt(n):\n    \n    return '0123456789abcdefghijklmnopqrstuvwxyz'[n] if (\n        0 <= n < 36\n    ) else '?'\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389365, "name": "Brilliant numbers", "source": "Translate Ruby to Python: func is_briliant_number(n) {\n    n.is_semiprime && (n.factor.map{.len}.uniq.len == 1)\n}\n\nfunc brilliant_numbers_count(n) {\n\n    var count = 0\n    var len = n.isqrt.len\n\n    for k in (1 .. len-1) {\n        var pi = prime_count(10**(k-1), 10**k - 1)\n        count += binomial(pi, 2)+pi\n    }\n\n    var min = (10**(len - 1))\n    var max = (10**len - 1)\n\n    each_prime(min, max, {|p|\n        count += prime_count(p, max `min` idiv(n, p))\n    })\n\n    return count\n}\n\nsay \"First 100 brilliant numbers:\"\n\n100.by(is_briliant_number).each_slice(10, {|*a|\n    say a.map { '%4s' % _}.join(' ')\n})\n\nsay ''\n\nfor n in (1 .. 12) {\n    var v = (10**n .. Inf -> first_by(is_briliant_number))\n    printf(\"First brilliant number >= 10^%d is %s\", n, v)\n    printf(\" at position %s\\n\", brilliant_numbers_count(v))\n}\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 389366, "name": "Brilliant numbers", "source": "Translate Ruby to Python: func is_briliant_number(n) {\n    n.is_semiprime && (n.factor.map{.len}.uniq.len == 1)\n}\n\nfunc brilliant_numbers_count(n) {\n\n    var count = 0\n    var len = n.isqrt.len\n\n    for k in (1 .. len-1) {\n        var pi = prime_count(10**(k-1), 10**k - 1)\n        count += binomial(pi, 2)+pi\n    }\n\n    var min = (10**(len - 1))\n    var max = (10**len - 1)\n\n    each_prime(min, max, {|p|\n        count += prime_count(p, max `min` idiv(n, p))\n    })\n\n    return count\n}\n\nsay \"First 100 brilliant numbers:\"\n\n100.by(is_briliant_number).each_slice(10, {|*a|\n    say a.map { '%4s' % _}.join(' ')\n})\n\nsay ''\n\nfor n in (1 .. 12) {\n    var v = (10**n .. Inf -> first_by(is_briliant_number))\n    printf(\"First brilliant number >= 10^%d is %s\", n, v)\n    printf(\" at position %s\\n\", brilliant_numbers_count(v))\n}\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 389367, "name": "Calkin-Wilf sequence", "source": "Translate Ruby to Python: cw = Enumerator.new do |y|\n  y << a = 1.to_r\n  loop { y << a = 1/(2*a.floor + 1 - a) }\nend\n\ndef term_num(rat)\n  num, den, res, pwr, dig = rat.numerator, rat.denominator, 0, 0, 1\n  while den > 0 \n    num, (digit, den) = den, num.divmod(den) \n    digit.times do\n      res |= dig << pwr\n      pwr += 1\n    end\n    dig ^= 1\n  end\n  res\nend\n\nputs  cw.take(20).join(\", \")\nputs  term_num  (83116/51639r)\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 389368, "name": "Calkin-Wilf sequence", "source": "Translate Ruby to Python: cw = Enumerator.new do |y|\n  y << a = 1.to_r\n  loop { y << a = 1/(2*a.floor + 1 - a) }\nend\n\ndef term_num(rat)\n  num, den, res, pwr, dig = rat.numerator, rat.denominator, 0, 0, 1\n  while den > 0 \n    num, (digit, den) = den, num.divmod(den) \n    digit.times do\n      res |= dig << pwr\n      pwr += 1\n    end\n    dig ^= 1\n  end\n  res\nend\n\nputs  cw.take(20).join(\", \")\nputs  term_num  (83116/51639r)\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 389369, "name": "Order disjoint list items", "source": "Translate Ruby to Python: def order_disjoint(m,n)\n  print \"\n  m, n = m.split, n.split\n  from = 0\n  n.each_slice(2) do |x,y|\n    next unless y\n    sd = m[from..-1]\n    if x > y && (sd.include? x) && (sd.include? y) && (sd.index(x) > sd.index(y))\n      new_from = m.index(x)+1\n      m[m.index(x)+from], m[m.index(y)+from] = m[m.index(y)+from], m[m.index(x)+from]\n      from = new_from\n    end\n  end\n  puts m.join(' ')\nend\n\n[\n  ['the cat sat on the mat', 'mat cat'],\n  ['the cat sat on the mat', 'cat mat'],\n  ['A B C A B C A B C'     , 'C A C A'],\n  ['A B C A B D A B E'     , 'E A D A'],\n  ['A B'                   , 'B'      ],\n  ['A B'                   , 'B A'    ],\n  ['A B B A'               , 'B A'    ]\n].each {|m,n| order_disjoint(m,n)}\n", "target": "from __future__ import print_function\n\ndef order_disjoint_list_items(data, items):\n    \n    itemindices = []\n    for item in set(items):\n        itemcount = items.count(item)\n        \n        lastindex = [-1]\n        for i in range(itemcount):\n            lastindex.append(data.index(item, lastindex[-1] + 1))\n        itemindices += lastindex[1:]\n    itemindices.sort()\n    for index, item in zip(itemindices, items):\n        data[index] = item\n\nif __name__ == '__main__':\n    tostring = ' '.join\n    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),\n                         (str.split('the cat sat on the mat'), str.split('cat mat')),\n                         (list('ABCABCABC'), list('CACA')),\n                         (list('ABCABDABE'), list('EADA')),\n                         (list('AB'), list('B')),\n                         (list('AB'), list('BA')),\n                         (list('ABBA'), list('BA')),\n                         (list(''), list('')),\n                         (list('A'), list('A')),\n                         (list('AB'), list('')),\n                         (list('ABBA'), list('AB')),\n                         (list('ABAB'), list('AB')),\n                         (list('ABAB'), list('BABA')),\n                         (list('ABCCBA'), list('ACAC')),\n                         (list('ABCCBA'), list('CACA')),\n                       ]:\n        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')\n        order_disjoint_list_items(data, items)\n        print(\"-> M' %r\" % tostring(data))\n"}
{"id": 389370, "name": "Prime words", "source": "Translate Ruby to Python: require 'prime'\n\nputs File.open(\"unixdict.txt\").select{|line| line.chomp.chars.all?{|c| c.ord.prime?} }\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 389371, "name": "Prime words", "source": "Translate Ruby to Python: require 'prime'\n\nputs File.open(\"unixdict.txt\").select{|line| line.chomp.chars.all?{|c| c.ord.prime?} }\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 389372, "name": "Palindromic primes", "source": "Translate Ruby to Python: require 'prime'\n\np Prime.each(1000).select{|pr| pr.digits == pr.digits.reverse}\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389373, "name": "Palindromic primes", "source": "Translate Ruby to Python: require 'prime'\n\np Prime.each(1000).select{|pr| pr.digits == pr.digits.reverse}\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389374, "name": "Sylvester's sequence", "source": "Translate Ruby to Python: def sylvester(n) = (1..n).reduce(2){|a| a*a - a + 1 }\n  \n(0..9).each {|n| puts \"\nputs \"\nSum of reciprocals of first 10 terms:\n\n", "target": "\n\nfrom functools import reduce\nfrom itertools import count, islice\n\n\n\ndef sylvester():\n    \n    def go(n):\n        return 1 + reduce(\n            lambda a, x: a * go(x),\n            range(0, n),\n            1\n        ) if 0 != n else 2\n\n    return map(go, count(0))\n\n\n\n\ndef main():\n    \n\n    print(\"First 10 terms of OEIS A000058:\")\n    xs = list(islice(sylvester(), 10))\n    print('\\n'.join([\n        str(x) for x in xs\n    ]))\n\n    print(\"\\nSum of the reciprocals of the first 10 terms:\")\n    print(\n        reduce(lambda a, x: a + 1 / x, xs, 0)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389375, "name": "Harmonic series", "source": "Translate Ruby to Python: harmonics = Enumerator.new do |y|\n  res = 0\n  (1..).each {|n| y << res += Rational(1, n) }\nend\n\nn = 20\nThe first \nharmonics.take(n).each_slice(5){|slice| puts \"%20s\"*slice.size % slice }\n\nputs\nmilestones = (1..10).to_a\nharmonics.each.with_index(1) do |h,i|\n  if h > milestones.first then\n    puts \"The first harmonic number > \n  end\n  break if milestones.empty?\nend\n", "target": "from  fractions import Fraction\n\ndef harmonic_series():\n    n, h = Fraction(1), Fraction(1)\n    while True:\n        yield h\n        h += 1 / (n + 1)\n        n += 1\n\nif __name__ == '__main__':\n    from itertools import islice\n    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):\n        print(n, '/', d)\n"}
{"id": 389376, "name": "Interactive programming (repl)", "source": "Translate Ruby to Python: $ irb\nirb(main):001:0> def f(string1, string2, separator)\nirb(main):002:1>     [string1, '', string2].join(separator)\nirb(main):003:1> end\n=> :f\nirb(main):004:0> f('Rosetta', 'Code', ':')\n=> \"Rosetta::Code\"\nirb(main):005:0> exit\n$\n", "target": "python\nPython 2.6.1 (r261:67517, Dec  4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] on\nwin32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def f(string1, string2, separator):\n\treturn separator.join([string1, '', string2])\n\n>>> f('Rosetta', 'Code', ':')\n'Rosetta::Code'\n>>>\n"}
{"id": 389377, "name": "Runtime evaluation_In an environment", "source": "Translate Ruby to Python: def bind_x_to_value(x)\n  binding\nend\n\ndef eval_with_x(code, a, b)\n  eval(code, bind_x_to_value(b)) - eval(code, bind_x_to_value(a))\nend\n\nputs eval_with_x('2 ** x', 3, 5) \n", "target": ">>> def eval_with_x(code, a, b):\n\treturn eval(code, {'x':b}) - eval(code, {'x':a})\n\n>>> eval_with_x('2 ** x', 3, 5)\n24\n"}
{"id": 389378, "name": "Runtime evaluation_In an environment", "source": "Translate Ruby to Python: def bind_x_to_value(x)\n  binding\nend\n\ndef eval_with_x(code, a, b)\n  eval(code, bind_x_to_value(b)) - eval(code, bind_x_to_value(a))\nend\n\nputs eval_with_x('2 ** x', 3, 5) \n", "target": ">>> def eval_with_x(code, a, b):\n\treturn eval(code, {'x':b}) - eval(code, {'x':a})\n\n>>> eval_with_x('2 ** x', 3, 5)\n24\n"}
{"id": 389379, "name": "Reverse the gender of a string", "source": "Translate Ruby to Python: var male2female = <<'EOD'\n  maleS femaleS, maleness femaleness, him her, himself herself, his her, his\n  hers, he she, Mr Mrs, Mister Missus, Ms Mr, Master Miss, MasterS MistressES,\n  uncleS auntS, nephewS nieceS, sonS daughterS, grandsonS granddaughterS,\n  brotherS sisterS, man woman, men women, boyS girlS, paternal maternal,\n  grandfatherS grandmotherS, GodfatherS GodmotherS, GodsonS GoddaughterS,\n  fianc\u00e9S fianc\u00e9eS, husband wife, husbands wives, fatherS motherS, bachelorS\n  spinsterS, bridegroomS brideS, widowerS widowS, KnightS DameS, Sir DameS,\n  KingS QueenS, DukeS DuchessES, PrinceS PrincessES, Lord Lady, Lords Ladies,\n  MarquessES MarchionessES, EarlS CountessES, ViscountS ViscountessES, ladS\n  lassES, sir madam, gentleman lady, gentlemen ladies, BaronS BaronessES,\n  stallionS mareS, ramS eweS, coltS fillieS, billy nanny, billies nannies,\n  bullS cowS, godS goddessES, heroS heroineS, shirtS blouseS, undies nickers,\n  sweat glow, jackarooS jillarooS, gigoloS hookerS, landlord landlady,\n  landlords landladies, manservantS maidservantS, actorS actressES, CountS\n  CountessES, EmperorS EmpressES, giantS giantessES, heirS heiressES, hostS\n  hostessES, lionS lionessES, managerS manageressES, murdererS murderessES,\n  priestS priestessES, poetS poetessES, shepherdS shepherdessES, stewardS\n  stewardessES, tigerS tigressES, waiterS waitressES, cockS henS, dogS bitchES,\n  drakeS henS, dogS vixenS, tomS tibS, boarS sowS, buckS roeS, peacockS\n  peahenS, gander goose, ganders geese, friarS nunS, monkS nunS\nEOD\n\u00a0\nvar m2f = male2female.split(/,\\s*/).map { |tok| tok.words}\n\u00a0\nvar re_plural = /E?S\\z/\nvar re_ES = /ES\\z/\n\u00a0\nfunc gen_pluralize(m, f) {\n    [\n        [m - re_plural, f - re_plural],\n        [m.sub(re_ES, 'es'), f.sub(re_ES, 'es')],\n        [m.sub(re_plural, 's'), f.sub(re_plural, 's')],\n    ]\n}\n\u00a0\nvar dict = Hash()\n\u00a0\nfor m,f in m2f {\n    for x,y in gen_pluralize(m, f).map{.map{.lc}} {\n        if (x ~~ dict) {\n            dict{y} = x\n        } else {\n            dict{x, y} = (y, x)\n        }\n    }\n}\n\u00a0\nvar gen_re = Regex.new('\\b(' + dict.keys.join('|') + ')\\b', 'i')\n\u00a0\nfunc copy_case(orig, repl) {\n    var a = orig.chars\n    var b = repl.chars\n\u00a0\n    var uc = 0\n    var min = [a, b].map{.len}.min\n    for i in ^min {\n        if (a[i] ~~ /^[[:upper:]]/) {\n            b[i].uc!\n            ++uc\n        }\n    }\n\u00a0\n    uc == min\u00a0? repl.uc\u00a0: b.join('')\n}\n\u00a0\nfunc reverse_gender(text) {\n    text.gsub(gen_re, { |a| copy_case(a, dict{a.lc}) })\n}\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 389380, "name": "Reverse the gender of a string", "source": "Translate Ruby to Python: var male2female = <<'EOD'\n  maleS femaleS, maleness femaleness, him her, himself herself, his her, his\n  hers, he she, Mr Mrs, Mister Missus, Ms Mr, Master Miss, MasterS MistressES,\n  uncleS auntS, nephewS nieceS, sonS daughterS, grandsonS granddaughterS,\n  brotherS sisterS, man woman, men women, boyS girlS, paternal maternal,\n  grandfatherS grandmotherS, GodfatherS GodmotherS, GodsonS GoddaughterS,\n  fianc\u00e9S fianc\u00e9eS, husband wife, husbands wives, fatherS motherS, bachelorS\n  spinsterS, bridegroomS brideS, widowerS widowS, KnightS DameS, Sir DameS,\n  KingS QueenS, DukeS DuchessES, PrinceS PrincessES, Lord Lady, Lords Ladies,\n  MarquessES MarchionessES, EarlS CountessES, ViscountS ViscountessES, ladS\n  lassES, sir madam, gentleman lady, gentlemen ladies, BaronS BaronessES,\n  stallionS mareS, ramS eweS, coltS fillieS, billy nanny, billies nannies,\n  bullS cowS, godS goddessES, heroS heroineS, shirtS blouseS, undies nickers,\n  sweat glow, jackarooS jillarooS, gigoloS hookerS, landlord landlady,\n  landlords landladies, manservantS maidservantS, actorS actressES, CountS\n  CountessES, EmperorS EmpressES, giantS giantessES, heirS heiressES, hostS\n  hostessES, lionS lionessES, managerS manageressES, murdererS murderessES,\n  priestS priestessES, poetS poetessES, shepherdS shepherdessES, stewardS\n  stewardessES, tigerS tigressES, waiterS waitressES, cockS henS, dogS bitchES,\n  drakeS henS, dogS vixenS, tomS tibS, boarS sowS, buckS roeS, peacockS\n  peahenS, gander goose, ganders geese, friarS nunS, monkS nunS\nEOD\n\u00a0\nvar m2f = male2female.split(/,\\s*/).map { |tok| tok.words}\n\u00a0\nvar re_plural = /E?S\\z/\nvar re_ES = /ES\\z/\n\u00a0\nfunc gen_pluralize(m, f) {\n    [\n        [m - re_plural, f - re_plural],\n        [m.sub(re_ES, 'es'), f.sub(re_ES, 'es')],\n        [m.sub(re_plural, 's'), f.sub(re_plural, 's')],\n    ]\n}\n\u00a0\nvar dict = Hash()\n\u00a0\nfor m,f in m2f {\n    for x,y in gen_pluralize(m, f).map{.map{.lc}} {\n        if (x ~~ dict) {\n            dict{y} = x\n        } else {\n            dict{x, y} = (y, x)\n        }\n    }\n}\n\u00a0\nvar gen_re = Regex.new('\\b(' + dict.keys.join('|') + ')\\b', 'i')\n\u00a0\nfunc copy_case(orig, repl) {\n    var a = orig.chars\n    var b = repl.chars\n\u00a0\n    var uc = 0\n    var min = [a, b].map{.len}.min\n    for i in ^min {\n        if (a[i] ~~ /^[[:upper:]]/) {\n            b[i].uc!\n            ++uc\n        }\n    }\n\u00a0\n    uc == min\u00a0? repl.uc\u00a0: b.join('')\n}\n\u00a0\nfunc reverse_gender(text) {\n    text.gsub(gen_re, { |a| copy_case(a, dict{a.lc}) })\n}\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 389381, "name": "Index finite lists of positive integers", "source": "Translate Ruby to Python: def rank(arr)\n  arr.join('a').to_i(11)\nend\n\ndef unrank(n)\n  n.to_s(11).split('a').map(&:to_i)\nend\n\nl = [1, 2, 3, 10, 100, 987654321]\np l\nn = rank(l)\np n\nl = unrank(n)\np l\n", "target": "def rank(x): return int('a'.join(map(str, [1] + x)), 11)\n\ndef unrank(n):\n\ts = ''\n\twhile n: s,n = \"0123456789a\"[n%11] + s, n//11\n\treturn map(int, s.split('a'))[1:]\n\nl = [1, 2, 3, 10, 100, 987654321]\nprint l\nn = rank(l)\nprint n\nl = unrank(n)\nprint l\n"}
{"id": 389382, "name": "Generate random numbers without repeating a value", "source": "Translate Ruby to Python: nums = (1..20).to_a\n5.times{ puts nums.shuffle.join(\" \") }\n", "target": "import random\n\nprint(random.sample(range(1, 21), 20))\n"}
{"id": 389383, "name": "Safe and Sophie Germain primes", "source": "Translate Ruby to Python: ^Inf -> lazy.grep{|p| all_prime(p, 2*p + 1) }.first(50).slices(10).each{\n    .join(', ').say\n}\n", "target": "print(\"working...\")\nrow = 0\nlimit = 1500\nSophie = []\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(2,limit):\n\tp = 2*n + 1\n\tif isPrime(n) and isPrime(p):\n\t\tSophie.append(n)\n\nprint(\"Found \",end = \"\")\nprint(len(Sophie),end = \"\")\nprint(\" Safe and Sophie primes.\")\n\nprint(Sophie)\nprint(\"done...\")\n"}
{"id": 389384, "name": "Safe and Sophie Germain primes", "source": "Translate Ruby to Python: ^Inf -> lazy.grep{|p| all_prime(p, 2*p + 1) }.first(50).slices(10).each{\n    .join(', ').say\n}\n", "target": "print(\"working...\")\nrow = 0\nlimit = 1500\nSophie = []\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(2,limit):\n\tp = 2*n + 1\n\tif isPrime(n) and isPrime(p):\n\t\tSophie.append(n)\n\nprint(\"Found \",end = \"\")\nprint(len(Sophie),end = \"\")\nprint(\" Safe and Sophie primes.\")\n\nprint(Sophie)\nprint(\"done...\")\n"}
{"id": 389385, "name": "Goldbach's comet", "source": "Translate Ruby to Python: require 'prime'\n\nn = 100\nputs \"The first \nsums = Prime.each(n*2 + 2).to_a[1..].repeated_combination(2).map(&:sum)\nsums << 4\nsums.sort.tally.values[...n].each_slice(10){|slice| puts \"%4d\"*slice.size % slice}\n\nn = 1000000\nputs \"\\nThe value of G(\n", "target": "from matplotlib.pyplot import scatter, show\nfrom sympy import isprime\n\ndef g(n):\n    assert n > 2 and n % 2 == 0, 'n in goldbach function g(n) must be even'          \n    count = 0\n    for i in range(1, n//2 + 1):\n        if isprime(i) and isprime(n - i):\n            count += 1\n    return count\n\nprint('The first 100 G numbers are:')\n \ncol = 1\nfor n in range(4, 204, 2):\n    print(str(g(n)).ljust(4), end = '\\n' if (col % 10 == 0) else '')\n    col += 1\n\nprint('\\nThe value of G(1000000) is', g(1_000_000))\n \nx = range(4, 4002, 2)\ny = [g(i) for i in x]\ncolors = [[\"red\", \"blue\", \"green\"][(i // 2) % 3] for i in x]\nscatter([i // 2 for i in x], y, marker='.', color = colors)\nshow()\n"}
{"id": 389386, "name": "Cyclops numbers", "source": "Translate Ruby to Python: require 'prime'\n\nNONZEROS = %w(1 2 3 4 5 6 7 8 9)\n\ncyclopes = Enumerator.new do |y|\n  (0..).each do |n|\n    NONZEROS.repeated_permutation(n) do |lside|\n      NONZEROS.repeated_permutation(n) do |rside|\n        y << (lside.join + \"0\" + rside.join).to_i\n      end\n    end\n  end\nend\n\nprime_cyclopes             = Enumerator.new {|y| cyclopes.each {|c| y << c if c.prime?} }\nblind_prime_cyclopes       = Enumerator.new {|y| prime_cyclopes.each {|c| y << c if c.to_s.delete(\"0\").to_i.prime?} }\npalindromic_prime_cyclopes = Enumerator.new {|y| prime_cyclopes.each {|c| y << c if c.to_s == c.to_s.reverse} }\n\nn, m = 50, 10_000_000\n[\"cyclopes\", \"prime cyclopes\", \"blind prime cyclopes\", \"palindromic prime cyclopes\"].zip(\n[cyclopes, prime_cyclopes, blind_prime_cyclopes, palindromic_prime_cyclopes]).each do |name, enum|\n  cycl, idx = enum.each_with_index.detect{|n, i| n > m}\n  puts \"The first \nend\n", "target": "from sympy import isprime\n\n\ndef print50(a, width=8):\n    for i, n in enumerate(a):\n        print(f'{n: {width},}', end='\\n' if (i + 1) % 10 == 0 else '')\n\n\ndef generate_cyclops(maxdig=9):\n    yield 0\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for left in arr:\n            for right in arr:\n                yield int(left + '0' + right)\n\n\ndef generate_prime_cyclops():\n    for c in generate_cyclops():\n        if isprime(c):\n            yield c\n\n\ndef generate_blind_prime_cyclops():\n    for c in generate_prime_cyclops():\n        cstr = str(c)\n        mid = len(cstr) // 2\n        if isprime(int(cstr[:mid] + cstr[mid+1:])):\n            yield c\n\n\ndef generate_palindromic_cyclops(maxdig=9):\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for s in arr:\n            yield int(s + '0' + s[::-1])\n\n\ndef generate_palindromic_prime_cyclops():\n    for c in generate_palindromic_cyclops():\n        if isprime(c):\n            yield c\n\n\nprint('The first 50 cyclops numbers are:')\ngen = generate_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 prime cyclops numbers are:')\ngen = generate_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 blind prime cyclops numbers are:')\ngen = generate_blind_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_blind_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next blind prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 palindromic prime cyclops numbers are:')\ngen = generate_palindromic_prime_cyclops()\nprint50([next(gen) for _ in range(50)], 11)\nfor i, c in enumerate(generate_palindromic_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next palindromic prime cyclops number after 10,000,000 is {c} at position {i}.')\n        break\n"}
{"id": 389387, "name": "Conjugate a Latin verb", "source": "Translate Ruby to Python: def conjugate(infinitive)\n    return [\"Can not conjugate \n  conjugations = case infinitive[-3..-1]\n    when \"are\" then [\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"]\n    when \"\u0113re\" then [\"eo\", \"es\", \"et\", \"emus\", \"etis\", \"ent\"]\n    when \"ere\" then [\"o\", \"is\", \"it\", \"imus\", \"itis\", \"unt\"]\n    when \"ire\" then [\"io\", \"is\", \"it\", \"imus\", \"itis\", \"iunt\"]\n    else return [\"Can not conjugate \n  end\n  conjugations.map{|c| infinitive[0..-4] + c}\nend\n\n[\"amare\", \"vid\u0113re\", \"ducere\", \"audire\",\"qwerty\", \"are\"].each do |inf|\n    puts \"\\n\" + inf + \":\"\n    puts conjugate inf \nend\n", "target": "\n\n \ndef conjugate(infinitive): \n    if not infinitive[-3:] == \"are\":\n        print(\"'\", infinitive, \"' non prima coniugatio verbi.\\n\", sep='')\n        return False\n    \n    stem = infinitive[0:-3]\n    if len(stem) == 0:\n        print(\"\\'\", infinitive, \"\\' non satis diu conjugatus\\n\", sep='')\n        return False\n\n    print(\"Praesens indicativi temporis of '\", infinitive, \"':\", sep='') \n    for ending in (\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"):\n        print(\"     \", stem, ending, sep='')\n    print()\n \n \nif __name__ == '__main__':\n    for infinitive in (\"amare\", \"dare\", \"qwerty\", \"are\"):\n        conjugate(infinitive)\n"}
{"id": 389388, "name": "Conjugate a Latin verb", "source": "Translate Ruby to Python: def conjugate(infinitive)\n    return [\"Can not conjugate \n  conjugations = case infinitive[-3..-1]\n    when \"are\" then [\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"]\n    when \"\u0113re\" then [\"eo\", \"es\", \"et\", \"emus\", \"etis\", \"ent\"]\n    when \"ere\" then [\"o\", \"is\", \"it\", \"imus\", \"itis\", \"unt\"]\n    when \"ire\" then [\"io\", \"is\", \"it\", \"imus\", \"itis\", \"iunt\"]\n    else return [\"Can not conjugate \n  end\n  conjugations.map{|c| infinitive[0..-4] + c}\nend\n\n[\"amare\", \"vid\u0113re\", \"ducere\", \"audire\",\"qwerty\", \"are\"].each do |inf|\n    puts \"\\n\" + inf + \":\"\n    puts conjugate inf \nend\n", "target": "\n\n \ndef conjugate(infinitive): \n    if not infinitive[-3:] == \"are\":\n        print(\"'\", infinitive, \"' non prima coniugatio verbi.\\n\", sep='')\n        return False\n    \n    stem = infinitive[0:-3]\n    if len(stem) == 0:\n        print(\"\\'\", infinitive, \"\\' non satis diu conjugatus\\n\", sep='')\n        return False\n\n    print(\"Praesens indicativi temporis of '\", infinitive, \"':\", sep='') \n    for ending in (\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"):\n        print(\"     \", stem, ending, sep='')\n    print()\n \n \nif __name__ == '__main__':\n    for infinitive in (\"amare\", \"dare\", \"qwerty\", \"are\"):\n        conjugate(infinitive)\n"}
{"id": 389389, "name": "Prime numbers which contain 123", "source": "Translate Ruby to Python: require 'prime'\n\nRE = /123/\nputs Prime.each(100_000).select {|prime| RE.match? prime.to_s}.join(\" \"), \"\"\nputs \"\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 389390, "name": "Prime numbers which contain 123", "source": "Translate Ruby to Python: require 'prime'\n\nRE = /123/\nputs Prime.each(100_000).select {|prime| RE.match? prime.to_s}.join(\" \"), \"\"\nputs \"\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 389391, "name": "Prime triplets", "source": "Translate Ruby to Python: say \"Values of p such that (p, p+2, p+6) are all prime:\"\n5500.primes.grep{|p| all_prime(p+2, p+6) }.say\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for p in range(3, 5499, 2):\n        if not isPrime(p+6):\n            continue\n        if not isPrime(p+2):\n            continue\n        if not isPrime(p):\n            continue\n        print(f'[{p} {p+2} {p+6}]')\n"}
{"id": 389392, "name": "Prime triplets", "source": "Translate Ruby to Python: say \"Values of p such that (p, p+2, p+6) are all prime:\"\n5500.primes.grep{|p| all_prime(p+2, p+6) }.say\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for p in range(3, 5499, 2):\n        if not isPrime(p+6):\n            continue\n        if not isPrime(p+2):\n            continue\n        if not isPrime(p):\n            continue\n        print(f'[{p} {p+2} {p+6}]')\n"}
{"id": 389393, "name": "Neighbour primes", "source": "Translate Ruby to Python: require 'prime'\n\np Prime.each(500).each_cons(2).select{|p, q| (p*q+2).prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 389394, "name": "Neighbour primes", "source": "Translate Ruby to Python: require 'prime'\n\np Prime.each(500).each_cons(2).select{|p, q| (p*q+2).prime? }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 389395, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Ruby to Python: class Integer\n  def square?\n    isqrt = Integer.sqrt(self)\n    isqrt*isqrt == self\n  end\nend\n\nlist = [3,4,34,25,9,12,36,56,36].chain(\n       [2,8,81,169,34,55,76,49,7],\n       [75,121,75,144,35,16,46,35])\n\np list.select(&:square?).sort\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 389396, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Ruby to Python: class Integer\n  def square?\n    isqrt = Integer.sqrt(self)\n    isqrt*isqrt == self\n  end\nend\n\nlist = [3,4,34,25,9,12,36,56,36].chain(\n       [2,8,81,169,34,55,76,49,7],\n       [75,121,75,144,35,16,46,35])\n\np list.select(&:square?).sort\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 389397, "name": "Composite numbers k with no single digit factors whose factors are all substrings of k", "source": "Translate Ruby to Python: require 'prime'\n\ngenerator2357 = Enumerator.new do |y|\n  gen23 = Prime::Generator23.new\n  gen23.each {|n| y << n unless (n%5 == 0 || n%7 == 0) }\nend\n\nres = generator2357.lazy.select do |n|\n  primes, exp = n.prime_division.transpose\n  next if exp.sum < 2 \n  s = n.to_s\n  primes.all?{|pr| s.match?(-pr.to_s) }\nend\n\nres.take(10).each{|n| puts n}\n", "target": "from sympy import isprime, factorint\n\ndef contains_its_prime_factors_all_over_7(n):\n    if n < 10 or isprime(n):\n        return False\n    strn = str(n)\n    pfacs = factorint(n).keys()\n    return all(f > 9 and str(f) in strn for f in pfacs)\n\nfound = 0\nfor n in range(1_000_000_000):\n    if contains_its_prime_factors_all_over_7(n):\n        found += 1\n        print(f'{n: 12,}', end = '\\n' if found % 10 == 0 else '')\n        if found == 20:\n            break\n"}
{"id": 389398, "name": "Composite numbers k with no single digit factors whose factors are all substrings of k", "source": "Translate Ruby to Python: require 'prime'\n\ngenerator2357 = Enumerator.new do |y|\n  gen23 = Prime::Generator23.new\n  gen23.each {|n| y << n unless (n%5 == 0 || n%7 == 0) }\nend\n\nres = generator2357.lazy.select do |n|\n  primes, exp = n.prime_division.transpose\n  next if exp.sum < 2 \n  s = n.to_s\n  primes.all?{|pr| s.match?(-pr.to_s) }\nend\n\nres.take(10).each{|n| puts n}\n", "target": "from sympy import isprime, factorint\n\ndef contains_its_prime_factors_all_over_7(n):\n    if n < 10 or isprime(n):\n        return False\n    strn = str(n)\n    pfacs = factorint(n).keys()\n    return all(f > 9 and str(f) in strn for f in pfacs)\n\nfound = 0\nfor n in range(1_000_000_000):\n    if contains_its_prime_factors_all_over_7(n):\n        found += 1\n        print(f'{n: 12,}', end = '\\n' if found % 10 == 0 else '')\n        if found == 20:\n            break\n"}
{"id": 389399, "name": "Comments", "source": "Translate Ruby to Python: \n\n\n\nclass Foo\nend\n", "target": "\n\nvar x = 0 \n\nvar y = 0 \n\n\nThere are also multi-line comments\nEverything inside of \n]\n\n\n\ndiscard \n"}
{"id": 389400, "name": "Magic constant", "source": "Translate Ruby to Python: func f(n) {\n    (n+2) * ((n+2)**2 + 1) / 2\n}\n\nfunc order(n) {\n    iroot(2*n, 3) + 1\n}\n\nsay (\"First 20 terms: \", f.map(1..20).join(' '))\nsay (\"1000th term: \", f(1000), \" with order \", order(f(1000)))\n\nfor n in (1 .. 20) {\n    printf(\"order(10^%-2s) = %s\\n\", n, order(10**n))\n}\n", "target": "\n\ndef a(n):\n    n += 2\n    return n*(n**2 + 1)/2\n \ndef inv_a(x):\n    k = 0\n    while k*(k**2+1)/2+2 < x:\n        k+=1\n    return k\n\n \nif __name__ == '__main__':\n    print(\"The first 20 magic constants are:\");\n    for n in range(1, 20):\n        print(int(a(n)), end = \" \");\n    print(\"\\nThe 1,000th magic constant is:\",int(a(1000)));\n     \n    for e in range(1, 20):\n        print(f'10^{e}: {inv_a(10**e)}');\n"}
{"id": 389401, "name": "Cullen and Woodall numbers", "source": "Translate Ruby to Python: require 'openssl'\n\ncullen  = Enumerator.new{|y| (1..).each{|n| y << (n*(1<<n) + 1)} }\nwoodall = Enumerator.new{|y| (1..).each{|n| y << (n*(1<<n) - 1)} }\ncullen_primes  = Enumerator.new{|y| (1..).each {|i|y << i if OpenSSL::BN.new(cullen.next).prime?}}\nwoodall_primes = Enumerator.new{|y| (1..).each{|i|y << i if OpenSSL::BN.new(woodall.next).prime?}} \n\nnum = 20\nputs \"First \nputs \"First \nputs \"First 5 Cullen primes:\\n\nputs \"First 12 Woodall primes:\\n\n", "target": "print(\"working...\")\nprint(\"First 20 Cullen numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)+1\n    print(str(num),end= \" \")\n\nprint()\nprint(\"First 20 Woodall numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)-1\n    print(str(num),end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 389402, "name": "Long literals, with continuations", "source": "Translate Ruby to Python: require \"time\"\n\nlast_revision = Time.utc year: 2021, month: 2, day: 25\n\n\n\n\nelement_list : Array(String) = %w(\nhydrogen     helium        lithium      beryllium\nboron        carbon        nitrogen     oxygen\nfluorine     neon          sodium       magnesium\naluminum     silicon       phosphorous  sulfur\nchlorine     argon         potassium    calcium\nscandium     titanium      vanadium     chromium\nmanganese    iron          cobalt       nickel\ncopper       zinc          gallium      germanium\narsenic      selenium      bromine      krypton\nrubidium     strontium     yttrium      zirconium\nniobium      molybdenum    technetium   ruthenium\nrhodium      palladium     silver       cadmium\nindium       tin           antimony     tellurium\niodine       xenon         cesium       barium\nlanthanum    cerium        praseodymium neodymium\npromethium   samarium      europium     gadolinium\nterbium      dysprosium    holmium      erbium\nthulium      ytterbium     lutetium     hafnium\ntantalum     tungsten      rhenium      osmium\niridium      platinum      gold         mercury\nthallium     lead          bismuth      polonium\nastatine     radon         francium     radium\nactinium     thorium       protactinium uranium\nneptunium    plutonium     americium    curium\nberkelium    californium   einsteinium  fermium\nmendelevium  nobelium      lawrencium   rutherfordium\ndubnium      seaborgium    bohrium      hassium\nmeitnerium   darmstadtium  roentgenium  copernicium\nnihonium     flerovium     moscovium    livermorium\ntennessine   oganesson)\n\nputs last_revision.to_s \"last revised %B %e, %Y\"\nputs \"number of elements: \nputs \"highest element: \n", "target": "\n\nrevision = \"October 13th 2020\"\n\n\n\n\nelements = (\n    \"hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine \"\n    \"neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon \"\n    \"potassium calcium scandium titanium vanadium chromium manganese iron \"\n    \"cobalt nickel copper zinc gallium germanium arsenic selenium bromine \"\n    \"krypton rubidium strontium yttrium zirconium niobium molybdenum \"\n    \"technetium ruthenium rhodium palladium silver cadmium indium tin \"\n    \"antimony tellurium iodine xenon cesium barium lanthanum cerium \"\n    \"praseodymium neodymium promethium samarium europium gadolinium terbium \"\n    \"dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum \"\n    \"tungsten rhenium osmium iridium platinum gold mercury thallium lead \"\n    \"bismuth polonium astatine radon francium radium actinium thorium \"\n    \"protactinium uranium neptunium plutonium americium curium berkelium \"\n    \"californium einsteinium fermium mendelevium nobelium lawrencium \"\n    \"rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium \"\n    \"roentgenium copernicium nihonium flerovium moscovium livermorium \"\n    \"tennessine oganesson\"\n)\n\n\ndef report():\n    \n    items = elements.split()\n\n    print(f\"Last revision date: {revision}\")\n    print(f\"Number of elements: {len(items)}\")\n    print(f\"Last element     \u00a0: {items[-1]}\")\n\n\nif __name__ == \"__main__\":\n    report()\n"}
{"id": 389403, "name": "Find squares n where n+1 is prime", "source": "Translate Ruby to Python: require 'prime'\n\np (1..Integer.sqrt(1000)).filter_map{|n| sqr = n*n; sqr if (sqr+1).prime? }\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 389404, "name": "Find squares n where n+1 is prime", "source": "Translate Ruby to Python: require 'prime'\n\np (1..Integer.sqrt(1000)).filter_map{|n| sqr = n*n; sqr if (sqr+1).prime? }\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 389405, "name": "Read a file character by character_UTF8", "source": "Translate Ruby to Python: File.open(\"input.txt\") do |file|\n  file.each_char { |c| p c }\nend\n", "target": "def get_next_character(f):\n  \n  c = f.read(1)\n  while c:\n    while True:\n      try:\n        yield c.decode('utf-8')\n      except UnicodeDecodeError:\n        \n        \n        c += f.read(1)\n      else:\n        \n        c = f.read(1)\n        break\n\n\nwith open(\"input.txt\",\"rb\") as f:\n    for c in get_next_character(f):\n        print(c)\n"}
{"id": 389406, "name": "Galton box animation", "source": "Translate Ruby to Python: $rows_of_pins = 12\n$width = $rows_of_pins * 10 + ($rows_of_pins+1)*14\n\nShoes.app(\n    :width => $width + 14,\n    :title => \"Galton Box\"\n) do\n  @bins = Array.new($rows_of_pins+1, 0)\n\n  @x_coords = Array.new($rows_of_pins) {Array.new}\n  @y_coords = Array.new($rows_of_pins)\n  stack(:width => $width) do\n    stroke gray\n    fill gray\n    1.upto($rows_of_pins) do |row|\n      y = 14 + 24*row\n      @y_coords[row-1] = y\n      row.times do |i|\n        x = $width / 2 + (i - 0.5*row)*24 + 14\n        @x_coords[row-1] << x\n        oval x+2, y, 6\n      end\n    end\n  end\n  @y_coords << @y_coords[-1] + 24\n  @x_coords << @x_coords[-1].map {|x| x-12} + [@x_coords[-1][-1]+12]\n\n  @balls = stack(:width => $width) do\n    stroke red\n    fill red\n  end.move(0,0)\n\n  @histogram = stack(:width => $width) do\n    nostroke\n    fill black\n  end.move(0, @y_coords[-1] + 10)\n\n  @paused = false\n  keypress do |key|\n    case key\n    when \"\\x11\", :control_q\n      exit\n    when \"\\x10\", :control_p\n      @paused = !@paused\n    end\n  end\n\n  @ball_row = 0\n  @ball_col = 0\n  animate(2*$rows_of_pins) do\n    if not @paused\n      y = @y_coords[@ball_row] - 12\n      x = @x_coords[@ball_row][@ball_col]\n      @balls.clear {oval x, y, 10}\n      @ball_row += 1\n      if @ball_row <= $rows_of_pins\n        @ball_col += 1 if rand >= 0.5\n      else\n        @bins[@ball_col] += 1\n        @ball_row = @ball_col = 0\n        update_histogram\n      end\n    end\n  end\n\n  def update_histogram\n    y = @y_coords[-1] + 10\n    @histogram.clear do\n      @bins.each_with_index do |num, i|\n        if num > 0\n          x = @x_coords[-1][i]\n          rect x-6, 0, 24, num\n        end\n      end\n    end\n  end\nend\n", "target": "\n\nimport sys, os\nimport random\nimport time\n\ndef print_there(x, y, text):\n     sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n     sys.stdout.flush()\n\n\nclass Ball():\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        \n    def update(self):\n        self.x += random.randint(0,1)\n        self.y += 1\n\n    def fall(self):\n        self.y +=1\n\n\nclass Board():\n    def __init__(self, width, well_depth, N):\n        self.balls = []\n        self.fallen = [0] * (width + 1)\n        self.width = width\n        self.well_depth = well_depth\n        self.N = N\n        self.shift = 4\n        \n    def update(self):\n        for ball in self.balls:\n            if ball.y < self.width:\n                ball.update()\n            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:\n                ball.fall()\n            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:\n                self.fallen[ball.x] += 1\n            else:\n                pass\n                \n    def balls_on_board(self):\n        return len(self.balls) - sum(self.fallen)\n                \n    def add_ball(self):\n        if(len(self.balls) <= self.N):\n            self.balls.append(Ball())\n\n    def print_board(self):\n        for y in range(self.width + 1):\n            for x in range(y):\n                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, \"\n    def print_ball(self, ball):\n        if ball.y <= self.width:\n            x = self.width - ball.y + 2*ball.x + self.shift\n        else:\n            x = 2*ball.x + self.shift\n        y = ball.y + 1\n        print_there(y, x, \"*\")\n         \n    def print_all(self):\n        print(chr(27) + \"[2J\")\n        self.print_board();\n        for ball in self.balls:\n            self.print_ball(ball)\n\n\ndef main():\n    board = Board(width = 15, well_depth = 5, N = 10)\n    board.add_ball() \n    while(board.balls_on_board() > 0):\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.add_ball()\n\n\nif __name__==\"__main__\":\n    main()\n"}
{"id": 389407, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Ruby to Python: var maxsum = 99\nvar primes = maxsum.primes\n\nvar descendants = (maxsum+1).of { [] }\nvar ancestors   = (maxsum+1).of { [] }\n\nfor p in (primes) {\n    descendants[p] << p\n    for s in (1 .. descendants.end-p) {\n        descendants[s + p] << descendants[s].map {|q| p*q }...\n    }\n}\n\nfor p in (primes + [4]) {\n    descendants[p].pop\n}\n\nvar total = 0\n\nfor s in (1 .. maxsum) {\n\n    descendants[s].sort!\n\n    total += (var dsclen = descendants[s].len)\n    var idx = descendants[s].first_index {|x| x > maxsum }\n\n    for d in (descendants[s].slice(0, idx)) {\n        ancestors[d] = (ancestors[s] + [s])\n    }\n\n    if ((s <= 20) || (s ~~ [46, 74, 99])) {\n        printf(\"%2d: %d Ancestor(s):\u00a0%-15s %5s Descendant(s): %s\\n\", s,\n            ancestors[s].len, \"[\n            dsclen <= 10 ? descendants[s] : \"[\n    }\n}\n\nsay \"\\nTotal descendants: \n", "target": "from __future__ import print_function\nfrom itertools import takewhile\n\nmaxsum = 99\n\ndef get_primes(max):\n    if max < 2:\n        return []\n    lprimes = [2]\n    for x in range(3, max + 1, 2):\n        for p in lprimes:\n            if x % p == 0:\n                break\n        else:\n            lprimes.append(x)\n    return lprimes\n\ndescendants = [[] for _ in range(maxsum + 1)]\nancestors = [[] for _ in range(maxsum + 1)]\n\nprimes = get_primes(maxsum)\n\nfor p in primes:\n    descendants[p].append(p)\n    for s in range(1, len(descendants) - p):\n        descendants[s + p] += [p * pr for pr in descendants[s]]\n\nfor p in primes + [4]:\n    descendants[p].pop()\n\ntotal = 0\nfor s in range(1, maxsum + 1):\n    descendants[s].sort()\n    for d in takewhile(lambda x: x <= maxsum, descendants[s]):\n        ancestors[d] = ancestors[s] + [s]\n    print([s], \"Level:\", len(ancestors[s]))\n    print(\"Ancestors:\", ancestors[s] if len(ancestors[s]) else \"None\")\n    print(\"Descendants:\", len(descendants[s]) if len(descendants[s]) else \"None\")\n    if len(descendants[s]):\n        print(descendants[s])\n    print()\n    total += len(descendants[s])\n\nprint(\"Total descendants\", total)\n"}
{"id": 389408, "name": "Smallest square that begins with n", "source": "Translate Ruby to Python: def f(n)\n    if n < 1 then\n        return\n    end\n\n    i = 1\n    while true do\n        sq = i * i\n        while sq > n do\n            sq = (sq / 10).floor\n        end\n        if sq == n then\n            print \"%3d %9d %4d\\n\" % [n, i * i, i]\n            return\n        end\n        i = i + 1\n    end\nend\n\nprint(\"Prefix    n^2    n\\n\")\nprint()\nfor i in 1 .. 49\n    f(i)\nend\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389409, "name": "Smallest square that begins with n", "source": "Translate Ruby to Python: def f(n)\n    if n < 1 then\n        return\n    end\n\n    i = 1\n    while true do\n        sq = i * i\n        while sq > n do\n            sq = (sq / 10).floor\n        end\n        if sq == n then\n            print \"%3d %9d %4d\\n\" % [n, i * i, i]\n            return\n        end\n        i = i + 1\n    end\nend\n\nprint(\"Prefix    n^2    n\\n\")\nprint()\nfor i in 1 .. 49\n    f(i)\nend\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389410, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Ruby to Python: class Array\n  def circle_sort!\n    while _circle_sort!(0, size-1) > 0\n    end\n    self\n  end\n  \n  private\n  def _circle_sort!(lo, hi, swaps=0)\n    return swaps if lo == hi\n    low, high = lo, hi\n    mid = (lo + hi) / 2\n    while lo < hi\n      if self[lo] > self[hi]\n        self[lo], self[hi] = self[hi], self[lo]\n        swaps += 1\n      end\n      lo += 1\n      hi -= 1\n    end\n    if lo == hi && self[lo] > self[hi+1]\n      self[lo], self[hi+1] = self[hi+1], self[lo]\n      swaps += 1\n    end\n    swaps + _circle_sort!(low, mid) + _circle_sort!(mid+1, high)\n  end\nend\n\nary = [6, 7, 8, 9, 2, 5, 3, 4, 1]\nputs \"before sort: \nputs \" after sort: \n", "target": "\n\n\n\n\ndef circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':\n    \n    n = R-L\n    if n < 2:\n        return 0\n    swaps = 0\n    m = n//2\n    for i in range(m):\n        if A[R-(i+1)] < A[L+i]:\n            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)\n            swaps += 1\n    if (n & 1) and (A[L+m] < A[L+m-1]):\n        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)\n        swaps += 1\n    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)\n\ndef circle_sort(L:list)->'sort A in place, returning the number of swaps':\n    swaps = 0\n    s = 1\n    while s:\n        s = circle_sort_backend(L, 0, len(L))\n        swaps += s\n    return swaps\n\n\nif __name__ == '__main__':\n    from random import shuffle\n    for i in range(309):\n        L = list(range(i))\n        M = L[:]\n        shuffle(L)\n        N = L[:]\n        circle_sort(L)\n        if L != M:\n            print(len(L))\n            print(N)\n            print(L)\n"}
{"id": 389411, "name": "Word wheel", "source": "Translate Ruby to Python: wheel  = \"ndeokgelw\"\nmiddle, wheel_size = wheel[4], wheel.size\n\nres = File.open(\"unixdict.txt\").each_line.select do |word|\n  w = word.chomp\n  next unless w.size.between?(3, wheel_size)  \n  next unless w.match?(middle)\n  wheel.each_char{|c| w.sub!(c, \"\") } \n  w.empty?\nend\n\nputs res\n", "target": "import urllib.request\nfrom collections import Counter\n\n\nGRID = \n\n\ndef getwords(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    \"Return lowercased words of 3 to 9 characters\"\n    words = urllib.request.urlopen(url).read().decode().strip().lower().split()\n    return (w for w in words if 2 < len(w) < 10)\n\ndef solve(grid, dictionary):\n    gridcount = Counter(grid)\n    mid = grid[4]\n    return [word for word in dictionary\n            if mid in word and not (Counter(word) - gridcount)]\n\n\nif __name__ == '__main__':\n    chars = ''.join(GRID.strip().lower().split())\n    found = solve(chars, dictionary=getwords())\n    print('\\n'.join(found))\n"}
{"id": 389412, "name": "Brace expansion", "source": "Translate Ruby to Python: def getitem(s, depth=0)\n  out = [\"\"]\n  until s.empty?\n    c = s[0]\n    break  if depth>0 and (c == ',' or c == '}')\n    if c == '{' and x = getgroup(s[1..-1], depth+1)\n      out = out.product(x[0]).map{|a,b| a+b}\n      s = x[1]\n    else\n      s, c = s[1..-1], c + s[1]  if c == '\\\\' and s.size > 1\n      out, s = out.map{|a| a+c}, s[1..-1]\n    end\n  end\n  return out, s\nend\n\ndef getgroup(s, depth)\n  out, comma = [], false\n  until s.empty?\n    g, s = getitem(s, depth)\n    break  if s.empty?\n    out += g\n    case s[0]\n      when '}' then return (comma ? out : out.map{|a| \"{\n      when ',' then comma, s = true, s[1..-1]\n    end\n  end\nend\n\nstrs = <<'EOS'\n~/{Downloads,Pictures}/*.{jpg,gif,png}\nIt{{em,alic}iz,erat}e{d,}, please.\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\nEOS\n\nstrs.each_line do |s|\n  puts s.chomp!\n  puts getitem(s)[0].map{|str| \"\\t\"+str}\n  puts\nend\n", "target": "def getitem(s, depth=0):\n    out = [\"\"]\n    while s:\n        c = s[0]\n        if depth and (c == ',' or c == '}'):\n            return out,s\n        if c == '{':\n            x = getgroup(s[1:], depth+1)\n            if x:\n                out,s = [a+b for a in out for b in x[0]], x[1]\n                continue\n        if c == '\\\\' and len(s) > 1:\n            s, c = s[1:], c + s[1]\n\n        out, s = [a+c for a in out], s[1:]\n\n    return out,s\n\ndef getgroup(s, depth):\n    out, comma = [], False\n    while s:\n        g,s = getitem(s, depth)\n        if not s: break\n        out += g\n\n        if s[0] == '}':\n            if comma: return out, s[1:]\n            return ['{' + a + '}' for a in out], s[1:]\n\n        if s[0] == ',':\n            comma,s = True, s[1:]\n\n    return None\n\n\nfor s in .split('\\n'):\n    print \"\\n\\t\".join([s] + getitem(s)[0]) + \"\\n\"\n"}
{"id": 389413, "name": "Intersecting number wheels", "source": "Translate Ruby to Python: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 389414, "name": "Intersecting number wheels", "source": "Translate Ruby to Python: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 389415, "name": "Color of a screen pixel", "source": "Translate Ruby to Python: module Screen\n  IMPORT_COMMAND = '/usr/bin/import'\n\n  \n  def self.pixel(x, y)\n    if m = `\n      m[1..3].map(&:to_i)\n    else\n      false\n    end\n  end\nend\n", "target": "def get_pixel_colour(i_x, i_y):\n\timport win32gui\n\ti_desktop_window_id = win32gui.GetDesktopWindow()\n\ti_desktop_window_dc = win32gui.GetWindowDC(i_desktop_window_id)\n\tlong_colour = win32gui.GetPixel(i_desktop_window_dc, i_x, i_y)\n\ti_colour = int(long_colour)\n\twin32gui.ReleaseDC(i_desktop_window_id,i_desktop_window_dc)\n\treturn (i_colour & 0xff), ((i_colour >> 8) & 0xff), ((i_colour >> 16) & 0xff)\n\nprint (get_pixel_colour(0, 0))\n"}
{"id": 389416, "name": "Yahoo! search interface", "source": "Translate Ruby to Python: require 'open-uri'\nrequire 'hpricot'\n\nSearchResult = Struct.new(:url, :title, :content)\n\nclass SearchYahoo\n  @@urlinfo = [nil, 'ca.search.yahoo.com', 80, '/search', nil, nil]\n\n  def initialize(term)\n    @term = term\n    @page = 1\n    @results = nil\n    @url = URI::HTTP.build(@@urlinfo)\n  end\n\n  def next_result\n    if not @results\n      @results = []\n      fetch_results\n    elsif @results.empty?\n      next_page\n    end\n    @results.shift\n  end\n\n  def fetch_results\n    @url.query = URI.escape(\"p=%s&b=%d\" % [@term, @page])\n    doc = open(@url) { |f| Hpricot(f) }  \n    parse_html(doc)\n  end\n\n  def next_page\n    @page += 10\n    fetch_results\n  end\n\n  def parse_html(doc)\n    doc.search(\"div\n      next unless div.has_attribute?(\"class\") and div.get_attribute(\"class\").index(\"res\") == 0\n      result = SearchResult.new\n      div.search(\"a\").each do |link|\n        next unless link.has_attribute?(\"class\") and link.get_attribute(\"class\") == \"yschttl spt\"\n        result.url = link.get_attribute(\"href\")\n        result.title = link.inner_text\n      end\n      div.search(\"div\").each do |abstract|\n        next unless abstract.has_attribute?(\"class\") and abstract.get_attribute(\"class\").index(\"abstr\")\n        result.content = abstract.inner_text\n      end\n      @results << result\n    end\n  end\nend\n\ns = SearchYahoo.new(\"test\")\n15.times do |i|\n  result = s.next_result\n  puts i+1\n  puts result.title\n  puts result.url\n  puts result.content\n  puts\nend\n", "target": "import urllib\nimport re\n\ndef fix(x):\n    p = re.compile(r'<[^<]*?>')\n    return p.sub('', x).replace('&amp;', '&')\n \nclass YahooSearch:\n    def __init__(self, query, page=1):       \n        self.query = query\n        self.page = page\n        self.url = \"http://search.yahoo.com/search?p=%s&b=%s\" %(self.query, ((self.page - 1) * 10 + 1))\n        self.content = urllib.urlopen(self.url).read()        \n \n    def getresults(self):\n        self.results = []\n \n        for i in re.findall('<a class=\"yschttl spt\" href=\".+?\">(.+?)</a></h3></div>(.+?)</div>.*?<span class=url>(.+?)</span>', self.content):\n \n            title = fix(i[0])\n            content = fix(i[1])\n            url = fix(i[2])\n \n            self.results.append(YahooResult(title, content, url))\n \n        return self.results\n \n    def getnextpage(self):\n        return YahooSearch(self.query, self.page+1)\n \n    search_results = property(fget=getresults)\n    nextpage = property(fget=getnextpage)\n \nclass YahooResult:\n    def __init__(self,title,content,url):\n        self.title = title\n        self.content = content\n        self.url = url\n \n\n \nx = YahooSearch(\"test\")\n \nfor result in x.search_results:\n    print result.title\n"}
{"id": 389417, "name": "Circles of given radius through two points", "source": "Translate Ruby to Python: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 389418, "name": "Circles of given radius through two points", "source": "Translate Ruby to Python: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 389419, "name": "Vampire number", "source": "Translate Ruby to Python: def factor_pairs n\n  first = n / (10 ** (n.to_s.size / 2) - 1)\n  (first .. n ** 0.5).map { |i| [i, n / i] if n % i == 0 }.compact\nend\n\ndef vampire_factors n\n  return [] if n.to_s.size.odd?\n  half = n.to_s.size / 2\n  factor_pairs(n).select do |a, b|\n    a.to_s.size == half && b.to_s.size == half &&\n    [a, b].count {|x| x%10 == 0} != 2          &&\n    \"\n  end\nend\n\ni = vamps = 0\nuntil vamps == 25\n  vf = vampire_factors(i += 1)\n  unless vf.empty?\n    puts \"\n    vamps += 1\n  end\nend\n\n[16758243290880, 24959017348650, 14593825548650].each do |n|\n  if (vf = vampire_factors n).empty?\n    puts \"\n  else\n    puts \"\n  end\nend\n", "target": "from __future__ import division\n\nimport math\nfrom operator import mul\nfrom itertools import product\nfrom functools import reduce\n\n\ndef fac(n):\n    \n    step = lambda x: 1 + x*4 - (x//2)*2\n    maxq = int(math.floor(math.sqrt(n)))\n    d = 1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n        q = step(d)\n        d += 1\n    res = []\n    if q <= maxq:\n        res.extend(fac(n//q))\n        res.extend(fac(q)) \n    else: res=[n]\n    return res\n\ndef fact(n):\n    \n    res = fac(n)\n    return [(c, res.count(c)) for c in set(res)]\n\ndef divisors(n):\n    'Returns all the divisors of n'\n    factors = fact(n)   \n    primes, maxpowers = zip(*factors)\n    powerranges = (range(m+1) for m in maxpowers)\n    powers = product(*powerranges)\n    return (\n        reduce(mul,\n               (prime**power for prime, power in zip(primes, powergroup)),\n               1)\n        for powergroup in powers)\n    \ndef vampire(n):\n    fangsets = set( frozenset([d, n//d])\n                    for d in divisors(n)\n                    if (len(str(d)) == len(str(n))/2.\n                        and sorted(str(d) + str(n//d)) == sorted(str(n))\n                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )\n    return sorted(tuple(sorted(fangs)) for fangs in fangsets)\n    \n\nif __name__ == '__main__':\n    print('First 25 vampire numbers')\n    count = n = 0\n    while count <25:\n        n += 1\n        fangpairs = vampire(n)\n        if fangpairs:\n            count += 1\n            print('%i: %r' % (n, fangpairs))\n    print('\\nSpecific checks for fangpairs')\n    for n in (16758243290880, 24959017348650, 14593825548650):\n        fangpairs = vampire(n)\n        print('%i: %r' % (n, fangpairs))\n"}
{"id": 389420, "name": "Play recorded sounds", "source": "Translate Ruby to Python: require 'win32/sound'\ninclude Win32\n\nsound1 = ENV['WINDIR'] + '\\Media\\Windows XP Startup.wav' \nsound2 = ENV['WINDIR'] + '\\Media\\Windows XP Shutdown.wav' \n\nputs \"play the sounds sequentially\"\n[sound1, sound2].each do |s| \n  t1 = Time.now\n  Sound.play(s)\n  puts \"'\nend\n\nputs \"attempt to play the sounds simultaneously\"\n[sound1, sound2].each {|s| Sound.play(s, Sound::ASYNC)}\n\nputs <<END\nthe above only plays the second sound2 because the library only appears \nto be able to play one sound at a time.\nEND\n\nputs \"loop a sound for a few seconds\"\nputs Time.now\nSound.play(sound1, Sound::ASYNC + Sound::LOOP)\nsleep 10\nSound.stop\nputs Time.now\n\nputs \"manipulate the volume\"\nvol_left, vol_right = Sound.wave_volume\nSound.play(sound1, Sound::ASYNC)\nsleep 1\nputs \"right channel quiet\"\nSound.set_wave_volume(vol_left, 0)\nsleep 1\nputs \"left channel quiet\"\nSound.set_wave_volume(0, vol_right)\nsleep 1\nputs \"restore volume\"\nSound.set_wave_volume(vol_left, vol_right)\n\nsleep 1\nputs \"the asynchronous sound is cancelled when the program exits\"\n", "target": "import time\nfrom pygame import mixer\n\nmixer.init(frequency=16000) \ns1 = mixer.Sound('test.wav')\ns2 = mixer.Sound('test2.wav')\n\n\ns1.play(-1)         \ntime.sleep(0.5)\n\n\ns2.play()          \ntime.sleep(2)\ns2.play(2)         \ntime.sleep(10)\n\n\ns1.set_volume(0.1)\ntime.sleep(5)\n\n\ns1.set_volume(1)\ntime.sleep(5)\n\ns1.stop()\ns2.stop()\nmixer.quit()\n"}
{"id": 389421, "name": "Mind boggling card trick", "source": "Translate Ruby to Python: deck = ([:black, :red] * 26 ).shuffle\nblack_pile, red_pile, discard = [] of Symbol, [] of Symbol, [] of Symbol\n\nuntil deck.empty?\n  discard << deck.pop\n  discard.last == :black ? black_pile << deck.pop : red_pile << deck.pop\nend\n\nx = rand( [black_pile.size, red_pile.size].min )\n \nred_bunch   = (0...x).map { red_pile.delete_at( rand( red_pile.size )) }\nblack_bunch = (0...x).map { black_pile.delete_at( rand( black_pile.size )) }\n \nblack_pile += red_bunch\nred_pile   += black_bunch\n \nputs \"The magician predicts there will be \nDrumroll...\nThere were \n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 389422, "name": "Mind boggling card trick", "source": "Translate Ruby to Python: deck = ([:black, :red] * 26 ).shuffle\nblack_pile, red_pile, discard = [] of Symbol, [] of Symbol, [] of Symbol\n\nuntil deck.empty?\n  discard << deck.pop\n  discard.last == :black ? black_pile << deck.pop : red_pile << deck.pop\nend\n\nx = rand( [black_pile.size, red_pile.size].min )\n \nred_bunch   = (0...x).map { red_pile.delete_at( rand( red_pile.size )) }\nblack_bunch = (0...x).map { black_pile.delete_at( rand( black_pile.size )) }\n \nblack_pile += red_bunch\nred_pile   += black_bunch\n \nputs \"The magician predicts there will be \nDrumroll...\nThere were \n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 389423, "name": "Cistercian numerals", "source": "Translate Ruby to Python: def initN\n    n = Array.new(15){Array.new(11, ' ')}\n    for i in 1..15\n        n[i - 1][5] = 'x'\n    end\n    return n\nend\n\ndef horiz(n, c1, c2, r)\n    for c in c1..c2\n        n[r][c] = 'x'\n    end\nend\n\ndef verti(n, r1, r2, c)\n    for r in r1..r2\n        n[r][c] = 'x'\n    end\nend\n\ndef diagd(n, c1, c2, r)\n    for c in c1..c2\n        n[r+c-c1][c] = 'x'\n    end\nend\n\ndef diagu(n, c1, c2, r)\n    for c in c1..c2\n        n[r-c+c1][c] = 'x'\n    end\nend\n\ndef initDraw\n    draw = []\n\n    draw[1] = lambda do |n| horiz(n, 6, 10, 0) end\n    draw[2] = lambda do |n| horiz(n, 6, 10, 4) end\n    draw[3] = lambda do |n| diagd(n, 6, 10, 0) end\n    draw[4] = lambda do |n| diagu(n, 6, 10, 4) end\n    draw[5] = lambda do |n|\n        draw[1].call(n)\n        draw[4].call(n)\n    end\n    draw[6] = lambda do |n| verti(n, 0, 4, 10) end\n    draw[7] = lambda do |n|\n        draw[1].call(n)\n        draw[6].call(n)\n    end\n    draw[8] = lambda do |n|\n        draw[2].call(n)\n        draw[6].call(n)\n    end\n    draw[9] = lambda do |n|\n        draw[1].call(n)\n        draw[8].call(n)\n    end\n\n    draw[10] = lambda do |n| horiz(n, 0, 4, 0) end\n    draw[20] = lambda do |n| horiz(n, 0, 4, 4) end\n    draw[30] = lambda do |n| diagu(n, 0, 4, 4) end\n    draw[40] = lambda do |n| diagd(n, 0, 4, 0) end\n    draw[50] = lambda do |n|\n        draw[10].call(n)\n        draw[40].call(n)\n    end\n    draw[60] = lambda do |n| verti(n, 0, 4, 0) end\n    draw[70] = lambda do |n|\n        draw[10].call(n)\n        draw[60].call(n)\n    end\n    draw[80] = lambda do |n|\n        draw[20].call(n)\n        draw[60].call(n)\n    end\n    draw[90] = lambda do |n|\n        draw[10].call(n)\n        draw[80].call(n)\n    end\n\n    draw[100] = lambda do |n| horiz(n, 6, 10, 14) end\n    draw[200] = lambda do |n| horiz(n, 6, 10, 10) end\n    draw[300] = lambda do |n| diagu(n, 6, 10, 14) end\n    draw[400] = lambda do |n| diagd(n, 6, 10, 10) end\n    draw[500] = lambda do |n|\n        draw[100].call(n)\n        draw[400].call(n)\n    end\n    draw[600] = lambda do |n| verti(n, 10, 14, 10) end\n    draw[700] = lambda do |n|\n        draw[100].call(n)\n        draw[600].call(n)\n    end\n    draw[800] = lambda do |n|\n        draw[200].call(n)\n        draw[600].call(n)\n    end\n    draw[900] = lambda do |n|\n        draw[100].call(n)\n        draw[800].call(n)\n    end\n\n    draw[1000] = lambda do |n| horiz(n, 0, 4, 14) end\n    draw[2000] = lambda do |n| horiz(n, 0, 4, 10) end\n    draw[3000] = lambda do |n| diagd(n, 0, 4, 10) end\n    draw[4000] = lambda do |n| diagu(n, 0, 4, 14) end\n    draw[5000] = lambda do |n|\n        draw[1000].call(n)\n        draw[4000].call(n)\n    end\n    draw[6000] = lambda do |n| verti(n, 10, 14, 0) end\n    draw[7000] = lambda do |n|\n        draw[1000].call(n)\n        draw[6000].call(n)\n    end\n    draw[8000] = lambda do |n|\n        draw[2000].call(n)\n        draw[6000].call(n)\n    end\n    draw[9000] = lambda do |n|\n        draw[1000].call(n)\n        draw[8000].call(n)\n    end\n\n    return draw\nend\n\ndef printNumeral(n)\n    for a in n\n        for b in a\n            print b\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndraw = initDraw()\nfor number in [0, 1, 20, 300, 4000, 5555, 6789, 9999]\n    n = initN()\n    print number, \":\\n\"\n\n    thousands = (number / 1000).floor\n    number = number % 1000\n\n    hundreds = (number / 100).floor\n    number = number % 100\n\n    tens = (number / 10).floor\n    ones = number % 10\n\n    if thousands > 0 then\n        draw[thousands * 1000].call(n)\n    end\n    if hundreds > 0 then\n        draw[hundreds * 100].call(n)\n    end\n    if tens > 0 then\n        draw[tens * 10].call(n)\n    end\n    if ones > 0 then\n        draw[ones].call(n)\n    end\n    printNumeral(n)\nend\n", "target": "\n\n\n\n\ndef _init():\n    \"digit sections for forming numbers\"\n    digi_bits = .strip()\n\n    lines = [[d.replace('.', ' ') for d in ln.strip().split()]\n             for ln in digi_bits.strip().split('\\n')\n             if '\n    formats = '<2 >2 <2 >2'.split()\n    digits = [[f\"{dig:{f}}\" for dig in line]\n              for f, line in zip(formats, lines)]\n\n    return digits\n\n_digits = _init()\n\n\n\ndef _to_digits(n):\n    assert 0 <= n < 10_000 and int(n) == n\n    \n    return [int(digit) for digit in f\"{int(n):04}\"][::-1]\n\ndef num_to_lines(n):\n    global _digits\n    d = _to_digits(n)\n    lines = [\n        ''.join((_digits[1][d[1]], '\u2503',  _digits[0][d[0]])),\n        ''.join((_digits[0][   0], '\u2503',  _digits[0][   0])),\n        ''.join((_digits[3][d[3]], '\u2503',  _digits[2][d[2]])),\n        ]\n    \n    return lines\n\ndef cjoin(c1, c2, spaces='   '):\n    return [spaces.join(by_row) for by_row in zip(c1, c2)]\n\n\nif __name__ == '__main__':\n    \n    \n    \n    \n    for pow10 in range(4):    \n        step = 10 ** pow10\n        print(f'\\nArabic {step}-to-{9*step} by {step} in Cistercian:\\n')\n        lines = num_to_lines(step)\n        for n in range(step*2, step*10, step):\n            lines = cjoin(lines, num_to_lines(n))\n        print('\\n'.join(lines))\n    \n\n    numbers = [0, 5555, 6789, 6666]\n    print(f'\\nArabic {str(numbers)[1:-1]} in Cistercian:\\n')\n    lines = num_to_lines(numbers[0])\n    for n in numbers[1:]:\n        lines = cjoin(lines, num_to_lines(n))\n    print('\\n'.join(lines))\n"}
{"id": 389424, "name": "Cistercian numerals", "source": "Translate Ruby to Python: def initN\n    n = Array.new(15){Array.new(11, ' ')}\n    for i in 1..15\n        n[i - 1][5] = 'x'\n    end\n    return n\nend\n\ndef horiz(n, c1, c2, r)\n    for c in c1..c2\n        n[r][c] = 'x'\n    end\nend\n\ndef verti(n, r1, r2, c)\n    for r in r1..r2\n        n[r][c] = 'x'\n    end\nend\n\ndef diagd(n, c1, c2, r)\n    for c in c1..c2\n        n[r+c-c1][c] = 'x'\n    end\nend\n\ndef diagu(n, c1, c2, r)\n    for c in c1..c2\n        n[r-c+c1][c] = 'x'\n    end\nend\n\ndef initDraw\n    draw = []\n\n    draw[1] = lambda do |n| horiz(n, 6, 10, 0) end\n    draw[2] = lambda do |n| horiz(n, 6, 10, 4) end\n    draw[3] = lambda do |n| diagd(n, 6, 10, 0) end\n    draw[4] = lambda do |n| diagu(n, 6, 10, 4) end\n    draw[5] = lambda do |n|\n        draw[1].call(n)\n        draw[4].call(n)\n    end\n    draw[6] = lambda do |n| verti(n, 0, 4, 10) end\n    draw[7] = lambda do |n|\n        draw[1].call(n)\n        draw[6].call(n)\n    end\n    draw[8] = lambda do |n|\n        draw[2].call(n)\n        draw[6].call(n)\n    end\n    draw[9] = lambda do |n|\n        draw[1].call(n)\n        draw[8].call(n)\n    end\n\n    draw[10] = lambda do |n| horiz(n, 0, 4, 0) end\n    draw[20] = lambda do |n| horiz(n, 0, 4, 4) end\n    draw[30] = lambda do |n| diagu(n, 0, 4, 4) end\n    draw[40] = lambda do |n| diagd(n, 0, 4, 0) end\n    draw[50] = lambda do |n|\n        draw[10].call(n)\n        draw[40].call(n)\n    end\n    draw[60] = lambda do |n| verti(n, 0, 4, 0) end\n    draw[70] = lambda do |n|\n        draw[10].call(n)\n        draw[60].call(n)\n    end\n    draw[80] = lambda do |n|\n        draw[20].call(n)\n        draw[60].call(n)\n    end\n    draw[90] = lambda do |n|\n        draw[10].call(n)\n        draw[80].call(n)\n    end\n\n    draw[100] = lambda do |n| horiz(n, 6, 10, 14) end\n    draw[200] = lambda do |n| horiz(n, 6, 10, 10) end\n    draw[300] = lambda do |n| diagu(n, 6, 10, 14) end\n    draw[400] = lambda do |n| diagd(n, 6, 10, 10) end\n    draw[500] = lambda do |n|\n        draw[100].call(n)\n        draw[400].call(n)\n    end\n    draw[600] = lambda do |n| verti(n, 10, 14, 10) end\n    draw[700] = lambda do |n|\n        draw[100].call(n)\n        draw[600].call(n)\n    end\n    draw[800] = lambda do |n|\n        draw[200].call(n)\n        draw[600].call(n)\n    end\n    draw[900] = lambda do |n|\n        draw[100].call(n)\n        draw[800].call(n)\n    end\n\n    draw[1000] = lambda do |n| horiz(n, 0, 4, 14) end\n    draw[2000] = lambda do |n| horiz(n, 0, 4, 10) end\n    draw[3000] = lambda do |n| diagd(n, 0, 4, 10) end\n    draw[4000] = lambda do |n| diagu(n, 0, 4, 14) end\n    draw[5000] = lambda do |n|\n        draw[1000].call(n)\n        draw[4000].call(n)\n    end\n    draw[6000] = lambda do |n| verti(n, 10, 14, 0) end\n    draw[7000] = lambda do |n|\n        draw[1000].call(n)\n        draw[6000].call(n)\n    end\n    draw[8000] = lambda do |n|\n        draw[2000].call(n)\n        draw[6000].call(n)\n    end\n    draw[9000] = lambda do |n|\n        draw[1000].call(n)\n        draw[8000].call(n)\n    end\n\n    return draw\nend\n\ndef printNumeral(n)\n    for a in n\n        for b in a\n            print b\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndraw = initDraw()\nfor number in [0, 1, 20, 300, 4000, 5555, 6789, 9999]\n    n = initN()\n    print number, \":\\n\"\n\n    thousands = (number / 1000).floor\n    number = number % 1000\n\n    hundreds = (number / 100).floor\n    number = number % 100\n\n    tens = (number / 10).floor\n    ones = number % 10\n\n    if thousands > 0 then\n        draw[thousands * 1000].call(n)\n    end\n    if hundreds > 0 then\n        draw[hundreds * 100].call(n)\n    end\n    if tens > 0 then\n        draw[tens * 10].call(n)\n    end\n    if ones > 0 then\n        draw[ones].call(n)\n    end\n    printNumeral(n)\nend\n", "target": "\n\n\n\n\ndef _init():\n    \"digit sections for forming numbers\"\n    digi_bits = .strip()\n\n    lines = [[d.replace('.', ' ') for d in ln.strip().split()]\n             for ln in digi_bits.strip().split('\\n')\n             if '\n    formats = '<2 >2 <2 >2'.split()\n    digits = [[f\"{dig:{f}}\" for dig in line]\n              for f, line in zip(formats, lines)]\n\n    return digits\n\n_digits = _init()\n\n\n\ndef _to_digits(n):\n    assert 0 <= n < 10_000 and int(n) == n\n    \n    return [int(digit) for digit in f\"{int(n):04}\"][::-1]\n\ndef num_to_lines(n):\n    global _digits\n    d = _to_digits(n)\n    lines = [\n        ''.join((_digits[1][d[1]], '\u2503',  _digits[0][d[0]])),\n        ''.join((_digits[0][   0], '\u2503',  _digits[0][   0])),\n        ''.join((_digits[3][d[3]], '\u2503',  _digits[2][d[2]])),\n        ]\n    \n    return lines\n\ndef cjoin(c1, c2, spaces='   '):\n    return [spaces.join(by_row) for by_row in zip(c1, c2)]\n\n\nif __name__ == '__main__':\n    \n    \n    \n    \n    for pow10 in range(4):    \n        step = 10 ** pow10\n        print(f'\\nArabic {step}-to-{9*step} by {step} in Cistercian:\\n')\n        lines = num_to_lines(step)\n        for n in range(step*2, step*10, step):\n            lines = cjoin(lines, num_to_lines(n))\n        print('\\n'.join(lines))\n    \n\n    numbers = [0, 5555, 6789, 6666]\n    print(f'\\nArabic {str(numbers)[1:-1]} in Cistercian:\\n')\n    lines = num_to_lines(numbers[0])\n    for n in numbers[1:]:\n        lines = cjoin(lines, num_to_lines(n))\n    print('\\n'.join(lines))\n"}
{"id": 389425, "name": "Poker hand analyser", "source": "Translate Ruby to Python: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 389426, "name": "Poker hand analyser", "source": "Translate Ruby to Python: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 389427, "name": "Fibonacci word_fractal", "source": "Translate Ruby to Python: def fibonacci_word(n)\n  words = [\"1\", \"0\"]\n  (n-1).times{ words << words[-1] + words[-2] }\n  words[n]\nend\n\ndef print_fractal(word)\n  area = Hash.new(\" \")\n  x = y = 0\n  dx, dy = 0, -1\n  area[[x,y]] = \"S\"\n  word.each_char.with_index(1) do |c,n|\n    area[[x+dx, y+dy]] = dx.zero? ? \"|\" : \"-\"\n    x, y = x+2*dx, y+2*dy\n    area[[x, y]] = \"+\"\n    dx,dy = n.even? ? [dy,-dx] : [-dy,dx]  if c==\"0\"\n  end\n  \n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  for y in ymin..ymax\n    puts (xmin..xmax).map{|x| area[[x,y]]}.join\n  end\nend\n\nword = fibonacci_word(16)\nprint_fractal(word)\n", "target": "from functools import wraps\nfrom turtle import *\n\ndef memoize(obj):\n    cache = obj.cache = {}\n    @wraps(obj)\n    def memoizer(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = obj(*args, **kwargs)\n        return cache[key]\n    return memoizer\n\n@memoize\ndef fibonacci_word(n):\n    assert n > 0\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"0\"\n    return fibonacci_word(n - 1) + fibonacci_word(n - 2)\n\ndef draw_fractal(word, step):\n    for i, c in enumerate(word, 1):\n        forward(step)\n        if c == \"0\":\n            if i % 2 == 0:\n                left(90)\n            else:\n                right(90)\n\ndef main():\n    n = 25 \n    step = 1 \n    width = 1050 \n    height = 1050 \n    w = fibonacci_word(n)\n\n    setup(width=width, height=height)\n    speed(0)\n    setheading(90)\n    left(90)\n    penup()\n    forward(500)\n    right(90)\n    backward(500)\n    pendown()\n    tracer(10000)\n    hideturtle()\n\n    draw_fractal(w, step)\n\n    \n    getscreen().getcanvas().postscript(file=\"fibonacci_word_fractal.eps\")\n    exitonclick()\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389428, "name": "Penney's game", "source": "Translate Ruby to Python: Toss = [:Heads, :Tails]\n\ndef yourChoice\n  puts \"Enter your choice (H/T)\"\n  choice = []\n  3.times do\n    until (c = $stdin.getc.upcase) == \"H\" or c == \"T\"\n    end\n    choice << (c==\"H\" ? Toss[0] : Toss[1])\n  end\n  puts \"You chose \n  choice\nend\n\nloop do\n  puts \"\\n%s I start, %s you start ..... %s\" % [*Toss, coin = Toss.sample]\n  if coin == Toss[0]\n    myC = Toss.shuffle << Toss.sample\n    puts \"I chose \n    yC = yourChoice\n  else\n    yC = yourChoice\n    myC = Toss - [yC[1]] + yC.first(2)\n    puts \"I chose \n  end\n  \n  seq = Array.new(3){Toss.sample}\n  print seq.join(' ')\n  loop do\n    puts \"\\n I win!\" or break   if seq == myC\n    puts \"\\n You win!\" or break if seq == yC\n    seq.push(Toss.sample).shift\n    print \" \n  end\nend\n", "target": "from __future__ import print_function\nimport random\nfrom time import sleep\n\nfirst = random.choice([True, False])\n\nyou = ''\nif first:\n    me = ''.join(random.sample('HT'*3, 3))\n    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))\n    while len(you) != 3 or any(ch not in 'HT' for ch in you) or you == me:\n        you = input('What sequence of three Heads/Tails will you win with: ')\nelse:\n    while len(you) != 3 or any(ch not in 'HT' for ch in you):\n        you = input('After you: What sequence of three Heads/Tails will you win with: ')\n    me = ('H' if you[1] == 'T' else 'T') + you[:2]\n    print('I win on first seeing {} in the list of tosses'.format(me))\n    \nprint('Rolling:\\n  ', end='')\nrolled = ''\nwhile True:\n    rolled += random.choice('HT')\n    print(rolled[-1], end='')\n    if rolled.endswith(you):\n        print('\\n  You win!')\n        break\n    if rolled.endswith(me):\n        print('\\n  I win!')\n        break\n    sleep(1)    \n"}
{"id": 389429, "name": "Sierpinski triangle_Graphical", "source": "Translate Ruby to Python: Shoes.app(:height=>540,:width=>540, :title=>\"Sierpinski Triangle\") do\n  def triangle(slot, tri, color)\n    x, y, len = tri\n    slot.append do\n      fill color\n      shape do\n        move_to(x,y)\n        dx = len * Math::cos(Math::PI/3)\n        dy = len * Math::sin(Math::PI/3)\n        line_to(x-dx, y+dy)\n        line_to(x+dx, y+dy)\n        line_to(x,y)\n      end\n    end\n  end\n  @s = stack(:width => 520, :height => 520) {}\n  @s.move(10,10)\n\n  length = 512\n  @triangles = [[length/2,0,length]]\n  triangle(@s, @triangles[0], rgb(0,0,0))\n\n  @n = 1\n  animate(1) do\n    if @n <= 7\n      @triangles = @triangles.inject([]) do |sum, (x, y, len)|\n        dx = len/2 * Math::cos(Math::PI/3)\n        dy = len/2 * Math::sin(Math::PI/3)\n        triangle(@s, [x, y+2*dy, -len/2], rgb(255,255,255))\n        sum += [[x, y, len/2], [x-dx, y+dy, len/2], [x+dx, y+dy, len/2]]\n      end\n    end\n    @n += 1\n  end\n\n  keypress do |key|\n    case key\n    when :control_q, \"\\x11\" then exit\n    end\n  end\nend\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 389430, "name": "Sierpinski triangle_Graphical", "source": "Translate Ruby to Python: Shoes.app(:height=>540,:width=>540, :title=>\"Sierpinski Triangle\") do\n  def triangle(slot, tri, color)\n    x, y, len = tri\n    slot.append do\n      fill color\n      shape do\n        move_to(x,y)\n        dx = len * Math::cos(Math::PI/3)\n        dy = len * Math::sin(Math::PI/3)\n        line_to(x-dx, y+dy)\n        line_to(x+dx, y+dy)\n        line_to(x,y)\n      end\n    end\n  end\n  @s = stack(:width => 520, :height => 520) {}\n  @s.move(10,10)\n\n  length = 512\n  @triangles = [[length/2,0,length]]\n  triangle(@s, @triangles[0], rgb(0,0,0))\n\n  @n = 1\n  animate(1) do\n    if @n <= 7\n      @triangles = @triangles.inject([]) do |sum, (x, y, len)|\n        dx = len/2 * Math::cos(Math::PI/3)\n        dy = len/2 * Math::sin(Math::PI/3)\n        triangle(@s, [x, y+2*dy, -len/2], rgb(255,255,255))\n        sum += [[x, y, len/2], [x-dx, y+dy, len/2], [x+dx, y+dy, len/2]]\n      end\n    end\n    @n += 1\n  end\n\n  keypress do |key|\n    case key\n    when :control_q, \"\\x11\" then exit\n    end\n  end\nend\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 389431, "name": "Nonoblock", "source": "Translate Ruby to Python: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 389432, "name": "Nonoblock", "source": "Translate Ruby to Python: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 389433, "name": "Eban numbers", "source": "Translate Ruby to Python: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 389434, "name": "Eban numbers", "source": "Translate Ruby to Python: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 389435, "name": "Mayan numerals", "source": "Translate Ruby to Python: numbers = ARGV.map(&:to_i)\nif numbers.length == 0\n  puts\n  puts(\"usage: \n  exit\nend\n\ndef maya_print(number)\n  digits5s1s = number.to_s(20).chars.map { |ch| ch.to_i(20) }.map { |dig| dig.divmod(5) }\n  puts(('+----' * digits5s1s.length) + '+')\n  3.downto(0) do |row|\n    digits5s1s.each do |d5s1s|\n      if row < d5s1s[0]\n        print('|----')\n      elsif row == d5s1s[0]\n        print(\"|\n      else\n        print('|    ')\n      end\n    end\n    puts('|')\n  end\n  puts(('+----' * digits5s1s.length) + '+')\nend\n\nnumbers.each do |num|\n  puts(num)\n  maya_print(num)\nend\n", "target": "\n\nfrom functools import (reduce)\n\n\n\n\n\ndef mayanNumerals(n):\n    \n    return showIntAtBase(20)(\n        mayanDigit\n    )(n)([])\n\n\n\ndef mayanDigit(n):\n    \n    if 0 < n:\n        r = n % 5\n        return [\n            (['\u25cf' * r] if 0 < r else []) +\n            (['\u2501\u2501'] * (n // 5))\n        ]\n    else:\n        return ['\u0398']\n\n\n\ndef mayanFramed(n):\n    \n    return 'Mayan ' + str(n) + ':\\n\\n' + (\n        wikiTable({\n            'class': 'wikitable',\n            'style': cssFromDict({\n                'text-align': 'center',\n                'background-color': '\n                'color': '\n                'border': '2px solid silver'\n            }),\n            'colwidth': '3em',\n            'cell': 'vertical-align: bottom;'\n        })([[\n            '<br>'.join(col) for col in mayanNumerals(n)\n        ]])\n    )\n\n\n\n\n\ndef main():\n    \n    print(\n        main.__doc__ + ':\\n\\n' +\n        '\\n'.join(mayanFramed(n) for n in [\n            4005, 8017, 326205, 886205, 1081439556,\n            1000000, 1000000000\n        ])\n    )\n\n\n\n\n\ndef wikiTable(opts):\n    \n    def colWidth():\n        return 'width:' + opts['colwidth'] + '; ' if (\n            'colwidth' in opts\n        ) else ''\n\n    def cellStyle():\n        return opts['cell'] if 'cell' in opts else ''\n\n    return lambda rows: '{| ' + reduce(\n        lambda a, k: (\n            a + k + '=\"' + opts[k] + '\" ' if (\n                k in opts\n            ) else a\n        ),\n        ['class', 'style'],\n        ''\n    ) + '\\n' + '\\n|-\\n'.join(\n        '\\n'.join(\n            ('|' if (\n                0 != i and ('cell' not in opts)\n            ) else (\n                '|style=\"' + colWidth() + cellStyle() + '\"|'\n            )) + (\n                str(x) or ' '\n            ) for x in row\n        ) for i, row in enumerate(rows)\n    ) + '\\n|}\\n\\n'\n\n\n\n\n\ndef cssFromDict(dct):\n    \n    return reduce(\n        lambda a, k: a + k + ':' + dct[k] + '; ',\n        dct.keys(),\n        ''\n    )\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389436, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to Python: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 389437, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to Python: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 389438, "name": "Bitmap_Read an image through a pipe", "source": "Translate Ruby to Python: \n\nrequire_relative 'raster_graphics'\n\nclass Pixmap\n  def self.read_ppm(ios)\n    format = ios.gets.chomp\n    width, height = ios.gets.chomp.split.map(&:to_i)\n    max_colour = ios.gets.chomp\n\n    if !PIXMAP_FORMATS.include?(format) ||\n       (width < 1) || (height < 1) ||\n       (max_colour != '255')\n      ios.close\n      raise StandardError, \"file '\n    end\n    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)\n\n    bitmap = new(width, height)\n    height.times do |y|\n      width.times do |x|\n        \n        red, green, blue = case format\n                           when 'P3' then ios.gets.chomp.split\n                           when 'P6' then ios.read(3).unpack('C3')\n                           end\n        bitmap[x, y] = RGBColour.new(red, green, blue)\n      end\n    end\n    ios.close\n    bitmap\n  end\n\n  def self.open(filename)\n    read_ppm(File.open(filename, 'r'))\n  end\n\n  def self.open_from_jpeg(filename)\n    read_ppm(IO.popen(\"convert jpg:\n  end\nend\n\nbitmap = Pixmap.open_from_jpeg('foto.jpg')\nbitmap.save('foto.ppm')\n", "target": "\n\nfrom PIL import Image\n\n\n\nim = Image.open(\"boxes_1.jpg\")\nim.save(\"boxes_1v2.ppm\")\n"}
{"id": 389439, "name": "Nautical bell", "source": "Translate Ruby to Python: watches = [ \"First\", \"Middle\", \"Morning\", \"Forenoon\", \"Afternoon\", \"First dog\", \"Last dog\", \"First\" ]\nwatch_ends = [ \"00:00\", \"04:00\", \"08:00\", \"12:00\", \"16:00\", \"18:00\", \"20:00\", \"23:59\" ]\nwords = [\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"]\nsound = \"ding!\"\n\nloop do\n  time = Time.now\n  if time.sec == 0 and time.min % 30 == 0\n    num = (time.hour * 60 + time.min) / 30 % 8\n    num = 8 if num == 0\n    hr_min = time.strftime \"%H:%M\"\n    idx = watch_ends.find_index {|t| hr_min <= t}\n    text = \"%s - %s watch, %s bell%s gone\" % [\n        hr_min, \n        watches[idx], \n        words[num-1], \n        num==1 ? \"\" : \"s\"\n    ]\n    bells = (sound * num).gsub(sound + sound) {|dd| dd + ' '}\n    puts \"%-45s %s\" % [text, bells]\n  end\n  sleep 1\nend\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 389440, "name": "Nautical bell", "source": "Translate Ruby to Python: watches = [ \"First\", \"Middle\", \"Morning\", \"Forenoon\", \"Afternoon\", \"First dog\", \"Last dog\", \"First\" ]\nwatch_ends = [ \"00:00\", \"04:00\", \"08:00\", \"12:00\", \"16:00\", \"18:00\", \"20:00\", \"23:59\" ]\nwords = [\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"]\nsound = \"ding!\"\n\nloop do\n  time = Time.now\n  if time.sec == 0 and time.min % 30 == 0\n    num = (time.hour * 60 + time.min) / 30 % 8\n    num = 8 if num == 0\n    hr_min = time.strftime \"%H:%M\"\n    idx = watch_ends.find_index {|t| hr_min <= t}\n    text = \"%s - %s watch, %s bell%s gone\" % [\n        hr_min, \n        watches[idx], \n        words[num-1], \n        num==1 ? \"\" : \"s\"\n    ]\n    bells = (sound * num).gsub(sound + sound) {|dd| dd + ' '}\n    puts \"%-45s %s\" % [text, bells]\n  end\n  sleep 1\nend\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 389441, "name": "Voronoi diagram", "source": "Translate Ruby to Python: \n\nrequire_relative 'raster_graphics'\n\nclass ColourPixel < Pixel\n  def initialize(x, y, colour)\n    @colour = colour\n    super x, y\n  end\n  attr_accessor :colour\n\n  def distance_to(px, py)\n    Math.hypot(px - x, py - y)\n  end\nend\n\nwidth = 300\nheight = 200\nnpoints = 20\npixmap = Pixmap.new(width, height)\n\n@bases = npoints.times.collect do |_i|\n  ColourPixel.new(\n    3 + rand(width - 6), 3 + rand(height - 6),  \n    RGBColour.new(rand(256), rand(256), rand(256))\n  )\nend\n\npixmap.each_pixel do |x, y|\n  nearest = @bases.min_by { |base| base.distance_to(x, y) }\n  pixmap[x, y] = nearest.colour\nend\n\n@bases.each do |base|\n  pixmap[base.x, base.y] = RGBColour::BLACK\n  pixmap.draw_circle(base, 2, RGBColour::BLACK)\nend\n\npixmap.save_as_png('voronoi_rb.png')\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 389442, "name": "Voronoi diagram", "source": "Translate Ruby to Python: \n\nrequire_relative 'raster_graphics'\n\nclass ColourPixel < Pixel\n  def initialize(x, y, colour)\n    @colour = colour\n    super x, y\n  end\n  attr_accessor :colour\n\n  def distance_to(px, py)\n    Math.hypot(px - x, py - y)\n  end\nend\n\nwidth = 300\nheight = 200\nnpoints = 20\npixmap = Pixmap.new(width, height)\n\n@bases = npoints.times.collect do |_i|\n  ColourPixel.new(\n    3 + rand(width - 6), 3 + rand(height - 6),  \n    RGBColour.new(rand(256), rand(256), rand(256))\n  )\nend\n\npixmap.each_pixel do |x, y|\n  nearest = @bases.min_by { |base| base.distance_to(x, y) }\n  pixmap[x, y] = nearest.colour\nend\n\n@bases.each do |base|\n  pixmap[base.x, base.y] = RGBColour::BLACK\n  pixmap.draw_circle(base, 2, RGBColour::BLACK)\nend\n\npixmap.save_as_png('voronoi_rb.png')\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 389443, "name": "Active Directory_Connect", "source": "Translate Ruby to Python: require 'rubygems'\nrequire 'net/ldap'\nldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')\nldap.authenticate('bind_dn', 'bind_pass')\n", "target": "import ldap\n\nl = ldap.initialize(\"ldap://ldap.example.com\")\ntry:\n    l.protocol_version = ldap.VERSION3\n    l.set_option(ldap.OPT_REFERRALS, 0)\n\n    bind = l.simple_bind_s(\"me@example.com\", \"password\")\nfinally:\n    l.unbind()\n"}
{"id": 389444, "name": "Knapsack problem_Bounded", "source": "Translate Ruby to Python: record Item, name : String, weight : Int32, value : Int32, count : Int32\n\nrecord Selection, mask : Array(Int32), cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    max_count = {candidate.count, remaining_weight // candidate.weight}.min\n    (0..max_count).reverse_each do |n|\n      mask = taken.mask.clone\n      mask[candidate_index] = n\n      knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + n*candidate.value), items, remaining_weight - n*candidate.weight\n    end\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    nothing = Selection.new(Array(Int32).new(items.size, 0), 0, 0)\n    @threshold_value = 0\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = Hash(Item, Int32).new(0)\n    selected.mask.each_with_index { |v, i| result[list[i]] = v if v > 0 }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150, 1),\n  Item.new(\"compass\", 13, 35, 1),\n  Item.new(\"water\", 153, 200, 2),\n  Item.new(\"sandwich\", 50, 60, 2),\n  Item.new(\"glucose\", 15, 60, 2),\n  Item.new(\"tin\", 68, 45, 3),\n  Item.new(\"banana\", 27, 60, 3),\n  Item.new(\"apple\", 39, 40, 3),\n  Item.new(\"cheese\", 23, 30, 1),\n  Item.new(\"beer\", 52, 10, 3),\n  Item.new(\"suntan cream\", 11, 70, 1),\n  Item.new(\"camera\", 32, 30, 1),\n  Item.new(\"T-shirt\", 24, 15, 2),\n  Item.new(\"trousers\", 48, 10, 2),\n  Item.new(\"umbrella\", 73, 40, 1),\n  Item.new(\"waterproof trousers\", 42, 70, 1),\n  Item.new(\"waterproof overclothes\", 43, 75, 1),\n  Item.new(\"note-case\", 22, 80, 1),\n  Item.new(\"sunglasses\", 7, 20, 1),\n  Item.new(\"towel\", 18, 12, 2),\n  Item.new(\"socks\", 4, 50, 1),\n  Item.new(\"book\", 30, 10, 2),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"total value \nputs \"checked nodes: \n", "target": "\n\nimport strformat\nimport tables\n\n\ntype Item = tuple[name: string; weight, value, pieces: int]\n\n\nconst Items: seq[Item] = @[(\"map\", 9, 150, 1),\n                           (\"compass\", 13, 35, 1),\n                           (\"water\", 153, 200, 2),\n                           (\"sandwich\", 50, 60, 2),\n                           (\"glucose\", 15, 60, 2),\n                           (\"tin\", 68, 45, 3),\n                           (\"banana\", 27, 60, 3),\n                           (\"apple\", 39, 40, 3),\n                           (\"cheese\", 23, 30, 1),\n                           (\"beer\", 52, 10, 3),\n                           (\"suntan cream\", 11, 70, 1),\n                           (\"camera\", 32, 30, 1),\n                           (\"T-shirt\", 24, 15, 2),\n                           (\"trousers\", 48, 10, 2),\n                           (\"umbrella\", 73, 40, 1),\n                           (\"waterproof trousers\", 42, 70, 1),\n                           (\"waterproof overclothes\", 43, 75, 1),\n                           (\"note-case\", 22, 80, 1),\n                           (\"sunglasses\", 7, 20, 1),\n                           (\"towel\", 18, 12, 2),\n                           (\"socks\", 4, 50, 1),\n                           (\"book\", 30, 10, 2)\n                          ]\n\ntype\n\n  \n  Number = range[0..Items.high]\n\n  \n  ExpandedItem = tuple[num: Number; weight, value: int]\n\n\n\n\nproc expandedItems(items: seq[Item]): seq[ExpandedItem] =\n  \n  for idx, item in Items:\n    for _ in 1..item.pieces:\n      result.add((idx.Number, item.weight, item.value))\n\nconst ItemList = expandedItems(Items)\n\ntype\n\n  \n  ExpandedIndex = 0..ItemList.high\n\n  \n  Choice = tuple[indexes: set[ExpandedIndex]; weight, value: int]\n\n\nvar cache: Table[tuple[index, weight: int], Choice]\n\n\n\n\nproc select(idx, weightLimit: int): Choice =\n  \n\n  if idx < 0 or weightLimit == 0:\n    return\n\n  if (idx, weightLimit) in cache:\n    return cache[(idx, weightLimit)]\n\n  let weight = ItemList[idx].weight\n  if weight > weightLimit:\n    return select(idx - 1, weightLimit)\n\n  \n  result = select(idx - 1, weightLimit)\n\n  \n  var result1 = select(idx - 1, weightLimit - weight)\n  inc result1.value, ItemList[idx].value\n\n  \n  if result1.value > result.value:\n    result = (result1.indexes + {idx.ExpandedIndex}, result1.weight + weight, result1.value)\n\n  cache[(idx, weightLimit)] = result\n\n\n\nlet (indexes, weight, value) = select(ItemList.high, 400)\n\n\nvar pieces = newSeq[int](Items.len)\nfor idx in indexes:\n  inc pieces[ItemList[idx].num]\n\necho \"List of items:\"\nfor num in 0..Items.high:\n  if pieces[num] > 0:\n    echo fmt\"\u2013 {pieces[num]} of {Items[num].pieces} {Items[num].name}\"\necho \"\"\necho \"Total weight: \", weight\necho \"Total value: \", value\n"}
{"id": 389445, "name": "SOAP", "source": "Translate Ruby to Python: require 'soap/wsdlDriver'\n\nwsdl = SOAP::WSDLDriverFactory.new(\"http://example.com/soap/wsdl\")\nsoap = wsdl.create_rpc_driver\n\nresponse1 = soap.soapFunc(:elementName => \"value\")\nputs response1.soapFuncReturn\n\nresponse2 = soap.anotherSoapFunc(:aNumber => 42)\nputs response2.anotherSoapFuncReturn\n", "target": "from SOAPpy import WSDL \nproxy = WSDL.Proxy(\"http://example.com/soap/wsdl\")\nresult = proxy.soapFunc(\"hello\")\nresult = proxy.anotherSoapFunc(34234)\n"}
{"id": 389446, "name": "Parse command-line arguments", "source": "Translate Ruby to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"getoptlong\"\nrequire \"rdoc/usage\"\n\ndef phone(name, message)\n\tputs \"Calling \n\tputs message\nend\n\ndef test\n\tphone(\"Barry\", \"Hi!\")\n\tphone(\"Cindy\", \"Hello!\")\nend\n\ndef main\n\tmode = :usage\n\n\tname = \"\"\n\tmessage = \"\"\n\n\topts=GetoptLong.new(\n\t\t[\"--help\", \"-h\", GetoptLong::NO_ARGUMENT],\n\t\t[\"--eddy\", \"-e\", GetoptLong::REQUIRED_ARGUMENT],\n\t\t[\"--daniel\", \"-d\", GetoptLong::REQUIRED_ARGUMENT],\n\t\t[\"--test\", \"-t\", GetoptLong::NO_ARGUMENT]\n\t)\n\n\topts.each { |option, value|\n\t\tcase option\n\t\twhen \"--help\"\n\t\t\tRDoc::usage(\"Usage\")\n\t\twhen \"--eddy\"\n\t\t\tmode = :call\n\t\t\tname = \"eddy\"\n\t\t\tmessage = value\n\t\twhen \"--daniel\"\n\t\t\tmode = :call\n\t\t\tname = \"daniel\"\n\t\t\tmessage = value\n\t\twhen \"--test\"\n\t\t\tmode = :test\n\t\tend\n\t}\n\n\tcase mode\n\twhen :usage\n\t\tRDoc::usage(\"Usage\")\n\twhen :call\n\t\tphone(name, message)\n\twhen :test\n\t\ttest\n\tend\nend\n\nif __FILE__==$0\n\tbegin\n\t\tmain\n\trescue Interrupt => e\n\t\tnil\n\tend\nend\n", "target": "from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                  help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n                  action=\"store_false\", dest=\"verbose\", default=True,\n                  help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nexample:\n\n<yourscript> --file=outfile -q\n"}
{"id": 389447, "name": "Parse command-line arguments", "source": "Translate Ruby to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire \"getoptlong\"\nrequire \"rdoc/usage\"\n\ndef phone(name, message)\n\tputs \"Calling \n\tputs message\nend\n\ndef test\n\tphone(\"Barry\", \"Hi!\")\n\tphone(\"Cindy\", \"Hello!\")\nend\n\ndef main\n\tmode = :usage\n\n\tname = \"\"\n\tmessage = \"\"\n\n\topts=GetoptLong.new(\n\t\t[\"--help\", \"-h\", GetoptLong::NO_ARGUMENT],\n\t\t[\"--eddy\", \"-e\", GetoptLong::REQUIRED_ARGUMENT],\n\t\t[\"--daniel\", \"-d\", GetoptLong::REQUIRED_ARGUMENT],\n\t\t[\"--test\", \"-t\", GetoptLong::NO_ARGUMENT]\n\t)\n\n\topts.each { |option, value|\n\t\tcase option\n\t\twhen \"--help\"\n\t\t\tRDoc::usage(\"Usage\")\n\t\twhen \"--eddy\"\n\t\t\tmode = :call\n\t\t\tname = \"eddy\"\n\t\t\tmessage = value\n\t\twhen \"--daniel\"\n\t\t\tmode = :call\n\t\t\tname = \"daniel\"\n\t\t\tmessage = value\n\t\twhen \"--test\"\n\t\t\tmode = :test\n\t\tend\n\t}\n\n\tcase mode\n\twhen :usage\n\t\tRDoc::usage(\"Usage\")\n\twhen :call\n\t\tphone(name, message)\n\twhen :test\n\t\ttest\n\tend\nend\n\nif __FILE__==$0\n\tbegin\n\t\tmain\n\trescue Interrupt => e\n\t\tnil\n\tend\nend\n", "target": "from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                  help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n                  action=\"store_false\", dest=\"verbose\", default=True,\n                  help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nexample:\n\n<yourscript> --file=outfile -q\n"}
{"id": 389448, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to Python: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 389449, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to Python: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 389450, "name": "Sorting algorithms_Strand sort", "source": "Translate Ruby to Python: class Array\n  def strandsort\n    a = dup\n    result = []\n    until a.empty?\n      v = a.first\n      sublist, a = a.partition{|val| v=val if v<=val}   \n      \n      result.each_index do |idx|\n        break if sublist.empty?\n        result.insert(idx, sublist.shift) if sublist.first < result[idx]\n      end\n      result += sublist\n    end\n    result\n  end\n  \n  def strandsort!\n    replace(strandsort)\n  end\nend\n\np [1, 6, 3, 2, 1, 7, 5, 3].strandsort\n", "target": "def merge_list(a, b):\n\tout = []\n\twhile len(a) and len(b):\n\t\tif a[0] < b[0]:\n\t\t\tout.append(a.pop(0))\n\t\telse:\n\t\t\tout.append(b.pop(0))\n\tout += a\n\tout += b\n\treturn out\n\ndef strand(a):\n\ti, s = 0, [a.pop(0)]\n\twhile i < len(a):\n\t\tif a[i] > s[-1]:\n\t\t\ts.append(a.pop(i))\n\t\telse:\n\t\t\ti += 1\n\treturn s\n\ndef strand_sort(a):\n\tout = strand(a)\n\twhile len(a):\n\t\tout = merge_list(out, strand(a))\n\treturn out\n\nprint strand_sort([1, 6, 3, 2, 1, 7, 5, 3])\n"}
{"id": 389451, "name": "Angles (geometric), normalization and conversion", "source": "Translate Ruby to Python: module Angles\n  BASES = {\"d\" => 360, \"g\" => 400, \"m\" => 6400, \"r\" => Math::PI*2 ,\"h\" => 24 }\n \n  def self.method_missing(meth, angle)\n    from, to = BASES.values_at(*meth.to_s.split(\"2\"))\n    raise NoMethodError, meth if (from.nil? or to.nil?)\n    mod = (angle.to_f * to / from) % to\n    angle < 0 ? mod - to : mod\n  end\n\nend\n\n\nnames = Angles::BASES.keys\nputs \" \" + \"%12s \"*names.size % names\ntest = [-2, -1, 0, 1, 2*Math::PI, 16, 360/(2*Math::PI), 360-1, 400-1, 6400-1, 1_000_000]\n\ntest.each do |n|\n  names.each do |first|\n    res = names.map{|last| Angles.send((first + \"2\" + last).to_sym, n)}\n    puts first + \"%12g \"*names.size % res\n  end\n  puts\nend\n", "target": "PI = 3.141592653589793\nTWO_PI = 6.283185307179586\n\ndef normalize2deg(a):\n  while a < 0: a += 360\n  while a >= 360: a -= 360\n  return a\ndef normalize2grad(a):\n  while a < 0: a += 400\n  while a >= 400: a -= 400\n  return a\ndef normalize2mil(a):\n  while a < 0: a += 6400\n  while a >= 6400: a -= 6400\n  return a\ndef normalize2rad(a):\n  while a < 0: a += TWO_PI\n  while a >= TWO_PI: a -= TWO_PI\n  return a\n\ndef deg2grad(a): return a * 10.0 / 9.0\ndef deg2mil(a): return a * 160.0 / 9.0\ndef deg2rad(a): return a * PI / 180.0\n\ndef grad2deg(a): return a * 9.0 / 10.0\ndef grad2mil(a): return a * 16.0\ndef grad2rad(a): return a * PI / 200.0\n\ndef mil2deg(a): return a * 9.0 / 160.0\ndef mil2grad(a): return a / 16.0\ndef mil2rad(a): return a * PI / 3200.0\n\ndef rad2deg(a): return a * 180.0 / PI\ndef rad2grad(a): return a * 200.0 / PI\ndef rad2mil(a): return a * 3200.0 / PI\n"}
{"id": 389452, "name": "XML_XPath", "source": "Translate Ruby to Python: \nrequire \"rexml/document\"\ninclude REXML\n\ndoc = Document.new(\n        %q@<inventory title=\"OmniCorp Store \n             ...\n           </inventory>\n          @\n                          )\n\ninvisibility = XPath.first( doc, \"//item\" ) \n\nXPath.each( doc, \"//price\") { |element| puts element.text }\n\nnames = XPath.match( doc, \"//name\" )\n", "target": "\n\nfrom xml.dom import minidom\n\nxmlfile = file(\"test3.xml\") \nxmldoc = minidom.parse(xmlfile).documentElement \nxmldoc = minidom.parseString(\"<inventory title=\"OmniCorp Store \n\t\n\ni = xmldoc.getElementsByTagName(\"item\") \nfirstItemElement = i[0] \n\n\nfor j in xmldoc.getElementsByTagName(\"price\"): \n\tprint j.childNodes[0].data \n\n\nnamesArray = xmldoc.getElementsByTagName(\"name\")\n"}
{"id": 389453, "name": "HTTPS_Authenticated", "source": "Translate Ruby to Python: require 'uri'\nrequire 'net/http'\n\nuri = URI.parse('https://www.example.com')\nresponse = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |http|\n  request = Net::HTTP::Get.new uri\n  request.basic_auth('username', 'password')\n  http.request request\nend\n", "target": "\n\n\nfrom mechanize import Browser\n\nUSER_AGENT = \"Mozilla/5.0 (X11; U; Linux i686; tr-TR; rv:1.8.1.9) Gecko/20071102 Pardus/2007 Firefox/2.0.0.9\"\n\nbr = Browser()\nbr.addheaders = [(\"User-agent\", USER_AGENT)]\n\n\n\n\n\n\nbr.open(\"https://www.facebook.com\")\n\nbr.select_form(\"loginform\")\nbr['email'] = \"xxxxxxx@xxxxx.com\"\nbr['pass'] = \"xxxxxxxxx\"\nbr['persistent'] = [\"1\"]\n\nresponse = br.submit()\nprint response.read()\n"}
{"id": 389454, "name": "Ranking methods", "source": "Translate Ruby to Python: ar = \"44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\".lines.map{|line| line.split}\ngrouped = ar.group_by{|pair| pair.shift.to_i}\ns_rnk = 1\nm_rnk = o_rnk = 0\nputs \"stand.\\tmod.\\tdense\\tord.\\tfract.\"\n\ngrouped.each.with_index(1) do |(score, names), d_rnk|\n  m_rnk += names.flatten!.size\n  f_rnk = (s_rnk + m_rnk)/2.0\n  names.each do |name|\n    o_rnk += 1\n    puts \"\n  end\n  s_rnk += names.size\nend\n", "target": "def mc_rank(iterable, start=1):\n    \n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n"}
{"id": 389455, "name": "Update a configuration file", "source": "Translate Ruby to Python: require 'stringio'\n\nclass ConfigFile\n\n  \n  def self.file(filename)\n    fh = File.open(filename)\n    obj = self.new(fh)\n    obj.filename = filename\n    fh.close\n    obj\n  end\n\n  \n  def self.data(string)\n    fh = StringIO.new(string)\n    obj = self.new(fh)\n    fh.close\n    obj\n  end\n\n  def initialize(filehandle)\n    @lines = filehandle.readlines\n    @filename = nil\n    tidy_file\n  end\n  attr :filename\n\n  def save()\n    if @filename\n      File.open(@filename, \"w\") {|f| f.write(self)}\n    end\n  end\n\n  def tidy_file()\n    @lines.map! do |line|\n      \n      line.lstrip!\n\n      if line.match(/^\n        \n        \n        line\n      else\n        \n        line.sub!(/^;+\\s+/, \"; \")\n      \n        if line.match(/^; \\s*$/) \n          \n          \n          line = \"\"\n        else\n          \n          line = line.rstrip + \"\\n\"\n\n          \n          \n          if m = line.match(/^(; )?([[:upper:]]+)\\s+(.*)/)\n            line = (m[1].nil? ? \"\" : m[1]) + format_line(m[2], m[3])\n          end\n        end\n\n        line\n      end\n    end\n  end\n\n  def format_line(option, value)\n    \"%s%s\\n\" % [option.upcase.strip, value.nil? ? \"\" : \" \" + value.to_s.strip]\n  end\n\n  \n  def find_option(option)\n    @lines.find_index {|line| line.match(/^\n  end\n\n  \n  def enable_option(option)\n    if idx = find_option(\"; \" + option)\n      @lines[idx][/^; /] = \"\"\n    end\n  end\n\n  \n  def disable_option(option)\n    if idx = find_option(option)\n      @lines[idx][/^/] = \"; \"\n    end\n  end\n\n  \n  \n  def set_value(option, value)\n    if idx = find_option(option)\n      @lines[idx] = format_line(option, value)\n    else\n      @lines << format_line(option, value) \n    end\n  end\n\n  def to_s\n    @lines.join('')\n  end\nend\n\n\nconfig = ConfigFile.data(DATA.read)\nconfig.disable_option('needspeeling')\nconfig.enable_option('seedsremoved')\nconfig.set_value('numberofbananas', 1024)\nconfig.set_value('numberofstrawberries', 62000)\nputs config\n\n\n__END__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFAVOURITEFRUIT \t\tbanana\n\n\n  NEEDSPEELING\n\n\n;;; SEEDSREMOVED\n;;; \n\n\nNUMBEROFBANANAS 48\n", "target": "\n\n\n\n\nimport re\nimport string\n\n\n\n\n\nDISABLED_PREFIX = ';'\n\n\n\n\n\nclass Option(object):\n    \n\n    \n    def __init__(self, name, value=None, disabled=False,\n                 disabled_prefix=DISABLED_PREFIX):\n        \n        self.name = str(name)\n        self.value = value\n        self.disabled = bool(disabled)\n        self.disabled_prefix = disabled_prefix\n\n    \n    def __str__(self):\n        \n        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]\n        value = (' %s' % self.value, '')[self.value is None]\n        return ''.join((disabled, self.name, value))\n\n    \n    def get(self):\n        \n        enabled = not bool(self.disabled)\n        if self.value is None:\n            value = enabled\n        else:\n            value = enabled and self.value\n        return value\n\n    \n\n\n\nclass Config(object):\n    \n    \n    reOPTION = r'^\\s*(?P<disabled>%s*)\\s*(?P<name>\\w+)(?:\\s+(?P<value>.+?))?\\s*$'\n\n    \n    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):\n        \n        self.disabled_prefix = disabled_prefix\n        self.contents = []          \n        self.options = {}           \n        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)\n        if fname:\n            self.parse_file(fname)\n\n    \n    def __str__(self):\n        \n        return '\\n'.join(map(str, self.contents))\n\n    \n    def parse_file(self, fname):\n        \n        with open(fname) as f:\n            self.parse_lines(f)\n        return self\n\n    \n    def parse_lines(self, lines):\n        \n        for line in lines:\n            self.parse_line(line)\n        return self\n\n    \n    def parse_line(self, line):\n        \n        s = ''.join(c for c in line.strip() if c in string.printable) \n        moOPTION = self.creOPTION.match(s)\n        if moOPTION:\n            name = moOPTION.group('name').upper()\n            if not name in self.options:\n                self.add_option(name, moOPTION.group('value'),\n                                moOPTION.group('disabled'))\n        else:\n            if not s.startswith(self.disabled_prefix):\n                self.contents.append(line.rstrip())\n        return self\n\n    \n    def add_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = Option(name, value, disabled)\n        self.options[name] = opt\n        self.contents.append(opt)\n        return opt\n\n    \n    def set_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = self.options.get(name)\n        if opt:\n            opt.value = value\n            opt.disabled = disabled\n        else:\n            opt = self.add_option(name, value, disabled)\n        return opt\n\n    \n    def enable_option(self, name, value=None):\n        \n        return self.set_option(name, value, False)\n\n    \n    def disable_option(self, name, value=None):\n        \n        return self.set_option(name, value, True)\n\n    \n    def get_option(self, name):\n        \n        opt = self.options.get(name.upper())\n        value = opt.get() if opt else None\n        return value\n\n\n\n\n\nif __name__ == '__main__':\n    import sys\n    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)\n    cfg.disable_option('needspeeling')\n    cfg.enable_option('seedsremoved')\n    cfg.enable_option('numberofbananas', 1024)\n    cfg.enable_option('numberofstrawberries', 62000)\n    print cfg\n"}
{"id": 389456, "name": "Straddling checkerboard", "source": "Translate Ruby to Python: class StraddlingCheckerboard\n  EncodableChars = \"A-Z0-9.\"\n  SortedChars = \"  ./\" + [*\"A\"..\"Z\"].join\n  \n  def initialize(board = nil)\n    if board.nil?\n      \n      rest = \"BCDFGHJKLMPQUVWXYZ/.\".chars.shuffle\n      @board = [\"  ESTONIAR\".chars.shuffle, rest[0..9], rest[10..19]]\n    elsif board.chars.sort.join == SortedChars\n      @board = board.chars.each_slice(10).to_a\n    else\n      raise ArgumentError, \"invalid \n    end\n    \n    @row_labels = @board[0].each_with_index.select {|v, i| v == \" \"}.map {|v,i| i}\n    \n    @mapping = {}\n    @board[0].each_with_index {|char, idx| @mapping[char] = idx.to_s unless char == \" \"}\n    @board[1..2].each_with_index do |row, row_idx|\n      row.each_with_index do |char, idx|\n        @mapping[char] = \"%d%d\" % [@row_labels[row_idx], idx]\n      end\n    end\n  end\n  \n  def encode(message)\n    msg = message.upcase.delete(\"^\n    msg.chars.inject(\"\") do |crypt, char|\n      crypt << (char =~ /[0-9]/ ? @mapping[\"/\"] + char : @mapping[char])\n    end\n  end\n  \n  def decode(code)\n    msg = \"\"\n    tokens = code.chars\n    until tokens.empty?\n      token = tokens.shift\n      itoken = token.to_i\n      unless @row_labels.include?(itoken)\n        msg << @board[0][itoken]\n      else\n        token2 = tokens.shift\n        if @mapping[\"/\"] == token + token2\n          msg << tokens.shift\n        else\n          msg << @board[1+@row_labels.index(itoken)][token2.to_i]\n        end\n      end\n    end\n    msg\n  end\n  \n  def to_s\n    @board.inject(\"\") {|res, row| res << row.join}\n  end\n  \n  def inspect\n    \"\n  end\nend\n", "target": "T = [[\"79\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n     [\"\",   \"H\", \"O\", \"L\", \"\",  \"M\", \"E\", \"S\", \"\",  \"R\", \"T\"],\n     [\"3\",  \"A\", \"B\", \"C\", \"D\", \"F\", \"G\", \"I\", \"J\", \"K\", \"N\"],\n     [\"7\",  \"P\", \"Q\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \".\", \"/\"]]\n\ndef straddle(s):\n    return \"\".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)\n\ndef unstraddle(s):\n    s = iter(s)\n    for c in s:\n        if c in [T[2][0], T[3][0]]:\n            i = [T[2][0], T[3][0]].index(c)\n            n = T[2 + i][T[0].index(s.next())]\n            yield s.next() if n == \"/\" else n\n        else:\n            yield T[1][T[0].index(c)]\n\nO = \"One night-it was on the twentieth of March, 1888-I was returning\"\nprint \"Encoded:\", straddle(O)\nprint \"Decoded:\", \"\".join(unstraddle(straddle(O)))\n"}
{"id": 389457, "name": "I before E except after C", "source": "Translate Ruby to Python: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 389458, "name": "I before E except after C", "source": "Translate Ruby to Python: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 389459, "name": "Xiaolin Wu's line algorithm", "source": "Translate Ruby to Python: def ipart(n); n.truncate; end\ndef fpart(n); n - ipart(n); end\ndef rfpart(n); 1.0 - fpart(n); end\n\nclass Pixmap\n  def draw_line_antialised(p1, p2, colour)\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n \n    steep = (y2 - y1).abs > (x2 - x1).abs\n    if steep\n      x1, y1 = y1, x1\n      x2, y2 = y2, x2\n    end\n    if x1 > x2\n      x1, x2 = x2, x1\n      y1, y2 = y2, y1\n    end\n    deltax = x2 - x1\n    deltay = (y2 - y1).abs\n    gradient = 1.0 * deltay / deltax\n \n    \n    xend = x1.round\n    yend = y1 + gradient * (xend - x1)\n    xgap = rfpart(x1 + 0.5)\n    xpxl1 = xend\n    ypxl1 = ipart(yend)\n    put_colour(xpxl1, ypxl1, colour, steep, rfpart(yend)*xgap)\n    put_colour(xpxl1, ypxl1 + 1, colour, steep, fpart(yend)*xgap)\n    itery = yend + gradient\n \n    \n    xend = x2.round\n    yend = y2 + gradient * (xend - x2)\n    xgap = rfpart(x2 + 0.5)\n    xpxl2 = xend\n    ypxl2 = ipart(yend)\n    put_colour(xpxl2, ypxl2, colour, steep, rfpart(yend)*xgap)\n    put_colour(xpxl2, ypxl2 + 1, colour, steep, fpart(yend)*xgap)\n \n    \n    (xpxl1 + 1).upto(xpxl2 - 1).each do |x|\n      put_colour(x, ipart(itery), colour, steep, rfpart(itery))\n      put_colour(x, ipart(itery) + 1, colour, steep, fpart(itery))\n      itery = itery + gradient\n    end\n  end\n\n  def put_colour(x, y, colour, steep, c)\n    x, y = y, x if steep\n    self[x, y] = anti_alias(colour, self[x, y], c)\n  end\n\n  def anti_alias(new, old, ratio)\n    blended = new.values.zip(old.values).map {|n, o| (n*ratio + o*(1.0 - ratio)).round}\n    RGBColour.new(*blended)\n  end\nend\n\nbitmap = Pixmap.new(500, 500)\nbitmap.fill(RGBColour::BLUE)\n10.step(430, 60) do |a|\n  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)\n  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)\nend\nbitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)\n", "target": "\nfrom __future__ import division\nimport sys\n\nfrom PIL import Image\n\n\ndef _fpart(x):\n    return x - int(x)\n\ndef _rfpart(x):\n    return 1 - _fpart(x)\n\ndef putpixel(img, xy, color, alpha=1):\n    \n    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))\n    c = compose_color(img.getpixel(xy), color)\n    img.putpixel(xy, c)\n\ndef draw_line(img, p1, p2, color):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    dx, dy = x2-x1, y2-y1\n    steep = abs(dx) < abs(dy)\n    p = lambda px, py: ((px,py), (py,px))[steep]\n\n    if steep:\n        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx\n    if x2 < x1:\n        x1, x2, y1, y2 = x2, x1, y2, y1\n\n    grad = dy/dx\n    intery = y1 + _rfpart(x1) * grad\n    def draw_endpoint(pt):\n        x, y = pt\n        xend = round(x)\n        yend = y + grad * (xend - x)\n        xgap = _rfpart(x + 0.5)\n        px, py = int(xend), int(yend)\n        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)\n        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)\n        return px\n\n    xstart = draw_endpoint(p(*p1)) + 1\n    xend = draw_endpoint(p(*p2))\n\n    for x in range(xstart, xend):\n        y = int(intery)\n        putpixel(img, p(x, y), color, _rfpart(intery))\n        putpixel(img, p(x, y+1), color, _fpart(intery))\n        intery += grad\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print 'usage: python xiaolinwu.py [output-file]'\n        sys.exit(-1)\n\n    blue = (0, 0, 255)\n    yellow = (255, 255, 0)\n    img = Image.new(\"RGB\", (500,500), blue)\n    for a in range(10, 431, 60):\n        draw_line(img, (10, 10), (490, a), yellow)\n        draw_line(img, (10, 10), (a, 490), yellow)\n    draw_line(img, (10, 10), (490, 490), yellow)\n    filename = sys.argv[1]\n    img.save(filename)\n    print 'image saved to', filename\n"}
{"id": 389460, "name": "Next highest int from digits", "source": "Translate Ruby to Python: func next_from_digits(n, b = 10) {\n\n    var a = n.digits(b).flip\n\n    while (a.next_permutation) {\n        with (a.flip.digits2num(b)) { |t|\n            return t if (t > n)\n        }\n    }\n\n    return 0\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:'\n\nfor n in (\n    0, 9, 12, 21, 12453, 738440, 3345333, 45072010,\n    95322020, 982765431, 9589776899767587796600,\n) {\n    printf(\"%30s  ->  %s\\n\", n, next_from_digits(n))\n}\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 389461, "name": "Next highest int from digits", "source": "Translate Ruby to Python: func next_from_digits(n, b = 10) {\n\n    var a = n.digits(b).flip\n\n    while (a.next_permutation) {\n        with (a.flip.digits2num(b)) { |t|\n            return t if (t > n)\n        }\n    }\n\n    return 0\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:'\n\nfor n in (\n    0, 9, 12, 21, 12453, 738440, 3345333, 45072010,\n    95322020, 982765431, 9589776899767587796600,\n) {\n    printf(\"%30s  ->  %s\\n\", n, next_from_digits(n))\n}\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 389462, "name": "Four is magic", "source": "Translate Ruby to Python: module NumberToWord\n  \n  NUMBERS = {  \n    1 => 'one',\n    2 => 'two',\n    3 => 'three',\n    4 => 'four',\n    5 => 'five',\n    6 => 'six',\n    7 => 'seven',\n    8 => 'eight',\n    9 => 'nine',\n    10 => 'ten',\n    11 => 'eleven',\n    12 => 'twelve',\n    13 => 'thirteen',\n    14 => 'fourteen',\n    15 => 'fifteen',\n    16 => 'sixteen',\n    17 => 'seventeen',\n    18 => 'eighteen',\n    19 => 'nineteen',\n    20 => 'twenty',\n    30 => 'thirty',\n    40 => 'forty',\n    50 => 'fifty',\n    60 => 'sixty',\n    70 => 'seventy',\n    80 => 'eighty',\n    90 => 'ninety',\n    100 => 'hundred',\n    1000 => 'thousand',\n    10 ** 6 => 'million',\n    10 ** 9 => 'billion',\n    10 ** 12 => 'trillion',\n    10 ** 15 => 'quadrillion',\n    10 ** 18 => 'quintillion',\n    10 ** 21 => 'sextillion',\n    10 ** 24 => 'septillion',\n    10 ** 27 => 'octillion',\n    10 ** 30 => 'nonillion',\n    10 ** 33 => 'decillion'}.reverse_each.to_h\n  \n  refine Integer do\n    def to_english\n      return 'zero' if i.zero?\n      words =  self < 0 ? ['negative'] : []\n      i = self.abs\n      NUMBERS.each do |k, v|\n        if k <= i then\n          times = i/k\n          words << times.to_english if k >= 100\n          words << v\n          i -= times * k\n        end\n        return words.join(\" \") if i.zero?\n      end\n    end\n  end\n    \nend\n  \nusing  NumberToWord\n  \ndef magic4(n)\n  words = []\n  until n == 4\n    s = n.to_english\n    n = s.size\n    words << \"\n  end\n  words << \"four is magic.\"\n  words.join(\", \").capitalize\nend\n  \n[0, 4, 6, 11, 13, 75, 337, -164, 9_876_543_209].each{|n| puts magic4(n) }\n", "target": "import random\nfrom collections import OrderedDict\n\nnumbers = {  \n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four',\n    5: 'five',\n    6: 'six',\n    7: 'seven',\n    8: 'eight',\n    9: 'nine',\n    10: 'ten',\n    11: 'eleven',\n    12: 'twelve',\n    13: 'thirteen',\n    14: 'fourteen',\n    15: 'fifteen',\n    16: 'sixteen',\n    17: 'seventeen',\n    18: 'eighteen',\n    19: 'nineteen',\n    20: 'twenty',\n    30: 'thirty',\n    40: 'forty',\n    50: 'fifty',\n    60: 'sixty',\n    70: 'seventy',\n    80: 'eighty',\n    90: 'ninety',\n    100: 'hundred',\n    1000: 'thousand',\n    10 ** 6: 'million',\n    10 ** 9: 'billion',\n    10 ** 12: 'trillion',\n    10 ** 15: 'quadrillion',\n    10 ** 18: 'quintillion',\n    10 ** 21: 'sextillion',\n    10 ** 24: 'septillion',\n    10 ** 27: 'octillion',\n    10 ** 30: 'nonillion',\n    10 ** 33: 'decillion',\n    10 ** 36: 'undecillion',\n    10 ** 39: 'duodecillion',\n    10 ** 42: 'tredecillion',\n    10 ** 45: 'quattuordecillion',\n    10 ** 48: 'quinquadecillion',\n    10 ** 51: 'sedecillion',\n    10 ** 54: 'septendecillion',\n    10 ** 57: 'octodecillion',\n    10 ** 60: 'novendecillion',\n    10 ** 63: 'vigintillion',\n    10 ** 66: 'unvigintillion',\n    10 ** 69: 'duovigintillion',\n    10 ** 72: 'tresvigintillion',\n    10 ** 75: 'quattuorvigintillion',\n    10 ** 78: 'quinquavigintillion',\n    10 ** 81: 'sesvigintillion',\n    10 ** 84: 'septemvigintillion',\n    10 ** 87: 'octovigintillion',\n    10 ** 90: 'novemvigintillion',\n    10 ** 93: 'trigintillion',\n    10 ** 96: 'untrigintillion',\n    10 ** 99: 'duotrigintillion',\n    10 ** 102: 'trestrigintillion',\n    10 ** 105: 'quattuortrigintillion',\n    10 ** 108: 'quinquatrigintillion',\n    10 ** 111: 'sestrigintillion',\n    10 ** 114: 'septentrigintillion',\n    10 ** 117: 'octotrigintillion',\n    10 ** 120: 'noventrigintillion',\n    10 ** 123: 'quadragintillion',\n    10 ** 153: 'quinquagintillion',\n    10 ** 183: 'sexagintillion',\n    10 ** 213: 'septuagintillion',\n    10 ** 243: 'octogintillion',\n    10 ** 273: 'nonagintillion',\n    10 ** 303: 'centillion',\n    10 ** 306: 'uncentillion',\n    10 ** 309: 'duocentillion',\n    10 ** 312: 'trescentillion',\n    10 ** 333: 'decicentillion',\n    10 ** 336: 'undecicentillion',\n    10 ** 363: 'viginticentillion',\n    10 ** 366: 'unviginticentillion',\n    10 ** 393: 'trigintacentillion',\n    10 ** 423: 'quadragintacentillion',\n    10 ** 453: 'quinquagintacentillion',\n    10 ** 483: 'sexagintacentillion',\n    10 ** 513: 'septuagintacentillion',\n    10 ** 543: 'octogintacentillion',\n    10 ** 573: 'nonagintacentillion',\n    10 ** 603: 'ducentillion',\n    10 ** 903: 'trecentillion',\n    10 ** 1203: 'quadringentillion',\n    10 ** 1503: 'quingentillion',\n    10 ** 1803: 'sescentillion',\n    10 ** 2103: 'septingentillion',\n    10 ** 2403: 'octingentillion',\n    10 ** 2703: 'nongentillion',\n    10 ** 3003: 'millinillion'\n}\nnumbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))\n\n\ndef string_representation(i: int) -> str:\n    \n    if i == 0:\n        return 'zero'\n\n    words = ['negative'] if i < 0 else []\n    working_copy = abs(i)\n\n    for key, value in numbers.items():\n        if key <= working_copy:\n            times = int(working_copy / key)\n\n            if key >= 100:\n                words.append(string_representation(times))\n\n            words.append(value)\n            working_copy -= times * key\n\n        if working_copy == 0:\n            break\n\n    return ' '.join(words)\n\n\ndef next_phrase(i: int):\n    \n    while not i == 4:  \n        str_i = string_representation(i)\n        len_i = len(str_i)\n\n        yield str_i, 'is', string_representation(len_i)\n\n        i = len_i\n\n    \n    yield string_representation(i), 'is', 'magic'\n\n\ndef magic(i: int) -> str:\n    phrases = []\n\n    for phrase in next_phrase(i):\n        phrases.append(' '.join(phrase))\n\n    return f'{\", \".join(phrases)}.'.capitalize()\n\n\nif __name__ == '__main__':\n\n    for j in (random.randint(0, 10 ** 3) for i in range(5)):\n        print(j, ':\\n', magic(j), '\\n')\n\n    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):\n        print(j, ':\\n', magic(j), '\\n')\n"}
{"id": 389463, "name": "Two bullet roulette", "source": "Translate Ruby to Python: class Revolver\n  attr_accessor :strategy\n  attr_reader :notches, :shot_count\n\n  def initialize(strategy = [:load, :spin, :shoot], num_chambers = 6) \n    @chambers = Array.new(num_chambers) \n    @strategy = strategy\n    @notches, @shot_count, @loaded_count = 0, 0, 0\n  end\n\n  def load\n    raise \"gun completely loaded \" if @chambers.all? :loaded\n    @chambers.rotate! until @chambers[1] == nil \n    @chambers[1] = :loaded\n    @chambers.rotate! \n    @loaded_count += 1\n  end\n\n  def spin\n    @chambers.rotate!(rand(1..@chambers.size))\n  end\n\n  def unload\n    @chambers.fill(nil)\n    @loaded_count = 0\n  end\n\n  def shoot\n    @chambers[0] = nil\n    @chambers.rotate!\n  end\n\n  def play\n    strategy.each{|action| send(action)}\n    @shot_count += 1\n    @notches += 1 unless @chambers.count(:loaded) == @loaded_count \n    unload\n  end\nend\n\nstrategies = {:A => [:load, :spin, :load, :spin, :shoot, :spin, :shoot],\n              :B => [:load, :spin, :load, :spin, :shoot, :shoot],\n              :C => [:load, :load, :spin, :shoot, :spin, :shoot],\n              :D => [:load, :load, :spin, :shoot, :shoot],\n              :E => [:load, :spin, :shoot, :load, :spin, :shoot]}\n\nn = 100_000\nputs \"simulation of \nstrategies.each do |name, strategy|\n  gun = Revolver.new(strategy) \n  n.times{gun.play}\n  puts \"Strategy \nend\n", "target": "\nimport numpy as np\n\nclass Revolver:\n    \n\n    def __init__(self):\n        \n        self.cylinder = np.array([False] * 6)\n\n    def unload(self):\n        \n        self.cylinder[:] = False\n\n    def load(self):\n        \n        while self.cylinder[1]:\n            self.cylinder[:] = np.roll(self.cylinder, 1)\n        self.cylinder[1] = True\n\n    def spin(self):\n        \n        self.cylinder[:] = np.roll(self.cylinder, np.random.randint(1, high=7))\n\n    def fire(self):\n        \n        shot = self.cylinder[0]\n        self.cylinder[:] = np.roll(self.cylinder, 1)\n        return shot\n\n    def LSLSFSF(self):\n        \n        self.unload()\n        self.load()\n        self.spin()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        self.spin()\n        if self.fire():\n            return True\n        return False\n\n    def LSLSFF(self):\n        \n        self.unload()\n        self.load()\n        self.spin()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        if self.fire():\n            return True\n        return False\n\n    def LLSFSF(self):\n        \n        self.unload()\n        self.load()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        self.spin()\n        if self.fire():\n            return True\n        return False\n\n    def LLSFF(self):\n        \n        self.unload()\n        self.load()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        if self.fire():\n            return True\n        return False\n\n\nif __name__ == '__main__':\n\n    REV = Revolver()\n    TESTCOUNT = 100000\n    for (name, method) in [['load, spin, load, spin, fire, spin, fire', REV.LSLSFSF],\n                           ['load, spin, load, spin, fire, fire', REV.LSLSFF],\n                           ['load, load, spin, fire, spin, fire', REV.LLSFSF],\n                           ['load, load, spin, fire, fire', REV.LLSFF]]:\n\n        percentage = 100 * sum([method() for _ in range(TESTCOUNT)]) / TESTCOUNT\n        print(\"Method\", name, \"produces\", percentage, \"per cent deaths.\")\n"}
{"id": 389464, "name": "Sierpinski pentagon", "source": "Translate Ruby to Python: THETA = Math::PI * 2 / 5\nSCALE_FACTOR = (3 - Math.sqrt(5)) / 2\nMARGIN = 20\n\nattr_reader :pentagons, :renderer\ndef settings\n  size(400, 400)\nend\n\ndef setup\n  sketch_title 'Pentaflake'\n  radius = width / 2 - 2 * MARGIN\n  center = Vec2D.new(radius - 2 * MARGIN, 3 * MARGIN)\n  pentaflake = Pentaflake.new(center, radius, 5)\n  @pentagons = pentaflake.pentagons\nend\n\ndef draw\n  background(255)\n  stroke(0)\n  pentagons.each do |penta|\n    draw_pentagon(penta)\n  end\n  no_loop\nend\n\ndef draw_pentagon(pent)\n  points = pent.vertices\n  begin_shape\n  points.each do |pnt|\n    pnt.to_vertex(renderer)\n  end\n  end_shape(CLOSE)\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(self.g)\nend\n\n\nclass Pentaflake\n  attr_reader :pentagons\n\n  def initialize(center, radius, depth)\n    @pentagons = []\n    create_pentagons(center, radius, depth)\n  end\n\n  def create_pentagons(center, radius, depth)\n    if depth.zero?\n      pentagons << Pentagon.new(center, radius)\n    else\n      radius *= SCALE_FACTOR\n      distance = radius * Math.sin(THETA) * 2\n      (0..4).each do |idx|\n        x = center.x + Math.cos(idx * THETA) * distance\n        y = center.y + Math.sin(idx * THETA) * distance\n        center = Vec2D.new(x, y)\n        create_pentagons(center, radius, depth - 1)\n      end\n    end\n  end\nend\n\nclass Pentagon\n  attr_reader :center, :radius\n\n  def initialize(center, radius)\n    @center = center\n    @radius = radius\n  end\n\n  def vertices\n    (0..4).map do |idx|\n      center + Vec2D.new(radius * Math.sin(THETA * idx), radius * Math.cos(THETA * idx))\n    end\n  end\nend\n", "target": "from turtle import *\nimport math\nspeed(0)      \nhideturtle()  \n\npart_ratio = 2 * math.cos(math.radians(72))\nside_ratio = 1 / (part_ratio + 2)\n\nhide_turtles = True   \npath_color = \"black\"  \nfill_color = \"black\"  \n\n\ndef pentagon(t, s):\n  t.color(path_color, fill_color)\n  t.pendown()\n  t.right(36)\n  t.begin_fill()\n  for i in range(5):\n    t.forward(s)\n    t.right(72)\n  t.end_fill()\n\n\ndef sierpinski(i, t, s):\n  t.setheading(0)\n  new_size = s * side_ratio\n  \n  if i > 1:\n    i -= 1\n    \n    \n    for j in range(4):\n      t.right(36)\n      short = s * side_ratio / part_ratio\n      dist = [short, s, s, short][j]\n      \n      \n      spawn = Turtle()\n      if hide_turtles:spawn.hideturtle()\n      spawn.penup()\n      spawn.setposition(t.position())\n      spawn.setheading(t.heading())\n      spawn.forward(dist)\n      \n      \n      sierpinski(i, spawn, new_size)\n    \n    \n    sierpinski(i, t, new_size)\n    \n  else:\n    \n    pentagon(t, s)\n    \n    del t\n\ndef main():\n  t = Turtle()\n  t.hideturtle()\n  t.penup()\n  screen = t.getscreen()\n  y = screen.window_height()\n  t.goto(0, y/2-20)\n  \n  i = 5       \n  size = 300  \n  \n  \n  size *= part_ratio\n  \n  \n  sierpinski(i, t, size)\n\nmain()\n"}
{"id": 389465, "name": "Zhang-Suen thinning algorithm", "source": "Translate Ruby to Python: class ZhangSuen\n  NEIGHBOUR8 = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]  \n  CIRCULARS = NEIGHBOUR8 + [NEIGHBOUR8.first]                       \n  def initialize(str, black=\"\n    s1 = str.each_line.map{|line| line.chomp.each_char.map{|c| c==black ? 1 : 0}}\n    s2 = s1.map{|line| line.map{0}}\n    xrange = 1 ... s1.size-1\n    yrange = 1 ... s1[0].size-1\n    printout(s1)\n    begin\n      @r = 0\n      xrange.each{|x| yrange.each{|y| s2[x][y] = s1[x][y] - zs(s1,x,y,1)}}  \n      xrange.each{|x| yrange.each{|y| s1[x][y] = s2[x][y] - zs(s2,x,y,0)}}  \n    end until @r == 0\n    printout(s1)\n  end\n  def zs(ng,x,y,g)\n    return 0 if ng[x][y] == 0 or                                    \n               (ng[x-1][y] + ng[x][y+1] + ng[x+g][y-1+g]) == 3 or   \n               (ng[x-1+g][y+g] + ng[x+1][y] + ng[x][y-1]) == 3      \n    bp1 = NEIGHBOUR8.inject(0){|res,(i,j)| res += ng[x+i][y+j]}     \n    return 0 if bp1 < 2 or 6 < bp1\n    ap1 = CIRCULARS.map{|i,j| ng[x+i][y+j]}.each_cons(2).count{|a,b| a<b}   \n    return 0 if ap1 != 1\n    @r = 1\n  end\n  def printout(image)\n    puts image.map{|row| row.map{|col| \" \n  end\nend\n\nstr = <<EOS\n...........................................................\n.\n.\n.\n.\n...\n...\n...\n...\n...\n...\n...\n...\n.\n.\n.\n.\n...........................................................\nEOS\n\nZhangSuen.new(str)\n\ntask_example = <<EOS\n00000000000000000000000000000000\n01111111110000000111111110000000\n01110001111000001111001111000000\n01110000111000001110000111000000\n01110001111000001110000000000000\n01111111110000001110000000000000\n01110111100000001110000111000000\n01110011110011101111001111011100\n01110001111011100111111110011100\n00000000000000000000000000000000\nEOS\n\nZhangSuen.new(task_example, \"1\")\n", "target": "\n\n\nbeforeTxt = \n\n\nsmallrc01 = \n\nrc01 = \n\ndef intarray(binstring):\n    \n    return [[1 if ch == '1' else 0 for ch in line] \n            for line in binstring.strip().split()]\n\ndef chararray(intmatrix):\n    \n    return '\\n'.join(''.join(str(p) for p in row) for row in intmatrix)\n\ndef toTxt(intmatrix):\n    Return 8-neighbours of point p1 of picture, in order'''\n    i = image\n    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n\ndef transitions(neighbours):\n    n = neighbours + neighbours[0:1]    \n    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:]))\n\ndef zhangSuen(image):\n    changing1 = changing2 = [(-1, -1)]\n    while changing1 or changing2:\n        \n        changing1 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P4 * P6 * P8 == 0 and   \n                    P2 * P4 * P6 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing1.append((x,y))\n        for x, y in changing1: image[y][x] = 0\n        \n        changing2 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P2 * P6 * P8 == 0 and   \n                    P2 * P4 * P8 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing2.append((x,y))\n        for x, y in changing2: image[y][x] = 0\n        \n        \n    return image\n            \n\nif __name__ == '__main__':\n    for picture in (beforeTxt, smallrc01, rc01):\n        image = intarray(picture)\n        print('\\nFrom:\\n%s' % toTxt(image))\n        after = zhangSuen(image)\n        print('\\nTo thinned:\\n%s' % toTxt(after))\n"}
{"id": 389466, "name": "Generate Chess960 starting position", "source": "Translate Ruby to Python: pieces = %i(\u2654 \u2655 \u2658 \u2658 \u2657 \u2657 \u2656 \u2656)\nregexes = [/\u2657(..)*\u2657/, /\u2656.*\u2654.*\u2656/]\nrow = pieces.shuffle.join until regexes.all?{|re| re.match(row)} \nputs row\n", "target": ">>> from itertools import permutations\n>>> pieces = 'KQRrBbNN'\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\n                     if p.index('B') % 2 != p.index('b') % 2 \t\t\n                     and ( p.index('r') < p.index('K') < p.index('R')\t\n                           or p.index('R') < p.index('K') < p.index('r') ) }\n>>> len(starts)\n960\n>>> starts.pop()\n'QNBRNKRB'\n>>>\n"}
{"id": 389467, "name": "UPC", "source": "Translate Ruby to Python: DIGIT_F = {\n    \"   \n    \"  \n    \"  \n    \" \n    \" \n    \" \n    \" \n    \" \n    \" \n    \"   \n}\n\nDIGIT_R = {\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n}\n\nEND_SENTINEL = \"\nMID_SENTINEL = \" \n\ndef decode_upc(s)\n    def decode_upc_impl(input)\n        upc = input.strip\n        if upc.length != 95 then\n            return false\n        end\n\n        pos = 0\n        digits = []\n        sum = 0\n\n        \n        if upc[pos .. pos + 2] == END_SENTINEL then\n            pos += 3\n        else\n            return false\n        end\n\n        \n        for i in 0 .. 5\n            digit = DIGIT_F[upc[pos .. pos + 6]]\n            if digit == nil then\n                return false\n            else\n                digits.push(digit)\n                sum += digit * [1, 3][digits.length % 2]\n                pos += 7\n            end\n        end\n\n        \n        if upc[pos .. pos + 4] == MID_SENTINEL then\n            pos += 5\n        else\n            return false\n        end\n\n        \n        for i in 0 .. 5\n            digit = DIGIT_R[upc[pos .. pos + 6]]\n            if digit == nil then\n                return false\n            else\n                digits.push(digit)\n                sum += digit * [1, 3][digits.length % 2]\n                pos += 7\n            end\n        end\n\n        \n        if upc[pos .. pos + 2] == END_SENTINEL then\n            pos += 3\n        else\n            return false\n        end\n\n        if sum % 10  == 0 then\n            print digits, \" \"\n            return true\n        else\n            print \"Failed Checksum \"\n            return false\n        end\n    end\n\n    if decode_upc_impl(s) then\n        puts \"Rightside Up\"\n    elsif decode_upc_impl(s.reverse) then\n        puts \"Upside Down\"\n    else\n        puts \"Invalid digit(s)\"\n    end\nend\n\ndef main\n    num = 0\n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"       \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"          \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \nend\n\nmain()\n", "target": "\nimport itertools\nimport re\n\nRE_BARCODE = re.compile(\n    r\"^(?P<s_quiet> +)\"  \n    r\"(?P<s_guard>\n    r\"(?P<left>[ \n    r\"(?P<m_guard> \n    r\"(?P<right>[ \n    r\"(?P<e_guard>\n    r\"(?P<e_quiet> +)$\"  \n)\n\nLEFT_DIGITS = {\n    (0, 0, 0, 1, 1, 0, 1): 0,\n    (0, 0, 1, 1, 0, 0, 1): 1,\n    (0, 0, 1, 0, 0, 1, 1): 2,\n    (0, 1, 1, 1, 1, 0, 1): 3,\n    (0, 1, 0, 0, 0, 1, 1): 4,\n    (0, 1, 1, 0, 0, 0, 1): 5,\n    (0, 1, 0, 1, 1, 1, 1): 6,\n    (0, 1, 1, 1, 0, 1, 1): 7,\n    (0, 1, 1, 0, 1, 1, 1): 8,\n    (0, 0, 0, 1, 0, 1, 1): 9,\n}\n\nRIGHT_DIGITS = {\n    (1, 1, 1, 0, 0, 1, 0): 0,\n    (1, 1, 0, 0, 1, 1, 0): 1,\n    (1, 1, 0, 1, 1, 0, 0): 2,\n    (1, 0, 0, 0, 0, 1, 0): 3,\n    (1, 0, 1, 1, 1, 0, 0): 4,\n    (1, 0, 0, 1, 1, 1, 0): 5,\n    (1, 0, 1, 0, 0, 0, 0): 6,\n    (1, 0, 0, 0, 1, 0, 0): 7,\n    (1, 0, 0, 1, 0, 0, 0): 8,\n    (1, 1, 1, 0, 1, 0, 0): 9,\n}\n\n\nMODULES = {\n    \" \": 0,\n    \"\n}\n\nDIGITS_PER_SIDE = 6\nMODULES_PER_DIGIT = 7\n\n\nclass ParityError(Exception):\n    \n\n\nclass ChecksumError(Exception):\n    \n\n\ndef group(iterable, n):\n    \n    args = [iter(iterable)] * n\n    return tuple(itertools.zip_longest(*args))\n\n\ndef parse(barcode):\n    \n    match = RE_BARCODE.match(barcode)\n\n    \n    \n    left = group((MODULES[c] for c in match.group(\"left\")), MODULES_PER_DIGIT)\n    right = group((MODULES[c] for c in match.group(\"right\")), MODULES_PER_DIGIT)\n\n    \n    left, right = check_parity(left, right)\n\n    \n    return tuple(\n        itertools.chain(\n            (LEFT_DIGITS[d] for d in left),\n            (RIGHT_DIGITS[d] for d in right),\n        )\n    )\n\n\ndef check_parity(left, right):\n    \n    \n    \n    \n    left_parity = sum(sum(d) % 2 for d in left)\n    right_parity = sum(sum(d) % 2 for d in right)\n\n    \n    \n    if left_parity == 0 and right_parity == DIGITS_PER_SIDE:\n        _left = tuple(tuple(reversed(d)) for d in reversed(right))\n        right = tuple(tuple(reversed(d)) for d in reversed(left))\n        left = _left\n    elif left_parity != DIGITS_PER_SIDE or right_parity != 0:\n        \n        error = tuple(\n            itertools.chain(\n                (LEFT_DIGITS.get(d, \"_\") for d in left),\n                (RIGHT_DIGITS.get(d, \"_\") for d in right),\n            )\n        )\n        raise ParityError(\" \".join(str(d) for d in error))\n\n    return left, right\n\n\ndef checksum(digits):\n    \n    odds = (digits[i] for i in range(0, 11, 2))\n    evens = (digits[i] for i in range(1, 10, 2))\n\n    check_digit = (sum(odds) * 3 + sum(evens)) % 10\n\n    if check_digit != 0:\n        check_digit = 10 - check_digit\n\n    if digits[-1] != check_digit:\n        raise ChecksumError(str(check_digit))\n\n    return check_digit\n\n\ndef main():\n    barcodes = [\n        \"         \n        \"        \n        \"         \n        \"       \n        \"         \n        \"          \n        \"         \n        \"        \n        \"         \n        \"        \n        \"        \n    ]\n\n    for barcode in barcodes:\n        try:\n            digits = parse(barcode)\n        except ParityError as err:\n            print(f\"{err} parity error!\")\n            continue\n\n        try:\n            check_digit = checksum(digits)\n        except ChecksumError as err:\n            print(f\"{' '.join(str(d) for d in digits)} checksum error! ({err})\")\n            continue\n\n        print(f\"{' '.join(str(d) for d in digits)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 389468, "name": "Write to Windows event log", "source": "Translate Ruby to Python: require 'win32/eventlog'\nlogger = Win32::EventLog.new\nlogger.report_event(:event_type => Win32::EventLog::INFO, :data => \"a test event log entry\")\n", "target": "import win32api\nimport win32con\nimport win32evtlog\nimport win32security\nimport win32evtlogutil\n\nph = win32api.GetCurrentProcess()\nth = win32security.OpenProcessToken(ph, win32con.TOKEN_READ)\nmy_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n\napplicationName = \"My Application\"\neventID = 1\ncategory = 5\t\nmyType = win32evtlog.EVENTLOG_WARNING_TYPE\ndescr = [\"A warning\", \"An even more dire warning\"]\ndata = \"Application\\0Data\".encode(\"ascii\")\n\nwin32evtlogutil.ReportEvent(applicationName, eventID, eventCategory=category, \n\teventType=myType, strings=descr, data=data, sid=my_sid)\n"}
{"id": 389469, "name": "Spelling of ordinal numbers", "source": "Translate Ruby to Python: var lingua_en = frequire('Lingua::EN::Numbers')\nvar tests = [1,2,3,4,5,11,65,100,101,272,23456,8007006005004003]\n\ntests.each {|n|\n    printf(\"%16s\u00a0: %s\\n\", n, lingua_en.num2en_ordinal(n))\n}\n", "target": "irregularOrdinals = {\n\t\"one\":    \"first\",\n\t\"two\":    \"second\",\n\t\"three\":  \"third\",\n\t\"five\":   \"fifth\",\n\t\"eight\":  \"eighth\",\n\t\"nine\":   \"ninth\",\n\t\"twelve\": \"twelfth\",\n}\n\ndef num2ordinal(n):\n    conversion = int(float(n))\n    num = spell_integer(conversion)\n    hyphen = num.rsplit(\"-\", 1)\n    num = num.rsplit(\" \", 1)\n    delim = \" \"\n    if len(num[-1]) > len(hyphen[-1]):\n        num = hyphen\n        delim = \"-\"\n    \n    if num[-1] in irregularOrdinals:\n        num[-1] = delim + irregularOrdinals[num[-1]]\n    elif num[-1].endswith(\"y\"):\n        num[-1] = delim + num[-1][:-1] + \"ieth\"\n    else:\n        num[-1] = delim + num[-1] + \"th\"\n    return \"\".join(num)\n    \nif __name__ == \"__main__\":\n    tests = \"1  2  3  4  5  11  65  100  101  272  23456  8007006005004003 123   00123.0   1.23e2\".split()\n    for num in tests:\n        print(\"{} => {}\".format(num, num2ordinal(num)))\n\n\n\n\nTENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n \ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n \ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n \ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n"}
{"id": 389470, "name": "Parse an IP Address", "source": "Translate Ruby to Python: require 'ipaddr'\n\n \nTESTCASES = [\"127.0.0.1\",                \"127.0.0.1:80\",\n                \"::1\",                      \"[::1]:80\",\n                \"2605:2700:0:3::4713:93e3\", \"[2605:2700:0:3::4713:93e3]:80\"]                            \n\noutput = [%w(String Address Port Family Hex),\n          %w(------ ------- ---- ------ ---)]\n\ndef output_table(rows)\n  widths = []\n  rows.each {|row| row.each_with_index {|col, i| widths[i] = [widths[i].to_i, col.to_s.length].max }}\n  format = widths.map {|size| \"%\n  rows.each {|row| puts format % row}\nend\n\nTESTCASES.each do |str|\n  case str  \n  when /\\A\\[(?<address> .* )\\]:(?<port> \\d+ )\\z/x      \n    address, port = $~[:address], $~[:port]\n  when /\\A(?<address> [^:]+ ):(?<port> \\d+ )\\z/x       \n    address, port = $~[:address], $~[:port]\n  else                                                 \n    address, port = str, nil\n  end\n  \n  ip_addr = IPAddr.new(address) \n  family = \"IPv4\" if ip_addr.ipv4?\n  family = \"IPv6\" if ip_addr.ipv6?\n\n  output << [str, ip_addr.to_s, port.to_s, family, ip_addr.to_i.to_s(16)]\nend\n\noutput_table(output)\n", "target": "from ipaddress import ip_address\nfrom urllib.parse import urlparse\n\ntests = [\n    \"127.0.0.1\",\n    \"127.0.0.1:80\",\n    \"::1\",\n    \"[::1]:80\",\n    \"::192.168.0.1\",\n    \"2605:2700:0:3::4713:93e3\",\n    \"[2605:2700:0:3::4713:93e3]:80\" ]\n\ndef parse_ip_port(netloc):\n    try:\n        ip = ip_address(netloc)\n        port = None\n    except ValueError:\n        parsed = urlparse('//{}'.format(netloc))\n        ip = ip_address(parsed.hostname)\n        port = parsed.port\n    return ip, port\n\nfor address in tests:\n    ip, port = parse_ip_port(address)\n    hex_ip = {4:'{:08X}', 6:'{:032X}'}[ip.version].format(int(ip))\n    print(\"{:39s}  {:>32s}  IPv{}  port={}\".format(\n        str(ip), hex_ip, ip.version, port ))\n"}
{"id": 389471, "name": "Largest prime factor", "source": "Translate Ruby to Python: require 'prime'\n\np 600851475143.prime_division.last.first\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    n = 600851475143\n    j = 3\n    while not isPrime(n):\n        if n % j == 0:\n            n /= j\n        j += 2\n    print(n);\n"}
{"id": 389472, "name": "Getting the number of decimal places", "source": "Translate Ruby to Python: func number_of_decimals(n, limit = 1e5) {\n    var prec = Num(Num!PREC)>>2\n    var prev = ''\n\n    n = Number(n) if !n.kind_of(Number)\n\n    loop {\n        var str = n.as_dec(prec)\n\n        if (prev == str) {\n            return (str.contains('.') ? str.substr(str.index('.')+1).len : 0)\n        }\n\n        prev = str\n        prec *= 2\n        return Inf if (prec > limit)\n    }\n}\n\nvar list = [\n    9, 12.345, \"12.3450\", \"12.345e53\",\n    12.34555555555555555555, 0.1234567890987654321,\n    Num.pi, 1/3, 1.5**63\n]\n\nlist.each {|n|\n    var c = number_of_decimals(n)\n    say \"Number of decimals: \n}\n", "target": "In [6]: def dec(n):\n   ...:     return len(n.rsplit('.')[-1]) if '.' in n else 0\n\nIn [7]: dec('12.345')\nOut[7]: 3\n\nIn [8]: dec('12.3450')\nOut[8]: 4\n\nIn [9]:\n"}
{"id": 389473, "name": "Minimum number of cells after, before, above and below NxN squares", "source": "Translate Ruby to Python: def dist2edge(n)\n  width = (n/2).to_s.size+1\n  m = n-1\n  (0..m).map do |x|\n    (0..m).map{|y| [x, y, m-x, m-y].min.to_s.center(width) }.join\n  end\nend\n    \nputs dist2edge(10)\n", "target": "def min_cells_matrix(siz):\n    return [[min(row, col, siz - row - 1, siz - col - 1) for col in range(siz)] for row in range(siz)]\n\ndef display_matrix(mat):\n    siz = len(mat)\n    spaces = 2 if siz < 20 else 3 if siz < 200 else 4\n    print(f\"\\nMinimum number of cells after, before, above and below {siz} x {siz} square:\")\n    for row in range(siz):\n        print(\"\".join([f\"{n:{spaces}}\" for n in mat[row]]))\n\ndef test_min_mat():\n    for siz in [23, 10, 9, 2, 1]:\n        display_matrix(min_cells_matrix(siz))\n\nif __name__ == \"__main__\":\n    test_min_mat()\n"}
{"id": 389474, "name": "Maximum difference between adjacent elements of list", "source": "Translate Ruby to Python: list   =   [1,8,2,-3,0,1,1,-2.3,0,5.5,8,6,2,9,11,10,3]\n\nmax_dif, pairs =  list.each_cons(2).group_by{|a,b| (a-b).abs}.max\n\nputs \"Maximum difference is \npairs.each{|pair| p pair}\n", "target": "\n\n\n\ndef maxDeltas(ns):\n    \n    pairs = [\n        (abs(a - b), (a, b)) for a, b\n        in zip(ns, ns[1:])\n    ]\n    delta = max(pairs, key=lambda ab: ab[0])[0]\n\n    return [\n        ab for ab in pairs\n        if delta == ab[0]\n    ]\n\n\n\n\ndef main():\n    \n\n    maxPairs = maxDeltas([\n        1, 8, 2, -3, 0, 1, 1, -2.3, 0,\n        5.5, 8, 6, 2, 9, 11, 10, 3\n    ])\n\n    for ab in maxPairs:\n        print(ab)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389475, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "from sys import stdout\n\nneighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]\ncnt = 0\npWid = 0\npHei = 0\n\n\ndef is_valid(a, b):\n    return -1 < a < pWid and -1 < b < pHei\n\n\ndef iterate(pa, x, y, v):\n    if v > cnt:\n        return 1\n\n    for i in range(len(neighbours)):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if is_valid(a, b) and pa[a][b] == 0:\n            pa[a][b] = v\n            r = iterate(pa, a, b, v + 1)\n            if r == 1:\n                return r\n            pa[a][b] = 0\n    return 0\n\n\ndef solve(pz, w, h):\n    global cnt, pWid, pHei\n\n    pa = [[-1 for j in range(h)] for i in range(w)]\n    f = 0\n    pWid = w\n    pHei = h\n    for j in range(h):\n        for i in range(w):\n            if pz[f] == \"1\":\n                pa[i][j] = 0\n                cnt += 1\n            f += 1\n\n    for y in range(h):\n        for x in range(w):\n            if pa[x][y] == 0:\n                pa[x][y] = 1\n                if 1 == iterate(pa, x, y, 2):\n                    return 1, pa\n                pa[x][y] = 0\n\n    return 0, pa\n\nr = solve(\"011011011111111111111011111000111000001000\", 7, 6)\nif r[0] == 1:\n    for j in range(6):\n        for i in range(7):\n            if r[1][i][j] == -1:\n                stdout.write(\"   \")\n            else:\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n        print()\nelse:\n    stdout.write(\"No solution!\")\n"}
{"id": 389476, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "from sys import stdout\n\nneighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]\ncnt = 0\npWid = 0\npHei = 0\n\n\ndef is_valid(a, b):\n    return -1 < a < pWid and -1 < b < pHei\n\n\ndef iterate(pa, x, y, v):\n    if v > cnt:\n        return 1\n\n    for i in range(len(neighbours)):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if is_valid(a, b) and pa[a][b] == 0:\n            pa[a][b] = v\n            r = iterate(pa, a, b, v + 1)\n            if r == 1:\n                return r\n            pa[a][b] = 0\n    return 0\n\n\ndef solve(pz, w, h):\n    global cnt, pWid, pHei\n\n    pa = [[-1 for j in range(h)] for i in range(w)]\n    f = 0\n    pWid = w\n    pHei = h\n    for j in range(h):\n        for i in range(w):\n            if pz[f] == \"1\":\n                pa[i][j] = 0\n                cnt += 1\n            f += 1\n\n    for y in range(h):\n        for x in range(w):\n            if pa[x][y] == 0:\n                pa[x][y] = 1\n                if 1 == iterate(pa, x, y, 2):\n                    return 1, pa\n                pa[x][y] = 0\n\n    return 0, pa\n\nr = solve(\"011011011111111111111011111000111000001000\", 7, 6)\nif r[0] == 1:\n    for j in range(6):\n        for i in range(7):\n            if r[1][i][j] == -1:\n                stdout.write(\"   \")\n            else:\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n        print()\nelse:\n    stdout.write(\"No solution!\")\n"}
{"id": 389477, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "from sys import stdout\nneighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]\nexists = []\nlastNumber = 0\nwid = 0\nhei = 0\n\n\ndef find_next(pa, x, y, z):\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == z:\n                return a, b\n\n    return -1, -1\n\n\ndef find_solution(pa, x, y, z):\n    if z > lastNumber:\n        return 1\n    if exists[z] == 1:\n        s = find_next(pa, x, y, z)\n        if s[0] < 0:\n            return 0\n        return find_solution(pa, s[0], s[1], z + 1)\n\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == 0:\n                pa[a][b] = z\n                r = find_solution(pa, a, b, z + 1)\n                if r == 1:\n                    return 1\n                pa[a][b] = 0\n\n    return 0\n\n\ndef solve(pz, w, h):\n    global lastNumber, wid, hei, exists\n\n    lastNumber = w * h\n    wid = w\n    hei = h\n    exists = [0 for j in range(lastNumber + 1)]\n\n    pa = [[0 for j in range(h)] for i in range(w)]\n    st = pz.split()\n    idx = 0\n    for j in range(h):\n        for i in range(w):\n            if st[idx] == \".\":\n                idx += 1\n            else:\n                pa[i][j] = int(st[idx])\n                exists[pa[i][j]] = 1\n                idx += 1\n\n    x = 0\n    y = 0\n    t = w * h + 1\n    for j in range(h):\n        for i in range(w):\n            if pa[i][j] != 0 and pa[i][j] < t:\n                t = pa[i][j]\n                x = i\n                y = j\n\n    return find_solution(pa, x, y, t + 1), pa\n\n\ndef show_result(r):\n    if r[0] == 1:\n        for j in range(hei):\n            for i in range(wid):\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n            print()\n    else:\n        stdout.write(\"No Solution!\\n\")\n\n    print()\n\n\nr = solve(\". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17\"\n          \" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1  2 . . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\". . . . . . . . . . 11 12 15 18 21 62 61 . .  6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37\"\n          \" .  1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . .  63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55\"\n          \" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45\", 9, 9)\nshow_result(r)\n"}
{"id": 389478, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to Python: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "from sys import stdout\nneighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]\nexists = []\nlastNumber = 0\nwid = 0\nhei = 0\n\n\ndef find_next(pa, x, y, z):\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == z:\n                return a, b\n\n    return -1, -1\n\n\ndef find_solution(pa, x, y, z):\n    if z > lastNumber:\n        return 1\n    if exists[z] == 1:\n        s = find_next(pa, x, y, z)\n        if s[0] < 0:\n            return 0\n        return find_solution(pa, s[0], s[1], z + 1)\n\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == 0:\n                pa[a][b] = z\n                r = find_solution(pa, a, b, z + 1)\n                if r == 1:\n                    return 1\n                pa[a][b] = 0\n\n    return 0\n\n\ndef solve(pz, w, h):\n    global lastNumber, wid, hei, exists\n\n    lastNumber = w * h\n    wid = w\n    hei = h\n    exists = [0 for j in range(lastNumber + 1)]\n\n    pa = [[0 for j in range(h)] for i in range(w)]\n    st = pz.split()\n    idx = 0\n    for j in range(h):\n        for i in range(w):\n            if st[idx] == \".\":\n                idx += 1\n            else:\n                pa[i][j] = int(st[idx])\n                exists[pa[i][j]] = 1\n                idx += 1\n\n    x = 0\n    y = 0\n    t = w * h + 1\n    for j in range(h):\n        for i in range(w):\n            if pa[i][j] != 0 and pa[i][j] < t:\n                t = pa[i][j]\n                x = i\n                y = j\n\n    return find_solution(pa, x, y, t + 1), pa\n\n\ndef show_result(r):\n    if r[0] == 1:\n        for j in range(hei):\n            for i in range(wid):\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n            print()\n    else:\n        stdout.write(\"No Solution!\\n\")\n\n    print()\n\n\nr = solve(\". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17\"\n          \" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1  2 . . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\". . . . . . . . . . 11 12 15 18 21 62 61 . .  6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37\"\n          \" .  1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . .  63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55\"\n          \" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45\", 9, 9)\nshow_result(r)\n"}
{"id": 389479, "name": "Respond to an unknown method call", "source": "Translate Ruby to Python: class Example\n    def foo\n        puts \"this is foo\"\n    end\n    def bar\n        puts \"this is bar\"\n    end\n    def method_missing(name, *args, &block)\n        puts \"tried to handle unknown method %s\" % name \n        unless args.empty?\n            puts \"it had arguments: %p\" % [args]\n        end\n    end\nend\n\nexample = Example.new\n\nexample.foo          \nexample.bar          \nexample.grill        \nexample.ding(\"dong\") \n                     \n", "target": "class Example(object):\n    def foo(self):\n        print(\"this is foo\")\n    def bar(self):\n        print(\"this is bar\")\n    def __getattr__(self, name):\n        def method(*args):\n            print(\"tried to handle unknown method \" + name)\n            if args:\n                print(\"it had arguments: \" + str(args))\n        return method\n\nexample = Example()\n\nexample.foo()        \nexample.bar()        \nexample.grill()      \nexample.ding(\"dong\") \n                     \n"}
{"id": 389480, "name": "Chemical calculator", "source": "Translate Ruby to Python: $atomicMass = {\n    \"H\"   =>  1.008,\n    \"He\"  =>  4.002602,\n    \"Li\"  =>  6.94,\n    \"Be\"  =>  9.0121831,\n    \"B\"   =>  10.81,\n    \"C\"   =>  12.011,\n    \"N\"   =>  14.007,\n    \"O\"   =>  15.999,\n    \"F\"   =>  18.998403163,\n    \"Ne\"  =>  20.1797,\n    \"Na\"  =>  22.98976928,\n    \"Mg\"  =>  24.305,\n    \"Al\"  =>  26.9815385,\n    \"Si\"  =>  28.085,\n    \"P\"   =>  30.973761998,\n    \"S\"   =>  32.06,\n    \"Cl\"  =>  35.45,\n    \"Ar\"  =>  39.948,\n    \"K\"   =>  39.0983,\n    \"Ca\"  =>  40.078,\n    \"Sc\"  =>  44.955908,\n    \"Ti\"  =>  47.867,\n    \"V\"   =>  50.9415,\n    \"Cr\"  =>  51.9961,\n    \"Mn\"  =>  54.938044,\n    \"Fe\"  =>  55.845,\n    \"Co\"  =>  58.933194,\n    \"Ni\"  =>  58.6934,\n    \"Cu\"  =>  63.546,\n    \"Zn\"  =>  65.38,\n    \"Ga\"  =>  69.723,\n    \"Ge\"  =>  72.630,\n    \"As\"  =>  74.921595,\n    \"Se\"  =>  78.971,\n    \"Br\"  =>  79.904,\n    \"Kr\"  =>  83.798,\n    \"Rb\"  =>  85.4678,\n    \"Sr\"  =>  87.62,\n    \"Y\"   =>  88.90584,\n    \"Zr\"  =>  91.224,\n    \"Nb\"  =>  92.90637,\n    \"Mo\"  =>  95.95,\n    \"Ru\"  =>  101.07,\n    \"Rh\"  =>  102.90550,\n    \"Pd\"  =>  106.42,\n    \"Ag\"  =>  107.8682,\n    \"Cd\"  =>  112.414,\n    \"In\"  =>  114.818,\n    \"Sn\"  =>  118.710,\n    \"Sb\"  =>  121.760,\n    \"Te\"  =>  127.60,\n    \"I\"   =>  126.90447,\n    \"Xe\"  =>  131.293,\n    \"Cs\"  =>  132.90545196,\n    \"Ba\"  =>  137.327,\n    \"La\"  =>  138.90547,\n    \"Ce\"  =>  140.116,\n    \"Pr\"  =>  140.90766,\n    \"Nd\"  =>  144.242,\n    \"Pm\"  =>  145,\n    \"Sm\"  =>  150.36,\n    \"Eu\"  =>  151.964,\n    \"Gd\"  =>  157.25,\n    \"Tb\"  =>  158.92535,\n    \"Dy\"  =>  162.500,\n    \"Ho\"  =>  164.93033,\n    \"Er\"  =>  167.259,\n    \"Tm\"  =>  168.93422,\n    \"Yb\"  =>  173.054,\n    \"Lu\"  =>  174.9668,\n    \"Hf\"  =>  178.49,\n    \"Ta\"  =>  180.94788,\n    \"W\"   =>  183.84,\n    \"Re\"  =>  186.207,\n    \"Os\"  =>  190.23,\n    \"Ir\"  =>  192.217,\n    \"Pt\"  =>  195.084,\n    \"Au\"  =>  196.966569,\n    \"Hg\"  =>  200.592,\n    \"Tl\"  =>  204.38,\n    \"Pb\"  =>  207.2,\n    \"Bi\"  =>  208.98040,\n    \"Po\"  =>  209,\n    \"At\"  =>  210,\n    \"Rn\"  =>  222,\n    \"Fr\"  =>  223,\n    \"Ra\"  =>  226,\n    \"Ac\"  =>  227,\n    \"Th\"  =>  232.0377,\n    \"Pa\"  =>  231.03588,\n    \"U\"   =>  238.02891,\n    \"Np\"  =>  237,\n    \"Pu\"  =>  244,\n    \"Am\"  =>  243,\n    \"Cm\"  =>  247,\n    \"Bk\"  =>  247,\n    \"Cf\"  =>  251,\n    \"Es\"  =>  252,\n    \"Fm\"  =>  257,\n    \"Uue\" =>  315,\n    \"Ubn\" =>  299,\n}\n\ndef evaluate(s)\n    s += \"[\" \n    sum = 0.0\n    i = 0\n    symbol = \"\"\n    number = \"\"\n    while i < s.length\n        c = s[i]\n        if '@' <= c and c <= '[' then\n            n = 1\n            if number != \"\" then\n                n = number.to_i\n            end\n            if symbol != \"\" then\n                mass = $atomicMass[symbol]\n                sum = sum + mass * n\n            end\n            if c == '[' then\n                break\n            end\n            symbol = c.to_s\n            number = \"\"\n        elsif 'a' <= c and c <= 'z' then\n            symbol = symbol + c\n        elsif '0' <= c and c <= '9' then\n            number = number + c\n        else\n            raise \"Unexpected symbol %c in molecule\" % [c]\n        end\n        i = i + 1\n    end\n    return sum\nend\n\ndef replaceParens(s)\n    letter = 'a'\n    while true\n        start = s.index '('\n        if start == nil then\n            break\n        end\n\n        i = start + 1\n        while i < s.length\n            if s[i] == ')' then\n                expr = s[start + 1 .. i - 1]\n                symbol = \"@%c\" % [letter]\n                r = s[start .. i + 0]\n                s = s.sub(r, symbol)\n                $atomicMass[symbol] = evaluate(expr)\n                letter = letter.next\n                break\n            end\n            if s[i] == '(' then\n                start = i\n            end\n\n            i = i + 1\n        end\n    end\n    return s\nend\n\ndef main\n    molecules = [\n        \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n        \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n    ]\n    for molecule in molecules\n        mass = evaluate(replaceParens(molecule))\n        print \"%17s -> %7.3f\\n\" % [molecule, mass]\n    end\nend\n\nmain()\n", "target": "assert   1.008 == molar_mass('H')                  \nassert   2.016 == molar_mass('H2')                 \nassert  18.015 == molar_mass('H2O')                \nassert  34.014 == molar_mass('H2O2')               \nassert  34.014 == molar_mass('(HO)2')              \nassert 142.036 == molar_mass('Na2SO4')             \nassert  84.162 == molar_mass('C6H12')              \nassert 186.295 == molar_mass('COOH(C(CH3)2)3CH3')  \nassert 176.124 == molar_mass('C6H4O2(OH)4')        \nassert 386.664 == molar_mass('C27H46O')            \nassert 315     == molar_mass('Uue')                \n"}
{"id": 389481, "name": "Arithmetic evaluation", "source": "Translate Ruby to Python: $op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n  \n  def initialize(info)\n    @info = info\n  end\n  \n  def leaf?\n    @left.nil? and @right.nil?\n  end\n  \n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n      \n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n      \n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n  \n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n  \n  tokens.each do |token|\n    if operator?(token)\n      \n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      \n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n  \n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n  \n  node_stack.last\nend\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 389482, "name": "Arithmetic evaluation", "source": "Translate Ruby to Python: $op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n  \n  def initialize(info)\n    @info = info\n  end\n  \n  def leaf?\n    @left.nil? and @right.nil?\n  end\n  \n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n      \n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n      \n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n  \n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n  \n  tokens.each do |token|\n    if operator?(token)\n      \n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      \n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n  \n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n  \n  node_stack.last\nend\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 389483, "name": "Sierpinski curve", "source": "Translate Ruby to Python: var rules = Hash(\n    x => 'xF+G+xF--F--xF+G+x',\n)\n\nvar lsys = LSystem(\n    width:  550,\n    height: 550,\n\n    xoff: -9,\n    yoff: -271,\n\n    len:   5,\n    angle: 45,\n    color: 'dark green',\n)\n\nlsys.execute('F--xF--F--xF', 5, \"sierpi\u0144ski_curve.png\", rules)\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import hsv_to_rgb as hsv\n\ndef curve(axiom, rules, angle, depth):\n    for _ in range(depth):\n        axiom = ''.join(rules[c] if c in rules else c for c in axiom)\n\n    a, x, y = 0, [0], [0]\n    for c in axiom:\n        match c:\n            case '+':\n                a += 1\n            case '-':\n                a -= 1\n            case 'F' | 'G':\n                x.append(x[-1] + np.cos(a*angle*np.pi/180))\n                y.append(y[-1] + np.sin(a*angle*np.pi/180))\n\n    l = len(x)\n    \n    for i in range(l - 1):\n        plt.plot(x[i:i+2], y[i:i+2], color=hsv([i/l, 1, .7]))\n    plt.gca().set_aspect(1)\n    plt.show()\n\ncurve('F--XF--F--XF', {'X': 'XF+G+XF--F--XF+G+X'}, 45, 5)\n\n\n\n\n"}
{"id": 389484, "name": "Sierpinski curve", "source": "Translate Ruby to Python: var rules = Hash(\n    x => 'xF+G+xF--F--xF+G+x',\n)\n\nvar lsys = LSystem(\n    width:  550,\n    height: 550,\n\n    xoff: -9,\n    yoff: -271,\n\n    len:   5,\n    angle: 45,\n    color: 'dark green',\n)\n\nlsys.execute('F--xF--F--xF', 5, \"sierpi\u0144ski_curve.png\", rules)\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import hsv_to_rgb as hsv\n\ndef curve(axiom, rules, angle, depth):\n    for _ in range(depth):\n        axiom = ''.join(rules[c] if c in rules else c for c in axiom)\n\n    a, x, y = 0, [0], [0]\n    for c in axiom:\n        match c:\n            case '+':\n                a += 1\n            case '-':\n                a -= 1\n            case 'F' | 'G':\n                x.append(x[-1] + np.cos(a*angle*np.pi/180))\n                y.append(y[-1] + np.sin(a*angle*np.pi/180))\n\n    l = len(x)\n    \n    for i in range(l - 1):\n        plt.plot(x[i:i+2], y[i:i+2], color=hsv([i/l, 1, .7]))\n    plt.gca().set_aspect(1)\n    plt.show()\n\ncurve('F--XF--F--XF', {'X': 'XF+G+XF--F--XF+G+X'}, 45, 5)\n\n\n\n\n"}
{"id": 389485, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Ruby to Python: fn selectively_replace_chars(s string, char_map map[string]string) string {\n    mut bytes := s.bytes()\n    mut counts := {\n        'a': 0\n        'b': 0\n        'r': 0\n    }\n    for i := s.len - 1; i >= 0; i-- {\n        c := s[i].ascii_str()\n        if c in ['a', 'b', 'r'] {\n            bytes[i] = char_map[c][counts[c]]\n            counts[c]++\n        }\n    }\n    return bytes.bytestr()\n}\n\nfn main() {\n    char_map := {\n        'a': 'DCaBA'\n        'b': 'bE'\n        'r': 'Fr'\n    }\n    for old in ['abracadabra', 'caaarrbabad'] {\n        new := selectively_replace_chars(old, char_map)\n        println('$old -> $new')\n    }\n}\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 389486, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Ruby to Python: fn selectively_replace_chars(s string, char_map map[string]string) string {\n    mut bytes := s.bytes()\n    mut counts := {\n        'a': 0\n        'b': 0\n        'r': 0\n    }\n    for i := s.len - 1; i >= 0; i-- {\n        c := s[i].ascii_str()\n        if c in ['a', 'b', 'r'] {\n            bytes[i] = char_map[c][counts[c]]\n            counts[c]++\n        }\n    }\n    return bytes.bytestr()\n}\n\nfn main() {\n    char_map := {\n        'a': 'DCaBA'\n        'b': 'bE'\n        'r': 'Fr'\n    }\n    for old in ['abracadabra', 'caaarrbabad'] {\n        new := selectively_replace_chars(old, char_map)\n        println('$old -> $new')\n    }\n}\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 389487, "name": "Nested templated data", "source": "Translate Ruby to Python: def with_payload(template, payload, used = nil)\n    template.map do |item|\n      if item.is_a? Enumerable\n        with_payload(item, payload, used)\n      else\n        used << item\n        payload[item]\n      end\n    end\nend\n\np = {\"Payload\nt = { { {1, 2}, {3, 4, 1}, 5}}\nused = Set(Int32).new\nputs with_payload(t, p, used)\n\nunused = Set(Int32).new((0..6).to_a) - used\nputs \"Unused indices: \n", "target": "from pprint import pprint as pp\n\nclass Template():\n    def __init__(self, structure):\n        self.structure = structure\n        self.used_payloads, self.missed_payloads = [], []\n    \n    def inject_payload(self, id2data):\n        \n        def _inject_payload(substruct, i2d, used, missed):\n            used.extend(i2d[x] for x in substruct if type(x) is not tuple and x in i2d)\n            missed.extend(f'??\n                          for x in substruct if type(x) is not tuple and x not in i2d)\n            return tuple(_inject_payload(x, i2d, used, missed) \n                           if type(x) is tuple \n                           else i2d.get(x, f'??\n                         for x in substruct)\n                           \n        ans = _inject_payload(self.structure, id2data, \n                              self.used_payloads, self.missed_payloads)\n        self.unused_payloads = sorted(set(id2data.values()) \n                                      - set(self.used_payloads))\n        self.missed_payloads = sorted(set(self.missed_payloads))\n        return ans\n\nif __name__ == '__main__':\n    index2data = {p: f'Payload\n    print(\"\n    print('\\n  '.join(list(index2data.values())))\n    for structure in [\n     (((1, 2),\n       (3, 4, 1),\n       5),),\n    \n     (((1, 2),\n       (10, 4, 1),\n       5),)]:\n        print(\"\\n\\n\n        pp(structure, width=13)\n        print(\"\\n TEMPLATE WITH PAYLOADS:\")\n        t = Template(structure)\n        out = t.inject_payload(index2data)\n        pp(out)\n        print(\"\\n UNUSED PAYLOADS:\\n  \", end='')\n        unused = t.unused_payloads\n        print('\\n  '.join(unused) if unused else '-')\n        print(\" MISSING PAYLOADS:\\n  \", end='')\n        missed = t.missed_payloads\n        print('\\n  '.join(missed) if missed else '-')\n"}
{"id": 389488, "name": "Make a backup file", "source": "Translate Ruby to Python: def backup_and_open(filename)\n  filename = File.realpath(filename)\n  bkup = filename + \".backup\"\n  backup_files = Dir.glob(bkup + \"*\").sort_by do |f|\n    f.match(/\\d+$/)\n    $&.nil? ? 0 : $&.to_i\n  end\n  backup_files.reverse.each do |fname|\n    if m = fname.match(/\\.backup\\.(\\d+)$/)\n      File.rename(fname, \"%s.%d\" % [bkup, m[1].to_i + 1])\n    elsif fname == bkup\n      File.rename(bkup, bkup + \".1\")\n    end\n  end\n  File.rename(filename, bkup)\n  File.open(filename, \"w\") {|handle| yield handle}\nend\n\n1.upto(12) {|i| backup_and_open(ARGV[0]) {|fh| fh.puts \"backup \n", "target": "import os\ntargetfile = \"pycon-china\"\nos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+\".bak\")\nf = open(os.path.realpath(targetfile), \"w\")\nf.write(\"this task was solved during a talk about rosettacode at the PyCon China in 2011\")\nf.close()\n"}
{"id": 389489, "name": "Make a backup file", "source": "Translate Ruby to Python: def backup_and_open(filename)\n  filename = File.realpath(filename)\n  bkup = filename + \".backup\"\n  backup_files = Dir.glob(bkup + \"*\").sort_by do |f|\n    f.match(/\\d+$/)\n    $&.nil? ? 0 : $&.to_i\n  end\n  backup_files.reverse.each do |fname|\n    if m = fname.match(/\\.backup\\.(\\d+)$/)\n      File.rename(fname, \"%s.%d\" % [bkup, m[1].to_i + 1])\n    elsif fname == bkup\n      File.rename(bkup, bkup + \".1\")\n    end\n  end\n  File.rename(filename, bkup)\n  File.open(filename, \"w\") {|handle| yield handle}\nend\n\n1.upto(12) {|i| backup_and_open(ARGV[0]) {|fh| fh.puts \"backup \n", "target": "import os\ntargetfile = \"pycon-china\"\nos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+\".bak\")\nf = open(os.path.realpath(targetfile), \"w\")\nf.write(\"this task was solved during a talk about rosettacode at the PyCon China in 2011\")\nf.close()\n"}
{"id": 389490, "name": "Rosetta Code_Fix code tags", "source": "Translate Ruby to Python: \n\n\ntext = DATA.read\nslash_lang = '/lang'\nlangs = %w(foo bar baz) \nfor lang in langs\n  text.gsub!(Regexp.new(\"<(\n  text.gsub!(Regexp.new(\"</\nend\ntext.gsub!(/<code (.*?)>/, '<lang \\1>')\ntext.gsub!(/<\\/code>/, \"<\nprint text\n\n__END__\nLorem ipsum <code foo>saepe audire</code> elaboraret ne quo, id equidem\natomorum inciderint usu. <foo>In sit inermis deleniti percipit</foo>,\nius ex tale civibus omittam. <barf>Vix ut doctus cetero invenire</barf>, his eu\naltera electram. Tota adhuc altera te sea, <code bar>soluta appetere ut mel</bar>.\nQuo quis graecis vivendo te, <baz>posse nullam lobortis ex usu</code>. Eam volumus perpetua\nconstituto id, mea an omittam fierent vituperatoribus.\n", "target": "\n\nfrom re import sub\n\ntesttexts = [\n,\n    ,\n    ]\n\nfor txt in testtexts:\n    text2 = sub(r'<lang\\s+\\\"?([\\w\\d\\s]+)\\\"?\\s?>', r'<syntaxhighlight lang=\\1>', txt)\n    text2 = sub(r'<lang\\s*>', r'<syntaxhighlight lang=text>', text2)\n    text2 = sub(r'</lang\\s*>', r'\n"}
{"id": 389491, "name": "Sort primes from list to a list", "source": "Translate Ruby to Python: require 'prime'\n\np [2,43,81,122,63,13,7,95,103].select(&:prime?).sort\n", "target": "print(\"working...\")\nprint(\"Primes are:\")\n\ndef isprime(m):\n    for i in range(2,int(m**0.5)+1):\n        if m%i==0:\n            return False\n    return True\n\nPrimes = [2,43,81,122,63,13,7,95,103]\nTemp = []\n\nfor n in range(len(Primes)):\n\tif isprime(Primes[n]):\n\t\tTemp.append(Primes[n])\n\nTemp.sort()\nprint(Temp)\nprint(\"done...\")\n"}
{"id": 389492, "name": "Find first missing positive", "source": "Translate Ruby to Python: nums  =   [1,2,0], [3,4,-1,1], [7,8,9,11,12]\nputs nums.map{|ar|(1..).find{|candidate| !ar.include?(candidate) }}.join(\", \")\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstGap(xs):\n    \n    return next(x for x in count(1) if x not in xs)\n\n\n\n\ndef main():\n    \n    print('\\n'.join([\n        f'{repr(xs)} -> {firstGap(xs)}' for xs in [\n            [1, 2, 0],\n            [3, 4, -1, 1],\n            [7, 8, 9, 11, 12]\n        ]\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389493, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Ruby to Python: require \"prime\"\n\nPrime.each(1_000_000).each_cons(2) do |a, b|\n  diff = b - a\n  next unless diff > 36\n  isqrt = Integer.sqrt(diff)\n  puts \"\nend\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 389494, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Ruby to Python: require \"prime\"\n\nPrime.each(1_000_000).each_cons(2) do |a, b|\n  diff = b - a\n  next unless diff > 36\n  isqrt = Integer.sqrt(diff)\n  puts \"\nend\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 389495, "name": "Snake and ladder", "source": "Translate Ruby to Python: NONE = 0; LADDER = 1; SNAKE = 2; STAY = 1; MOVE = 2; WIN = 3\nclass Cell\n    @type; @to; attr_reader :type, :to\n    def initialize; @type = NONE; @to = 0; end \n    def set( t, o ); @type = t; @to = o; end\nend\nclass Player\n    @pos; @name; attr_accessor :pos; attr_reader :name\n    def initialize( n ); @pos = 0; @name = n; end\n    def play( dice )\n        s = dice.roll; return s, STAY if @pos + s > 99\n        @pos += s; return s, WIN if @pos == 99\n        return s, MOVE\n    end\nend\nclass Die\n    @sides; def initialize( s = 6 ); @sides = s; end\n    def roll; return 1 + rand( @sides ); end\nend\ndef initBoard\n    @board = Array.new( 100 ); for i in 0 .. 99; @board[i] = Cell.new(); end\n    @board[3].set( LADDER, 13 ); @board[8].set( LADDER, 30 ); @board[19].set( LADDER, 37 );\n    @board[27].set( LADDER, 83 );@board[39].set( LADDER, 58 ); @board[50].set( LADDER, 66 );\n    @board[62].set( LADDER, 80 ); @board[70].set( LADDER, 90 ); @board[16].set( SNAKE, 6 );\n    @board[61].set( SNAKE, 18 ); @board[86].set( SNAKE, 23 ); @board[53].set( SNAKE, 33 );\n    @board[63].set( SNAKE, 59 ); @board[92].set( SNAKE, 72 ); @board[94].set( SNAKE, 74 ); \n    @board[98].set( SNAKE, 77 );\nend\ndef initPlayers\n    @players = Array.new( 4 );\n    for i in 0 .. @playersCount - 1; @players[i] = Player.new( \"player \" << i + 49 ); end\nend\ndef play\n    initBoard; initPlayers; @die = Die.new\n    while true\n        for p in 0 .. @playersCount - 1\n            puts; puts\n            if( 0 == p ) \n                print \"\n                \"Press [RETURN] to roll the die.\"\n                gets; np = @players[p].play( @die ); print \"You rolled a \n                if np[1] == WIN\n                    print \"You reached position \n                elsif np[1] == STAY; print \"Sorry, you cannot move!\\n\"\n                else print \"Your new position is cell \n                end\n            else\n                np = @players[p].play( @die ); print \"\n                if np[1] == WIN \n                     print \"He reached position \n                elsif np[1] == STAY; print \"But he cannot move....\\n\"\n                else print \"His new position is cell \n                end\n            end\n            s = @board[@players[p].pos].type\n            next if s == NONE\n            @players[p].pos = @board[@players[p].pos].to\n            case s\n                when SNAKE; print \"What a pitty, landed on a snake. \"\n                when LADDER; print \"Lucky move! Landed on a ladder. \"\n            end\n            print \"New position is cell \n        end\n    end\nend\n@playersCount = 4; @board; @players; @die\nplay\n", "target": "import random\nimport sys\n\nsnl = {\n    4: 14,\n    9: 31,\n    17: 7,\n    20: 38,\n    28: 84,\n    40: 59,\n    51: 67,\n    54: 34,\n    62: 19,\n    63: 81,\n    64: 60,\n    71: 91,\n    87: 24,\n    93: 73,\n    95: 75,\n    99: 78\n}\nsixesRollAgain = True\n\ndef turn(player, square):\n    while True:\n        roll = random.randint(1,6)\n        sys.stdout.write(\"Player {0} on square {1}, rolls a {2}\".format(player, square, roll))\n        if square + roll > 100:\n            print \" but cannot move.\"\n        else:\n            square += roll\n            print \" and moves to square {0}\".format(square)\n            if square == 100:\n                return 100\n            next = snl.get(square, square)\n            if square < next:\n                print \"Yay! landed on a ladder. Climb up to {0}.\".format(next)\n                if square == 100:\n                    return 100\n                square = next\n            elif square > next:\n                print \"Oops! Landed on a snake. Slither down to {0}.\".format(next)\n                square = next\n        if roll < 6 or not sixesRollAgain:\n            return square\n        print \"Rolled a 6 so roll again.\"\n\ndef main():\n    players = [1, 1, 1]\n    while True:\n        for i in range(0, 3):\n            ns = turn(i+1, players[i])\n            if ns == 100:\n                print \"Player {0} wins!\".format(i+1)\n                return\n            players[i] = ns;\n            print\n\nmain()\n"}
{"id": 389496, "name": "Farey sequence", "source": "Translate Ruby to Python: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 389497, "name": "Farey sequence", "source": "Translate Ruby to Python: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 389498, "name": "Aliquot sequence classifications", "source": "Translate Ruby to Python: def aliquot(n, maxlen=16, maxterm=2**47)\n  return \"terminating\", [0] if n == 0\n  s = []\n  while (s << n).size <= maxlen and n < maxterm\n    n = n.proper_divisors.inject(0, :+)\n    if s.include?(n)\n      case n\n      when s[0]\n        case s.size\n        when 1   then   return \"perfect\", s\n        when 2   then   return \"amicable\", s\n        else            return \"sociable of length \n        end\n      when s[-1] then   return \"aspiring\", s\n      else              return \"cyclic back to \n      end\n    elsif n == 0 then   return \"terminating\", s << 0\n    end\n  end\n  return \"non-terminating\", s\nend\n\nfor n in 1..10\n  puts \"%20s: %p\" % aliquot(n)\nend\nputs\nfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n  puts \"%20s: %p\" % aliquot(n)\nend\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 389499, "name": "Aliquot sequence classifications", "source": "Translate Ruby to Python: def aliquot(n, maxlen=16, maxterm=2**47)\n  return \"terminating\", [0] if n == 0\n  s = []\n  while (s << n).size <= maxlen and n < maxterm\n    n = n.proper_divisors.inject(0, :+)\n    if s.include?(n)\n      case n\n      when s[0]\n        case s.size\n        when 1   then   return \"perfect\", s\n        when 2   then   return \"amicable\", s\n        else            return \"sociable of length \n        end\n      when s[-1] then   return \"aspiring\", s\n      else              return \"cyclic back to \n      end\n    elsif n == 0 then   return \"terminating\", s << 0\n    end\n  end\n  return \"non-terminating\", s\nend\n\nfor n in 1..10\n  puts \"%20s: %p\" % aliquot(n)\nend\nputs\nfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n  puts \"%20s: %p\" % aliquot(n)\nend\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 389500, "name": "Implicit type conversion", "source": "Translate Ruby to Python: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "from fractions import Fraction\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 60\nfrom itertools import product\n\ncasting_functions = [int, float, complex,   \n                     Fraction, Decimal,     \n                     hex, oct, bin,         \n                     bool,                  \n                     iter,                  \n                     list, tuple, range,    \n                     str, bytes,            \n                     bytearray,             \n                     set, frozenset,        \n                     dict,                  \n                    ]\n\nexamples_of_types = [0, 42, \n                     0.0 -0.0, 12.34, 56.0, \n                     (0+0j), (1+2j), (1+0j), (78.9+0j), (0+1.2j),\n                     Fraction(0, 1), Fraction(22, 7), Fraction(4, 2), \n                     Decimal('0'),\n                     Decimal('3.14159265358979323846264338327950288419716939937510'),\n                     Decimal('1'), Decimal('1.5'),\n                     True, False,\n                     iter(()), iter([1, 2, 3]), iter({'A', 'B', 'C'}), \n                     iter([[1, 2], [3, 4]]), iter((('a', 1), (2, 'b'))),\n                     [], [1, 2], [[1, 2], [3, 4]],\n                     (), (1, 'two', (3+0j)), (('a', 1), (2, 'b')),\n                     range(0), range(3),\n                     \"\", \"A\", \"ABBA\", \"Mil\u00fc\",\n                     b\"\", b\"A\", b\"ABBA\",\n                     bytearray(b\"\"), bytearray(b\"A\"), bytearray(b\"ABBA\"),\n                     set(), {1, 'two', (3+0j), (4, 5, 6)},\n                     frozenset(), frozenset({1, 'two', (3+0j), (4, 5, 6)}),\n                     {}, {1: 'one', 'two': (2+3j), ('RC', 3): None} \n                    ]\nif __name__ == '__main__':\n    print('Common Python types/type casting functions:')\n    print('  ' + '\\n  '.join(f.__name__ for f in casting_functions))\n    print('\\nExamples of those types:')\n    print('  ' + '\\n  '.join('%-26s %r' % (type(e), e) for e in examples_of_types))\n    print('\\nCasts of the examples:')\n    for f, e in product(casting_functions, examples_of_types):\n        try:\n            ans = f(e)\n        except BaseException:\n            ans = 'EXCEPTION RAISED!'\n        print('%-60s -> %r' % ('%s(%r)' % (f.__name__, e), ans))\n"}
{"id": 389501, "name": "Implicit type conversion", "source": "Translate Ruby to Python: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "from fractions import Fraction\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 60\nfrom itertools import product\n\ncasting_functions = [int, float, complex,   \n                     Fraction, Decimal,     \n                     hex, oct, bin,         \n                     bool,                  \n                     iter,                  \n                     list, tuple, range,    \n                     str, bytes,            \n                     bytearray,             \n                     set, frozenset,        \n                     dict,                  \n                    ]\n\nexamples_of_types = [0, 42, \n                     0.0 -0.0, 12.34, 56.0, \n                     (0+0j), (1+2j), (1+0j), (78.9+0j), (0+1.2j),\n                     Fraction(0, 1), Fraction(22, 7), Fraction(4, 2), \n                     Decimal('0'),\n                     Decimal('3.14159265358979323846264338327950288419716939937510'),\n                     Decimal('1'), Decimal('1.5'),\n                     True, False,\n                     iter(()), iter([1, 2, 3]), iter({'A', 'B', 'C'}), \n                     iter([[1, 2], [3, 4]]), iter((('a', 1), (2, 'b'))),\n                     [], [1, 2], [[1, 2], [3, 4]],\n                     (), (1, 'two', (3+0j)), (('a', 1), (2, 'b')),\n                     range(0), range(3),\n                     \"\", \"A\", \"ABBA\", \"Mil\u00fc\",\n                     b\"\", b\"A\", b\"ABBA\",\n                     bytearray(b\"\"), bytearray(b\"A\"), bytearray(b\"ABBA\"),\n                     set(), {1, 'two', (3+0j), (4, 5, 6)},\n                     frozenset(), frozenset({1, 'two', (3+0j), (4, 5, 6)}),\n                     {}, {1: 'one', 'two': (2+3j), ('RC', 3): None} \n                    ]\nif __name__ == '__main__':\n    print('Common Python types/type casting functions:')\n    print('  ' + '\\n  '.join(f.__name__ for f in casting_functions))\n    print('\\nExamples of those types:')\n    print('  ' + '\\n  '.join('%-26s %r' % (type(e), e) for e in examples_of_types))\n    print('\\nCasts of the examples:')\n    for f, e in product(casting_functions, examples_of_types):\n        try:\n            ans = f(e)\n        except BaseException:\n            ans = 'EXCEPTION RAISED!'\n        print('%-60s -> %r' % ('%s(%r)' % (f.__name__, e), ans))\n"}
{"id": 389502, "name": "Mersenne primes", "source": "Translate Ruby to Python: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 389503, "name": "Mersenne primes", "source": "Translate Ruby to Python: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 389504, "name": "Cubic special primes", "source": "Translate Ruby to Python: require 'prime'\n\nres = [2]\n\nuntil res.last > 15000 do\n  res << (1..).detect{|n| (res.last + n**3).prime? } ** 3 + res.last\nend\n\nputs res[..-2].join(\" \")\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    p = 2\n    n = 1\n\n    print(\"2\",end = \" \")\n    while True:\n        if isPrime(p + n**3):\n            p += n**3\n            n = 1\n            print(p,end = \" \")\n        else:\n            n += 1\n        if p + n**3 >= 15000:\n            break\n"}
{"id": 389505, "name": "Cubic special primes", "source": "Translate Ruby to Python: require 'prime'\n\nres = [2]\n\nuntil res.last > 15000 do\n  res << (1..).detect{|n| (res.last + n**3).prime? } ** 3 + res.last\nend\n\nputs res[..-2].join(\" \")\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    p = 2\n    n = 1\n\n    print(\"2\",end = \" \")\n    while True:\n        if isPrime(p + n**3):\n            p += n**3\n            n = 1\n            print(p,end = \" \")\n        else:\n            n += 1\n        if p + n**3 >= 15000:\n            break\n"}
{"id": 389506, "name": "Sexy primes", "source": "Translate Ruby to Python: require 'prime'\n\nprime_array, sppair2, sppair3, sppair4, sppair5 = Array.new(5) {Array.new()} \nunsexy, i, start = [2], 0, Time.now\nPrime.each(1_000_100) {|prime| prime_array.push prime}\n\nwhile prime_array[i] < 1_000_035\n  i+=1\n  unsexy.push(i) if prime_array[(i+1)..(i+2)].include?(prime_array[i]+6) == false && prime_array[(i-2)..(i-1)].include?(prime_array[i]-6) == false && prime_array[i]+6 < 1_000_035\n  prime_array[(i+1)..(i+4)].include?(prime_array[i]+6) && prime_array[i]+6 < 1_000_035 ? sppair2.push(i) : next\n  prime_array[(i+2)..(i+5)].include?(prime_array[i]+12) && prime_array[i]+12 < 1_000_035 ? sppair3.push(i) : next\n  prime_array[(i+3)..(i+6)].include?(prime_array[i]+18) && prime_array[i]+18 < 1_000_035 ? sppair4.push(i) : next\n  prime_array[(i+4)..(i+7)].include?(prime_array[i]+24) && prime_array[i]+24 < 1_000_035 ? sppair5.push(i) : next\nend\n\nputs \"\\nSexy prime pairs: \nsppair2.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime triplets: \nsppair3.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime quadruplets: \nsppair4.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12, prime_array[prime]+18].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime quintuplets: \nsppair5.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12, prime_array[prime]+18, prime_array[prime]+24].join(\" - \"), \"\\n\"}\n\nputs \"\\nUnSexy prime: \nunsexy.last(10).each {|item| print prime_array[item], \" \"}\nprint \"\\n\\n\", Time.now - start, \" seconds\"\n", "target": "LIMIT = 1_000_035\ndef primes2(limit=LIMIT):\n    if limit < 2: return []\n    if limit < 3: return [2]\n    lmtbf = (limit - 3) // 2\n    buf = [True] * (lmtbf + 1)\n    for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n        if buf[i]:\n            p = i + i + 3\n            s = p * (i + 1) + i\n            buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]\n\nprimes = primes2(LIMIT +6)\nprimeset = set(primes)\nprimearray = [n in primeset for n in range(LIMIT)]\n\n\ns = [[] for x in range(4)]\nunsexy = []\n\nfor p in primes:\n    if p > LIMIT:\n        break\n    if p + 6 in primeset and p + 6 < LIMIT:\n        s[0].append((p, p+6))\n    elif p + 6 in primeset:\n        break\n    else:\n        if p - 6 not in primeset:\n            unsexy.append(p)\n        continue\n    if p + 12 in primeset and p + 12 < LIMIT:\n        s[1].append((p, p+6, p+12))\n    else:\n        continue\n    if p + 18 in primeset and p + 18 < LIMIT:\n        s[2].append((p, p+6, p+12, p+18))\n    else:\n        continue\n    if p + 24 in primeset and p + 24 < LIMIT:\n        s[3].append((p, p+6, p+12, p+18, p+24))\n\n\nprint('\"SEXY\" PRIME GROUPINGS:')\nfor sexy, name in zip(s, 'pairs triplets quadruplets quintuplets'.split()):\n    print(f'  {len(sexy)} {na (not isPrime(n-6))))) |> Array.ofSeq\nprintfn \"There are %d unsexy primes less than 1,000,035. The last 10 are:\" n.Length\nArray.skip (n.Length-10) n |> Array.iter(fun n->printf \"%d \" n); printfn \"\"\nlet ni=pCache |> Seq.takeWhile(fun n->nme} ending with ...')\n    for sx in sexy[-5:]:\n        print('   ',sx)\n\nprint(f'\\nThere are {len(unsexy)} unsexy primes ending with ...')\nfor usx in unsexy[-10:]:\n    print(' ',usx)\n"}
{"id": 389507, "name": "Klarner-Rado sequence", "source": "Translate Ruby to Python: using Formatting\n\nfunction KlamerRado(N)\n    kr = falses(100 * N)\n    kr[1] = true\n    for i in 1:30N\n        if kr[i]\n            kr[2i + 1] = true\n            kr[3i + 1] = true\n        end\n    end\n    return [i for i in eachindex(kr) if kr[i]]\nend\n\nkr1m = KlamerRado(1000000)\n\nprintln(\"First 100 Klarner-Rado numbers:\")\nforeach(p -> print(rpad(p[2], 4), p[1] % 20 == 0 ? \"\\n\" : \"\"), enumerate(kr1m[1:100]))\nforeach(n -> println(\"The \", format(n, commas=true), \"th Klarner-Rado number is \",\n   format(kr1m[n], commas=true)), [1000, 10000, 100000, 1000000])\n", "target": "def KlarnerRado(N):\n    K = [1]\n    for i in range(N):\n        j = K[i]\n        firstadd, secondadd = 2 * j + 1, 3 * j + 1\n        if firstadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < firstadd < K[pos + 1]:\n                    K.insert(pos + 1, firstadd)\n                    break\n        elif firstadd > K[-1]:\n            K.append(firstadd)\n        if secondadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < secondadd < K[pos + 1]:\n                    K.insert(pos + 1, secondadd)\n                    break\n        elif secondadd > K[-1]:\n            K.append(secondadd)\n\n    return K\n\nkr1m = KlarnerRado(100_000)\n\nprint('First 100 Klarner-Rado sequence numbers:')\nfor idx, v in enumerate(kr1m[:100]):\n    print(f'{v: 4}', end='\\n' if (idx + 1) % 20 == 0 else '')\nfor n in [1000, 10_000, 100_000]:\n    print(f'The {n :,}th Klarner-Rado number is {kr1m[n-1] :,}')\n"}
{"id": 389508, "name": "Klarner-Rado sequence", "source": "Translate Ruby to Python: using Formatting\n\nfunction KlamerRado(N)\n    kr = falses(100 * N)\n    kr[1] = true\n    for i in 1:30N\n        if kr[i]\n            kr[2i + 1] = true\n            kr[3i + 1] = true\n        end\n    end\n    return [i for i in eachindex(kr) if kr[i]]\nend\n\nkr1m = KlamerRado(1000000)\n\nprintln(\"First 100 Klarner-Rado numbers:\")\nforeach(p -> print(rpad(p[2], 4), p[1] % 20 == 0 ? \"\\n\" : \"\"), enumerate(kr1m[1:100]))\nforeach(n -> println(\"The \", format(n, commas=true), \"th Klarner-Rado number is \",\n   format(kr1m[n], commas=true)), [1000, 10000, 100000, 1000000])\n", "target": "def KlarnerRado(N):\n    K = [1]\n    for i in range(N):\n        j = K[i]\n        firstadd, secondadd = 2 * j + 1, 3 * j + 1\n        if firstadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < firstadd < K[pos + 1]:\n                    K.insert(pos + 1, firstadd)\n                    break\n        elif firstadd > K[-1]:\n            K.append(firstadd)\n        if secondadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < secondadd < K[pos + 1]:\n                    K.insert(pos + 1, secondadd)\n                    break\n        elif secondadd > K[-1]:\n            K.append(secondadd)\n\n    return K\n\nkr1m = KlarnerRado(100_000)\n\nprint('First 100 Klarner-Rado sequence numbers:')\nfor idx, v in enumerate(kr1m[:100]):\n    print(f'{v: 4}', end='\\n' if (idx + 1) % 20 == 0 else '')\nfor n in [1000, 10_000, 100_000]:\n    print(f'The {n :,}th Klarner-Rado number is {kr1m[n-1] :,}')\n"}
{"id": 389509, "name": "Taxicab numbers", "source": "Translate Ruby to Python: def taxicab_number(nmax=1200)\n  [*1..nmax].repeated_combination(2).group_by{|x,y| x**3 + y**3}.select{|k,v| v.size>1}.sort\nend\n\nt = [0] + taxicab_number\n\n[*1..25, *2000...2007].each do |i|\n  puts \"%4d: %10d\" % [i, t[i][0]] + t[i][1].map{|a| \" = %4d**3 + %4d**3\" % a}.join\nend\n", "target": "from collections import defaultdict\nfrom itertools import product\nfrom pprint import pprint as pp\n\ncube2n = {x**3:x for x in range(1, 1201)}\nsum2cubes = defaultdict(set)\nfor c1, c2 in product(cube2n, cube2n):\n\tif c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2]))\n\t\ntaxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2)\n\n\nfor t in enumerate(taxied[:25], 1):\n    pp(t)\nprint('...')    \nfor t in enumerate(taxied[2000-1:2000+6], 2000):\n    pp(t)\n"}
{"id": 389510, "name": "Strong and weak primes", "source": "Translate Ruby to Python: require 'prime'\n\nstrong_gen = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b<b} }\nweak_gen   = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b>b} }\n\nputs \"First 36 strong primes:\"\nputs strong_gen.take(36).join(\" \"), \"\\n\"\nputs \"First 37 weak primes:\"\nputs weak_gen.take(37).join(\" \"), \"\\n\"\n\n[1_000_000, 10_000_000].each do |limit|\n  strongs, weaks = 0, 0\n  Prime.each_cons(3) do |a,b,c|\n    strongs += 1 if b > a+c-b\n    weaks += 1 if b < a+c-b\n    break if c > limit\n  end\n  puts \"\nend\n", "target": "import numpy as np\n\ndef primesfrom2to(n):\n    \n    \n    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)//3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&1))//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\np = primes10m   = primesfrom2to(10_000_000)\ns = strong10m   = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t > (s + u) / 2]\nw = weak10m     = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t < (s + u) / 2]\nb = balanced10m = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t == (s + u) / 2]\n\nprint('The first   36   strong primes:', s[:36])\nprint('The   count   of the strong primes below   1,000,000:',\n      sum(1 for p in s if p < 1_000_000))\nprint('The   count   of the strong primes below  10,000,000:', len(s))\nprint('\\nThe first   37   weak primes:', w[:37])\nprint('The   count   of the weak   primes below   1,000,000:',\n      sum(1 for p in w if p < 1_000_000))\nprint('The   count   of the weak   primes below  10,000,000:', len(w))\nprint('\\n\\nThe first   10 balanced primes:', b[:10])\nprint('The   count   of balanced   primes below   1,000,000:',\n      sum(1 for p in b if p < 1_000_000))\nprint('The   count   of balanced   primes below  10,000,000:', len(b))\nprint('\\nTOTAL primes below   1,000,000:',\n      sum(1 for pr in p if pr < 1_000_000))\nprint('TOTAL primes below  10,000,000:', len(p))\n"}
{"id": 389511, "name": "Left factorials", "source": "Translate Ruby to Python: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 389512, "name": "Left factorials", "source": "Translate Ruby to Python: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 389513, "name": "Strange unique prime triplets", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 389514, "name": "Strange unique prime triplets", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 389515, "name": "Motzkin numbers", "source": "Translate Ruby to Python: require \"prime\"\n\nmotzkin = Enumerator.new do |y|\n  m = [1,1]\n  m.each{|m| y << m }\n  \n  2.step do |i| \n    m << (m.last*(2*i+1) + m[-2]*(3*i-3)) / (i+2)\n    m.unshift \n    y << m.last\n  end\nend\n\nmotzkin.take(42).each_with_index do |m, i|\n  puts \"\nend\n", "target": "\n\nfrom sympy import isprime\n\n\ndef motzkin(num_wanted):\n    \n    mot = [1] * (num_wanted + 1)\n    for i in range(2, num_wanted + 1):\n        mot[i] = (mot[i-1]*(2*i+1) + mot[i-2]*(3*i-3)) // (i + 2)\n    return mot\n\n\ndef print_motzkin_table(N=41):\n    \n    print(\n        \" n          M[n]             Prime?\\n-----------------------------------\")\n    for i, e in enumerate(motzkin(N)):\n        print(f'{i : 3}{e : 24,}', isprime(e))\n\n\nprint_motzkin_table()\n"}
{"id": 389516, "name": "Special neighbor primes", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each(100).each_cons(2).select{|p1, p2|(p1+p2-1).prime?}.each{|ar| p ar}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef nextPrime(n):\n    \n    if n == 0:\n        return 2\n    if n < 3:\n        return n + 1\n    q = n + 2\n    while not isPrime(q):\n        q += 2\n    return q\n\n\nif __name__ == \"__main__\":\n    for p1 in range(3,100,2):\n        p2 = nextPrime(p1)\n        if isPrime(p1) and p2 < 100 and isPrime(p1 + p2 - 1):\n            print(p1,'\\t', p2,'\\t', p1 + p2 - 1)\n"}
{"id": 389517, "name": "Special neighbor primes", "source": "Translate Ruby to Python: require 'prime'\n\nPrime.each(100).each_cons(2).select{|p1, p2|(p1+p2-1).prime?}.each{|ar| p ar}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef nextPrime(n):\n    \n    if n == 0:\n        return 2\n    if n < 3:\n        return n + 1\n    q = n + 2\n    while not isPrime(q):\n        q += 2\n    return q\n\n\nif __name__ == \"__main__\":\n    for p1 in range(3,100,2):\n        p2 = nextPrime(p1)\n        if isPrime(p1) and p2 < 100 and isPrime(p1 + p2 - 1):\n            print(p1,'\\t', p2,'\\t', p1 + p2 - 1)\n"}
{"id": 389518, "name": "Strange plus numbers", "source": "Translate Ruby to Python: $p = [\n    false, false, true, true, false,\n    true, false, true, false, false,\n    false, true, false, true, false,\n    false, false, true, false\n]\n\ndef isStrange(n)\n    if n < 10 then\n        return false\n    end\n\n    while n >= 10 do\n        if not $p[n % 10 + (n / 10).floor % 10] then\n            return false\n        end\n        n = (n / 10).floor\n    end\n\n    return true\nend\n\ndef test(nMin, nMax)\n    k = 0\n    for n in nMin .. nMax\n        if isStrange(n) then\n            print n\n            k = k + 1\n            if k % 10 != 0 then\n                print ' '\n            else\n                print \"\\n\"\n            end\n        end\n    end\nend\n\ntest(101, 499)\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 389519, "name": "Strange plus numbers", "source": "Translate Ruby to Python: $p = [\n    false, false, true, true, false,\n    true, false, true, false, false,\n    false, true, false, true, false,\n    false, false, true, false\n]\n\ndef isStrange(n)\n    if n < 10 then\n        return false\n    end\n\n    while n >= 10 do\n        if not $p[n % 10 + (n / 10).floor % 10] then\n            return false\n        end\n        n = (n / 10).floor\n    end\n\n    return true\nend\n\ndef test(nMin, nMax)\n    k = 0\n    for n in nMin .. nMax\n        if isStrange(n) then\n            print n\n            k = k + 1\n            if k % 10 != 0 then\n                print ' '\n            else\n                print \"\\n\"\n            end\n        end\n    end\nend\n\ntest(101, 499)\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 389520, "name": "Smarandache prime-digital sequence", "source": "Translate Ruby to Python: require \"prime\"\n \nsmarandache = Enumerator.new do|y|\n  prime_digits = [2,3,5,7]\n  prime_digits.each{|pr| y << pr} \n  (1..).each do |n|\n    prime_digits.repeated_permutation(n).each do |perm|\n      c = perm.join.to_i * 10 \n      y << c + 3 if (c+3).prime?\n      y << c + 7 if (c+7).prime?\n    end\n  end\nend\n\nseq = smarandache.take(100)\np seq.first(25)\np seq.last\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef digit_check(n):\n    if len(str(n))<2:\n        return True\n    else:\n        for digit in str(n):\n            if not is_prime(int(digit)):\n                return False\n        return True\n\n\ndef sequence(max_n=None):\n    ii = 0\n    n = 0\n    while True:\n        ii += 1\n        if is_prime(ii):\n            if max_n is not None:\n                if n>max_n:\n                    break\n            if digit_check(ii):\n                n += 1\n                yield ii\n\n\nif __name__ == '__main__':\n    generator = sequence(100)\n    for index, item in zip(range(1, 16), generator):\n        print(index, item)\n    for index, item in zip(range(16, 100), generator):\n        pass\n    print(100, generator.__next__())\n"}
{"id": 389521, "name": "Magic squares of doubly even order", "source": "Translate Ruby to Python: def double_even_magic_square(n)\n  raise ArgumentError, \"Need multiple of four\" if n%4 > 0\n  block_size, max = n/4, n*n\n  pre_pat = [true, false, false, true,\n             false, true, true, false]\n  pre_pat += pre_pat.reverse\n  pattern = pre_pat.flat_map{|b| [b] * block_size} * block_size\n  flat_ar = pattern.each_with_index.map{|yes, num| yes ? num+1 : max-num}\n  flat_ar.each_slice(n).to_a\nend\n\ndef to_string(square)\n  n = square.size\n  fmt = \"%\n  square.inject(\"\"){|str,row| str << fmt % row << \"\\n\"}\nend\n\nputs to_string(double_even_magic_square(8))\n", "target": "def MagicSquareDoublyEven(order):\n    sq = [range(1+n*order,order + (n*order)+1) for n in range(order) ]\n    n1 = order/4\n    for r in range(n1):\n        r1 = sq[r][n1:-n1]\n        r2 = sq[order -r - 1][n1:-n1]\n        r1.reverse()\n        r2.reverse()\n        sq[r][n1:-n1] = r2\n        sq[order -r - 1][n1:-n1] = r1\n    for r in range(n1, order-n1):\n        r1 = sq[r][:n1]\n        r2 = sq[order -r - 1][order-n1:]\n        r1.reverse()\n        r2.reverse()\n        sq[r][:n1] = r2\n        sq[order -r - 1][order-n1:] = r1\n    return sq\n\ndef printsq(s):\n    n = len(s)\n    bl = len(str(n**2))+1\n    for i in range(n):\n        print ''.join( [ (\"%\"+str(bl)+\"s\")%(str(x)) for x in s[i]] )\n    print \"\\nMagic constant = %d\"%sum(s[0])\n\nprintsq(MagicSquareDoublyEven(8))\n"}
{"id": 389522, "name": "Plasma effect", "source": "Translate Ruby to Python: attr_reader :buffer, :palette, :r, :g, :b, :rd, :gd, :bd, :dim\n\ndef settings\n  size(600, 600)\nend\n\ndef setup\n  sketch_title 'Plasma Effect'\n  frame_rate 25\n  @r = 42\n  @g = 84\n  @b = 126\n  @rd = true\n  @gd = true\n  @bd = true\n  @dim = width * height\n  @buffer = Array.new(dim)\n  grid(width, height) do |x, y|\n    buffer[x + y * width] = (\n      (\n        (128 + (128 * sin(x / 32.0))) +\n        (128 + (128 * cos(y / 32.0))) +\n        (128 + (128 * sin(Math.hypot(x, y) / 32.0)))\n      ) / 4\n    ).to_i\n  end\n  load_pixels\nend\n\ndef draw\n  if rd\n    @r -= 1\n    @rd = false if r.negative?\n  else\n    @r += 1\n    @rd = true if r > 128\n  end\n  if gd\n    @g -= 1\n    @gd = false if g.negative?\n  else\n    @g += 1\n    @gd = true if g > 128\n  end\n  if bd\n    @b -= 1\n    @bd = false if b.negative?\n  else\n    @b += 1\n    @bd = true if b > 128\n  end\n  @palette = (0..127).map do |col|\n    s1 = sin(col * Math::PI / 25)\n    s2 = sin(col * Math::PI / 50 + Math::PI / 4)\n    color(r + s1 * 128, g + s2 * 128, b + s1 * 128)\n  end\n  dim.times do |idx|\n    pixels[idx] = palette[(buffer[idx] + frame_count) & 127]\n  end\n  update_pixels\nend\n", "target": "\n\npal = [0] * 128\nr = 42\ng = 84\nb = 126\nrd = gd = bd = False\n\ndef setup():\n    global buffer\n    size(600, 600)\n    frameRate(25)\n    buffer = [None] * width * height\n    for x in range(width):\n        for y in range(width):\n            value = int(((128 + (128 * sin(x / 32.0)))\n                         + (128 + (128 * cos(y / 32.0)))\n                         + (128 + (128 * sin(sqrt((x * x + y * y)) / 32.0)))) / 4)\n            buffer[x + y * width] = value\n\ndef draw():\n    global r, g, b, rd, gd, bd\n    if r > 128: rd = True\n    if not rd: r += 1\n    else: r-=1\n    if r < 0: rd = False\n    if g > 128: gd = True\n    if not gd: g += 1\n    else: g- = 1\n    if r < 0: gd = False \n    if b > 128: bd = True\n    if not bd: b += 1\n    else: b- = 1\n    if b < 0: bd = False\n \n    for i in range(128):\n          s_1 = sin(i * PI / 25)\n          s_2 = sin(i * PI / 50 + PI / 4)\n          pal[i] = color(r + s_1 * 128, g + s_2 * 128, b + s_1 * 128)\n\n    loadPixels()\n    for i, b in enumerate(buffer):\n          pixels[i] = pal[(b + frameCount) % 127]\n    updatePixels()\n"}
{"id": 389523, "name": "Square-free integers", "source": "Translate Ruby to Python: require \"prime\"\n\nclass Integer\n  def square_free?\n    prime_division.none?{|pr, exp| exp > 1}\n  end\nend\n\nputs (1..145).select(&:square_free?).each_slice(20).map{|a| a.join(\" \")}\nputs\n\nm = 10**12\nputs (m..m+145).select(&:square_free?).each_slice(6).map{|a| a.join(\" \")}\nputs\n\nmarkers = [100, 1000, 10_000, 100_000, 1_000_000]\ncount = 0\n(1..1_000_000).each do |n|\n  count += 1 if n.square_free?\n  puts \"\nend\n", "target": "import math\n\ndef SquareFree ( _number ) :\n\tmax = (int) (math.sqrt ( _number ))\n\n\tfor root in range ( 2, max+1 ):\t\t\t\t\t\n\t\tif 0 == _number % ( root * root ):\n\t\t\treturn False\n\n\treturn True\n\ndef ListSquareFrees( _start, _end ):\n\tcount = 0\n\tfor i in range ( _start, _end+1 ):\n\t\tif True == SquareFree( i ):\n\t\t\tprint ( \"{}\\t\".format(i), end=\"\" )\n\t\t\tcount += 1\n\n\tprint ( \"\\n\\nTotal count of square-free numbers between {} and {}: {}\".format(_start, _end, count))\n\nListSquareFrees( 1, 100 )\nListSquareFrees( 1000000000000, 1000000000145 )\n"}
{"id": 389524, "name": "Self numbers", "source": "Translate Ruby to Python: func is_self_number(n) {\n\n    if (n < 30) {\n        return (((n < 10) && (n.is_odd)) || (n == 20))\n    }\n\n    var qd = (1 + n.ilog10)\n    var r  = (1 + (n-1)%9)\n    var h  = (r + 9*(r%2))/2\n    var ld = 10\n\n    while (h + 9*qd >= n%ld) {\n        ld *= 10\n    }\n\n    var vs = idiv(n, ld).sumdigits\n    n %= ld\n\n    0..qd -> none { |i|\n        vs + sumdigits(n - h - 9*i) == (h + 9*i)\n    }\n}\n\nsay is_self_number.first(50).join(' ')\n", "target": "class DigitSumer :\n    def __init__(self): \n        sumdigit = lambda n : sum( map( int,str( n )))\n        self.t = [sumdigit( i ) for i in xrange( 10000 )]\n    def __call__ ( self,n ):\n        r = 0\n        while n >= 10000 :\n            n,q = divmod( n,10000 )\n            r += self.t[q]\n        return r + self.t[n] \n\n\ndef self_numbers ():\n    d = DigitSumer()\n    s = set([])\n    i = 1\n    while 1 :\n        n = i + d( i )\n        if i in s :\n            s.discard( i )\n        else:\n            yield i\n        s.add( n )\n        i += 1\n\nimport time\np = 100\nt = time.time()\nfor i,s in enumerate( self_numbers(),1 ):\n    if i <= 50 : \n        print s,\n        if i == 50 : print\n    if i == p :\n        print '%7.1f sec  %9dth = %d'%( time.time()-t,i,s )\n        p *= 10\n"}
{"id": 389525, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Ruby to Python: nivens = Enumerator.new {|y| (1..).each {|n| y << n if n.remainder(n.digits.sum).zero?} }\n\ncur_gap = 0\nputs 'Gap    Index of gap  Starting Niven'\n\nnivens.each_cons(2).with_index(1) do |(n1, n2), i|\n  break if i > 10_000_000\n  if n2-n1 > cur_gap then\n    printf \"%3d %15s %15s\\n\", n2-n1, i, n1\n    cur_gap = n2-n1\n  end\nend\n", "target": "\n\n\n\n\n\ndef digit_sum(n, sum):\n    sum += 1\n    while n > 0 and n % 10 == 0:\n        sum -= 9\n        n /= 10\n    \n    return sum\n    \nprevious = 1\ngap = 0\nsum = 0\nniven_index = 0\ngap_index = 1\n \nprint(\"Gap index  Gap    Niven index    Niven number\")\n\nniven = 1\n\nwhile gap_index <= 22:\n    sum = digit_sum(niven, sum)\n    if niven % sum == 0:\n        if niven > previous + gap:\n            gap = niven - previous;\n            print('{0:9d} {1:4d}  {2:13d}     {3:11d}'.format(gap_index, gap, niven_index, previous))\n            gap_index += 1\n        previous = niven\n        niven_index += 1\n    niven += 1\n"}
{"id": 389526, "name": "Old Russian measure of length", "source": "Translate Ruby to Python: module Distances\n\n  RATIOS = \n  {arshin: 0.7112, centimeter: 0.01,     diuym:   0.0254,\n   fut:    0.3048, kilometer:  1000.0,   liniya:  0.00254,\n   meter:  1.0,    milia:      7467.6,   piad:    0.1778,\n   sazhen: 2.1336, tochka:     0.000254, vershok: 0.04445,\n   versta: 1066.8}\n\n  def self.method_missing(meth, arg)\n    from, to = meth.to_s.split(\"2\").map(&:to_sym)\n    raise NoMethodError, meth if ([from,to]-RATIOS.keys).size > 0\n    RATIOS[from] * arg / RATIOS[to]\n  end\n\n  def self.print_others(name, num)\n    puts \"\n    RATIOS.except(name.to_sym).each {|k,v| puts \"\n  end\nend\n\nDistances.print_others(\"meter\", 2)\nputs\np Distances.meter2centimeter(3)\np Distances.arshin2meter(1)\np Distances.versta2kilometer(20) \n\np Distances.mile2piad(1)\n", "target": "from sys import argv\n \nunit2mult = {\"arshin\": 0.7112, \"centimeter\": 0.01,     \"diuym\":   0.0254,\n             \"fut\":    0.3048, \"kilometer\":  1000.0,   \"liniya\":  0.00254,\n             \"meter\":  1.0,    \"milia\":      7467.6,   \"piad\":    0.1778,\n             \"sazhen\": 2.1336, \"tochka\":     0.000254, \"vershok\": 0.04445,\n             \"versta\": 1066.8}\n \nif __name__ == '__main__':\n    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'\n    try:\n        value = float(argv[1])\n    except:\n        print('ERROR. First argument must be a (float) number')\n        raise\n    unit = argv[2]\n    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' \n                                + ' '.join(unit2mult.keys()) )\n\n    print(\"%g %s to:\" % (value, unit))\n    for unt, mlt in sorted(unit2mult.items()):\n        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))\n"}
{"id": 389527, "name": "Minimum multiple of m where digital sum equals m", "source": "Translate Ruby to Python: a131382  = (0..).lazy.map{|n| (1..).detect{|m|(n*m).digits.sum == n} }\na131382.take(70).each_slice(10){|slice| puts \"%8d\"*slice.size % slice }\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef a131382():\n    \n    return (\n        elemIndex(x)(\n            productDigitSums(x)\n        ) for x in count(1)\n    )\n\n\n\ndef productDigitSums(n):\n    \n    return (digitSum(n * x) for x in count(0))\n\n\n\n\ndef main():\n    \n\n    print(\n        table(10)([\n            str(x) for x in islice(\n                a131382(),\n                40\n            )\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitSum(n):\n    \n    return sum(int(x) for x in list(str(n)))\n\n\n\ndef elemIndex(x):\n    \n    def go(xs):\n        try:\n            return next(\n                i for i, v in enumerate(xs) if x == v\n            )\n        except StopIteration:\n            return None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389528, "name": "Pancake numbers", "source": "Translate Ruby to Python: def pancake(n)\n    gap = 2\n    sum = 2\n    adj = -1\n    while sum < n\n        adj = adj + 1\n        gap = gap * 2 - 1\n        sum = sum + gap\n    end\n    return n + adj\nend\n\nfor i in 0 .. 3\n    for j in 1 .. 5\n        n = i * 5 + j\n        print \"p(%2d) = %2d  \" % [n, pancake(n)]\n    end\n    print \"\\n\"\nend\n", "target": "\nimport time\n\nfrom collections import deque\nfrom operator import itemgetter\nfrom typing import Tuple\n\nPancakes = Tuple[int, ...]\n\n\ndef flip(pancakes: Pancakes, position: int) -> Pancakes:\n    \n    return tuple([*reversed(pancakes[:position]), *pancakes[position:]])\n\n\ndef pancake(n: int) -> Tuple[Pancakes, int]:\n    \n    init_stack = tuple(range(1, n + 1))\n    stack_flips = {init_stack: 0}\n    queue = deque([init_stack])\n\n    while queue:\n        stack = queue.popleft()\n        flips = stack_flips[stack] + 1\n\n        for i in range(2, n + 1):\n            flipped = flip(stack, i)\n            if flipped not in stack_flips:\n                stack_flips[flipped] = flips\n                queue.append(flipped)\n\n    return max(stack_flips.items(), key=itemgetter(1))\n\n\nif __name__ == \"__main__\":\n    start = time.time()\n\n    for n in range(1, 10):\n        pancakes, p = pancake(n)\n        print(f\"pancake({n}) = {p:>2}. Example: {list(pancakes)}\")\n\n    print(f\"\\nTook {time.time() - start:.3} seconds.\")\n"}
{"id": 389529, "name": "Pythagorean quadruples", "source": "Translate Ruby to Python: n = 2200\nl_add, l = Hash(Int32, Bool).new(false), Hash(Int32, Bool).new(false)\n(1..n).each do |x|\n  x2 = x * x \n  (x..n).each { |y| l_add[x2 + y * y] = true } \nend\n\ns = 3\n(1..n).each do |x|\n  s1 = s\n  s += 2\n  s2 = s\n  ((x+1)..n).each do |y|\n    l[y] = true if l_add[s1]\n    s1 += s2\n    s2 += 2\n  end\nend\n\nputs (1..n).reject{ |x| l[x] }.join(\" \")\n", "target": "def quad(top=2200):\n    r = [False] * top\n    ab = [False] * (top * 2)**2\n    for a in range(1, top):\n        for b in range(a, top):\n            ab[a * a + b * b] = True\n    s = 3\n    for c in range(1, top):\n        s1, s, s2 = s, s + 2, s + 2\n        for d in range(c + 1, top):\n            if ab[s1]:\n                r[d] = True\n            s1 += s2\n            s2 += 2\n    return [i for i, val in enumerate(r) if not val and i]\n    \nif __name__ == '__main__':\n    n = 2200\n    print(f\"Those values of d in 1..{n} that can't be represented: {quad(n)}\")\n"}
{"id": 389530, "name": "Sum and product puzzle", "source": "Translate Ruby to Python: def add(x,y) x + y end\ndef mul(x,y) x * y end\n\ndef sumEq(s,p) s.select{|q| add(*p) == add(*q)} end\ndef mulEq(s,p) s.select{|q| mul(*p) == mul(*q)} end\n\ns1 = (a = *2...100).product(a).select{|x,y| x<y && x+y<100}\ns2 = s1.select{|p| sumEq(s1,p).all?{|q| mulEq(s1,q).size != 1} }\ns3 = s2.select{|p| (mulEq(s1,p) & s2).size == 1}\np    s3.select{|p| (sumEq(s1,p) & s3).size == 1}\n", "target": "\n\nfrom collections import Counter\n\ndef decompose_sum(s):\n    return [(a,s-a) for a in range(2,int(s/2+1))]\n\n\nall_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)\n\n\nproduct_counts = Counter(c*d for c,d in all_pairs)\nunique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)\ns_pairs = [(a,b) for a,b in all_pairs if\n    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]\n\n\nproduct_counts = Counter(c*d for c,d in s_pairs)\np_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]\n\n\nsum_counts = Counter(c+d for c,d in p_pairs)\nfinal_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]\n\nprint(final_pairs)\n"}
{"id": 389531, "name": "Superpermutation minimisation", "source": "Translate Ruby to Python: \n\n\n\n\n\n\n\nl = []\n(1..6).each{|e|\n  a, i = [], e-2\n  (0..l.length-e+1).each{|g|\n     if not (n = l[g..g+e-2]).uniq!\n       a.concat(n[(a[0]? i : 0)..-1]).push(e).concat(n)\n       i = e-2\n     else\n       i -= 1\n     end\n   }\n   a.each{|n| print n}; puts \"\\n\\n\"\n   l = a\n}\n", "target": "\"Generate a short Superpermutation of n characters A... as a string using various algorithms.\"\n\n\nfrom __future__ import print_function, division\n\nfrom itertools import permutations\nfrom math import factorial\nimport string\nimport datetime\nimport gc\n\n\n\nMAXN = 7\n\n\ndef s_perm0(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in permutations(allchars)]\n    sp, tofind = allperms[0], set(allperms[1:])\n    while tofind:\n        for skip in range(1, n):\n            for trial_add in (''.join(p) for p in permutations(sp[-n:][:skip])):\n                \n                trial_perm = (sp + trial_add)[-n:]\n                if trial_perm in tofind:\n                    \n                    sp += trial_add\n                    tofind.discard(trial_perm)\n                    trial_add = None    \n                    break\n            if trial_add is None:\n                break\n    assert all(perm in sp for perm in allperms) \n    return sp\n\ndef s_perm1(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        nxt = perms.pop()\n        if nxt not in sp:\n            sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef s_perm2(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        nxt = perms.pop(0)\n        if nxt not in sp:\n            sp += nxt\n        if perms:\n            nxt = perms.pop(-1)\n            if nxt not in sp:\n                sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef _s_perm3(n, cmp):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        lastn = sp[-n:]\n        nxt = cmp(perms,\n                  key=lambda pm:\n                    sum((ch1 == ch2) for ch1, ch2 in zip(pm, lastn)))\n        perms.remove(nxt)\n        if nxt not in sp:\n            sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef s_perm3_max(n):\n    \n    return _s_perm3(n, max)\n\ndef s_perm3_min(n):\n    \n    return _s_perm3(n, min)\n\n\nlongest = [factorial(n) * n for n in range(MAXN + 1)]\nweight, runtime = {}, {}\nprint(__doc__)\nfor algo in [s_perm0, s_perm1, s_perm2, s_perm3_max, s_perm3_min]:\n    print('\\n\n    print(algo.__doc__)\n    weight[algo.__name__], runtime[algo.__name__] = 1, datetime.timedelta(0)\n    for n in range(1, MAXN + 1):\n        gc.collect()\n        gc.disable()\n        t = datetime.datetime.now()\n        sp = algo(n)\n        t = datetime.datetime.now() - t\n        gc.enable()\n        runtime[algo.__name__] += t\n        lensp = len(sp)\n        wt = (lensp / longest[n]) ** 2\n        print('  For N=%i: SP length %5i Max: %5i Weight: %5.2f'\n              % (n, lensp, longest[n], wt))\n        weight[algo.__name__] *= wt\n    weight[algo.__name__] **= 1 / n  \n    weight[algo.__name__] = 1 / weight[algo.__name__]\n    print('%*s Overall Weight: %5.2f in %.1f seconds.'\n          % (29, '', weight[algo.__name__], runtime[algo.__name__].total_seconds()))\n\nprint('\\n\nprint('\\n'.join('%12s (%.3f)' % kv for kv in\n                sorted(weight.items(), key=lambda keyvalue: -keyvalue[1])))\n      \nprint('\\n\nprint('\\n'.join('%12s (%.3f)' % (k, v.total_seconds()) for k, v in\n                sorted(runtime.items(), key=lambda keyvalue: keyvalue[1])))\n"}
{"id": 389532, "name": "Test integerness", "source": "Translate Ruby to Python: class Numeric\n  def to_i?\n    self == self.to_i rescue false\n   end\nend\n \n\nar = [25.000000, 24.999999, 25.000100, -2.1e120, -5e-2,  \n      Float::NAN, Float::INFINITY,                       \n      2r, 2.5r,                                          \n      2+0i, 2+0.0i, 5-5i]                                \n \nar.each{|num| puts \"\n", "target": ">>> def isint(f): \n    return complex(f).imag == 0 and complex(f).real.is_integer()\n\n>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]\n[True, True, True, False, False, False]\n\n>>> \n...\n>>> isint(25.000000)\nTrue\n>>> isint(24.999999)\nFalse\n>>> isint(25.000100)\nFalse\n>>> isint(-2.1e120)\nTrue\n>>> isint(-5e-2)\nFalse\n>>> isint(float('nan'))\nFalse\n>>> isint(float('inf'))\nFalse\n>>> isint(5.0+0.0j)\nTrue\n>>> isint(5-5j)\nFalse\n"}
{"id": 389533, "name": "Sum of two adjacent numbers are primes", "source": "Translate Ruby to Python: var wanted = (1..Inf -> lazy.map  {|n| [n, n+1, n+(n+1)] }\\\n                            .grep { .tail.is_prime })\n\nwanted.first(20).each_2d {|a,b,c|\n    printf(\"%2d + %2d = %2d\\n\", a,b,c)\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == \"__main__\":\n    n = 0\n    num = 0\n\n    print('The first 20 pairs of numbers whose sum is prime:') \n    while True:\n        n += 1\n        suma = 2*n+1\n        if isPrime(suma):\n            num += 1\n            if num < 21:\n                print('{:2}'.format(n), \"+\", '{:2}'.format(n+1), \"=\", '{:2}'.format(suma))\n            else:\n                break\n"}
{"id": 389534, "name": "Largest difference between adjacent primes", "source": "Translate Ruby to Python: func prime_gap_records(upto) {\n\n    var gaps = []\n    var p = 2\n\n    each_prime(p.next_prime, upto, {|q|\n        gaps[q-p] := p\n        p = q\n    })\n\n    gaps.grep { defined(_) }\n}\n\nvar upto   = 1e8\nvar primes = prime_gap_records(upto)\n\nfor n in (2 .. upto.ilog10) {\n\n    var b = primes.last_by {|p| p < 10**n } \\\\ break\n\n    printf(\"Largest prime gap up to 10^%s is %3s between %s and %s\\n\",\n        n, b.next_prime - b, b, b.next_prime)\n}\n", "target": "print(\"working...\")\nlimit = 1000000\nres1 = 0\nres2 = 0\nmaxOld = 0\nnewDiff = 0\noldDiff = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(limit):\n    newDiff = n - maxOld\n    if isprime(n):\n       if (newDiff > oldDiff):\n       \t  res1 = n\n       \t  res2 = maxOld\n          oldDiff = newDiff\n       maxOld = n\n\ndiff = res1 - res2\nprint(res1)\nprint(res2)\nprint(\"Largest difference is = \",end=\"\")\nprint(diff)\nprint(\"done...\")\n"}
{"id": 389535, "name": "Ulam numbers", "source": "Translate Ruby to Python: func ulam(n) {\n\n    static u     = Set(1,2)\n    static ulams = [0, 1, 2]\n\n    return ulams[n] if (ulams.end >= n)\n\n    ++n\n\n    for(var i = 3; true; ++i) {\n        var count = 0\n\n        ulams.each {|v|\n            if (u.has(i - v) && (v != i-v)) {\n                break if (count++ > 2)\n            }\n        }\n\n        if (count == 2) {\n            ulams << i\n            u << i\n            break if (ulams.len == n)\n        }\n    }\n\n    ulams.tail\n}\n\nfor k in (1..3) {\n    say \"The 10^\n}\n", "target": "import time\n\ndef ulam(n):\n    if n <= 2:\n        return n\n    mx = 1352000\n    lst = [1, 2] + [0] * mx\n    sums = [0] * (mx * 2 + 1)\n    sums[3] = 1\n    size = 2\n    while size < n:\n        query = lst[size-1] + 1\n        while True:\n            if sums[query] == 1:\n                for i in range(size):\n                    sum = query + lst[i]\n                    t = sums[sum] + 1\n                    if t <= 2:\n                        sums[sum] = t\n                lst[size], size = query, size + 1\n                break\n            query += 1\n    return query\n \nt0 = time.time()\nfor p in range(5):\n    n = 10**p\n    print(f\"The {n}{'th' if n!=1 else 'st'} Ulam number is {ulam(n)}\")\n\nprint(\"\\nElapsed time:\", time.time() - t0)\n"}
{"id": 389536, "name": "Ramsey's theorem", "source": "Translate Ruby to Python: a = Array.new(17){['0'] * 17}\n17.times{|i| a[i][i] = '-'}\n4.times do |k|\n  17.times do |i|\n    j = (i + 2 ** k) % 17\n    a[i][j] = a[j][i] = '1'\n  end\nend\na.each {|row| puts row.join(' ')}\n\n(0...17).to_a.combination(4) do |quartet|\n  links = quartet.combination(2).map{|i,j| a[i][j].to_i}.reduce(:+)\n  abort \"Bogus\" unless 0 < links && links < 6\nend\nputs \"Ok\"\n", "target": "range17 = range(17)\na = [['0'] * 17 for i in range17]\nidx = [0] * 4\n\n\ndef find_group(mark, min_n, max_n, depth=1):\n    if (depth == 4):\n        prefix = \"\" if (mark == '1') else \"un\"\n        print(\"Fail, found totally {}connected group:\".format(prefix))\n        for i in range(4):\n            print(idx[i])\n        return True\n\n    for i in range(min_n, max_n):\n        n = 0\n        while (n < depth):\n            if (a[idx[n]][i] != mark):\n                break\n            n += 1\n\n        if (n == depth):\n            idx[n] = i\n            if (find_group(mark, 1, max_n, depth + 1)):\n                return True\n\n    return False\n\n\nif __name__ == '__main__':\n    for i in range17:\n        a[i][i] = '-'\n    for k in range(4):\n        for i in range17:\n            j = (i + pow(2, k)) % 17\n            a[i][j] = a[j][i] = '1'\n\n    \n    \n\n    for row in a:\n        print(' '.join(row))\n\n    for i in range17:\n        idx[0] = i\n        if (find_group('1', i + 1, 17) or find_group('0', i + 1, 17)):\n            print(\"no good\")\n            exit()\n\n    print(\"all good\")\n"}
{"id": 389537, "name": "Smallest power of 6 whose decimal expansion contains n", "source": "Translate Ruby to Python: def smallest_6(n)\n  i = 1\n  c = 0\n  s = n.to_s \n  until i.to_s.match?(s)\n    c += 1\n    i *= 6\n  end\n  [n, c, i]\nend\n\n(0..21).each{|n| puts \"%3d**%-3d: %d\" %  smallest_6(n) }\n", "target": "def smallest_six(n):\n    p = 1\n    while str(n) not in str(p): p *= 6\n    return p\n    \nfor n in range(22):\n    print(\"{:2}: {}\".format(n, smallest_six(n)))\n"}
{"id": 389538, "name": "Summation of primes", "source": "Translate Ruby to Python: def prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt = Math.isqrt(n)\n  pc = typeof(n).new(5)\n  while pc <= sqrt\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\nputs \"The sum of all primes below 2 million is \n\n\n\nputs \"The sum of all primes below 2 million is \n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    suma = 2\n    n = 1\n    for i in range(3, 2000000, 2):\n        if isPrime(i):\n            suma += i\n            n+=1 \n    print(suma)\n"}
{"id": 389539, "name": "Steady squares", "source": "Translate Ruby to Python: p (0..10_000).select{|n| (n*n).to_s.end_with? n.to_s }\n", "target": "print(\"working...\")\nprint(\"Steady squares under 10.000 are:\")\nlimit = 10000\n\nfor n in range(1,limit):\n    nstr = str(n)\n    nlen = len(nstr)\n    square = str(pow(n,2))\n    rn = square[-nlen:]\n    if nstr == rn:\n       print(str(n) + \" \" + str(square))\n\nprint(\"done...\")\n"}
{"id": 389540, "name": "Safe primes and unsafe primes", "source": "Translate Ruby to Python: require \"prime\"\nclass Integer\n  def safe_prime? \n    ((self-1)/2).prime?\n  end\nend\n\ndef format_parts(n)\n  partitions = Prime.each(n).partition(&:safe_prime?).map(&:count)\n  \"There are %d safes and %d unsafes below \nend\n\nputs \"First 35 safe-primes:\"\np Prime.each.lazy.select(&:safe_prime?).take(35).to_a\nputs format_parts(1_000_000), \"\\n\" \n\nputs \"First 40 unsafe-primes:\"\np Prime.each.lazy.reject(&:safe_prime?).take(40).to_a\nputs format_parts(10_000_000)\n", "target": "primes =[]\nsp =[]\nusp=[]\nn = 10000000\nif 2<n:\n    primes.append(2)\nfor i in range(3,n+1,2):\n    for j in primes:\n        if(j>i/2) or (j==primes[-1]):\n            primes.append(i)\n            if((i-1)/2) in primes:\n                sp.append(i)\n                break\n            else:\n                usp.append(i)\n                break\n        if (i%j==0):\n            break\n\nprint('First 35 safe primes are:\\n' , sp[:35])\nprint('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')\nprint('There are '+str(len(sp))+' safe primes below 10,000,000')\nprint('First 40 unsafe primes:\\n',usp[:40])\nprint('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')\nprint('There are '+str(len(usp))+' safe primes below 10,000,000')\n"}
{"id": 389541, "name": "Hash join", "source": "Translate Ruby to Python: def hashJoin(table1, index1, table2, index2)\n  \n  h = table1.group_by {|s| s[index1]}\n  h.default = []\n  \n  table2.collect {|r|\n    h[r[index2]].collect {|s| [s, r]}\n  }.flatten(1)\nend\n\ntable1 = [[27, \"Jonah\"],\n          [18, \"Alan\"],\n          [28, \"Glory\"],\n          [18, \"Popeye\"],\n          [28, \"Alan\"]]\ntable2 = [[\"Jonah\", \"Whales\"],\n          [\"Jonah\", \"Spiders\"],\n          [\"Alan\", \"Ghosts\"],\n          [\"Alan\", \"Zombies\"],\n          [\"Glory\", \"Buffy\"]]\n\nhashJoin(table1, 1, table2, 0).each { |row| p row }\n", "target": "from collections import defaultdict\n\ndef hashJoin(table1, index1, table2, index2):\n    h = defaultdict(list)\n    \n    for s in table1:\n        h[s[index1]].append(s)\n    \n    return [(s, r) for r in table2 for s in h[r[index2]]]\n\ntable1 = [(27, \"Jonah\"),\n          (18, \"Alan\"),\n          (28, \"Glory\"),\n          (18, \"Popeye\"),\n          (28, \"Alan\")]\ntable2 = [(\"Jonah\", \"Whales\"),\n          (\"Jonah\", \"Spiders\"),\n          (\"Alan\", \"Ghosts\"),\n          (\"Alan\", \"Zombies\"),\n          (\"Glory\", \"Buffy\")]\n\nfor row in hashJoin(table1, 1, table2, 0):\n    print(row)\n"}
{"id": 389542, "name": "Largest palindrome product", "source": "Translate Ruby to Python: func largest_palindrome_product (n) {\n\n    for k in ((10**n - 1) `downto` 10**(n-1)) {\n        var t = Num(\"\n\n        t.divisors.each {|d|\n            if ((d.len == n) && ((t/d).len == n)) {\n                return (d, t/d)\n            }\n        }\n    }\n}\n\nfor n in (2..9) {\n    var (a,b) = largest_palindrome_product(n)\n    say \"Largest palindromic product of two \n}\n", "target": "\n\nT=[set([(0, 0)])]\n\ndef double(it):\n    for a, b in it:\n        yield a, b\n        yield b, a\n\ndef tails(n):\n    \n    if len(T)<=n:\n        l = set()\n        for i in range(10):\n            for j in range(i, 10):\n                I = i*10**(n-1)\n                J = j*10**(n-1)\n                it = tails(n-1)\n                if I!=J: it = double(it)\n                for t1, t2 in it:\n                    if ((I+t1)*(J+t2)+1)%10**n == 0:\n                        l.add((I+t1, J+t2))\n        T.append(l)\n    return T[n]\n\ndef largestPalindrome(n):\n    \n    m, tail = 0, n // 2\n    head = n - tail\n    up = 10**head\n    for L in range(1, 9*10**(head-1)+1):\n        \n        m = 0\n        sol = None\n        for i in range(1, L + 1):\n            lo = max(i, int(up - (up - L + 1)**2 / (up - i)) + 1)\n            hi = int(up - (up - L)**2 / (up - i))\n            for j in range(lo, hi + 1):\n                I = (up-i) * 10**tail\n                J = (up-j) * 10**tail\n                it = tails(tail)\n                if I!=J: it = double(it)\n                    for t1, t2 in it:\n                        val = (I + t1)*(J + t2)\n                        s = str(val)\n                        if s == s[::-1] and val>m:\n                            sol = (I + t1, J + t2)\n                            m = val\n\n        if m:\n            print(\"{:2d}\\t{:4d}\".format(n, m % 1337), sol, sol[0] * sol[1])\n            return m % 1337\n    return 0\n\nif __name__ == \"__main__\":\n    for k in range(1, 14):\n        largestPalindrome(k)\n"}
{"id": 389543, "name": "Permutations with repetitions", "source": "Translate Ruby to Python: rp = [1,2,3].repeated_permutation(2) \np rp.to_a \n\n\np rp.take_while{|(a, b)| a + b < 5}  \n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389544, "name": "Permutations with repetitions", "source": "Translate Ruby to Python: rp = [1,2,3].repeated_permutation(2) \np rp.to_a \n\n\np rp.take_while{|(a, b)| a + b < 5}  \n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389545, "name": "Audio alarm", "source": "Translate Ruby to Python: puts \"Enter a number of seconds:\"\nseconds = gets.chomp.to_i\nputs \"Enter a MP3 file to be played\"\nmp3filepath = File.dirname(__FILE__) + \"/\" + gets.chomp + \".mp3\"\nsleep(seconds)\npid = fork{ exec 'mpg123','-q', mp3filepath }\n", "target": "import time\nimport os\n\nseconds = input(\"Enter a number of seconds: \")\nsound = input(\"Enter an mp3 filename: \")\n\ntime.sleep(float(seconds))\nos.startfile(sound + \".mp3\")\n"}
{"id": 389546, "name": "Quadrat special primes", "source": "Translate Ruby to Python: require 'prime'\n\nres = [2]\n\nuntil res.last > 16000 do\n  res << (1..).detect{|n| (res.last + n**2).prime? } ** 2 + res.last\nend\n\nputs res[..-2].join(\" \")\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 2\n    j = 1\n    print(2, end = \" \");\n    while True:\n        while True:\n            if isPrime(p + j*j):\n                break\n            j += 1\n        p += j*j\n        if p > 16000:\n            break\n        print(p, end = \" \");\n        j = 1\n"}
{"id": 389547, "name": "Quadrat special primes", "source": "Translate Ruby to Python: require 'prime'\n\nres = [2]\n\nuntil res.last > 16000 do\n  res << (1..).detect{|n| (res.last + n**2).prime? } ** 2 + res.last\nend\n\nputs res[..-2].join(\" \")\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 2\n    j = 1\n    print(2, end = \" \");\n    while True:\n        while True:\n            if isPrime(p + j*j):\n                break\n            j += 1\n        p += j*j\n        if p > 16000:\n            break\n        print(p, end = \" \");\n        j = 1\n"}
{"id": 389548, "name": "Euclid-Mullin sequence", "source": "Translate Ruby to Python: func f(n) is cached {\n    return 2 if (n == 1)\n    lpf(1 + prod(1..^n, {|k| f(k) }))\n}\n\nsay f.map(1..16)\nsay f.map(17..27)\n", "target": "\n\nfrom primePy import primes\n\ndef euclid_mullin():\n    \n    total = 1\n    while True:\n        next_iter = primes.factor(total + 1)\n        total *= next_iter\n        yield next_iter\n\nGEN = euclid_mullin()\nprint('First 16 Euclid-Mullin numbers:', ', '.join(str(next(GEN)) for _ in range(16)))\n"}
{"id": 389549, "name": "Euclid-Mullin sequence", "source": "Translate Ruby to Python: func f(n) is cached {\n    return 2 if (n == 1)\n    lpf(1 + prod(1..^n, {|k| f(k) }))\n}\n\nsay f.map(1..16)\nsay f.map(17..27)\n", "target": "\n\nfrom primePy import primes\n\ndef euclid_mullin():\n    \n    total = 1\n    while True:\n        next_iter = primes.factor(total + 1)\n        total *= next_iter\n        yield next_iter\n\nGEN = euclid_mullin()\nprint('First 16 Euclid-Mullin numbers:', ', '.join(str(next(GEN)) for _ in range(16)))\n"}
{"id": 389550, "name": "Largest product in a grid", "source": "Translate Ruby to Python: gridstr =\n\"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\"\n\ngrid = gridstr.lines.map{|line| line.split.map(&:to_i) }\nhor_ver = grid.each + grid.transpose.each\nputs hor_ver.map{|line| line.each_cons(4).map{|slice| slice.inject(&:*) }.max}.max\n", "target": "\n\nfrom math import prod\n\ndef maxproduct(mat, length):\n    \n    nrow, ncol = len(mat), len(mat[0])\n    maxprod, maxrow, maxcol, arr = 0, [0, 0], [0, 0], [0]\n    for row in range(nrow):\n        for col in range(ncol):\n            row2, col2 = row + length, col + length\n            if row < nrow - length:\n                array = [r[col] for r in mat[row:row2]]\n                pro = prod(array)\n                if pro > maxprod:\n                    maxprod, maxrow, maxcol, arr = pro, [row, row2], col, array\n            if col < ncol - length:\n                pro = prod(mat[row][col:col2])\n                if pro > maxprod:\n                    maxprod, maxrow, maxcol, arr = pro, row, [col, col2], mat[row][col:col2]\n\n    print(f\"The max {length}-product is {maxprod}, product of {arr} at row {maxrow}, col {maxcol}.\")\n\nMATRIX = [\n    [ 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8],\n    [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0],\n    [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65],\n    [52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91],\n    [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],\n    [24, 47, 32, 60, 99,  3, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],\n    [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],\n    [67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21],\n    [24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],\n    [21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95],\n    [78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92],\n    [16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57],\n    [86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],\n    [19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40],\n    [ 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],\n    [88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],\n    [ 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36],\n    [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16],\n    [20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54],\n    [ 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48]\n]\n\nfor n in range(2, 6):\n    maxproduct(MATRIX, n)\n"}
{"id": 389551, "name": "Terminal control_Preserve screen", "source": "Translate Ruby to Python: print \"\\e[?1049h\\e[H\";\nsay \"Alternate buffer!\";\n\n3.downto(1).each { |i|\n    say \"Going back in: \n    Sys.sleep(1);\n}\n\nprint \"\\e[?1049l\";\n", "target": "\n\nimport time\n\nprint \"\\033[?1049h\\033[H\"\nprint \"Alternate buffer!\"\n\nfor i in xrange(5, 0, -1):\n    print \"Going back in:\", i\n    time.sleep(1)\n\nprint \"\\033[?1049l\"\n"}
{"id": 389552, "name": "Find largest left truncatable prime in a given base", "source": "Translate Ruby to Python: \n\n\n\n\nrequire 'prime'\nBASE = 3\nMAX = 500\nstems = Prime.each(BASE-1).to_a\n(1..MAX-1).each {|i|\n  print \"\n  t = []\n  b = BASE ** i\n  stems.each {|z|\n    (1..BASE-1).each {|n|\n      c = n*b+z\n      t.push(c) if c.prime?\n  }}\n  break if t.empty?\n  stems = t\n}\nputs \"The largest left truncatable prime \n", "target": "import random\n\ndef is_probable_prime(n,k):\n    \n    if n==0 or n==1:\n        return False\n    if n==2:\n        return True\n    if n % 2 == 0:\n        return False\n    s = 0\n    d = n-1\n\n    while True:\n        quotient, remainder = divmod(d, 2)\n        if remainder == 1:\n            break\n        s += 1\n        d = quotient\n\n    def try_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True \n \n    for i in range(k):\n        a = random.randrange(2, n)\n        if try_composite(a):\n            return False\n \n    return True \n    \n    \ndef largest_left_truncatable_prime(base):    \n    radix = 0\n    candidates = [0]\n    while True:\n        new_candidates=[]\n        multiplier = base**radix\n        for i in range(1,base):\n            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]\n        if len(new_candidates)==0:\n            return max(candidates)\n        candidates = new_candidates\n        radix += 1\n\nfor b in range(3,24):\n    print(\"%d:%d\\n\" % (b,largest_left_truncatable_prime(b)))\n"}
{"id": 389553, "name": "Speech synthesis", "source": "Translate Ruby to Python: module OperatingSystem\n  require 'rbconfig'\n  module_function\n  def operating_system\n    case RbConfig::CONFIG[\"host_os\"]\n    when /linux/i\n      :linux\n    when /cygwin|mswin|mingw|windows/i\n      :windows\n    when /darwin/i\n      :mac\n    when /solaris/i\n      :solaris\n    else\n      nil\n    end\n  end\n  def linux?;   operating_system == :linux;   end\n  def windows?; operating_system == :windows; end\n  def mac?;     operating_system == :mac;     end\nend\n", "target": "import pyttsx\n\nengine = pyttsx.init()\nengine.say(\"It was all a dream.\")\nengine.runAndWait()\n"}
{"id": 389554, "name": "Compare sorting algorithms' performance", "source": "Translate Ruby to Python: class Array\n  def radix_sort(base=10)       \n    ary = dup\n    rounds = (Math.log(ary.max)/Math.log(base)).ceil\n    rounds.times do |i|\n      buckets = Array.new(base){[]}\n      base_i = base**i\n      ary.each do |n|\n        digit = (n/base_i) % base\n        buckets[digit] << n\n      end\n      ary = buckets.flatten\n    end\n    ary\n  end\n  \n  def quick_sort\n    return self  if size <= 1\n    pivot = sample\n    g = group_by{|x| x<=>pivot}\n    g.default = []\n    g[-1].quick_sort + g[0] + g[1].quick_sort\n  end\n  \n  def shell_sort\n    inc = size / 2\n    while inc > 0\n      (inc...size).each do |i|\n        value = self[i]\n        while i >= inc and self[i - inc] > value\n          self[i] = self[i - inc]\n          i -= inc\n        end\n        self[i] = value\n      end\n      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)\n    end\n    self\n  end\n  \n  def insertion_sort\n    (1...size).each do |i|\n      value = self[i]\n      j = i - 1\n      while j >= 0 and self[j] > value\n        self[j+1] = self[j]\n        j -= 1\n      end\n      self[j+1] = value\n    end\n    self\n  end\n  \n  def bubble_sort\n    (1...size).each do |i|\n      (0...size-i).each do |j|\n        self[j], self[j+1] = self[j+1], self[j]  if self[j] > self[j+1]\n      end\n    end\n    self\n  end\nend\n\ndata_size = [1000, 10000, 100000, 1000000]\ndata = []\ndata_size.each do |size|\n  ary = *1..size\n  data << [ [1]*size, ary, ary.shuffle, ary.reverse ]\nend\ndata = data.transpose\n\ndata_type = [\"set to all ones\", \"ascending sequence\", \"randomly shuffled\", \"descending sequence\"]\nprint \"Array size:          \"\nputs data_size.map{|size| \"%9d\" % size}.join\n\ndata.each_with_index do |arys,i|\n  puts \"\\nData \n  [:sort, :radix_sort, :quick_sort, :shell_sort, :insertion_sort, :bubble_sort].each do |m|\n    printf \"%20s \", m\n    flag = true\n    arys.each do |ary|\n      if flag\n        t0 = Time.now\n        ary.dup.send(m)\n        printf \"  %7.3f\", (t1 = Time.now - t0)\n        flag = false  if t1 > 2\n      else\n        print \"   --.---\"\n      end\n    end\n    puts\n  end\nend\n", "target": "def builtinsort(x):\n    x.sort()\n\ndef partition(seq, pivot):\n   low, middle, up = [], [], []\n   for x in seq:\n       if x < pivot:\n           low.append(x)\n       elif x == pivot:\n           middle.append(x)\n       else:\n           up.append(x)\n   return low, middle, up\nimport random\ndef qsortranpart(seq):\n   size = len(seq)\n   if size < 2: return seq\n   low, middle, up = partition(seq, random.choice(seq))\n   return qsortranpart(low) + middle + qsortranpart(up)\n"}
{"id": 389555, "name": "24 game_Solve", "source": "Translate Ruby to Python: class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n  \n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n  \n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      \n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 \n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n\ndigits = ARGV.map do |arg| \n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have \n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found \n  puts solutions.sort\nend\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 389556, "name": "24 game_Solve", "source": "Translate Ruby to Python: class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n  \n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n  \n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      \n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 \n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n\ndigits = ARGV.map do |arg| \n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have \n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found \n  puts solutions.sort\nend\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 389557, "name": "Hough transform", "source": "Translate Ruby to Python: require 'mathn'\nrequire 'rubygems'\nrequire 'gd2'\ninclude GD2\n\ndef hough_transform(img)\n  mx, my = img.w*0.5, img.h*0.5\n  max_d = Math.sqrt(mx**2 + my**2)\n  min_d = max_d * -1\n  hough = Hash.new(0)\n  (0..img.w).each do |x|\n    puts \"\n    (0..img.h).each do |y|\n      if img.pixel2color(img.get_pixel(x,y)).g > 32\n        (0...180).each do |a|\n          rad = a * (Math::PI / 180.0)\n          d = (x-mx) * Math.cos(rad) + (y-my) * Math.sin(rad)\n          hough[\"\n        end\n      end\n    end\n  end\n  heat = GD2::Image.import 'heatmap.png'\n  out = GD2::Image::TrueColor.new(180,max_d*2)\n  max = hough.values.max\n  p max\n  hough.each_pair do |k,v|\n    a,d = k.split('_').map(&:to_i)\n    c = (v / max) * 255\n    c = heat.get_pixel(c,0)\n    out.set_pixel(a, max_d + d, c)\n  end\n  out\nend\n", "target": "from math import hypot, pi, cos, sin\nfrom PIL import Image\n\n\ndef hough(im, ntx=460, mry=360):\n    \"Calculate Hough transform.\"\n    pim = im.load()\n    nimx, mimy = im.size\n    mry = int(mry/2)*2          \n    him = Image.new(\"L\", (ntx, mry), 255)\n    phim = him.load()\n\n    rmax = hypot(nimx, mimy)\n    dr = rmax / (mry/2)\n    dth = pi / ntx\n\n    for jx in xrange(nimx):\n        for iy in xrange(mimy):\n            col = pim[jx, iy]\n            if col == 255: continue\n            for jtx in xrange(ntx):\n                th = dth * jtx\n                r = jx*cos(th) + iy*sin(th)\n                iry = mry/2 + int(r/dr+0.5)\n                phim[jtx, iry] -= 1\n    return him\n\n\ndef test():\n    \"Test Hough transform with pentagon.\"\n    im = Image.open(\"pentagon.png\").convert(\"L\")\n    him = hough(im)\n    him.save(\"ho5.bmp\")\n\n\nif __name__ == \"__main__\": test()\n"}
{"id": 389558, "name": "First class environments", "source": "Translate Ruby to Python: \nenvs = (1..12).map do |n|\n  Object.new.instance_eval {@n = n; @cnt = 0; self}\nend\n\n\nuntil envs.all? {|e| e.instance_eval{@n} == 1}\n  envs.each do |e|\n    e.instance_eval do          \n      printf \"%4s\", @n\n      if @n > 1\n        @cnt += 1               \n        @n = if @n.odd?         \n               @n * 3 + 1\n             else\n               @n / 2\n             end\n      end\n    end\n  end\n  puts\nend\nputs '=' * 48\nenvs.each do |e|                \n  e.instance_eval do\n    printf \"%4s\", @cnt          \n  end\nend\nputs\n", "target": "environments = [{'cnt':0, 'seq':i+1} for i in range(12)]\n\ncode = \n\nwhile any(env['seq'] > 1 for env in environments):\n    for env in environments:\n        exec(code, globals(), env)\n    print()\n\nprint('Counts')\nfor env in environments:\n    print('% 4d' % env['cnt'], end='')\nprint()\n"}
{"id": 389559, "name": "Tonelli-Shanks algorithm", "source": "Translate Ruby to Python: func tonelli(n, p) {\n    legendre(n, p) == 1 || die \"not a square (mod p)\"\n    var q = p-1\n    var s = valuation(q, 2)\n    s == 1 ? return(powmod(n, (p + 1) >> 2, p)) : (q >>= s)\n    var c = powmod(2 ..^ p -> first {|z| legendre(z, p) == -1}, q, p)\n    var r = powmod(n, (q + 1) >> 1, p)\n    var t = powmod(n, q, p)\n    var m = s\n    var t2 = 0\n    while (!p.divides(t - 1)) {\n        t2 = ((t * t) % p)\n        var b\n        for i in (1 ..^ m) {\n            if (p.divides(t2 - 1)) {\n                b = powmod(c, 1 << (m - i - 1), p)\n                m = i\n                break\n            }\n            t2 = ((t2 * t2) % p)\n        }\n\n        r = ((r * b) % p)\n        c = ((b * b) % p)\n        t = ((t * c) % p)\n    }\n    return r\n}\n\nvar tests = [\n    [10, 13], [56, 101], [1030, 10009], [44402, 100049],\n    [665820697, 1000000009], [881398088036, 1000000000039],\n    [41660815127637347468140745042827704103445750172002, 10**50 + 577],\n]\n\nfor n,p in tests {\n    var r = tonelli(n, p)\n    assert((r*r - n) % p == 0)\n    say \"Roots of \n}\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 389560, "name": "Tonelli-Shanks algorithm", "source": "Translate Ruby to Python: func tonelli(n, p) {\n    legendre(n, p) == 1 || die \"not a square (mod p)\"\n    var q = p-1\n    var s = valuation(q, 2)\n    s == 1 ? return(powmod(n, (p + 1) >> 2, p)) : (q >>= s)\n    var c = powmod(2 ..^ p -> first {|z| legendre(z, p) == -1}, q, p)\n    var r = powmod(n, (q + 1) >> 1, p)\n    var t = powmod(n, q, p)\n    var m = s\n    var t2 = 0\n    while (!p.divides(t - 1)) {\n        t2 = ((t * t) % p)\n        var b\n        for i in (1 ..^ m) {\n            if (p.divides(t2 - 1)) {\n                b = powmod(c, 1 << (m - i - 1), p)\n                m = i\n                break\n            }\n            t2 = ((t2 * t2) % p)\n        }\n\n        r = ((r * b) % p)\n        c = ((b * b) % p)\n        t = ((t * c) % p)\n    }\n    return r\n}\n\nvar tests = [\n    [10, 13], [56, 101], [1030, 10009], [44402, 100049],\n    [665820697, 1000000009], [881398088036, 1000000000039],\n    [41660815127637347468140745042827704103445750172002, 10**50 + 577],\n]\n\nfor n,p in tests {\n    var r = tonelli(n, p)\n    assert((r*r - n) % p == 0)\n    say \"Roots of \n}\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 389561, "name": "Truth table", "source": "Translate Ruby to Python: loop do\n  print \"\\ninput a boolean expression (e.g. 'a & b'): \"\n  expr = gets.strip.downcase \n  break if expr.empty?\n\n  vars = expr.scan(/\\p{Alpha}+/)\n  if vars.empty?\n    puts \"no variables detected in your boolean expression\"\n    next\n  end\n\n  vars.each {|v| print \"\n  puts \"| \n\n  prefix = []\n  suffix = []\n  vars.each do |v|\n    prefix << \"[false, true].each do |\n    suffix << \"end\"\n  end\n\n  body = vars.inject(\"puts \") {|str, v| str + \"\n  body += '\"| \" + eval(expr).to_s'\n\n  eval (prefix + [body] + suffix).join(\"\\n\")\nend\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 389562, "name": "Truth table", "source": "Translate Ruby to Python: loop do\n  print \"\\ninput a boolean expression (e.g. 'a & b'): \"\n  expr = gets.strip.downcase \n  break if expr.empty?\n\n  vars = expr.scan(/\\p{Alpha}+/)\n  if vars.empty?\n    puts \"no variables detected in your boolean expression\"\n    next\n  end\n\n  vars.each {|v| print \"\n  puts \"| \n\n  prefix = []\n  suffix = []\n  vars.each do |v|\n    prefix << \"[false, true].each do |\n    suffix << \"end\"\n  end\n\n  body = vars.inject(\"puts \") {|str, v| str + \"\n  body += '\"| \" + eval(expr).to_s'\n\n  eval (prefix + [body] + suffix).join(\"\\n\")\nend\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 389563, "name": "Set of real numbers", "source": "Translate Ruby to Python: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 389564, "name": "Set of real numbers", "source": "Translate Ruby to Python: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 389565, "name": "State name puzzle", "source": "Translate Ruby to Python: require 'set'\n\n\nPrimes = [ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n          43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\nStates = [\n    \"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\", \"Colorado\",\n    \"Connecticut\", \"Delaware\", \"Florida\", \"Georgia\", \"Hawaii\", \"Idaho\",\n    \"Illinois\", \"Indiana\", \"Iowa\", \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\",\n    \"Maryland\", \"Massachusetts\", \"Michigan\", \"Minnesota\", \"Mississippi\",\n    \"Missouri\", \"Montana\", \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\",\n    \"New Mexico\", \"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\",\n    \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n    \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n    \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\"\n]\n\ndef print_answer(states)\n  \n  goedel = lambda {|str| str.chars.map {|c| Primes[c.ord - 65]}.reduce(:*)}\n  pairs = Hash.new {|h,k| h[k] = Array.new}\n  map = states.uniq.map {|state| [state, goedel[state.upcase.delete(\"^A-Z\")]]}\n  map.combination(2) {|(s1,g1), (s2,g2)| pairs[g1 * g2] << [s1, s2]}\n\n  \n  result = []\n  pairs.values.select {|val| val.length > 1}.each do |list_of_pairs|\n    list_of_pairs.combination(2) do |pair1, pair2|\n      if Set[*pair1, *pair2].length == 4\n        result << [pair1, pair2]\n      end\n    end\n  end\n\n  \n  result.each_with_index do |(pair1, pair2), i| \n    puts \"%d\\t%s\\t%s\" % [i+1, pair1.join(', '), pair2.join(', ')]\n  end\nend\n\nputs \"real states only\"\nprint_answer(States)\nputs \"\"\nputs \"with fictional states\"\nprint_answer(States + [\"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\"])\n", "target": "from collections import defaultdict\n\nstates = [\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n\"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n\"Georgia\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\", \"Kansas\",\n\"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n\"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n\"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n\"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n\"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n\"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n\"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n\n\n]\n\nstates = sorted(set(states))\n\nsmap = defaultdict(list)\nfor i, s1 in enumerate(states[:-1]):\n    for s2 in states[i + 1:]:\n        smap[\"\".join(sorted(s1 + s2))].append(s1 + \" + \" + s2)\n\nfor pairs in sorted(smap.itervalues()):\n    if len(pairs) > 1:\n        print \" = \".join(pairs)\n"}
{"id": 389566, "name": "Super-d numbers", "source": "Translate Ruby to Python: (2..8).each do |d|\n  rep = d.to_s * d\n  print \"\n  puts (2..).lazy.select{|n| (d * n**d).to_s.include?(rep) }.first(10).join(\", \")\nend\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 389567, "name": "Super-d numbers", "source": "Translate Ruby to Python: (2..8).each do |d|\n  rep = d.to_s * d\n  print \"\n  puts (2..).lazy.select{|n| (d * n**d).to_s.include?(rep) }.first(10).join(\", \")\nend\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 389568, "name": "Padovan sequence", "source": "Translate Ruby to Python: padovan = Enumerator.new do |y|\n  ar = [1, 1, 1]\n  loop do\n    ar << ar.first(2).sum\n    y  << ar.shift\n  end\nend\n\nP, S = 1.324717957244746025960908854, 1.0453567932525329623\ndef padovan_f(n) = (P**(n-1) / S + 0.5).floor\n  \nputs \"Recurrence Padovan: \nputs \"Floor function:     \n\nn = 63\nbool =  (0...n).map{|n| padovan_f(n)} == padovan.take(n)\nputs \"Recurrence and floor function are equal upto \nputs\n  \ndef l_system(axiom = \"A\", rules = {\"A\" => \"B\", \"B\" => \"C\", \"C\" => \"AB\"} )\n  return enum_for(__method__,  axiom, rules) unless block_given? \n  loop do\n    yield axiom \n    axiom = axiom.chars.map{|c| rules[c] }.join\n  end\nend\n  \nputs \"First 10 elements of L-system: \nn = 32\nbool = l_system.take(n).map(&:size) == padovan.take(n)\nputs \"Sizes of first \n", "target": "from math import floor\nfrom collections import deque\nfrom typing import Dict, Generator\n\n\ndef padovan_r() -> Generator[int, None, None]:\n    last = deque([1, 1, 1], 4)\n    while True:\n        last.append(last[-2] + last[-3])\n        yield last.popleft()\n\n_p, _s = 1.324717957244746025960908854, 1.0453567932525329623\n\ndef padovan_f(n: int) -> int:\n    return floor(_p**(n-1) / _s + .5)\n\ndef padovan_l(start: str='A',\n             rules: Dict[str, str]=dict(A='B', B='C', C='AB')\n             ) -> Generator[str, None, None]:\n    axiom = start\n    while True:\n        yield axiom\n        axiom = ''.join(rules[ch] for ch in axiom)\n\n\nif __name__ == \"__main__\":\n    from itertools import islice\n\n    print(\"The first twenty terms of the sequence.\")\n    print(str([padovan_f(n) for n in range(20)])[1:-1])\n\n    r_generator = padovan_r()\n    if all(next(r_generator) == padovan_f(n) for n in range(64)):\n        print(\"\\nThe recurrence and floor based algorithms match to n=63 .\")\n    else:\n        print(\"\\nThe recurrence and floor based algorithms DIFFER!\")\n\n    print(\"\\nThe first 10 L-system string-lengths and strings\")\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    print('\\n'.join(f\"  {len(string):3} {repr(string)}\"\n                    for string in islice(l_generator, 10)))\n\n    r_generator = padovan_r()\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)\n           for n in range(32)):\n        print(\"\\nThe L-system, recurrence and floor based algorithms match to n=31 .\")\n    else:\n        print(\"\\nThe L-system, recurrence and floor based algorithms DIFFER!\")\n"}
{"id": 389569, "name": "Monads_Maybe monad", "source": "Translate Ruby to Python: class Maybe\n  def initialize(value)\n    @value = value\n  end\n\n  def map\n    if @value.nil?\n      self\n    else\n      Maybe.new(yield @value)\n    end\n  end\nend\n\nMaybe.new(3).map { |n| 2*n }.map { |n| n+1 }\n\n\nMaybe.new(nil).map { |n| 2*n }.map { |n| n+1 }\n\n\nMaybe.new(3).map { |n| nil }.map { |n| n+1 }\n\n\n\n\nclass Maybe\n  class << self\n    alias :unit :new\n  end\n  \n  def initialize(value)\n    @value = value\n  end\n\n  def bind\n    if @value.nil?\n      self\n    else\n      yield @value\n    end\n  end\nend\n\nMaybe.unit(3).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }\n\n\nMaybe.unit(nil).bind { |n| Maybe.unit(2*n) }.bind { |n| Maybe.unit(n+1) }\n\n", "target": "\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Maybe(Generic[T]):\n    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):\n        if isinstance(value, Maybe):\n            self.value: Optional[T] = value.value\n        else:\n            self.value = value\n\n    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):\n        return self.bind(func)\n\n    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:\n        return func(self.value)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}({self.value!r})\"\n\n\ndef plus_one(value: Optional[int]) -> Maybe[int]:\n    if value is not None:\n        return Maybe[int](value + 1)\n    return Maybe[int](None)\n\n\ndef currency(value: Optional[int]) -> Maybe[str]:\n    if value is not None:\n        return Maybe[str](f\"${value}.00\")\n    return Maybe[str](None)\n\n\nif __name__ == \"__main__\":\n    test_cases = [1, 99, None, 4]\n\n    for case in test_cases:\n        m_int = Maybe[int](case)\n        result = m_int >> plus_one >> currency\n        \n        \n        print(f\"{str(case):<4} -> {result}\")\n"}
{"id": 389570, "name": "Monads_List monad", "source": "Translate Ruby to Python: class Array\n  def bind(f)\n    flat_map(&f)\n  end\n  def self.unit(*args)\n    args\n  end\n  \n  \n  def self.lift(f)\n    -> e { self.unit(f[e]) }\n  end\nend\n\ninc = -> n { n + 1 }\nstr = -> n { n.to_s }\nlisty_inc = Array.lift(inc)\nlisty_str = Array.lift(str)\n\nArray.unit(3,4,5).bind(listy_inc).bind(listy_str) \n\n\n\n\n\n\ndoub = -> n { 2*n }\nlisty_doub = Array.lift(doub)\n[3,4,5].bind(listy_inc).bind(listy_doub) \n\n\n\ncomp = -> f, g {-> x {f[g[x]]}}\n[3,4,5].bind(comp[listy_doub, listy_inc]) \n\n\nclass Array\n  def bind_comp(f, g)\n    bind(g).bind(f)\n  end\nend\n\n[3,4,5].bind_comp(listy_doub, listy_inc) \n", "target": "\nfrom __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )\n"}
{"id": 389571, "name": "Textonyms", "source": "Translate Ruby to Python: CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nNUMS  = \"22233344455566677778889999\" * 2\ndict  = \"unixdict.txt\"\n\ntextonyms = File.open(dict){|f| f.map(&:chomp).group_by {|word| word.tr(CHARS, NUMS) } }\n\nputs \"There are \nThey require \n\n\nputs \"\\n25287876746242: \n", "target": "from collections import defaultdict\nimport urllib.request\n\nCH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}\nURL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\n\n\ndef getwords(url):\n return urllib.request.urlopen(url).read().decode(\"utf-8\").lower().split()\n\ndef mapnum2words(words):\n    number2words = defaultdict(list)\n    reject = 0\n    for word in words:\n        try:\n            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)\n        except KeyError:\n            \n            reject += 1\n    return dict(number2words), reject\n\ndef interactiveconversions():\n    global inp, ch, num\n    while True:\n        inp = input(\"\\nType a number or a word to get the translation and textonyms: \").strip().lower()\n        if inp:\n            if all(ch in '23456789' for ch in inp):\n                if inp in num2words:\n                    print(\"  Number {0} has the following textonyms in the dictionary: {1}\".format(inp, ', '.join(\n                        num2words[inp])))\n                else:\n                    print(\"  Number {0} has no textonyms in the dictionary.\".format(inp))\n            elif all(ch in CH2NUM for ch in inp):\n                num = ''.join(CH2NUM[ch] for ch in inp)\n                print(\"  Word {0} is{1} in the dictionary and is number {2} with textonyms: {3}\".format(\n                    inp, ('' if inp in wordset else \"n't\"), num, ', '.join(num2words[num])))\n            else:\n                print(\"  I don't understand %r\" % inp)\n        else:\n            print(\"Thank you\")\n            break\n\n\nif __name__ == '__main__':\n    words = getwords(URL)\n    print(\"Read %i words from %r\" % (len(words), URL))\n    wordset = set(words)\n    num2words, reject = mapnum2words(words)\n    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)\n    maxwordpernum = max(len(values) for values in num2words.values())\n    print(.format(len(words) - reject, URL, len(num2words), morethan1word))\n\n    print(\"\\nThe numbers mapping to the most words map to %i words each:\" % maxwordpernum)\n    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)\n    for num, wrds in maxwpn:\n        print(\"  %s maps to: %s\" % (num, ', '.join(wrds)))\n\n    interactiveconversions()\n"}
{"id": 389572, "name": "Minesweeper game", "source": "Translate Ruby to Python: puts <<EOS\n    Minesweeper game.\n\n    There is an n by m grid that has a random number of between 20% to 60%\n    of randomly hidden mines that need to be found. \n\n    Positions in the grid are modified by entering their coordinates\n    where the first coordinate is horizontal in the grid and the second\n    vertical. The top left of the grid is position 1,1; the bottom right is\n    at n,m.\n\n    * The total number of mines to be found is shown at the beginning of the\n    game.\n    * Each mine occupies a single grid point, and its position is initially\n    unknown to the player\n    * The grid is shown as a rectangle of characters between moves.\n    * You are initially shown all grids as obscured, by a single dot '.'\n    * You may mark what you think is the position of a mine which will show\n    as a '?'\n    * You can mark what you think is free space by entering its coordinates.\n   \u00a0:*  If the point is free space then it is cleared, as are any adjacent\n    points that are also free space- this is repeated recursively for\n    subsequent adjacent free points unless that point is marked as a mine\n    or is a mine.\n   \u00a0::*   Points marked as a mine show as a '?'.\n   \u00a0::*   Other free points show as an integer count of the number of adjacent\n    true mines in its immediate neighbourhood, or as a single space ' ' if the\n    free point is not adjacent to any true mines.\n    * Of course you loose if you try to clear space that starts on a mine.\n    * You win when you have correctly identified all mines.\n\n\n    When prompted you may:\n        Toggle where you think a mine is at position x, y:\n          m <x> <y>\n        Clear the grid starting at position x, y (and print the result):\n          c <x> <y>\n        Print the grid so far:\n          p\n        Quit\n          q\n    Resigning will first show the grid with an 'N' for unfound true mines, a\n    'Y' for found true mines and a '?' for where you marked clear space as a\n    mine\nEOS\n\nWIDTH, HEIGHT = 6, 4\nPCT = 0.15\nNUM_MINES = (WIDTH * HEIGHT * PCT).round\n\ndef create_mines sx, sy\n  arr = Array.new(WIDTH) { Array.new(HEIGHT, false) }\n  NUM_MINES.times do\n    x, y = rand(WIDTH), rand(HEIGHT)\n    \n    redo if arr[x][y] or (x == sx and y == sy)\n    arr[x][y] = true\n  end\n  arr\nend\n\ndef num_marks\n  $screen.inject(0) { |sum, row| sum + row.count(\"?\") }\nend\n\ndef show_grid revealed = false\n  if revealed\n    puts $mines.transpose.map { |row| row.map { |cell| cell ? \"*\" : \" \" }.join(\" \") }\n  else\n    puts \"Grid has \n    puts $screen.transpose.map{ |row| row.join(\" \") }\n  end\nend\n\nSURROUND = [-1,0,1].product([-1,0,1]) - [[0,0]]     \ndef surrounding x, y\n  \n  SURROUND.each do |dx, dy|\n    \n    yield(x+dx, y+dy) if (0...WIDTH).cover?(x+dx) and (0...HEIGHT).cover?(y+dy)\n  end\nend\n\ndef clear_space x, y\n  return unless $screen[x][y] == \".\"\n  \n  count = 0\n  surrounding(x, y) { |px, py| count += 1 if $mines[px][py] }\n  if count == 0\n    $screen[x][y] = \" \"\n    surrounding(x, y) { |px, py| clear_space px, py }\n  else\n    $screen[x][y] = count.to_s\n  end\nend\n\ndef victory?\n  return false if $mines.nil?  \n  return false if num_marks != NUM_MINES\n  mines_left = NUM_MINES\n  WIDTH.times do |x|\n    HEIGHT.times do |y|\n      mines_left -= 1 if $mines[x][y] and $screen[x][y] == \"?\"\n    end\n  end\n  \n  mines_left == 0\nend\n\ndef check_input x, y\n  x, y = x.to_i - 1, y.to_i - 1\n  [x, y] if (0...WIDTH).cover?(x) and (0...HEIGHT).cover?(y)\nend\n\n$mines = nil\n$screen = Array.new(WIDTH) { Array.new(HEIGHT, \".\") }\n\nputs \"Welcome to Minesweeper!\"\nshow_grid\n\nloop do\n  print \"> \"\n  action = gets.chomp.downcase\n  \n  case action\n  when \"quit\", \"exit\", \"x\", \"q\"\n    puts \"Bye!\"\n    break\n  when /^m (\\d+) (\\d+)$/\n    \n    x, y = check_input $1, $2\n    next unless x\n    if $screen[x][y] == \".\"\n      \n      $screen[x][y] = \"?\"\n      if victory?\n        show_grid\n        puts \"You win!\"\n        break\n      end\n    elsif $screen[x][y] == \"?\"\n      \n      $screen[x][y] = \".\"\n    end\n    show_grid\n  when /^c (\\d+) (\\d+)$/\n    x, y = check_input $1, $2\n    next unless x\n    $mines ||= create_mines(x, y)\n    if $mines[x][y]\n      puts \"You hit a mine!\"\n      show_grid true\n      break\n    else\n      clear_space x, y\n      show_grid\n      if victory?\n        puts \"You win!\"\n        break\n      end\n    end\n  when \"p\"\n    show_grid\n  end\nend\n", "target": "\n\n\ngridsize  = (6, 4)\nminerange = (0.2, 0.6)\n\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\nfrom itertools import product\nfrom pprint import pprint as pp\n\n\ndef gridandmines(gridsize=gridsize, minerange=minerange):\n    xgrid, ygrid = gridsize\n    minmines, maxmines = minerange\n    minecount = xgrid * ygrid    \n    minecount = random.randint(int(minecount*minmines), int(minecount*maxmines))\n    grid = set(product(range(xgrid), range(ygrid)))\n    mines = set(random.sample(grid, minecount))\n    show = {xy:'.' for xy in grid}\n    return grid, mines, show\n\ndef printgrid(show, gridsize=gridsize):\n    xgrid, ygrid = gridsize\n    grid = '\\n'.join(''.join(show[(x,y)] for x in range(xgrid))\n                     for y in range(ygrid))\n    print( grid )\n\ndef resign(showgrid, mines, markedmines):\n    for m in mines:\n        showgrid[m] = 'Y' if m in markedmines else 'N'\n\ndef clear(x,y, showgrid, grid, mines, markedmines):\n    if showgrid[(x, y)] == '.':\n        xychar = str(sum(1\n                         for xx in (x-1, x, x+1)\n                         for yy in (y-1, y, y+1)\n                         if (xx, yy) in mines ))\n        if xychar == '0': xychar = '.'\n        showgrid[(x,y)] = xychar\n        for xx in (x-1, x, x+1):\n            for yy in (y-1, y, y+1):\n                xxyy = (xx, yy)\n                if ( xxyy != (x, y)\n                     and xxyy in grid\n                     and xxyy not in mines | markedmines ):\n                    clear(xx, yy, showgrid, grid, mines, markedmines)\n\nif __name__ == '__main__':\n    grid, mines, showgrid = gridandmines()\n    markedmines = set([])\n    print( __doc__ )\n    print( '\\nThere are %i true mines of fixed position in the grid\\n' % len(mines) )\n    printgrid(showgrid)\n    while markedmines != mines:\n        inp = raw_input('m x y/c x y/p/r: ').strip().split()\n        if inp:\n            if inp[0] == 'm':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in markedmines:\n                    markedmines.remove((x,y))\n                    showgrid[(x,y)] = '.'\n                else:\n                    markedmines.add((x,y))\n                    showgrid[(x,y)] = '?'\n            elif inp[0] == 'p':\n                printgrid(showgrid)\n            elif inp[0] == 'c':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in mines | markedmines:\n                    print( '\\nKLABOOM!! You hit a mine.\\n' )\n                    resign(showgrid, mines, markedmines)\n                    printgrid(showgrid)\n                    break\n                clear(x,y, showgrid, grid, mines, markedmines)\n                printgrid(showgrid)\n            elif inp[0] == 'r':\n                print( '\\nResigning!\\n' )\n                resign(showgrid, mines, markedmines)\n                printgrid(showgrid)\n                break\n    \n    print( '\\nYou got %i and missed %i of the %i mines'\n           % (len(mines.intersection(markedmines)),\n              len(markedmines.difference(mines)),\n              len(mines)) )\n"}
{"id": 389573, "name": "Church numerals", "source": "Translate Ruby to Python: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389574, "name": "Church numerals", "source": "Translate Ruby to Python: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389575, "name": "Reflection_List methods", "source": "Translate Ruby to Python: \nclass Super\n  CLASSNAME = 'super'\n  \n  def initialize(name)\n    @name = name\n    def self.superOwn\n      'super owned'\n    end\n  end\n  \n  def to_s\n    \"Super(\n  end\n  \n  def doSup\n    'did super stuff'\n  end\n  \n  def self.superClassStuff\n    'did super class stuff'\n  end\n  \n  protected\n  def protSup\n    \"Super's protected\"\n  end\n  \n  private\n  def privSup\n    \"Super's private\"\n  end\nend\n\nmodule Other\n  def otherStuff\n    'did other stuff'\n  end\nend\n\nclass Sub < Super\n  CLASSNAME = 'sub'\n  attr_reader :dynamic\n  \n  include Other\n  \n  def initialize(name, *args)\n    super(name)\n    @rest = args;\n    @dynamic = {}\n    def self.subOwn\n      'sub owned'\n    end\n  end\n  \n  def methods(regular=true)\n    super + @dynamic.keys\n  end\n  \n  def method_missing(name, *args, &block)\n    return super unless @dynamic.member?(name)\n    method = @dynamic[name]\n    if method.arity > 0\n      if method.parameters[0][1] == :self\n        args.unshift(self)\n      end\n      if method.lambda?\n        \n        args += args + [nil] * [method.arity - args.length, 0].max\n        \n        if method.parameters[-1][0] != :rest\n          args = args[0,method.arity]\n        end\n      end\n      method.call(*args)\n    else\n      method.call\n    end\n  end\n  \n  def public_methods(all=true)\n    super + @dynamic.keys\n  end\n  \n  def respond_to?(symbol, include_all=false)\n    @dynamic.member?(symbol) || super\n  end\n  \n  def to_s\n    \"Sub(\n  end\n  \n  def doSub\n    'did sub stuff'\n  end\n  \n  def self.subClassStuff\n    'did sub class stuff'\n  end\n  \n  protected\n  def protSub\n    \"Sub's protected\"\n  end\n  \n  private\n  def privSub\n    \"Sub's private\"\n  end\nend\n\nsup = Super.new('sup')\nsub = Sub.new('sub', 0, 'I', 'two')\nsub.dynamic[:incr] = proc {|i| i+1}\n\np sub.public_methods(false)\n\n\np sub.methods - Object.methods\n\n\np sub.public_methods - Object.public_methods\n\n\np sub.methods - sup.methods\n\n\n\np sub.methods(false)\n\np sub.singleton_methods\n\n", "target": "import inspect\n\n\nclass Super(object):\n  def __init__(self, name):\n    self.name = name\n  \n  def __str__(self):\n    return \"Super(%s)\" % (self.name,)\n  \n  def doSup(self):\n    return 'did super stuff'\n  \n  @classmethod\n  def cls(cls):\n    return 'cls method (in sup)'\n  \n  @classmethod\n  def supCls(cls):\n    return 'Super method'\n  \n  @staticmethod\n  def supStatic():\n    return 'static method'\n\nclass Other(object):\n  def otherMethod(self):\n    return 'other method'\n\nclass Sub(Other, Super):\n  def __init__(self, name, *args):\n    super(Sub, self).__init__(name);\n    self.rest = args;\n    self.methods = {}\n  \n  def __dir__(self):\n    return list(set( \\\n        sum([dir(base) for base in type(self).__bases__], []) \\\n        + type(self).__dict__.keys() \\\n        + self.__dict__.keys() \\\n        + self.methods.keys() \\\n      ))\n  \n  def __getattr__(self, name):\n    if name in self.methods:\n      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:\n        if self.methods[name].__code__.co_varnames[0] == 'self':\n          return self.methods[name].__get__(self, type(self))\n        if self.methods[name].__code__.co_varnames[0] == 'cls':\n          return self.methods[name].__get__(type(self), type)\n      return self.methods[name]\n    raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n  \n  def __str__(self):\n    return \"Sub(%s)\" % self.name\n  \n  def doSub():\n    return 'did sub stuff'\n  \n  @classmethod\n  def cls(cls):\n    return 'cls method (in Sub)'\n  \n  @classmethod\n  def subCls(cls):\n    return 'Sub method'\n  \n  @staticmethod\n  def subStatic():\n    return 'Sub method'\n\nsup = Super('sup')\nsub = Sub('sub', 0, 'I', 'two')\nsub.methods['incr'] = lambda x: x+1\nsub.methods['strs'] = lambda self, x: str(self) * x\n\n\n[method for method in dir(sub) if callable(getattr(sub, method))]\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]\n\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]\n\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]\n\n\n\ninspect.getmembers(sub, predicate=inspect.ismethod)\n\nmap(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))\n\n"}
{"id": 389576, "name": "Send an unknown method call", "source": "Translate Ruby to Python: class Example\n  def foo\n    42\n  end\n  def bar(arg1, arg2, &block)\n    block.call arg1, arg2\n  end\nend\n\nsymbol = :foo\nExample.new.send symbol                         \nExample.new.send( :bar, 1, 2 ) { |x,y| x+y }    \nargs = [1, 2]\nExample.new.send( \"bar\", *args ) { |x,y| x+y }  \n", "target": "class Example(object):\n     def foo(self, x):\n             return 42 + x\n\nname = \"foo\"\ngetattr(Example(), name)(5)      \n"}
{"id": 389577, "name": "Topic variable", "source": "Translate Ruby to Python: while DATA.gets     \n  print             \nend\n__END__\nThis is line one\nThis is line two\nThis is line three\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 389578, "name": "Topic variable", "source": "Translate Ruby to Python: while DATA.gets     \n  print             \nend\n__END__\nThis is line one\nThis is line two\nThis is line three\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 389579, "name": "Bitcoin_public point to address", "source": "Translate Ruby to Python: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nX = '50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352'\nY = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'\nn = '00'+Digest::RMD160.hexdigest(Digest::SHA256.digest(convert('04'+X+Y)))\nn+= Digest::SHA256.hexdigest(Digest::SHA256.digest(convert(n)))[0,8]\nG = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nn,res = n.hex,''\nwhile n > 0 do\n  n,ng = n.divmod(58)\n  res << G[ng]\nend\nputs res.reverse\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 389580, "name": "Bitcoin_public point to address", "source": "Translate Ruby to Python: \n\n\n\nrequire 'digest/sha2'\ndef convert g\n  i,e = '',[]\n  (0...g.length/2).each{|n| e[n] = g[n+=n]+g[n+1]; i+='H2'}\n  e.pack(i)\nend\nX = '50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352'\nY = '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'\nn = '00'+Digest::RMD160.hexdigest(Digest::SHA256.digest(convert('04'+X+Y)))\nn+= Digest::SHA256.hexdigest(Digest::SHA256.digest(convert(n)))[0,8]\nG = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nn,res = n.hex,''\nwhile n > 0 do\n  n,ng = n.divmod(58)\n  res << G[ng]\nend\nputs res.reverse\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 389581, "name": "Canonicalize CIDR", "source": "Translate Ruby to Python: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 389582, "name": "Canonicalize CIDR", "source": "Translate Ruby to Python: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 389583, "name": "Sequence of primorial primes", "source": "Translate Ruby to Python: \n\nrequire 'prime' \nrequire 'openssl' \n \ni, urutan, primorial_number = 1, 1, OpenSSL::BN.new(1)\nstart = Time.now\nprime_array = Prime.first (500)\n\nuntil urutan > 20\n  primorial_number *= prime_array[i-1] \n  if (primorial_number - 1).prime_fasttest? || (primorial_number + 1).prime_fasttest?\n    puts \"\n    urutan += 1\n  end \n  i += 1\nend\n", "target": "import pyprimes\n\ndef primorial_prime(_pmax=500):\n    isprime = pyprimes.isprime\n    n, primo = 0, 1\n    for prime in pyprimes.nprimes(_pmax):\n        n, primo = n+1, primo * prime\n        if isprime(primo-1) or isprime(primo+1):\n            yield n\n        \nif __name__ == '__main__':\n    \n    pyprimes.warn_probably = False  \n    for i, n in zip(range(20), primorial_prime()):\n        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))\n"}
{"id": 389584, "name": "Combinations and permutations", "source": "Translate Ruby to Python: require \"big\"\ninclude Math\n \nstruct Int\n \n  def permutation(k)\n    (self-k+1..self).product(1.to_big_i)\n  end\n \n  def combination(k)\n    self.permutation(k) // (1..k).product(1.to_big_i)\n  end\n \n  def big_permutation(k)\n    exp(lgamma_plus(self) - lgamma_plus(self-k)) \n  end\n \n  def big_combination(k)\n    exp( lgamma_plus(self) - lgamma_plus(self - k) - lgamma_plus(k))\n  end\n \n  private def lgamma_plus(n)\n    lgamma(n+1)  \n  end\n \nend\n\np 12.permutation(9)               \np 12.big_permutation(9)           \np 60.combination(53)              \np 145.big_permutation(133)        \np 900.big_combination(450)        \np 1000.big_combination(969)       \np 15000.big_permutation(73)       \n\np 15000.big_permutation(74)       \n\np 15000.permutation(74)           \n", "target": "from __future__ import print_function\n\nfrom scipy.misc import factorial as fact\nfrom scipy.misc import comb\n\ndef perm(N, k, exact=0):\n    return comb(N, k, exact) * fact(k, exact)\n\nexact=True\nprint('Sample Perms 1..12')\nfor N in range(1, 13):\n    k = max(N-2, 1)\n    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\\n')\n          \nprint('\\n\\nSample Combs 10..60')\nfor N in range(10, 61, 10):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\\n')\n\nexact=False\nprint('\\n\\nSample Perms 5..1500 Using FP approximations')\nfor N in [5, 15, 150, 1500, 15000]:\n    k = N-2\n    print('%iP%i =' % (N, k), perm(N, k, exact))\n          \nprint('\\nSample Combs 100..1000 Using FP approximations')\nfor N in range(100, 1001, 100):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact))\n"}
{"id": 389585, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to Python: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 389586, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to Python: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 389587, "name": "Long primes", "source": "Translate Ruby to Python: require \"big\"\n\ndef prime?(n)                     \n  return n | 1 == 3 if n < 5      \n  return false if n.gcd(6) != 1   \n  pc = typeof(n).new(5)           \n  until pc*pc > n\n    return false if n % pc == 0 || n % (pc + 2) == 0  \n    pc += 6                       \n  end\n  true\nend\n\n\n\ndef long_prime?(p)\n  return false unless prime? p\n  (2...p).each do |d|\n    return d == (p - 1) if (p - 1) % d == 0 && (10.to_big_i ** d) % p == 1\n  end \n  false\nend\n\nstart = Time.monotonic  \nputs \"Long primes \u2264 500:\"\n(2..500).each { |pc| print \"\nputs \n[500, 1000, 2000, 4000, 8000, 16000, 32000, 64000].each do |n|\n  puts \"Number of long primes \u2264 \nend\nputs \"\\nTime: \n", "target": "def sieve(limit):\n    primes = []\n    c = [False] * (limit + 1) \n    \n    p = 3\n    while True:\n        p2 = p * p\n        if p2 > limit: break\n        for i in range(p2, limit, 2 * p): c[i] = True\n        while True:\n            p += 2\n            if not c[p]: break\n\n    for i in range(3, limit, 2):\n        if not c[i]: primes.append(i)\n    return primes\n\n\ndef findPeriod(n):\n    r = 1\n    for i in range(1, n): r = (10 * r) % n\n    rr = r\n    period = 0\n    while True:\n        r = (10 * r) % n\n        period += 1\n        if r == rr: break\n    return period\n\nprimes = sieve(64000)\nlongPrimes = []\nfor prime in primes:\n    if findPeriod(prime) == prime - 1:\n        longPrimes.append(prime)\nnumbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]\ncount = 0\nindex = 0\ntotals = [0] * len(numbers)\nfor longPrime in longPrimes:\n    if longPrime > numbers[index]:\n        totals[index] = count\n        index += 1\n    count += 1\ntotals[-1] = count\nprint('The long primes up to 500 are:')\nprint(str(longPrimes[:totals[0]]).replace(',', ''))\nprint('\\nThe number of long primes up to:')\nfor (i, total) in enumerate(totals):\n    print('  %5d is %d' % (numbers[i], total))\n"}
{"id": 389588, "name": "Biorhythms", "source": "Translate Ruby to Python: require 'date'\nCYCLES = {physical: 23, emotional: 28, mental: 33}\n\ndef biorhythms(date_of_birth, target_date = Date.today.to_s)\n  days_alive = Date.parse(target_date) - Date.parse(date_of_birth) \n  CYCLES.each do |name, num_days|\n    cycle_day = days_alive % num_days\n    state = case cycle_day\n      when 0, num_days/2 then \"neutral\"\n      when (1.. num_days/2) then \"positive\"\n      when (num_days/2+1..num_days) then \"negative\"\n    end\n    puts \"%-10s: cycle day %2s, %s\" % [name, cycle_day.to_i, state]    \n  end\nend\n      \nbiorhythms(\"1943-03-09\", \"1972-07-11\")\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 389589, "name": "Biorhythms", "source": "Translate Ruby to Python: require 'date'\nCYCLES = {physical: 23, emotional: 28, mental: 33}\n\ndef biorhythms(date_of_birth, target_date = Date.today.to_s)\n  days_alive = Date.parse(target_date) - Date.parse(date_of_birth) \n  CYCLES.each do |name, num_days|\n    cycle_day = days_alive % num_days\n    state = case cycle_day\n      when 0, num_days/2 then \"neutral\"\n      when (1.. num_days/2) then \"positive\"\n      when (num_days/2+1..num_days) then \"negative\"\n    end\n    puts \"%-10s: cycle day %2s, %s\" % [name, cycle_day.to_i, state]    \n  end\nend\n      \nbiorhythms(\"1943-03-09\", \"1972-07-11\")\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 389590, "name": "Primorial numbers", "source": "Translate Ruby to Python: require 'prime'\n \ndef primorial_number(n)\n  pgen = Prime.each\n  (1..n).inject(1){|p,_| p*pgen.next}\nend\n \nputs \"First ten primorials: \n \n(1..5).each do |n|\n  puts \"primorial(10**\nend\n", "target": "from pyprimes import nprimes\nfrom functools import reduce\n\n\nprimelist = list(nprimes(1000001))    \n\ndef primorial(n):\n    return reduce(int.__mul__, primelist[:n], 1)\n\nif __name__ == '__main__':\n    print('First ten primorals:', [primorial(n) for n in range(10)])\n    for e in range(7):\n        n = 10**e\n        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))\n"}
{"id": 389591, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to Python: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 389592, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to Python: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 389593, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Ruby to Python: func legendre_pair((1), x) { (x, 1) }\nfunc legendre_pair( n,  x) {\n    var (m1, m2) = legendre_pair(n - 1, x)\n    var u = (1 - 1/n)\n    ((1 + u)*x*m1 - u*m2, m1)\n}\n\nfunc legendre((0), _) { 1 }\nfunc legendre( n,  x) { [legendre_pair(n, x)][0] }\n\nfunc legendre_prime({ .is_zero }, _) { 0 }\nfunc legendre_prime({ .is_one  }, _) { 1 }\n\nfunc legendre_prime(n, x) {\n    var (m0, m1) = legendre_pair(n, x)\n    (m1 - x*m0) * n / (1 - x**2)\n}\n\nfunc approximate_legendre_root(n, k) {\n    \n    var t = ((4*k - 1) / (4*n + 2))\n    (1 - ((n - 1)/(8 * n**3))) * cos(Num.pi * t)\n}\n\nfunc newton_raphson(f, f_prime, r, eps = 2e-16) {\n    loop {\n        var dr = (-f(r) / f_prime(r))\n        dr.abs >= eps || break\n        r += dr\n    }\n    return r\n}\n\nfunc legendre_root(n, k) {\n    newton_raphson(legendre.method(:call, n), legendre_prime.method(:call, n),\n                   approximate_legendre_root(n, k))\n}\n\nfunc weight(n, r) { 2 / ((1 - r**2) * legendre_prime(n, r)**2) }\n\nfunc nodes(n) {\n    gather {\n        take(Pair(0, weight(n, 0))) if n.is_odd\n        { |i|\n            var r = legendre_root(n, i)\n            var w = weight(n, r)\n            take(Pair(r, w), Pair(-r, w))\n        }.each(1 .. (n >> 1))\n    }\n}\n\nfunc quadrature(n, f, a, b, nds = nodes(n)) {\n    func scale(x) { (x*(b - a) + a + b) / 2 }\n    (b - a) / 2 * nds.sum { .second * f(scale(.first)) }\n}\n\n[(5..10)..., 20].each { |i|\n    printf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.15f\\n\",\n        i, quadrature(i, {.exp}, -3, +3))\n}\n", "target": "from numpy import *\n \n\n\ndef Legendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0+1.0\n\telif (n==1):\n\t\treturn x\n\telse:\n\t\treturn ((2.0*n-1.0)*x*Legendre(n-1,x)-(n-1)*Legendre(n-2,x))/n\n \n\n\ndef DLegendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0\n\telif (n==1):\n\t\treturn x*0+1.0\n\telse:\n\t\treturn (n/(x**2-1.0))*(x*Legendre(n,x)-Legendre(n-1,x))\n\n\ndef LegendreRoots(polyorder,tolerance=1e-20):\n\tif polyorder<2:\n\t\terr=1 \n\telse:\n\t\troots=[]\n\t\t\n\t\tfor i in range(1,int(polyorder)/2 +1):\n\t\t\tx=cos(pi*(i-0.25)/(polyorder+0.5))\n\t\t\terror=10*tolerance\n\t\t        iters=0\n\t\t        while (error>tolerance) and (iters<1000):\n\t\t                dx=-Legendre(polyorder,x)/DLegendre(polyorder,x)\n\t\t                x=x+dx\n\t\t                iters=iters+1\n\t\t                error=abs(dx)\n\t\t\troots.append(x)\n\t\t\n\t\troots=array(roots)\n\t\tif polyorder%2==0:\n\t\t\troots=concatenate( (-1.0*roots, roots[::-1]) )\n\t\telse:\n\t\t\troots=concatenate( (-1.0*roots, [0.0], roots[::-1]) )\n\t\terr=0 \n\treturn [roots, err]\n\n\ndef GaussLegendreWeights(polyorder):\n\tW=[]\n\t[xis,err]=LegendreRoots(polyorder)\n\tif err==0:\n\t\tW=2.0/( (1.0-xis**2)*(DLegendre(polyorder,xis)**2) )\n\t\terr=0\n\telse:\n\t\terr=1 \n\treturn [W, xis, err]\n\n\n\n\n\n\ndef GaussLegendreQuadrature(func, polyorder, a, b):\n\t[Ws,xs, err]= GaussLegendreWeights(polyorder)\n\tif err==0:\n\t\tans=(b-a)*0.5*sum( Ws*func( (b-a)*0.5*xs+ (b+a)*0.5 ) )\n\telse: \n\t\t\n\t\terr=1\n\t\tans=None\n\treturn [ans,err]\n\n\ndef func(x):\n\treturn exp(x)\n\n\n \norder=5\n[Ws,xs,err]=GaussLegendreWeights(order)\nif err==0:\n\tprint \"Order   \u00a0: \", order\n\tprint \"Roots   \u00a0: \", xs\n\tprint \"Weights \u00a0: \", Ws\nelse:\n\tprint \"Roots/Weights evaluation failed\"\n \n\n[ans,err]=GaussLegendreQuadrature(func , order, -3,3)\nif err==0:\n\tprint \"Integral\u00a0: \", ans\nelse:\n\tprint \"Integral evaluation failed\"\n"}
{"id": 389594, "name": "K-d tree", "source": "Translate Ruby to Python: struct Kd_node {\n    d,\n    split,\n    left,\n    right,\n}\n\nstruct Orthotope {\n    min,\n    max,\n}\n\nclass Kd_tree(n, bounds) {\n\n    method init {\n        n = self.nk2(0, n);\n    }\n\n    method nk2(split, e) {\n        return(nil) if (e.len <= 0);\n        var exset = e.sort_by { _[split] }\n        var m = (exset.len // 2);\n        var d = exset[m];\n        while ((m+1 < exset.len) && (exset[m+1][split] == d[split])) {\n            ++m;\n        }\n\n        var s2 = ((split + 1) % d.len);     \n        Kd_node(d: d, split: split,\n                left:  self.nk2(s2, exset.first(m)),\n                right: self.nk2(s2, exset.last(m-1)));\n    }\n}\n\nstruct T3 {\n    nearest,\n    dist_sqd = Inf,\n    nodes_visited = 0,\n}\n\nfunc find_nearest(k, t, p) {\n    func nn(kd, target, hr, max_dist_sqd) {\n        kd || return T3(nearest: [0]*k);\n\n        var nodes_visited = 1;\n        var s = kd.split;\n        var pivot = kd.d;\n        var left_hr = Orthotope(hr.min, hr.max);\n        var right_hr = Orthotope(hr.min, hr.max);\n        left_hr.max[s] = pivot[s];\n        right_hr.min[s] = pivot[s];\n\n        var nearer_kd;\n        var further_kd;\n        var nearer_hr;\n        var further_hr;\n        if (target[s] <= pivot[s]) {\n            (nearer_kd, nearer_hr) = (kd.left, left_hr);\n            (further_kd, further_hr) = (kd.right, right_hr);\n        }\n        else {\n            (nearer_kd, nearer_hr) = (kd.right, right_hr);\n            (further_kd, further_hr) = (kd.left, left_hr);\n        }\n\n        var n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd);\n        var nearest = n1.nearest;\n        var dist_sqd = n1.dist_sqd;\n        nodes_visited += n1.nodes_visited;\n\n        if (dist_sqd < max_dist_sqd) {\n            max_dist_sqd = dist_sqd;\n        }\n        var d = (pivot[s] - target[s] -> sqr);\n        if (d > max_dist_sqd) {\n            return T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n        }\n        d = (pivot ~Z- target \u00bbsqr\u00bb() \u00ab+\u00bb);\n        if (d < dist_sqd) {\n            nearest = pivot;\n            dist_sqd = d;\n            max_dist_sqd = dist_sqd;\n        }\n\n        var n2 = nn(further_kd, target, further_hr, max_dist_sqd);\n        nodes_visited += n2.nodes_visited;\n        if (n2.dist_sqd < dist_sqd) {\n            nearest = n2.nearest;\n            dist_sqd = n2.dist_sqd;\n        }\n\n        T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n    }\n\n    return nn(t.n, p, t.bounds, Inf);\n}\n\nfunc show_nearest(k, heading, kd, p) {\n    print <<-\"END\"\n        \n        Point:            [\n        END\n    var n = find_nearest(k, kd, p);\n    print <<-\"END\"\n        Nearest neighbor: [\n        Distance:         \n        Nodes visited:    \n\n        END\n}\n\nfunc random_point(k) { k.of { 1.rand } }\nfunc random_points(k, n) { n.of { random_point(k) } }\n\nvar kd1 = Kd_tree([[2, 3],[5, 4],[9, 6],[4, 7],[8, 1],[7, 2]],\n              Orthotope(min: [0, 0], max: [10, 10]));\nshow_nearest(2, \"Wikipedia example data\", kd1, [9, 2]);\n\nvar N = 1000\nvar t0 = Time.micro\nvar kd2 = Kd_tree(random_points(3, N), Orthotope(min: [0,0,0], max: [1,1,1]))\n\nvar t1 = Time.micro\nshow_nearest(2,\n    \"k-d tree with \n     kd2, random_point(3))\n", "target": "from random import seed, random\nfrom time import time\nfrom operator import itemgetter\nfrom collections import namedtuple\nfrom math import sqrt\nfrom copy import deepcopy\n\n\ndef sqd(p1, p2):\n    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))\n\n\nclass KdNode(object):\n    __slots__ = (\"dom_elt\", \"split\", \"left\", \"right\")\n\n    def __init__(self, dom_elt, split, left, right):\n        self.dom_elt = dom_elt\n        self.split = split\n        self.left = left\n        self.right = right\n\n\nclass Orthotope(object):\n    __slots__ = (\"min\", \"max\")\n\n    def __init__(self, mi, ma):\n        self.min, self.max = mi, ma\n\n\nclass KdTree(object):\n    __slots__ = (\"n\", \"bounds\")\n\n    def __init__(self, pts, bounds):\n        def nk2(split, exset):\n            if not exset:\n                return None\n            exset.sort(key=itemgetter(split))\n            m = len(exset) // 2\n            d = exset[m]\n            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:\n                m += 1\n            d = exset[m]\n\n\n            s2 = (split + 1) % len(d)  \n            return KdNode(d, split, nk2(s2, exset[:m]),\n                                    nk2(s2, exset[m + 1:]))\n        self.n = nk2(0, pts)\n        self.bounds = bounds\n\nT3 = namedtuple(\"T3\", \"nearest dist_sqd nodes_visited\")\n\n\ndef find_nearest(k, t, p):\n    def nn(kd, target, hr, max_dist_sqd):\n        if kd is None:\n            return T3([0.0] * k, float(\"inf\"), 0)\n\n        nodes_visited = 1\n        s = kd.split\n        pivot = kd.dom_elt\n        left_hr = deepcopy(hr)\n        right_hr = deepcopy(hr)\n        left_hr.max[s] = pivot[s]\n        right_hr.min[s] = pivot[s]\n\n        if target[s] <= pivot[s]:\n            nearer_kd, nearer_hr = kd.left, left_hr\n            further_kd, further_hr = kd.right, right_hr\n        else:\n            nearer_kd, nearer_hr = kd.right, right_hr\n            further_kd, further_hr = kd.left, left_hr\n\n        n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)\n        nearest = n1.nearest\n        dist_sqd = n1.dist_sqd\n        nodes_visited += n1.nodes_visited\n\n        if dist_sqd < max_dist_sqd:\n            max_dist_sqd = dist_sqd\n        d = (pivot[s] - target[s]) ** 2\n        if d > max_dist_sqd:\n            return T3(nearest, dist_sqd, nodes_visited)\n        d = sqd(pivot, target)\n        if d < dist_sqd:\n            nearest = pivot\n            dist_sqd = d\n            max_dist_sqd = dist_sqd\n\n        n2 = nn(further_kd, target, further_hr, max_dist_sqd)\n        nodes_visited += n2.nodes_visited\n        if n2.dist_sqd < dist_sqd:\n            nearest = n2.nearest\n            dist_sqd = n2.dist_sqd\n\n        return T3(nearest, dist_sqd, nodes_visited)\n\n    return nn(t.n, p, t.bounds, float(\"inf\"))\n\n\ndef show_nearest(k, heading, kd, p):\n    print(heading + \":\")\n    print(\"Point:           \", p)\n    n = find_nearest(k, kd, p)\n    print(\"Nearest neighbor:\", n.nearest)\n    print(\"Distance:        \", sqrt(n.dist_sqd))\n    print(\"Nodes visited:   \", n.nodes_visited, \"\\n\")\n\n\ndef random_point(k):\n    return [random() for _ in range(k)]\n\n\ndef random_points(k, n):\n    return [random_point(k) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    seed(1)\n    P = lambda *coords: list(coords)\n    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],\n                  Orthotope(P(0, 0), P(10, 10)))\n    show_nearest(2, \"Wikipedia example data\", kd1, P(9, 2))\n\n    N = 400000\n    t0 = time()\n    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))\n    t1 = time()\n    text = lambda *parts: \"\".join(map(str, parts))\n    show_nearest(2, text(\"k-d tree with \", N,\n                         \" random 3D points (generation time: \",\n                         t1-t0, \"s)\"),\n                 kd2, random_point(3))\n"}
{"id": 389595, "name": "K-d tree", "source": "Translate Ruby to Python: struct Kd_node {\n    d,\n    split,\n    left,\n    right,\n}\n\nstruct Orthotope {\n    min,\n    max,\n}\n\nclass Kd_tree(n, bounds) {\n\n    method init {\n        n = self.nk2(0, n);\n    }\n\n    method nk2(split, e) {\n        return(nil) if (e.len <= 0);\n        var exset = e.sort_by { _[split] }\n        var m = (exset.len // 2);\n        var d = exset[m];\n        while ((m+1 < exset.len) && (exset[m+1][split] == d[split])) {\n            ++m;\n        }\n\n        var s2 = ((split + 1) % d.len);     \n        Kd_node(d: d, split: split,\n                left:  self.nk2(s2, exset.first(m)),\n                right: self.nk2(s2, exset.last(m-1)));\n    }\n}\n\nstruct T3 {\n    nearest,\n    dist_sqd = Inf,\n    nodes_visited = 0,\n}\n\nfunc find_nearest(k, t, p) {\n    func nn(kd, target, hr, max_dist_sqd) {\n        kd || return T3(nearest: [0]*k);\n\n        var nodes_visited = 1;\n        var s = kd.split;\n        var pivot = kd.d;\n        var left_hr = Orthotope(hr.min, hr.max);\n        var right_hr = Orthotope(hr.min, hr.max);\n        left_hr.max[s] = pivot[s];\n        right_hr.min[s] = pivot[s];\n\n        var nearer_kd;\n        var further_kd;\n        var nearer_hr;\n        var further_hr;\n        if (target[s] <= pivot[s]) {\n            (nearer_kd, nearer_hr) = (kd.left, left_hr);\n            (further_kd, further_hr) = (kd.right, right_hr);\n        }\n        else {\n            (nearer_kd, nearer_hr) = (kd.right, right_hr);\n            (further_kd, further_hr) = (kd.left, left_hr);\n        }\n\n        var n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd);\n        var nearest = n1.nearest;\n        var dist_sqd = n1.dist_sqd;\n        nodes_visited += n1.nodes_visited;\n\n        if (dist_sqd < max_dist_sqd) {\n            max_dist_sqd = dist_sqd;\n        }\n        var d = (pivot[s] - target[s] -> sqr);\n        if (d > max_dist_sqd) {\n            return T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n        }\n        d = (pivot ~Z- target \u00bbsqr\u00bb() \u00ab+\u00bb);\n        if (d < dist_sqd) {\n            nearest = pivot;\n            dist_sqd = d;\n            max_dist_sqd = dist_sqd;\n        }\n\n        var n2 = nn(further_kd, target, further_hr, max_dist_sqd);\n        nodes_visited += n2.nodes_visited;\n        if (n2.dist_sqd < dist_sqd) {\n            nearest = n2.nearest;\n            dist_sqd = n2.dist_sqd;\n        }\n\n        T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n    }\n\n    return nn(t.n, p, t.bounds, Inf);\n}\n\nfunc show_nearest(k, heading, kd, p) {\n    print <<-\"END\"\n        \n        Point:            [\n        END\n    var n = find_nearest(k, kd, p);\n    print <<-\"END\"\n        Nearest neighbor: [\n        Distance:         \n        Nodes visited:    \n\n        END\n}\n\nfunc random_point(k) { k.of { 1.rand } }\nfunc random_points(k, n) { n.of { random_point(k) } }\n\nvar kd1 = Kd_tree([[2, 3],[5, 4],[9, 6],[4, 7],[8, 1],[7, 2]],\n              Orthotope(min: [0, 0], max: [10, 10]));\nshow_nearest(2, \"Wikipedia example data\", kd1, [9, 2]);\n\nvar N = 1000\nvar t0 = Time.micro\nvar kd2 = Kd_tree(random_points(3, N), Orthotope(min: [0,0,0], max: [1,1,1]))\n\nvar t1 = Time.micro\nshow_nearest(2,\n    \"k-d tree with \n     kd2, random_point(3))\n", "target": "from random import seed, random\nfrom time import time\nfrom operator import itemgetter\nfrom collections import namedtuple\nfrom math import sqrt\nfrom copy import deepcopy\n\n\ndef sqd(p1, p2):\n    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))\n\n\nclass KdNode(object):\n    __slots__ = (\"dom_elt\", \"split\", \"left\", \"right\")\n\n    def __init__(self, dom_elt, split, left, right):\n        self.dom_elt = dom_elt\n        self.split = split\n        self.left = left\n        self.right = right\n\n\nclass Orthotope(object):\n    __slots__ = (\"min\", \"max\")\n\n    def __init__(self, mi, ma):\n        self.min, self.max = mi, ma\n\n\nclass KdTree(object):\n    __slots__ = (\"n\", \"bounds\")\n\n    def __init__(self, pts, bounds):\n        def nk2(split, exset):\n            if not exset:\n                return None\n            exset.sort(key=itemgetter(split))\n            m = len(exset) // 2\n            d = exset[m]\n            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:\n                m += 1\n            d = exset[m]\n\n\n            s2 = (split + 1) % len(d)  \n            return KdNode(d, split, nk2(s2, exset[:m]),\n                                    nk2(s2, exset[m + 1:]))\n        self.n = nk2(0, pts)\n        self.bounds = bounds\n\nT3 = namedtuple(\"T3\", \"nearest dist_sqd nodes_visited\")\n\n\ndef find_nearest(k, t, p):\n    def nn(kd, target, hr, max_dist_sqd):\n        if kd is None:\n            return T3([0.0] * k, float(\"inf\"), 0)\n\n        nodes_visited = 1\n        s = kd.split\n        pivot = kd.dom_elt\n        left_hr = deepcopy(hr)\n        right_hr = deepcopy(hr)\n        left_hr.max[s] = pivot[s]\n        right_hr.min[s] = pivot[s]\n\n        if target[s] <= pivot[s]:\n            nearer_kd, nearer_hr = kd.left, left_hr\n            further_kd, further_hr = kd.right, right_hr\n        else:\n            nearer_kd, nearer_hr = kd.right, right_hr\n            further_kd, further_hr = kd.left, left_hr\n\n        n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)\n        nearest = n1.nearest\n        dist_sqd = n1.dist_sqd\n        nodes_visited += n1.nodes_visited\n\n        if dist_sqd < max_dist_sqd:\n            max_dist_sqd = dist_sqd\n        d = (pivot[s] - target[s]) ** 2\n        if d > max_dist_sqd:\n            return T3(nearest, dist_sqd, nodes_visited)\n        d = sqd(pivot, target)\n        if d < dist_sqd:\n            nearest = pivot\n            dist_sqd = d\n            max_dist_sqd = dist_sqd\n\n        n2 = nn(further_kd, target, further_hr, max_dist_sqd)\n        nodes_visited += n2.nodes_visited\n        if n2.dist_sqd < dist_sqd:\n            nearest = n2.nearest\n            dist_sqd = n2.dist_sqd\n\n        return T3(nearest, dist_sqd, nodes_visited)\n\n    return nn(t.n, p, t.bounds, float(\"inf\"))\n\n\ndef show_nearest(k, heading, kd, p):\n    print(heading + \":\")\n    print(\"Point:           \", p)\n    n = find_nearest(k, kd, p)\n    print(\"Nearest neighbor:\", n.nearest)\n    print(\"Distance:        \", sqrt(n.dist_sqd))\n    print(\"Nodes visited:   \", n.nodes_visited, \"\\n\")\n\n\ndef random_point(k):\n    return [random() for _ in range(k)]\n\n\ndef random_points(k, n):\n    return [random_point(k) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    seed(1)\n    P = lambda *coords: list(coords)\n    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],\n                  Orthotope(P(0, 0), P(10, 10)))\n    show_nearest(2, \"Wikipedia example data\", kd1, P(9, 2))\n\n    N = 400000\n    t0 = time()\n    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))\n    t1 = time()\n    text = lambda *parts: \"\".join(map(str, parts))\n    show_nearest(2, text(\"k-d tree with \", N,\n                         \" random 3D points (generation time: \",\n                         t1-t0, \"s)\"),\n                 kd2, random_point(3))\n"}
{"id": 389596, "name": "Color quantization", "source": "Translate Ruby to Python: require('Image::Magick')\n\nfunc quantize_image(n = 16, input, output='output.png') {\n    var im = %O<Image::Magick>.new\n    im.Read(input)\n    im.Quantize(colors => n, dither => 1)    \n    im.Write(output)\n}\n\nquantize_image(input: 'Quantum_frog.png')\n", "target": "from PIL import Image\n\nif __name__==\"__main__\":\n\tim = Image.open(\"frog.png\")\n\tim2 = im.quantize(16)\n\tim2.show()\n"}
{"id": 389597, "name": "Cut a rectangle", "source": "Translate Ruby to Python: def cut_it(h, w)\n  if h.odd?\n    return 0  if w.odd?\n    h, w = w, h\n  end\n  return 1  if w == 1\n  \n  nxt = [[w+1, 1, 0], [-w-1, -1, 0], [-1, 0, -1], [1, 0, 1]]  \n  blen = (h + 1) * (w + 1) - 1\n  grid = [false] * (blen + 1)\n  \n  walk = lambda do |y, x, count=0|\n    return count+1  if y==0 or y==h or x==0 or x==w\n    t = y * (w + 1) + x\n    grid[t] = grid[blen - t] = true\n    nxt.each do |nt, dy, dx|\n      count += walk[y + dy, x + dx]  unless grid[t + nt]\n    end\n    grid[t] = grid[blen - t] = false\n    count\n  end\n  \n  t = h / 2 * (w + 1) + w / 2\n  if w.odd?\n    grid[t] = grid[t + 1] = true\n    count = walk[h / 2, w / 2 - 1]\n    count + walk[h / 2 - 1, w / 2] * 2\n  else\n    grid[t] = true\n    count = walk[h / 2, w / 2 - 1]\n    return count * 2  if h == w\n    count + walk[h / 2 - 1, w / 2]\n  end\nend\n\nfor w in 1..9\n  for h in 1..w\n    puts \"%d x %d: %d\" % [w, h, cut_it(w, h)]  if (w * h).even?\n  end\nend\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 389598, "name": "Cut a rectangle", "source": "Translate Ruby to Python: def cut_it(h, w)\n  if h.odd?\n    return 0  if w.odd?\n    h, w = w, h\n  end\n  return 1  if w == 1\n  \n  nxt = [[w+1, 1, 0], [-w-1, -1, 0], [-1, 0, -1], [1, 0, 1]]  \n  blen = (h + 1) * (w + 1) - 1\n  grid = [false] * (blen + 1)\n  \n  walk = lambda do |y, x, count=0|\n    return count+1  if y==0 or y==h or x==0 or x==w\n    t = y * (w + 1) + x\n    grid[t] = grid[blen - t] = true\n    nxt.each do |nt, dy, dx|\n      count += walk[y + dy, x + dx]  unless grid[t + nt]\n    end\n    grid[t] = grid[blen - t] = false\n    count\n  end\n  \n  t = h / 2 * (w + 1) + w / 2\n  if w.odd?\n    grid[t] = grid[t + 1] = true\n    count = walk[h / 2, w / 2 - 1]\n    count + walk[h / 2 - 1, w / 2] * 2\n  else\n    grid[t] = true\n    count = walk[h / 2, w / 2 - 1]\n    return count * 2  if h == w\n    count + walk[h / 2 - 1, w / 2]\n  end\nend\n\nfor w in 1..9\n  for h in 1..w\n    puts \"%d x %d: %d\" % [w, h, cut_it(w, h)]  if (w * h).even?\n  end\nend\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 389599, "name": "Cuban primes", "source": "Translate Ruby to Python: require \"openssl\"\n \nRE = /(\\d)(?=(\\d\\d\\d)+(?!\\d))/ \ncuban_primes = Enumerator.new do |y|\n  (1..).each do |n|\n    cand = 3*n*(n+1) + 1\n    y << cand if OpenSSL::BN.new(cand).prime?\n  end\nend\n \ndef commatize(num)\n  num.to_s.gsub(RE, \"\\\\1,\")\nend\n \ncbs = cuban_primes.take(200)\nformatted = cbs.map{|cb| commatize(cb).rjust(10) }\nputs formatted.each_slice(10).map(&:join)\n \nt0 = Time.now \nputs \"\n100_000th cuban prime is \nwhich took \n", "target": "import datetime\nimport math\n\nprimes = [ 3, 5 ]\n\ncutOff = 200\n\nbigUn =  100_000\nchunks = 50\nlittle = bigUn / chunks\n\ntn = \" cuban prime\"\nprint (\"The first {:,}{}s:\".format(cutOff, tn))\n\nc = 0\nshowEach = True\nu = 0\nv = 1\nst = datetime.datetime.now()\n\nfor i in range(1, int(math.pow(2,20))):\n\tfound = False\n\tu += 6\n\tv += u\n\tmx = int(math.sqrt(v))\n\t\n\tfor item in primes:\n\t\tif (item > mx):\n\t\t\tbreak\n\t\tif (v % item == 0):\n\t\t\tfound = True\n\t\t\tbreak\n\t\n\tif (found == 0):\n\t\tc += 1\n\t\tif (showEach):\n\t\t\tz = primes[-1]\n\t\t\twhile (z <= v - 2):\n\t\t\t\tz += 2\n\t\t\t\t\n\t\t\t\tfnd = False\n\t\t\t\tfor item in primes:\n\t\t\t\t\tif (item > mx):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif (z % item == 0):\n\t\t\t\t\t\tfnd = True\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\tif (not fnd):\n\t\t\t\t\tprimes.append(z)\n\t\t\t\n\t\t\tprimes.append(v)\n\t\t\tprint(\"{:>11,}\".format(v), end='')\n\t\t\t\n\t\t\tif (c % 10 == 0):\n\t\t\t\tprint(\"\");\n\t\t\tif (c == cutOff):\n\t\t\t\tshowEach = False\n\t\t\t\tprint (\"Progress to the {:,}th {}:\".format(bigUn, tn), end='')\n\t\tif (c % little == 0):\n\t\t\tprint('.', end='')\n\t\tif (c == bigUn):\n\t\t\tbreak\n\nprint(\"\");\nprint (\"The {:,}th{} is {:,}\".format(c, tn, v))\nprint(\"Computation time was {} seconds\".format((datetime.datetime.now() - st).seconds))\n"}
{"id": 389600, "name": "Chaos game", "source": "Translate Ruby to Python: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 389601, "name": "Chaos game", "source": "Translate Ruby to Python: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 389602, "name": "World Cup group stage", "source": "Translate Ruby to Python: teams = [:a, :b, :c, :d]\nmatches = teams.combination(2).to_a\noutcomes = [:win, :draw, :loss]\ngains = {win:[3,0], draw:[1,1], loss:[0,3]}\nplaces_histogram = Array.new(4) {Array.new(10,0)}\n\n\n\noutcomes.repeated_permutation(6).each do |outcome|\n  results = Hash.new(0)\n  \n  \n  outcome.zip(matches).each do |decision, (team1, team2)|\n    results[team1] += gains[decision][0]\n    results[team2] += gains[decision][1]\n  end \n  \n  \n  results.values.sort.reverse.each_with_index do |points, place|\n    places_histogram[place][points] += 1\n  end\nend\n\nfmt = \"%s\u00a0:\" + \"%4s\"*10\nputs fmt % [\" \", *0..9]\nputs fmt % [\"-\", *[\"---\"]*10]\nplaces_histogram.each.with_index(1) {|hist,place| puts fmt % [place, *hist]}\n", "target": "from itertools import product, combinations, izip\n\nscoring = [0, 1, 3]\nhisto = [[0] * 10 for _ in xrange(4)]\n\nfor results in product(range(3), repeat=6):\n    s = [0] * 4\n    for r, g in izip(results, combinations(range(4), 2)):\n        s[g[0]] += scoring[r]\n        s[g[1]] += scoring[2 - r]\n\n    for h, v in izip(histo, sorted(s)):\n        h[v] += 1\n\nfor x in reversed(histo):\n    print x\n"}
{"id": 389603, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Ruby to Python: rpn = RPNExpression.from_infix(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n"}
{"id": 389604, "name": "Perlin noise", "source": "Translate Ruby to Python: const p = (%w'47 4G 3T 2J 2I F 3N D 5L 2N 2O 1H 5E 6H 7 69 3W 10 2V U 1X 3Y 8\n2R 11 6O L A N 5A 6 44 6V 3C 6I 23 0 Q 5H 1Q 2M 70 63 5N 39 Z B W 1L 4X X 2G\n6L 45 1K 2F 4U K 3H 3S 4R 4O 1W 4V 22 4L 1Z 3Q 3V 1C R 4M 25 42 4E 6F 2B 33 6D\n3E 1O 5V 3P 6E 64 2X 2K 15 1J 1A 6T 14 6S 2U 3Z 1I 1T P 1R 4H 1 60 28 21 5T 24\n3O 57 5S 2H I 4P 5K 5G 3R 3M 38 58 4F 2E 4K 2S 31 5I 4T 56 3 1S 1G 61 6A 6Y 3G\n3F 5 5M 12 43 3A 3I 73 2A 2D 5W 5R 5Q 1N 6B 1B G 1M H 52 59 S 16 67 53 4Q 5X\n3B 6W 48 2 18 4A 4J 1Y 65 49 2T 4B 4N 17 4S 9 3L M 13 71 J 2Q 30 32 27 35 68\n6G 4Y 55 34 2W 62 6U 2P 6C 6Z Y 6Q 5D 6M 5U 40 C 5B 4Z 4I 6P 29 1F 41 6J 6X E\n6N 2Z 1D 5C 5Y V 51 5J 2Y 4D 54 2C 5O 4W 37 3D 1E 19 3J 4 46 72 3U 6K 5P 2L 66\n36 1V T O 20 6R 3X 3K 5F 26 1U 5Z 1P 4C 50' * 2 -> map {|n| Num(n, 36) })\n\nfunc fade(n) { n * n * n * (n * (n * 6 - 15) + 10) }\nfunc lerp(t, a, b) { a + t*(b-a) }\n\nfunc grad(h, x, y, z) {\n    h &= 15\n    var u = (h < 8 ? x : y)\n    var v = (h < 4 ? y : (h ~~ [12,14] ? x : z))\n    (h&1 ? -u : u) + (h&2 ? -v : v)\n}\n\nfunc noise(x, y, z) {\n    var(X, Y, Z) = [x, y, z].map { .floor & 255 }...\n    var (u, v, w) = [x-=X, y-=Y, z-=Z].map { fade(_) }...\n    var (AA, AB) = with(p[X]   + Y) {|i| (p[i] + Z, p[i+1] + Z) }\n    var (BA, BB) = with(p[X+1] + Y) {|i| (p[i] + Z, p[i+1] + Z) }\n    lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z  ),\n                            grad(p[BA  ], x-1, y  , z  )),\n                    lerp(u, grad(p[AB  ], x  , y-1, z  ),\n                            grad(p[BB  ], x-1, y-1, z  ))),\n            lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1),\n                            grad(p[BA+1], x-1, y  , z-1)),\n                    lerp(u, grad(p[AB+1], x  , y-1, z-1),\n                            grad(p[BB+1], x-1, y-1, z-1))))\n}\n\nsay noise(3.14, 42, 7)\n", "target": "import math\n\ndef perlin_noise(x, y, z):\n    X = math.floor(x) & 255                  \n    Y = math.floor(y) & 255                  \n    Z = math.floor(z) & 255\n    x -= math.floor(x)                                \n    y -= math.floor(y)                                \n    z -= math.floor(z)\n    u = fade(x)                                \n    v = fade(y)                                \n    w = fade(z)\n    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      \n    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      \n \n    return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                   grad(p[BA  ], x-1, y  , z   )), \n                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                   grad(p[BB  ], x-1, y-1, z   ))),\n                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                   grad(p[BA+1], x-1, y  , z-1 )), \n                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                   grad(p[BB+1], x-1, y-1, z-1 ))))\n                                   \ndef fade(t): \n    return t ** 3 * (t * (t * 6 - 15) + 10)\n    \ndef lerp(t, a, b):\n    return a + t * (b - a)\n    \ndef grad(hash, x, y, z):\n    h = hash & 15                      \n    u = x if h<8 else y                \n    v = y if h<4 else (x if h in (12, 14) else z)\n    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)\n\np = [None] * 512\npermutation = [151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]\nfor i in range(256):\n    p[256+i] = p[i] = permutation[i]\n\nif __name__ == '__main__':\n    print(\"%1.17f\" % perlin_noise(3.14, 42, 7))\n"}
{"id": 389605, "name": "A_ search algorithm", "source": "Translate Ruby to Python: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 389606, "name": "A_ search algorithm", "source": "Translate Ruby to Python: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 389607, "name": "Almkvist-Giullera formula for pi", "source": "Translate Ruby to Python: func almkvist_giullera(n) {\n    (32 * (14*n * (38*n + 9) + 9) * (6*n)!) / (3 * n!**6)\n}\n\nfunc almkvist_giullera_pi(prec = 70) {\n\n    local Num!PREC = (4*(prec+1)).numify\n\n    var sum = 0\n    var target = -1\n\n    for n in (0..Inf) {\n        sum += (almkvist_giullera(n) / (10**(6*n + 3)))\n        var curr = (sum**-.5).as_dec\n        return target if (target == curr)\n        target = curr\n    }\n}\n\nsay 'First 10 integer portions: '\n\n10.of {|n|\n    say \"\n}\n\nwith(70) {|n|\n    say \"\u03c0 to \n    say almkvist_giullera_pi(n)\n}\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 389608, "name": "Almkvist-Giullera formula for pi", "source": "Translate Ruby to Python: func almkvist_giullera(n) {\n    (32 * (14*n * (38*n + 9) + 9) * (6*n)!) / (3 * n!**6)\n}\n\nfunc almkvist_giullera_pi(prec = 70) {\n\n    local Num!PREC = (4*(prec+1)).numify\n\n    var sum = 0\n    var target = -1\n\n    for n in (0..Inf) {\n        sum += (almkvist_giullera(n) / (10**(6*n + 3)))\n        var curr = (sum**-.5).as_dec\n        return target if (target == curr)\n        target = curr\n    }\n}\n\nsay 'First 10 integer portions: '\n\n10.of {|n|\n    say \"\n}\n\nwith(70) {|n|\n    say \"\u03c0 to \n    say almkvist_giullera_pi(n)\n}\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 389609, "name": "Lychrel numbers", "source": "Translate Ruby to Python: require \"set\"\nrequire \"big\"\n \ndef add_reverse(num, max_iter=1000)\n  num = num.to_big_i\n  nums = [] of BigInt\n  (1..max_iter).each_with_object(Set.new([num])) do |_, nums|\n    num += reverse_int(num)\n    nums << num\n    return nums if palindrome?(num)\n  end\nend\n \ndef palindrome?(num)\n  num == reverse_int(num)\nend\n \ndef reverse_int(num)\n  num.to_s.reverse.to_big_i\nend\n \ndef split_roots_from_relateds(roots_and_relateds)\n  roots = roots_and_relateds.dup\n  i = 1\n  while i < roots.size\n    this = roots[i]\n    if roots[0...i].any?{ |prev| this.intersects?(prev) }\n      roots.delete_at(i)\n    else\n      i += 1\n    end\n  end\n  root = roots.map{ |each_set| each_set.min }\n  related = roots_and_relateds.map{ |each_set| each_set.min }\n  related = related.reject{ |n| root.includes?(n) }\n  return root, related\nend\n \ndef find_lychrel(maxn, max_reversions)\n  series = (1..maxn).map{ |n| add_reverse(n, max_reversions*2) }\n  roots_and_relateds = series.select{ |s| s.size > max_reversions }\n  split_roots_from_relateds(roots_and_relateds)\nend\n \nmaxn, reversion_limit = 10000, 500\nputs \"Calculations using n = 1..\nlychrel, l_related = find_lychrel(maxn, reversion_limit)\nputs \"  Number of Lychrel numbers: \nputs \"    Lychrel numbers: \nputs \"  Number of Lychrel related: \npals = (lychrel + l_related).select{|x| palindrome?(x)}.sort\nputs \"  Number of Lychrel palindromes: \nputs \"    Lychrel palindromes: \n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 389610, "name": "Lychrel numbers", "source": "Translate Ruby to Python: require \"set\"\nrequire \"big\"\n \ndef add_reverse(num, max_iter=1000)\n  num = num.to_big_i\n  nums = [] of BigInt\n  (1..max_iter).each_with_object(Set.new([num])) do |_, nums|\n    num += reverse_int(num)\n    nums << num\n    return nums if palindrome?(num)\n  end\nend\n \ndef palindrome?(num)\n  num == reverse_int(num)\nend\n \ndef reverse_int(num)\n  num.to_s.reverse.to_big_i\nend\n \ndef split_roots_from_relateds(roots_and_relateds)\n  roots = roots_and_relateds.dup\n  i = 1\n  while i < roots.size\n    this = roots[i]\n    if roots[0...i].any?{ |prev| this.intersects?(prev) }\n      roots.delete_at(i)\n    else\n      i += 1\n    end\n  end\n  root = roots.map{ |each_set| each_set.min }\n  related = roots_and_relateds.map{ |each_set| each_set.min }\n  related = related.reject{ |n| root.includes?(n) }\n  return root, related\nend\n \ndef find_lychrel(maxn, max_reversions)\n  series = (1..maxn).map{ |n| add_reverse(n, max_reversions*2) }\n  roots_and_relateds = series.select{ |s| s.size > max_reversions }\n  split_roots_from_relateds(roots_and_relateds)\nend\n \nmaxn, reversion_limit = 10000, 500\nputs \"Calculations using n = 1..\nlychrel, l_related = find_lychrel(maxn, reversion_limit)\nputs \"  Number of Lychrel numbers: \nputs \"    Lychrel numbers: \nputs \"  Number of Lychrel related: \npals = (lychrel + l_related).select{|x| palindrome?(x)}.sort\nputs \"  Number of Lychrel palindromes: \nputs \"    Lychrel palindromes: \n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 389611, "name": "Check Machin-like formulas", "source": "Translate Ruby to Python: var equationtext = <<'EOT'\n  pi/4 = arctan(1/2) + arctan(1/3)\n  pi/4 = 2*arctan(1/3) + arctan(1/7)\n  pi/4 = 4*arctan(1/5) - arctan(1/239)\n  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)\n  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)\n  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8)\n  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99)\n  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)\n  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)\n  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)\n  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)\n  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)\n  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)\n  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)\n  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)\nEOT\n\nfunc parse_eqn(equation) {\n    static eqn_re = %r{\n    (^ \\s* pi/4 \\s* = \\s* )?                 \n    (?:                                      \n        \\s* ( [-+] )? \\s*\n        (?: ( \\d+ ) \\s* \\*)?\n        \\s* arctan\\((.*?)\\)\n    )}x\n\n    gather {\n        for lhs,sign,mult,rat in (equation.findall(eqn_re)) {\n            take([\n                [+1, -1][sign == '-'] * (mult ? Num(mult) : 1),\n                Num(rat)\n            ])\n        }\n    }\n}\n\nfunc tanEval(coef, f) {\n    return f if (coef == 1)\n    return -tanEval(-coef, f) if (coef < 0)\n    var ca = coef>>1\n    var cb = (coef - ca)\n    var (a, b) = (tanEval(ca, f), tanEval(cb, f))\n    (a + b) / (1 - a*b)\n}\n\nfunc tans(xs) {\n    var xslen = xs.len\n    return tanEval(xs[0]...) if (xslen == 1)\n    var (aa, bb) = xs.part(xslen>>1)\n    var (a, b) = (tans(aa), tans(bb))\n    (a + b) / (1 - a*b)\n}\n\nvar machins = equationtext.lines.map(parse_eqn)\n\nfor machin,eqn in (machins ~Z equationtext.lines) {\n    var ans = tans(machin)\n    printf(\"%5s: %s\\n\", (ans == 1 ? 'OK' : 'ERROR'), eqn)\n}\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 389612, "name": "Check Machin-like formulas", "source": "Translate Ruby to Python: var equationtext = <<'EOT'\n  pi/4 = arctan(1/2) + arctan(1/3)\n  pi/4 = 2*arctan(1/3) + arctan(1/7)\n  pi/4 = 4*arctan(1/5) - arctan(1/239)\n  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)\n  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)\n  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8)\n  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99)\n  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)\n  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)\n  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)\n  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)\n  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)\n  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)\n  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)\n  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)\nEOT\n\nfunc parse_eqn(equation) {\n    static eqn_re = %r{\n    (^ \\s* pi/4 \\s* = \\s* )?                 \n    (?:                                      \n        \\s* ( [-+] )? \\s*\n        (?: ( \\d+ ) \\s* \\*)?\n        \\s* arctan\\((.*?)\\)\n    )}x\n\n    gather {\n        for lhs,sign,mult,rat in (equation.findall(eqn_re)) {\n            take([\n                [+1, -1][sign == '-'] * (mult ? Num(mult) : 1),\n                Num(rat)\n            ])\n        }\n    }\n}\n\nfunc tanEval(coef, f) {\n    return f if (coef == 1)\n    return -tanEval(-coef, f) if (coef < 0)\n    var ca = coef>>1\n    var cb = (coef - ca)\n    var (a, b) = (tanEval(ca, f), tanEval(cb, f))\n    (a + b) / (1 - a*b)\n}\n\nfunc tans(xs) {\n    var xslen = xs.len\n    return tanEval(xs[0]...) if (xslen == 1)\n    var (aa, bb) = xs.part(xslen>>1)\n    var (a, b) = (tans(aa), tans(bb))\n    (a + b) / (1 - a*b)\n}\n\nvar machins = equationtext.lines.map(parse_eqn)\n\nfor machin,eqn in (machins ~Z equationtext.lines) {\n    var ans = tans(machin)\n    printf(\"%5s: %s\\n\", (ans == 1 ? 'OK' : 'ERROR'), eqn)\n}\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 389613, "name": "Find Chess960 starting position identifier", "source": "Translate Ruby to Python: CHESS_PIECES = %w<\u2656\u2658\u2657\u2655\u2654 \u265c\u265e\u265d\u265b\u265a>\ndef chess960_to_spid(pos)\n  start_str = pos.tr(CHESS_PIECES.join, \"RNBQKRNBQK\")\n  \n  s = start_str.delete(\"QB\")\n  n = [0,1,2,3,4].combination(2).to_a.index( [s.index(\"N\"), s.rindex(\"N\")] )\n  \n  q = start_str.delete(\"B\").index(\"Q\")\n  \n  bs = start_str.index(\"B\"), start_str.rindex(\"B\")\n  d = bs.detect(&:even?).div(2)\n  l = bs.detect(&:odd? ).div(2)\n\n  96*n + 16*q + 4*d + l\nend\n\n%w<QNRBBNKR RNBQKBNR RQNBBKRN RNQBBKRN>.each_with_index do |array, i|\n  pieces = array.tr(\"RNBQK\", CHESS_PIECES[i%2])\n  puts \"\nend\n", "target": "\ndef validate_position(candidate: str):\n    assert (\n        len(candidate) == 8\n    ), f\"candidate position has invalide len = {len(candidate)}\"\n\n    valid_pieces = {\"R\": 2, \"N\": 2, \"B\": 2, \"Q\": 1, \"K\": 1}\n    assert {\n        piece for piece in candidate\n    } == valid_pieces.keys(), f\"candidate position contains invalid pieces\"\n    for piece_type in valid_pieces.keys():\n        assert (\n            candidate.count(piece_type) == valid_pieces[piece_type]\n        ), f\"piece type '{piece_type}' has invalid count\"\n\n    bishops_pos = [index for index, \n                   value in enumerate(candidate) if value == \"B\"]\n    assert (\n        bishops_pos[0] % 2 != bishops_pos[1] % 2\n    ), f\"candidate position has both bishops in the same color\"\n\n    assert [piece for piece in candidate if piece in \"RK\"] == [\n        \"R\",\n        \"K\",\n        \"R\",\n    ], \"candidate position has K outside of RR\"\n\n\ndef calc_position(start_pos: str):\n    try:\n        validate_position(start_pos)\n    except AssertionError:\n        raise AssertionError\n    \n    subset_step1 = [piece for piece in start_pos if piece not in \"QB\"]\n    nights_positions = [\n        index for index, value in enumerate(subset_step1) if value == \"N\"\n    ]\n    nights_table = {\n        (0, 1): 0,\n        (0, 2): 1,\n        (0, 3): 2,\n        (0, 4): 3,\n        (1, 2): 4,\n        (1, 3): 5,\n        (1, 4): 6,\n        (2, 3): 7,\n        (2, 4): 8,\n        (3, 4): 9,\n    }\n    N = nights_table.get(tuple(nights_positions))\n\n    \n    subset_step2 = [piece for piece in start_pos if piece != \"B\"]\n    Q = subset_step2.index(\"Q\")\n\n    \n    dark_squares = [\n        piece for index, piece in enumerate(start_pos) if index in range(0, 9, 2)\n    ]\n    light_squares = [\n        piece for index, piece in enumerate(start_pos) if index in range(1, 9, 2)\n    ]\n    D = dark_squares.index(\"B\")\n    L = light_squares.index(\"B\")\n\n    return 4 * (4 * (6*N + Q) + D) + L\n\nif __name__ == '__main__':\n    for example in [\"QNRBBNKR\", \"RNBQKBNR\", \"RQNBBKRN\", \"RNQBBKRN\"]:\n        print(f'Position: {example}; Chess960 PID= {calc_position(example)}')\n"}
{"id": 389614, "name": "Names to numbers", "source": "Translate Ruby to Python: require 'number_names'\n\ndef int_from_words(num)\n  words = num.downcase.gsub(/(,| and |-)/,' ').split\n  if words[0] =~ /(minus|negative)/\n    negmult = -1\n    words.shift\n  else\n    negmult = 1\n  end\n  small, total = 0, 0\n  for word in words\n    case word\n    when *SMALL\n      small += SMALL.index(word)\n    when *TENS\n      small += TENS.index(word) * 10\n    when 'hundred'\n      small *= 100\n    when 'thousand'\n      total += small * 1000\n      small = 0\n    when *BIG\n      total += small * 1000 ** BIG.index(word)\n      small = 0\n    else\n      raise ArgumentError, \"Don't understand %s part of %s\" % [word, num]\n    end\n  end\n  negmult * (total + small)\nend\n", "target": "from spell_integer import spell_integer, SMALL, TENS, HUGE\n\ndef int_from_words(num):\n    words = num.replace(',','').replace(' and ', ' ').replace('-', ' ').split()\n    if words[0] == 'minus':\n        negmult = -1\n        words.pop(0)\n    else:\n        negmult = 1\n    small, total = 0, 0\n    for word in words:\n        if word in SMALL:\n            small += SMALL.index(word)\n        elif word in TENS:\n            small += TENS.index(word) * 10\n        elif word == 'hundred':\n            small *= 100\n        elif word == 'thousand':\n            total += small * 1000\n            small = 0\n        elif word in HUGE:\n            total += small * 1000 ** HUGE.index(word)\n            small = 0\n        else:\n            raise ValueError(\"Don't understand %r part of %r\" % (word, num))\n    return negmult * (total + small)\n\n\nif __name__ == '__main__':\n    \n    for n in range(-10000, 10000, 17):\n        assert n == int_from_words(spell_integer(n))\n\n    for n in range(20):\n        assert 13**n == int_from_words(spell_integer(13**n))\n    \n    print('\\n\n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%+4i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n        n //= -10\n    txt = spell_integer(n)\n    num = int_from_words(txt)\n    print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')\n"}
{"id": 389615, "name": "The ISAAC cipher", "source": "Translate Ruby to Python: require('Math::Random::ISAAC')\n\nfunc xor_isaac(key, msg) {\n  var rng = %O<Math::Random::ISAAC>.new(unpack('C*', key))\n\n  msg.chars\u00bbord()\u00bb                                          \\\n    -> \u00bb^\u00ab 256.of{ rng.irand % 95 + 32 }.last(msg.len).flip \\\n    -> \u00ab%\u00ab '%02X' -> join\n}\n\nvar msg = 'a Top Secret secret'\nvar key = 'this is my secret key'\n\nvar enc = xor_isaac(key, msg)\nvar dec = xor_isaac(key, pack('H*', enc))\n\nsay \"Message: \nsay \"Key   \u00a0: \nsay \"XOR   \u00a0: \nsay \"XOR dcr: \n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 389616, "name": "The ISAAC cipher", "source": "Translate Ruby to Python: require('Math::Random::ISAAC')\n\nfunc xor_isaac(key, msg) {\n  var rng = %O<Math::Random::ISAAC>.new(unpack('C*', key))\n\n  msg.chars\u00bbord()\u00bb                                          \\\n    -> \u00bb^\u00ab 256.of{ rng.irand % 95 + 32 }.last(msg.len).flip \\\n    -> \u00ab%\u00ab '%02X' -> join\n}\n\nvar msg = 'a Top Secret secret'\nvar key = 'this is my secret key'\n\nvar enc = xor_isaac(key, msg)\nvar dec = xor_isaac(key, pack('H*', enc))\n\nsay \"Message: \nsay \"Key   \u00a0: \nsay \"XOR   \u00a0: \nsay \"XOR dcr: \n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 389617, "name": "Permutations_Rank of a permutation", "source": "Translate Ruby to Python: class Permutation\n  include Enumerable\n  attr_reader :num_elements, :size\n  \n  def initialize(num_elements)\n    @num_elements = num_elements\n    @size = fact(num_elements)\n  end\n  \n  def each\n    return self.to_enum unless block_given?\n    (0...@size).each{|i| yield unrank(i)}\n  end\n  \n  def unrank(r)  \n    pi = (0...num_elements).to_a\n    (@num_elements-1).downto(1) do |n|\n      s, r = r.divmod(fact(n))\n      pi[n], pi[s] = pi[s], pi[n]\n    end\n    pi\n  end\n  \n  def rank(pi)  \n    pi = pi.dup\n    pi1 = pi.zip(0...pi.size).sort.map(&:last)\n    (pi.size-1).downto(0).inject(0) do |memo,i|\n      pi[i], pi[pi1[i]] = pi[pi1[i]], (s = pi[i])\n      pi1[s], pi1[i] = pi1[i], pi1[s]\n      memo += s * fact(i)\n    end\n  end\n  \n  private\n  def fact(n)\n    n.zero? ? 1 : n.downto(1).inject(:*)\n  end\nend\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 389618, "name": "Permutations_Rank of a permutation", "source": "Translate Ruby to Python: class Permutation\n  include Enumerable\n  attr_reader :num_elements, :size\n  \n  def initialize(num_elements)\n    @num_elements = num_elements\n    @size = fact(num_elements)\n  end\n  \n  def each\n    return self.to_enum unless block_given?\n    (0...@size).each{|i| yield unrank(i)}\n  end\n  \n  def unrank(r)  \n    pi = (0...num_elements).to_a\n    (@num_elements-1).downto(1) do |n|\n      s, r = r.divmod(fact(n))\n      pi[n], pi[s] = pi[s], pi[n]\n    end\n    pi\n  end\n  \n  def rank(pi)  \n    pi = pi.dup\n    pi1 = pi.zip(0...pi.size).sort.map(&:last)\n    (pi.size-1).downto(0).inject(0) do |memo,i|\n      pi[i], pi[pi1[i]] = pi[pi1[i]], (s = pi[i])\n      pi1[s], pi1[i] = pi1[i], pi1[s]\n      memo += s * fact(i)\n    end\n  end\n  \n  private\n  def fact(n)\n    n.zero? ? 1 : n.downto(1).inject(:*)\n  end\nend\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 389619, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to Python: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 389620, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to Python: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 389621, "name": "Stirling numbers of the second kind", "source": "Translate Ruby to Python: @memo = {}\n\ndef sterling2(n, k)\n  key = [n,k]\n  return @memo[key] if @memo.key?(key)\n  return 1 if n.zero? and k.zero?\n  return 0 if n.zero? or  k.zero?\n  return 1 if n == k\n  return 0 if k > n\n  res = k * sterling2(n-1, k) + sterling2(n - 1, k-1)\n  @memo[key] = res\nend\n\nr = (0..12)\nputs \"Sterling2 numbers:\"\nputs \"n/k \n \nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n \nputs \"\\nMaximum value from the sterling2(100, k)\";\nputs (1..100).map{|a| sterling2(100,a)}.max\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 389622, "name": "Stirling numbers of the second kind", "source": "Translate Ruby to Python: @memo = {}\n\ndef sterling2(n, k)\n  key = [n,k]\n  return @memo[key] if @memo.key?(key)\n  return 1 if n.zero? and k.zero?\n  return 0 if n.zero? or  k.zero?\n  return 1 if n == k\n  return 0 if k > n\n  res = k * sterling2(n-1, k) + sterling2(n - 1, k-1)\n  @memo[key] = res\nend\n\nr = (0..12)\nputs \"Sterling2 numbers:\"\nputs \"n/k \n \nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n \nputs \"\\nMaximum value from the sterling2(100, k)\";\nputs (1..100).map{|a| sterling2(100,a)}.max\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 389623, "name": "Cipolla's algorithm", "source": "Translate Ruby to Python: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "\n\ndef convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))\n"}
{"id": 389624, "name": "Cipolla's algorithm", "source": "Translate Ruby to Python: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "\n\ndef convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))\n"}
{"id": 389625, "name": "Pierpont primes", "source": "Translate Ruby to Python: require 'gmp'\n\ndef  smooth_generator(ar)\n  return to_enum(__method__, ar) unless block_given?\n  next_smooth = 1\n  queues = ar.map{|num| [num, []] }\n  loop do\n    yield next_smooth\n    queues.each {|m, queue| queue << next_smooth * m}\n    next_smooth = queues.collect{|m, queue| queue.first}.min\n    queues.each{|m, queue| queue.shift if queue.first == next_smooth }\n  end\nend\n  \ndef pierpont(num = 1)\n    return to_enum(__method__, num) unless block_given?\n    smooth_generator([2,3]).each{|smooth| yield smooth+num if GMP::Z(smooth + num).probab_prime? > 0}\nend\n\ndef puts_cols(ar, n=10)\n  ar.each_slice(n).map{|slice|puts  slice.map{|n| n.to_s.rjust(10)}.join }\nend\n\nn, m = 50, 250\nputs \"First \nputs_cols(pierpont.take(n))\nputs \"\nputs \"First \nputs_cols(pierpont(-1).take(n))\nputs \"\n", "target": "import random\n\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef pierpont(ulim, vlim, first):\n    p = 0\n    p2 = 1\n    p3 = 1\n    pp = []\n    for v in xrange(vlim):\n        for u in xrange(ulim):\n            p = p2 * p3\n            if first:\n                p = p + 1\n            else:\n                p = p - 1\n            if is_Prime(p):\n                pp.append(p)\n            p2 = p2 * 2\n        p3 = p3 * 3\n        p2 = 1\n    pp.sort()\n    return pp\n\ndef main():\n    print \"First 50 Pierpont primes of the first kind:\"\n    pp = pierpont(120, 80, True)\n    for i in xrange(50):\n        print \"%8d \" % pp[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"First 50 Pierpont primes of the second kind:\"\n    pp2 = pierpont(120, 80, False)\n    for i in xrange(50):\n        print \"%8d \" % pp2[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"250th Pierpont prime of the first kind:\", pp[249]\n    print \"250th Pierpont prime of the second kind:\", pp2[249]\n\nmain()\n"}
{"id": 389626, "name": "N-smooth numbers", "source": "Translate Ruby to Python: require \"big\"\n\ndef prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt_n = Math.isqrt(n)  \n  pc = typeof(n).new(5)\n  while pc <= sqrt_n\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\ndef gen_primes(a, b)\n    (a..b).select { |pc| pc if prime? pc }\nend\n\ndef nsmooth(n, limit)\n    raise \"Exception(n or limit)\" if n < 2 || n > 521 || limit < 1\n    raise \"Exception(must be a prime number: n)\" unless prime? n\n    \n    primes = gen_primes(2, n)\n    ns = [0.to_big_i] * limit\n    ns[0] = 1.to_big_i\n    nextp = primes[0..primes.index(n)].map { |prm| prm.to_big_i }\n\n    indices = [0] * nextp.size\n    (1...limit).each do |m|\n        ns[m] = nextp.min\n        (0...indices.size).each do |i|\n            if ns[m] == nextp[i]\n                indices[i] += 1\n                nextp[i] = primes[i] * ns[indices[i]]\n            end\n        end\n    end\n    ns\nend\n\ngen_primes(2, 29).each do |prime|\n    print \"The first 25 \n    print nsmooth(prime, 25)\n    puts\nend\nputs\ngen_primes(3, 29).each do |prime|\n    print \"The 3000 to 3202 \n    print nsmooth(prime, 3002)[2999..]\n    puts\nend\nputs\ngen_primes(503, 521).each do |prime|\n    print \"The 30,000 to 30,019 \n    print nsmooth(prime, 30019)[29999..]\n    puts\nend\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\ndef isPrime(n):\n    if n < 2:\n        return False\n\n    for i in primes:\n        if n == i:\n            return True\n        if n % i == 0:\n            return False\n        if i * i > n:\n            return True\n    print \"Oops,\", n, \" is too large\"\n\ndef init():\n    s = 24\n    while s < 600:\n        if isPrime(s - 1) and s - 1 > primes[-1]:\n            primes.append(s - 1)\n        if isPrime(s + 1) and s + 1 > primes[-1]:\n            primes.append(s + 1)\n        s += 6\n\ndef nsmooth(n, size):\n    if n < 2 or n > 521:\n        raise Exception(\"n\")\n    if size < 1:\n        raise Exception(\"n\")\n\n    bn = n\n    ok = False\n    for prime in primes:\n        if bn == prime:\n            ok = True\n            break\n    if not ok:\n        raise Exception(\"must be a prime number: n\")\n\n    ns = [0] * size\n    ns[0] = 1\n\n    next = []\n    for prime in primes:\n        if prime > bn:\n            break\n        next.append(prime)\n\n    indicies = [0] * len(next)\n    for m in xrange(1, size):\n        ns[m] = min(next)\n        for i in xrange(0, len(indicies)):\n            if ns[m] == next[i]:\n                indicies[i] += 1\n                next[i] = primes[i] * ns[indicies[i]]\n\n    return ns\n\ndef main():\n    init()\n\n    for p in primes:\n        if p >= 30:\n            break\n        print \"The first\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 25)\n        print\n\n    for p in primes[1:]:\n        if p >= 30:\n            break\n        print \"The 3000 to 3202\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 3002)[2999:]\n        print\n\n    for p in [503, 509, 521]:\n        print \"The 30000 to 3019\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 30019)[29999:]\n        print\n\nmain()\n"}
{"id": 389627, "name": "Partition an integer x into n primes", "source": "Translate Ruby to Python: require \"prime\"\n\ndef prime_partition(x, n)\n  Prime.each(x).to_a.combination(n).detect{|primes| primes.sum == x}\nend\n\nTESTCASES = [[99809, 1], [18, 2], [19, 3], [20, 4], [2017, 24], \n             [22699, 1], [22699, 2], [22699, 3], [22699, 4], [40355, 3]]\n\nTESTCASES.each do |prime, num|\n  res = prime_partition(prime, num) \n  str = res.nil? ? \"no solution\" : res.join(\" + \")\n  puts  \"Partitioned \nend\n", "target": "from itertools import combinations as cmb\n\n\ndef isP(n):\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))\n\n\ndef genP(n):\n    p = [2]\n    p.extend([x for x in range(3, n + 1, 2) if isP(x)])\n    return p\n\n\ndata = [\n    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),\n    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]\n\n\nfor n, cnt in data:\n    ci = iter(cmb(genP(n), cnt))\n    while True:\n        try:\n            c = next(ci)\n            if sum(c) == n:\n                print(' '.join(\n                    [repr((n, cnt)), \"->\", '+'.join(str(s) for s in c)]\n                ))\n                break\n        except StopIteration:\n            print(repr((n, cnt)) + \" -> Not possible\")\n            break\n"}
{"id": 389628, "name": "Stirling numbers of the first kind", "source": "Translate Ruby to Python: $cache = {}\ndef sterling1(n, k)\n    if n == 0 and k == 0 then\n        return 1\n    end\n    if n > 0 and k == 0 then\n        return 0\n    end\n    if k > n then\n        return 0\n    end\n    key = [n, k]\n    if $cache[key] then\n        return $cache[key]\n    end\n    value = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n    $cache[key] = value\n    return value\nend\n\nMAX = 12\ndef main\n    print \"Unsigned Stirling numbers of the first kind:\\n\"\n    print \"n/k\"\n    for n in 0 .. MAX\n        print \"%10d\" % [n]\n    end\n    print \"\\n\"\n\n    for n in 0 .. MAX\n        print \"%-3d\" % [n]\n        for k in 0 .. n\n            print \"%10d\" % [sterling1(n, k)]\n        end\n        print \"\\n\"\n    end\n\n    print \"The maximum value of S1(100, k) =\\n\"\n    previous = 0\n    for k in 1 .. 100\n        current = sterling1(100, k)\n        if previous < current then\n            previous = current\n        else\n            print previous, \"\\n\"\n            print \"(%d digits, k = %d)\\n\" % [previous.to_s.length, k - 1]\n            break\n        end\n    end\nend\n\nmain()\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 389629, "name": "Stirling numbers of the first kind", "source": "Translate Ruby to Python: $cache = {}\ndef sterling1(n, k)\n    if n == 0 and k == 0 then\n        return 1\n    end\n    if n > 0 and k == 0 then\n        return 0\n    end\n    if k > n then\n        return 0\n    end\n    key = [n, k]\n    if $cache[key] then\n        return $cache[key]\n    end\n    value = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n    $cache[key] = value\n    return value\nend\n\nMAX = 12\ndef main\n    print \"Unsigned Stirling numbers of the first kind:\\n\"\n    print \"n/k\"\n    for n in 0 .. MAX\n        print \"%10d\" % [n]\n    end\n    print \"\\n\"\n\n    for n in 0 .. MAX\n        print \"%-3d\" % [n]\n        for k in 0 .. n\n            print \"%10d\" % [sterling1(n, k)]\n        end\n        print \"\\n\"\n    end\n\n    print \"The maximum value of S1(100, k) =\\n\"\n    previous = 0\n    for k in 1 .. 100\n        current = sterling1(100, k)\n        if previous < current then\n            previous = current\n        else\n            print previous, \"\\n\"\n            print \"(%d digits, k = %d)\\n\" % [previous.to_s.length, k - 1]\n            break\n        end\n    end\nend\n\nmain()\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 389630, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to Python: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 389631, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to Python: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 389632, "name": "Bilinear interpolation", "source": "Translate Ruby to Python: require('Imager')\n\nfunc scale(img, scaleX, scaleY) {\n    var (width, height) = (img.getwidth, img.getheight)\n    var (newWidth, newHeight) = (int(width*scaleX), int(height*scaleY))\n\n    var out = %O<Imager>.new(xsize => newWidth, ysize => newHeight)\n\n    var lerp = { |s, e, t|\n        s + t*(e-s)\n    }\n\n    var blerp = { |c00, c10, c01, c11, tx, ty|\n        lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty)\n    }\n\n    for x,y in (^newWidth ~X ^newHeight) {\n        var gxf = (x/newWidth  * (width  - 1))\n        var gyf = (y/newHeight * (height - 1))\n\n        var gx = gxf.int\n        var gy = gyf.int\n\n        var *c00 = img.getpixel(x => gx,   y => gy  ).rgba\n        var *c10 = img.getpixel(x => gx+1, y => gy  ).rgba\n        var *c01 = img.getpixel(x => gx,   y => gy+1).rgba\n        var *c11 = img.getpixel(x => gx+1, y => gy+1).rgba\n\n        var rgb = 3.of { |i|\n            blerp(c00[i], c10[i], c01[i], c11[i], gxf - gx, gyf - gy).int\n        }\n\n        out.setpixel(x => x, y => y, color => rgb)\n    }\n\n    return out\n}\n\nvar img = %O<Imager>.new(file => \"input.png\")\nvar out = scale(img, 1.6, 1.6)\nout.write(file => \"output.png\")\n", "target": "\nimport numpy as np\nfrom scipy.misc import imread, imshow\nfrom scipy import ndimage\n\ndef GetBilinearPixel(imArr, posX, posY):\n\tout = []\n\n\t\n\tmodXi = int(posX)\n\tmodYi = int(posY)\n\tmodXf = posX - modXi\n\tmodYf = posY - modYi\n\tmodXiPlusOneLim = min(modXi+1,imArr.shape[1]-1)\n\tmodYiPlusOneLim = min(modYi+1,imArr.shape[0]-1)\n\n\t\n\tfor chan in range(imArr.shape[2]):\n\t\tbl = imArr[modYi, modXi, chan]\n\t\tbr = imArr[modYi, modXiPlusOneLim, chan]\n\t\ttl = imArr[modYiPlusOneLim, modXi, chan]\n\t\ttr = imArr[modYiPlusOneLim, modXiPlusOneLim, chan]\n\t\n\t\t\n\t\tb = modXf * br + (1. - modXf) * bl\n\t\tt = modXf * tr + (1. - modXf) * tl\n\t\tpxf = modYf * t + (1. - modYf) * b\n\t\tout.append(int(pxf+0.5))\n\n\treturn out\n\nif __name__==\"__main__\":\n\t\n\tim = imread(\"test.jpg\", mode=\"RGB\")\n\tenlargedShape = list(map(int, [im.shape[0]*1.6, im.shape[1]*1.6, im.shape[2]]))\n\tenlargedImg = np.empty(enlargedShape, dtype=np.uint8)\n\trowScale = float(im.shape[0]) / float(enlargedImg.shape[0])\n\tcolScale = float(im.shape[1]) / float(enlargedImg.shape[1])\n\n\tfor r in range(enlargedImg.shape[0]):\n\t\tfor c in range(enlargedImg.shape[1]):\n\t\t\torir = r * rowScale \n\t\t\toric = c * colScale\n\t\t\tenlargedImg[r, c] = GetBilinearPixel(im, oric, orir)\n\n\timshow(enlargedImg)\n"}
{"id": 389633, "name": "Vector", "source": "Translate Ruby to Python: class Vector\n  def self.polar(r, angle=0)\n    new(r*Math.cos(angle), r*Math.sin(angle))\n  end\n  \n  attr_reader :x, :y\n  \n  def initialize(x, y)\n    raise TypeError unless x.is_a?(Numeric) and y.is_a?(Numeric)\n    @x, @y = x, y\n  end\n  \n  def +(other)\n    raise TypeError if self.class != other.class\n    self.class.new(@x + other.x, @y + other.y)\n  end\n  \n  def -@;       self.class.new(-@x, -@y)        end\n  def -(other)  self + (-other)                 end\n  \n  def *(scalar)\n    raise TypeError unless scalar.is_a?(Numeric)\n    self.class.new(@x * scalar, @y * scalar)\n  end\n  \n  def /(scalar)\n    raise TypeError unless scalar.is_a?(Numeric) and scalar.nonzero?\n    self.class.new(@x / scalar, @y / scalar)\n  end\n  \n  def r;        @r     ||= Math.hypot(@x, @y)   end\n  def angle;    @angle ||= Math.atan2(@y, @x)   end\n  def polar;    [r, angle]                      end\n  def rect;     [@x, @y]                        end\n  def to_s;     \"\n  alias inspect to_s\nend\n\np v = Vector.new(1,1)                   \np w = Vector.new(3,4)                   \np v + w                                 \np v - w                                 \np -v                                    \np w * 5                                 \np w / 2.0                               \np w.x                                   \np w.y                                   \np v.polar                               \np w.polar                               \np z = Vector.polar(1, Math::PI/2)       \np z.rect                                \np z.polar                               \np z = Vector.polar(-2, Math::PI/4)      \np z.polar                               \n", "target": "v1 = PVector(5, 7)\nv2 = PVector(2, 3)\n\nprintln('{} {} {} {}\\n'.format( v1.x, v1.y, v1.mag(), v1.heading()))\n\n\nprintln(v1 + v2) \nprintln(v1 - v2) \nprintln(v1 * 11) \nprintln(v1 / 2)  \nprintln('')\n\n\nprintln(v1.sub(v1))  \nprintln(v1.add(v2))  \nprintln(v1.mult(10)) \nprintln(v1.div(10))  \n"}
{"id": 389634, "name": "Elliptic curve arithmetic", "source": "Translate Ruby to Python: module EC {\n\n    var A = 0\n    var B = 7\n\n    class Horizon {\n        method to_s {\n            \"EC Point at horizon\"\n        }\n\n        method *(_) {\n            self\n        }\n\n        method -(_) {\n            self\n        }\n    }\n\n    class Point(Number x, Number y) {\n        method to_s {\n            \"EC Point at x=\n        }\n\n        method neg {\n            Point(x, -y)\n        }\n\n        method -(Point p) {\n            self + -p\n        }\n\n        method +(Point p) {\n\n            if (x == p.x) {\n                return (y == p.y ? self*2 : Horizon())\n            }\n            else {\n                var slope = (p.y - y)/(p.x - x)\n                var x2 = (slope**2 - x - p.x)\n                var y2 = (slope * (x - x2) - y)\n                Point(x2, y2)\n            }\n        }\n\n        method +(Horizon _) {\n            self\n        }\n\n        method *((0)) {\n            Horizon()\n        }\n\n        method *((1)) {\n            self\n        }\n\n        method *((2)) {\n            var l = (3 * x**2 + A)/(2 * y)\n            var x2 = (l**2 - 2*x)\n            var y2 = (l * (x - x2) - y)\n            Point(x2, y2)\n        }\n\n        method *(Number n) {\n            2*(self * (n>>1)) + self*(n % 2)\n        }\n    }\n\n    class Horizon {\n        method +(Point p) {\n            p\n        }\n    }\n\n    class Number {\n        method +(Point p) {\n            p + self\n        }\n        method *(Point p) {\n            p * self\n        }\n        method *(Horizon h) {\n            h\n        }\n        method -(Point p) {\n            -p + self\n        }\n    }\n}\n\nsay var p = with(1) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var q = with(2) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var s = (p + q)\n\nsay (\"checking alignment:  \", abs((p.x - q.x)*(-s.y - q.y) - (p.y - q.y)*(s.x - q.x)) < 1e-20)\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 389635, "name": "Elliptic curve arithmetic", "source": "Translate Ruby to Python: module EC {\n\n    var A = 0\n    var B = 7\n\n    class Horizon {\n        method to_s {\n            \"EC Point at horizon\"\n        }\n\n        method *(_) {\n            self\n        }\n\n        method -(_) {\n            self\n        }\n    }\n\n    class Point(Number x, Number y) {\n        method to_s {\n            \"EC Point at x=\n        }\n\n        method neg {\n            Point(x, -y)\n        }\n\n        method -(Point p) {\n            self + -p\n        }\n\n        method +(Point p) {\n\n            if (x == p.x) {\n                return (y == p.y ? self*2 : Horizon())\n            }\n            else {\n                var slope = (p.y - y)/(p.x - x)\n                var x2 = (slope**2 - x - p.x)\n                var y2 = (slope * (x - x2) - y)\n                Point(x2, y2)\n            }\n        }\n\n        method +(Horizon _) {\n            self\n        }\n\n        method *((0)) {\n            Horizon()\n        }\n\n        method *((1)) {\n            self\n        }\n\n        method *((2)) {\n            var l = (3 * x**2 + A)/(2 * y)\n            var x2 = (l**2 - 2*x)\n            var y2 = (l * (x - x2) - y)\n            Point(x2, y2)\n        }\n\n        method *(Number n) {\n            2*(self * (n>>1)) + self*(n % 2)\n        }\n    }\n\n    class Horizon {\n        method +(Point p) {\n            p\n        }\n    }\n\n    class Number {\n        method +(Point p) {\n            p + self\n        }\n        method *(Point p) {\n            p * self\n        }\n        method *(Horizon h) {\n            h\n        }\n        method -(Point p) {\n            -p + self\n        }\n    }\n}\n\nsay var p = with(1) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var q = with(2) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var s = (p + q)\n\nsay (\"checking alignment:  \", abs((p.x - q.x)*(-s.y - q.y) - (p.y - q.y)*(s.x - q.x)) < 1e-20)\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 389636, "name": "Chebyshev coefficients", "source": "Translate Ruby to Python: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "import math\n\ndef test_func(x):\n    return math.cos(x)\n\ndef mapper(x, min_x, max_x, min_to, max_to):\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\n\ndef cheb_coef(func, n, min, max):\n    coef = [0.0] * n\n    for i in xrange(n):\n        f = func(mapper(math.cos(math.pi * (i + 0.5) / n), -1, 1, min, max)) * 2 / n\n        for j in xrange(n):\n            coef[j] += f * math.cos(math.pi * j * (i + 0.5) / n)\n    return coef\n\ndef cheb_approx(x, n, min, max, coef):\n    a = 1\n    b = mapper(x, min, max, -1, 1)\n    c = float('nan')\n    res = coef[0] / 2 + coef[1] * b\n\n    x = 2 * b\n    i = 2\n    while i < n:\n        c = x * b - a\n        res = res + coef[i] * c\n        (a, b) = (b, c)\n        i += 1\n\n    return res\n\ndef main():\n    N = 10\n    min = 0\n    max = 1\n    c = cheb_coef(test_func, N, min, max)\n\n    print \"Coefficients:\"\n    for i in xrange(N):\n        print \" % lg\" % c[i]\n\n    print \"\\n\\nApproximation:\\n    x      func(x)       approx      diff\"\n    for i in xrange(20):\n        x = mapper(i, 0.0, 20.0, min, max)\n        f = test_func(x)\n        approx = cheb_approx(x, N, min, max, c)\n        print \"%1.3f %10.10f %10.10f % 4.2e\" % (x, f, approx, approx - f)\n\n    return None\n\nmain()\n"}
{"id": 389637, "name": "Chebyshev coefficients", "source": "Translate Ruby to Python: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "import math\n\ndef test_func(x):\n    return math.cos(x)\n\ndef mapper(x, min_x, max_x, min_to, max_to):\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\n\ndef cheb_coef(func, n, min, max):\n    coef = [0.0] * n\n    for i in xrange(n):\n        f = func(mapper(math.cos(math.pi * (i + 0.5) / n), -1, 1, min, max)) * 2 / n\n        for j in xrange(n):\n            coef[j] += f * math.cos(math.pi * j * (i + 0.5) / n)\n    return coef\n\ndef cheb_approx(x, n, min, max, coef):\n    a = 1\n    b = mapper(x, min, max, -1, 1)\n    c = float('nan')\n    res = coef[0] / 2 + coef[1] * b\n\n    x = 2 * b\n    i = 2\n    while i < n:\n        c = x * b - a\n        res = res + coef[i] * c\n        (a, b) = (b, c)\n        i += 1\n\n    return res\n\ndef main():\n    N = 10\n    min = 0\n    max = 1\n    c = cheb_coef(test_func, N, min, max)\n\n    print \"Coefficients:\"\n    for i in xrange(N):\n        print \" % lg\" % c[i]\n\n    print \"\\n\\nApproximation:\\n    x      func(x)       approx      diff\"\n    for i in xrange(20):\n        x = mapper(i, 0.0, 20.0, min, max)\n        f = test_func(x)\n        approx = cheb_approx(x, N, min, max, c)\n        print \"%1.3f %10.10f %10.10f % 4.2e\" % (x, f, approx, approx - f)\n\n    return None\n\nmain()\n"}
{"id": 389638, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to Python: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 389639, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to Python: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 389640, "name": "Card shuffles", "source": "Translate Ruby to Python: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "import random\n\ndef riffleShuffle(va, flips):\n    nl = va\n    for n in range(flips):\n        \n        cutPoint = len(nl)/2 + random.choice([-1, 1]) * random.randint(0, len(va)/10)\n\n        \n        left = nl[0:cutPoint]\n        right = nl[cutPoint:]\n\n        del nl[:]\n        while (len(left) > 0 and len(right) > 0):\n            \n            \n            \n            if (random.uniform(0, 1) >= len(left) / len(right) / 2):\n                nl.append(right.pop(0))\n            else:\n                nl.append(left.pop(0))\n        if (len(left) > 0):\n            nl = nl + left\n        if (len(right) > 0):\n            nl = nl + right\n    return nl\n\ndef overhandShuffle(va, passes):\n    mainHand = va\n    for n in range(passes):\n        otherHand = []\n        while (len(mainHand) > 0):\n            \n            cutSize = random.randint(0, len(va) / 5) + 1\n            temp = []\n\n            \n            i=0\n            while (i<cutSize and len(mainHand) > 0):\n                temp.append(mainHand.pop(0))\n                i = i + 1\n\n            \n            if (random.uniform(0, 1) >= 0.1):\n                \n                otherHand = temp + otherHand\n            else:\n                otherHand = otherHand + temp\n        \n        mainHand = otherHand\n    return mainHand\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 10)\nprint\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 1)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 10)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 1)\nprint\n\nprint \"Library shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nrandom.shuffle(nums)\nprint nums\nprint\n"}
{"id": 389641, "name": "Card shuffles", "source": "Translate Ruby to Python: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "import random\n\ndef riffleShuffle(va, flips):\n    nl = va\n    for n in range(flips):\n        \n        cutPoint = len(nl)/2 + random.choice([-1, 1]) * random.randint(0, len(va)/10)\n\n        \n        left = nl[0:cutPoint]\n        right = nl[cutPoint:]\n\n        del nl[:]\n        while (len(left) > 0 and len(right) > 0):\n            \n            \n            \n            if (random.uniform(0, 1) >= len(left) / len(right) / 2):\n                nl.append(right.pop(0))\n            else:\n                nl.append(left.pop(0))\n        if (len(left) > 0):\n            nl = nl + left\n        if (len(right) > 0):\n            nl = nl + right\n    return nl\n\ndef overhandShuffle(va, passes):\n    mainHand = va\n    for n in range(passes):\n        otherHand = []\n        while (len(mainHand) > 0):\n            \n            cutSize = random.randint(0, len(va) / 5) + 1\n            temp = []\n\n            \n            i=0\n            while (i<cutSize and len(mainHand) > 0):\n                temp.append(mainHand.pop(0))\n                i = i + 1\n\n            \n            if (random.uniform(0, 1) >= 0.1):\n                \n                otherHand = temp + otherHand\n            else:\n                otherHand = otherHand + temp\n        \n        mainHand = otherHand\n    return mainHand\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 10)\nprint\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 1)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 10)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 1)\nprint\n\nprint \"Library shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nrandom.shuffle(nums)\nprint nums\nprint\n"}
{"id": 389642, "name": "Faulhaber's triangle", "source": "Translate Ruby to Python: class Frac\n    attr_accessor:num\n    attr_accessor:denom\n\n    def initialize(n,d)\n        if d == 0 then\n            raise ArgumentError.new('d cannot be zero')\n        end\n\n        nn = n\n        dd = d\n        if nn == 0 then\n            dd = 1\n        elsif dd < 0 then\n            nn = -nn\n            dd = -dd\n        end\n\n        g = nn.abs.gcd(dd.abs)\n        if g > 1 then\n            nn = nn / g\n            dd = dd / g\n        end\n\n        @num = nn\n        @denom = dd\n    end\n\n    def to_s\n        if self.denom == 1 then\n            return self.num.to_s\n        else\n            return \"%d/%d\" % [self.num, self.denom]\n        end\n    end\n\n    def -@\n        return Frac.new(-self.num, self.denom)\n    end\n\n    def +(rhs)\n        return Frac.new(self.num * rhs.denom + self.denom * rhs.num, rhs.denom * self.denom)\n    end\n    def -(rhs)\n        return Frac.new(self.num * rhs.denom - self.denom * rhs.num, rhs.denom * self.denom)\n    end\n\n    def *(rhs)\n        return Frac.new(self.num * rhs.num, rhs.denom * self.denom)\n    end\nend\n\nFRAC_ZERO = Frac.new(0, 1)\nFRAC_ONE  = Frac.new(1, 1)\n\ndef bernoulli(n)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n\n    a = Array.new(n + 1)\n    a[0] = FRAC_ZERO\n\n    for m in 0 .. n do\n        a[m] = Frac.new(1, m + 1)\n        m.downto(1) do |j|\n            a[j - 1] = (a[j - 1] - a[j]) * Frac.new(j, 1)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef binomial(n, k)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n    if k < 0 then\n        raise ArgumentError.new('k cannot be negative')\n    end\n    if n < k then\n        raise ArgumentError.new('n cannot be less than k')\n    end\n\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k + 1 .. n do\n        num = num * i\n    end\n\n    den = 1\n    for i in 2 .. n - k do\n        den = den * i\n    end\n\n    return num / den\nend\n\ndef faulhaberTriangle(p)\n    coeffs = Array.new(p + 1)\n    coeffs[0] = FRAC_ZERO\n    q = Frac.new(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -sign\n        coeffs[p - j] = q * Frac.new(sign, 1) * Frac.new(binomial(p + 1, j), 1) * bernoulli(j)\n    end\n    return coeffs\nend\n\ndef main\n    for i in 0 .. 9 do\n        coeffs = faulhaberTriangle(i)\n        coeffs.each do |coeff|\n            print \"%5s  \" % [coeff]\n        end\n        puts\n    end\nend\n\nmain()\n", "target": "\n\nfrom itertools import accumulate, chain, count, islice\nfrom fractions import Fraction\n\n\n\ndef faulhaberTriangle(m):\n    \n    def go(rs, n):\n        def f(x, y):\n            return Fraction(n, x) * y\n        xs = list(map(f, islice(count(2), m), rs))\n        return [Fraction(1 - sum(xs), 1)] + xs\n\n    return list(accumulate(\n        [[]] + list(islice(count(0), 1 + m)),\n        go\n    ))[1:]\n\n\n\ndef faulhaberSum(p, n):\n    \n    def go(x, y):\n        return y * (n ** x)\n\n    return sum(\n        map(go, count(1), faulhaberTriangle(p)[-1])\n    )\n\n\n\ndef main():\n    \n\n    fs = faulhaberTriangle(9)\n    print(\n        fTable(__doc__ + ':\\n')(str)(\n            compose(concat)(\n                fmap(showRatio(3)(3))\n            )\n        )(\n            index(fs)\n        )(range(0, len(fs)))\n    )\n    print('')\n    print(\n        faulhaberSum(17, 1000)\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def gox(xShow):\n        def gofx(fxShow):\n            def gof(f):\n                def goxs(xs):\n                    ys = [xShow(x) for x in xs]\n                    w = max(map(len, ys))\n\n                    def arrowed(x, y):\n                        return y.rjust(w, ' ') + ' -> ' + (\n                            fxShow(f(x))\n                        )\n                    return s + '\\n' + '\\n'.join(\n                        map(arrowed, xs, ys)\n                    )\n                return goxs\n            return gof\n        return gofx\n    return gox\n\n\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\n\ndef concat(xs):\n    \n    def f(ys):\n        zs = list(chain(*ys))\n        return ''.join(zs) if isinstance(ys[0], str) else zs\n\n    return (\n        f(xs) if isinstance(xs, list) else (\n            chain.from_iterable(xs)\n        )\n    ) if xs else []\n\n\n\ndef fmap(f):\n    \n    def go(xs):\n        return list(map(f, xs))\n\n    return go\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef showRatio(m):\n    \n    def go(n):\n        def f(r):\n            d = r.denominator\n            return str(r.numerator).rjust(m, ' ') + (\n                ('/' + str(d).ljust(n, ' ')) if 1 != d else (\n                    ' ' * (1 + n)\n                )\n            )\n        return f\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389643, "name": "Paraffins", "source": "Translate Ruby to Python: MAX_N = 500\nBRANCH = 4\n\ndef tree(br, n, l=n, sum=1, cnt=1)\n  for b in br+1 .. BRANCH\n    sum += n\n    return if sum >= MAX_N\n    \n    return if l * 2 >= sum and b >= BRANCH\n    if b == br + 1\n      c = $ra[n] * cnt\n    else\n      c = c * ($ra[n] + (b - br - 1)) / (b - br)\n    end\n    $unrooted[sum] += c if l * 2 < sum\n    next if b >= BRANCH\n    $ra[sum] += c\n    (1...n).each {|m| tree(b, m, l, sum, c)}\n  end\nend\n\ndef bicenter(s)\n  return if s.odd?\n  aux = $ra[s / 2]\n  $unrooted[s] += aux * (aux + 1) / 2\nend\n\n$ra       = [0] * MAX_N\n$unrooted = [0] * MAX_N\n\n$ra[0] = $ra[1] = $unrooted[0] = $unrooted[1] = 1\nfor n in 1...MAX_N\n  tree(0, n)\n  bicenter(n)\n  puts \"%d: %d\" % [n, $unrooted[n]]\nend\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 389644, "name": "Paraffins", "source": "Translate Ruby to Python: MAX_N = 500\nBRANCH = 4\n\ndef tree(br, n, l=n, sum=1, cnt=1)\n  for b in br+1 .. BRANCH\n    sum += n\n    return if sum >= MAX_N\n    \n    return if l * 2 >= sum and b >= BRANCH\n    if b == br + 1\n      c = $ra[n] * cnt\n    else\n      c = c * ($ra[n] + (b - br - 1)) / (b - br)\n    end\n    $unrooted[sum] += c if l * 2 < sum\n    next if b >= BRANCH\n    $ra[sum] += c\n    (1...n).each {|m| tree(b, m, l, sum, c)}\n  end\nend\n\ndef bicenter(s)\n  return if s.odd?\n  aux = $ra[s / 2]\n  $unrooted[s] += aux * (aux + 1) / 2\nend\n\n$ra       = [0] * MAX_N\n$unrooted = [0] * MAX_N\n\n$ra[0] = $ra[1] = $unrooted[0] = $unrooted[1] = 1\nfor n in 1...MAX_N\n  tree(0, n)\n  bicenter(n)\n  puts \"%d: %d\" % [n, $unrooted[n]]\nend\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 389645, "name": "Faulhaber's formula", "source": "Translate Ruby to Python: def binomial(n,k)\n    if n < 0 or k < 0 or n < k then\n        return -1\n    end\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k+1 .. n do\n        num = num * i\n    end\n\n    denom = 1\n    for i in 2 .. n-k do\n        denom = denom * i\n    end\n\n    return num / denom\nend\n\ndef bernoulli(n)\n    if n < 0 then\n        raise \"n cannot be less than zero\"\n    end\n\n    a = Array.new(16)\n    for m in 0 .. n do\n        a[m] = Rational(1, m + 1)\n        for j in m.downto(1) do\n            a[j-1] = (a[j-1] - a[j]) * Rational(j)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef faulhaber(p)\n    print(\"%d\u00a0: \" % [p])\n    q = Rational(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -1 * sign\n        coeff = q * Rational(sign) * Rational(binomial(p+1, j)) * bernoulli(j)\n        if coeff == 0 then\n            next\n        end\n        if j == 0 then\n            if coeff != 1 then\n                if coeff == -1 then\n                    print \"-\"\n                else\n                    print coeff\n                end\n            end\n        else\n            if coeff == 1 then\n                print \" + \"\n            elsif coeff == -1 then\n                print \" - \"\n            elsif 0 < coeff then\n                print \" + \"\n                print coeff\n            else\n                print \" - \"\n                print -coeff\n            end\n        end\n        pwr = p + 1 - j\n        if pwr > 1 then\n            print \"n^%d\" % [pwr]\n        else\n            print \"n\"\n        end\n    end\n    print \"\\n\"\nend\n\ndef main\n    for i in 0 .. 9 do\n        faulhaber(i)\n    end\nend\n\nmain()\n", "target": "from fractions import Fraction\n\ndef nextu(a):\n    n = len(a)\n    a.append(1)\n    for i in range(n - 1, 0, -1):\n        a[i] = i * a[i] + a[i - 1]\n    return a\n\ndef nextv(a):\n    n = len(a) - 1\n    b = [(1 - n) * x for x in a]\n    b.append(1)\n    for i in range(n):\n        b[i + 1] += a[i]\n    return b\n\ndef sumpol(n):\n    u = [0, 1]\n    v = [[1], [1, 1]]\n    yield [Fraction(0), Fraction(1)]\n    for i in range(1, n):\n        v.append(nextv(v[-1]))\n        t = [0] * (i + 2)\n        p = 1\n        for j, r in enumerate(u):\n            r = Fraction(r, j + 1)\n            for k, s in enumerate(v[j + 1]):\n                t[k] += r * s\n        yield t\n        u = nextu(u)\n\ndef polstr(a):\n    s = \"\"\n    q = False\n    n = len(a) - 1\n    for i, x in enumerate(reversed(a)):\n        i = n - i\n        if i < 2:\n            m = \"n\" if i == 1 else \"\"\n        else:\n            m = \"n^%d\" % i\n        c = str(abs(x))\n        if i > 0:\n            if c == \"1\":\n                c = \"\"\n            else:\n                m = \" \" + m\n        if x != 0:\n            if q:\n                t = \" + \" if x > 0 else \" - \"\n                s += \"%s%s%s\" % (t, c, m)\n            else:\n                t = \"\" if x > 0 else \"-\"\n                s = \"%s%s%s\" % (t, c, m)\n                q = True\n    if q:\n        return s\n    else:\n        return \"0\"\n\nfor i, p in enumerate(sumpol(10)):\n    print(i, \":\", polstr(p))\n"}
{"id": 389646, "name": "Active Directory_Search for a user", "source": "Translate Ruby to Python: require 'rubygems'\nrequire 'net/ldap'\n\nldap = Net::LDAP.new(:host => 'hostname', :base => 'base')\nldap.authenticate('bind_dn', 'bind_pass')\n\nfilter = Net::LDAP::Filter.pres('objectclass')\nfilter &= Net::LDAP::Filter.eq('sn','Jackman')\n\nfilter = Net::LDAP::Filter.construct('(&(objectclass=*)(sn=Jackman))')\n\nresults = ldap.search(:filter => filter)  \n\nputs results[0][:sn]  \n", "target": "Import-Module ActiveDirectory\n\n$searchData = \"user name\"\n$searchBase = \"DC=example,DC=com\"\n\n\nget-aduser -Filter((DistinguishedName -eq $searchdata) -or (UserPrincipalName -eq $searchdata) -or (SamAccountName -eq $searchdata)) -SearchBase $searchBase\n"}
{"id": 389647, "name": "Prime conspiracy", "source": "Translate Ruby to Python: require \"prime\"\n\ndef prime_conspiracy(m)\n  conspiracy = Hash.new(0)\n  Prime.take(m).map{|n| n%10}.each_cons(2){|a,b| conspiracy[[a,b]] += 1}\n  puts \"\n  conspiracy.sort.each do |(a,b),v|\n    puts \"%d \u2192 %d count:%10d frequency:%7.4f\u00a0%\" % [a, b, v, 100.0*v/m]\n  end\nend\n\nprime_conspiracy(1_000_000)\n", "target": "def isPrime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    if n % 3 == 0:\n        return n == 3\n\n    d = 5\n    while d * d <= n:\n        if n % d == 0:\n            return False\n        d += 2\n\n        if n % d == 0:\n            return False\n        d += 4\n    return True\n\ndef generatePrimes():\n    yield 2\n    yield 3\n\n    p = 5\n    while p > 0:\n        if isPrime(p):\n            yield p\n        p += 2\n        if isPrime(p):\n            yield p\n        p += 4\n\ng = generatePrimes()\ntransMap = {}\nprev = None\nlimit = 1000000\nfor _ in xrange(limit):\n    prime = next(g)\n    if prev:\n        transition = (prev, prime %10)\n        if transition in transMap:\n            transMap[transition] += 1\n        else:\n            transMap[transition] = 1\n    prev = prime % 10\n\nprint \"First {:,} primes. Transitions prime\u00a0% 10 > next-prime\u00a0% 10.\".format(limit)\nfor trans in sorted(transMap):\n    print \"{0} -> {1} count {2:5} frequency: {3}%\".format(trans[0], trans[1], transMap[trans], 100.0 * transMap[trans] / limit)\n"}
{"id": 389648, "name": "List rooted trees", "source": "Translate Ruby to Python: TREE_LIST = []\nOFFSET = []\n\nfor i in 0..31\n    if i == 1 then\n        OFFSET << 1\n    else\n        OFFSET << 0\n    end\nend\n\ndef append(t)\n    TREE_LIST << (1 | (t << 1))\nend\n\ndef show(t, l)\n    while l > 0\n        l = l - 1\n        if t % 2 == 1 then\n            print '('\n        else\n            print ')'\n        end\n        t = t >> 1\n    end\nend\n\ndef listTrees(n)\n    for i in OFFSET[n] .. OFFSET[n + 1] - 1\n        show(TREE_LIST[i], n * 2)\n        print \"\\n\"\n    end\nend\n\ndef assemble(n, t, sl, pos, rem)\n    if rem == 0 then\n        append(t)\n        return\n    end\n\n    if sl > rem then\n        sl = rem\n        pos = OFFSET[sl]\n    elsif pos >= OFFSET[sl + 1] then\n        sl = sl - 1\n        if sl == 0 then\n            return\n        end\n        pos = OFFSET[sl]\n    end\n\n    assemble(n, t << (2 * sl) | TREE_LIST[pos], sl, pos, rem - sl)\n    assemble(n, t, sl, pos + 1, rem)\nend\n\ndef makeTrees(n)\n    if OFFSET[n + 1] != 0 then\n        return\n    end\n    if n > 0 then\n        makeTrees(n - 1)\n    end\n    assemble(n, 0, n - 1, OFFSET[n - 1], n - 1)\n    OFFSET[n + 1] = TREE_LIST.length()\nend\n\ndef test(n)\n    if n < 1 || n > 12 then\n        raise ArgumentError.new(\"Argument must be between 1 and 12\")\n    end\n\n    append(0)\n\n    makeTrees(n)\n    print \"Number of %d-trees: %d\\n\" % [n, OFFSET[n + 1] - OFFSET[n]]\n    listTrees(n)\nend\n\ntest(5)\n", "target": "def bags(n,cache={}):\n\tif not n: return [(0, \"\")]\n\n\tupto = sum([bags(x) for x in range(n-1, 0, -1)], [])\n\treturn [(c+1, '('+s+')') for c,s in bagchain((0, \"\"), n-1, upto)]\n\ndef bagchain(x, n, bb, start=0):\n\tif not n: return [x]\n\n\tout = []\n\tfor i in range(start, len(bb)):\n\t\tc,s = bb[i]\n\t\tif c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)\n\treturn out\n\n\ndef replace_brackets(s):\n\tdepth,out = 0,[]\n\tfor c in s:\n\t\tif c == '(':\n\t\t\tout.append(\"([{\"[depth%3])\n\t\t\tdepth += 1\n\t\telse:\n\t\t\tdepth -= 1\n\t\t\tout.append(\")]}\"[depth%3])\n\treturn \"\".join(out)\n\nfor x in bags(5): print(replace_brackets(x[1]))\n"}
{"id": 389649, "name": "Elementary cellular automaton_Random number generator", "source": "Translate Ruby to Python: size = 100\neca = ElemCellAutomat.new(\"1\"+\"0\"*(size-1), 30)\neca.take(80).map{|line| line[0]}.each_slice(8){|bin| p bin.join.to_i(2)}\n", "target": "from elementary_cellular_automaton import eca, eca_wrap\n\ndef rule30bytes(lencells=100):\n    cells = '1' + '0' * (lencells - 1)\n    gen = eca(cells, 30)\n    while True:\n        yield int(''.join(next(gen)[0] for i in range(8)), 2)\n\nif __name__ == '__main__':\n    print([b for i,b in zip(range(10), rule30bytes())])\n"}
{"id": 389650, "name": "Lucky and even lucky numbers", "source": "Translate Ruby to Python: def generator(even=false, nmax=1000000)\n  start = even ? 2 : 1\n  Enumerator.new do |y|\n    n = 1\n    ary = [0] + (start..nmax).step(2).to_a      \n    y << ary[n]\n    while (m = ary[n+=1]) < ary.size\n      y << m\n      (m...ary.size).step(m){|i| ary[i]=nil}\n      ary.compact!                              \n    end\n    \n    ary[n..-1].each{|i| y << i}\n    raise StopIteration\n  end\nend\n\ndef lucky(argv)\n  j, k = argv[0].to_i, argv[1].to_i\n  mode = /even/i=~argv[2] ? :'even lucky' : :lucky\n  seq = generator(mode == :'even lucky')\n  ord = ->(n){\"\n  if k.zero?\n    puts \"\n  elsif 0 < k\n    puts \"\n         \"  \n  else\n    k = -k\n    ary = []\n    loop do\n      case num=seq.next\n      when 1...j\n      when j..k  then ary << num\n      else break\n      end\n    end\n    puts \"all \n         \"  \n  end\nend\n\nif __FILE__ == $0\n  lucky(ARGV)\nend\n", "target": "from __future__ import print_function\n\ndef lgen(even=False, nmax=1000000):\n    start = 2 if even else 1\n    n, lst = 1, list(range(start, nmax + 1, 2))\n    lenlst = len(lst)\n    yield lst[0]\n    while n < lenlst and lst[n] < lenlst:\n        yield lst[n]\n        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]\n        lenlst = len(lst)\n    \n    for i in lst[n:]:\n        yield i\n"}
{"id": 389651, "name": "Imaginary base numbers", "source": "Translate Ruby to Python: \n\ndef base2i_decode(qi)\n  return 0 if qi == '0'\n  md = qi.match(/^(?<int>[0-3]+)(?:\\.(?<frc>[0-3]+))?$/)\n  raise 'ill-formed quarter-imaginary base value' if !md\n  ls_pow = md[:frc] ? -(md[:frc].length) : 0\n  value = 0\n  (md[:int] + (md[:frc] ? md[:frc] : '')).reverse.each_char.with_index do |dig, inx|\n    value += dig.to_i * (2i)**(inx + ls_pow)\n  end\n  return value\nend\n\n\n\ndef base2i_encode(gi)\n  odd = gi.imag.to_i.odd?\n  frac = (gi.imag.to_i != 0)\n  real = gi.real.to_i\n  imag = (gi.imag.to_i + 1) / 2\n  value = ''\n  phase_real = true\n  while (real != 0) || (imag != 0)\n    if phase_real\n      real, rem = real.divmod(4)\n      real = -real\n    else\n      imag, rem = imag.divmod(4)\n      imag = -imag\n    end\n    value.prepend(rem.to_s)\n    phase_real = !phase_real\n  end\n  value = '0' if value == ''\n  value.concat(odd ? '.2' : '.0') if frac\n  return value\nend\n", "target": "import math\nimport re\n\ndef inv(c):\n    denom = c.real * c.real + c.imag * c.imag\n    return complex(c.real / denom, -c.imag / denom)\n\nclass QuaterImaginary:\n    twoI = complex(0, 2)\n    invTwoI = inv(twoI)\n\n    def __init__(self, str):\n        if not re.match(\"^[0123.]+$\", str) or str.count('.') > 1:\n            raise Exception('Invalid base 2i number')\n        self.b2i = str\n\n    def toComplex(self):\n        pointPos = self.b2i.find('.')\n        posLen = len(self.b2i) if (pointPos < 0) else pointPos\n        sum = complex(0, 0)\n        prod = complex(1, 0)\n        for j in xrange(0, posLen):\n            k = int(self.b2i[posLen - 1 - j])\n            if k > 0:\n                sum += prod * k\n            prod *= QuaterImaginary.twoI\n        if pointPos != -1:\n            prod = QuaterImaginary.invTwoI\n            for j in xrange(posLen + 1, len(self.b2i)):\n                k = int(self.b2i[j])\n                if k > 0:\n                    sum += prod * k\n                prod *= QuaterImaginary.invTwoI\n        return sum\n\n    def __str__(self):\n        return str(self.b2i)\n\ndef toQuaterImaginary(c):\n    if c.real == 0.0 and c.imag == 0.0:\n        return QuaterImaginary(\"0\")\n\n    re = int(c.real)\n    im = int(c.imag)\n    fi = -1\n    ss = \"\"\n    while re != 0:\n        re, rem = divmod(re, -4)\n        if rem < 0:\n            rem += 4\n            re += 1\n        ss += str(rem) + '0'\n    if im != 0:\n        f = c.imag / 2\n        im = int(math.ceil(f))\n        f = -4 * (f - im)\n        index = 1\n        while im != 0:\n            im, rem = divmod(im, -4)\n            if rem < 0:\n                rem += 4\n                im += 1\n            if index < len(ss):\n                ss[index] = str(rem)\n            else:\n                ss += '0' + str(rem)\n            index = index + 2\n        fi = int(f)\n    ss = ss[::-1]\n    if fi != -1:\n        ss += '.' + str(fi)\n    ss = ss.lstrip('0')\n    if ss[0] == '.':\n        ss = '0' + ss\n    return QuaterImaginary(ss)\n\nfor i in xrange(1,17):\n    c1 = complex(i, 0)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\nprint\n\nfor i in xrange(1,17):\n    c1 = complex(0, i)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\n\nprint \"done\"\n"}
{"id": 389652, "name": "Statistics_Normal distribution", "source": "Translate Ruby to Python: \n\n\nclass NormalFromUniform\n  \n  def initialize()\n    @next = nil\n  end\n  \n  def rand()\n    if @next\n      retval, @next = @next, nil\n      return retval\n    else\n      u = v = s = nil\n      loop do\n        u = Random.rand(-1.0..1.0)\n        v = Random.rand(-1.0..1.0)\n        s = u**2 + v**2\n        break if (s > 0.0) && (s <= 1.0)\n      end\n      f = Math.sqrt(-2.0 * Math.log(s) / s)\n      @next = v * f\n      return u * f\n    end\n  end\nend\n", "target": "from __future__ import division\nimport matplotlib.pyplot as plt \nimport random\n\nmean, stddev, size = 50, 4, 100000\ndata = [random.gauss(mean, stddev) for c in range(size)]\n\nmn = sum(data) / size\nsd = (sum(x*x for x in data) / size \n      - (sum(data) / size) ** 2) ** 0.5\n\nprint(\"Sample mean = %g; Stddev = %g; max = %g; min = %g for %i values\" \n      % (mn, sd, max(data), min(data), size))\n\nplt.hist(data,bins=50)\n"}
{"id": 389653, "name": "Vogel's approximation method", "source": "Translate Ruby to Python: \n\n\n\nCOSTS  = {W: {A: 16, B: 16, C: 13, D: 22, E: 17},\n          X: {A: 14, B: 14, C: 13, D: 19, E: 15},\n          Y: {A: 19, B: 19, C: 20, D: 23, E: 50},\n          Z: {A: 50, B: 12, C: 50, D: 15, E: 11}}\ndemand = {A: 30, B: 20, C: 70, D: 30, E: 60}\nsupply = {W: 50, X: 60, Y: 50, Z: 50}\nCOLS = demand.keys\nres = {}; COSTS.each_key{|k| res[k] = Hash.new(0)}\ng = {}; supply.each_key{|x| g[x] = COSTS[x].keys.sort_by{|g| COSTS[x][g]}}\n        demand.each_key{|x| g[x] = COSTS.keys.sort_by{|g| COSTS[g][x]}}\n\nuntil g.empty? \n  d = demand.collect{|x,y| [x, z = COSTS[g[x][0]][x], g[x][1] ? COSTS[g[x][1]][x] - z : z]}\n  dmax = d.max_by{|n| n[2]}\n  d = d.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}\n  s = supply.collect{|x,y| [x, z = COSTS[x][g[x][0]], g[x][1] ? COSTS[x][g[x][1]] - z : z]}\n  dmax = s.max_by{|n| n[2]}\n  s = s.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}\n  t,f = d[2]==s[2] ? [s[1], d[1]] : [d[2],s[2]] \n  d,s = t > f ? [d[0],g[d[0]][0]] : [g[s[0]][0],s[0]]\n  v = [supply[s], demand[d]].min\n  res[s][d] += v\n  demand[d] -= v\n  if demand[d] == 0 then\n    supply.reject{|k, n| n == 0}.each_key{|x| g[x].delete(d)}\n    g.delete(d)\n    demand.delete(d)\n  end\n  supply[s] -= v\n  if supply[s] == 0 then\n    demand.reject{|k, n| n == 0}.each_key{|x| g[x].delete(s)}\n    g.delete(s)\n    supply.delete(s)\n  end\nend\n\nCOLS.each{|n| print \"\\t\", n}\nputs\ncost = 0\nCOSTS.each_key do |g|\n  print g, \"\\t\"\n  COLS.each do |n|\n    y = res[g][n]\n    print y if y != 0\n    cost += y * COSTS[g][n]\n    print \"\\t\"\n  end\n  puts\nend\nprint \"\\n\\nTotal Cost = \", cost\n", "target": "from collections import defaultdict\n\ncosts  = {'W': {'A': 16, 'B': 16, 'C': 13, 'D': 22, 'E': 17},\n          'X': {'A': 14, 'B': 14, 'C': 13, 'D': 19, 'E': 15},\n          'Y': {'A': 19, 'B': 19, 'C': 20, 'D': 23, 'E': 50},\n          'Z': {'A': 50, 'B': 12, 'C': 50, 'D': 15, 'E': 11}}\ndemand = {'A': 30, 'B': 20, 'C': 70, 'D': 30, 'E': 60}\ncols = sorted(demand.iterkeys())\nsupply = {'W': 50, 'X': 60, 'Y': 50, 'Z': 50}\nres = dict((k, defaultdict(int)) for k in costs)\ng = {}\nfor x in supply:\n    g[x] = sorted(costs[x].iterkeys(), key=lambda g: costs[x][g])\nfor x in demand:\n    g[x] = sorted(costs.iterkeys(), key=lambda g: costs[g][x])\n\nwhile g:\n    d = {}\n    for x in demand:\n        d[x] = (costs[g[x][1]][x] - costs[g[x][0]][x]) if len(g[x]) > 1 else costs[g[x][0]][x]\n    s = {}\n    for x in supply:\n        s[x] = (costs[x][g[x][1]] - costs[x][g[x][0]]) if len(g[x]) > 1 else costs[x][g[x][0]]\n    f = max(d, key=lambda n: d[n])\n    t = max(s, key=lambda n: s[n])\n    t, f = (f, g[f][0]) if d[f] > s[t] else (g[t][0], t)\n    v = min(supply[f], demand[t])\n    res[f][t] += v\n    demand[t] -= v\n    if demand[t] == 0:\n        for k, n in supply.iteritems():\n            if n != 0:\n                g[k].remove(t)\n        del g[t]\n        del demand[t]\n    supply[f] -= v\n    if supply[f] == 0:\n        for k, n in demand.iteritems():\n            if n != 0:\n                g[k].remove(f)\n        del g[f]\n        del supply[f]\n\nfor n in cols:\n    print \"\\t\", n,\nprint\ncost = 0\nfor g in sorted(costs):\n    print g, \"\\t\",\n    for n in cols:\n        y = res[g][n]\n        if y != 0:\n            print y,\n        cost += y * costs[g][n]\n        print \"\\t\",\n    print\nprint \"\\n\\nTotal Cost = \", cost\n"}
{"id": 389654, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Ruby to Python: def mod(m, n)\n    result = m % n\n    if result < 0 then\n        result = result + n\n    end\n    return result\nend\n\ndef getA004290(n)\n    if n == 1 then\n        return 1\n    end\n    arr = Array.new(n) { Array.new(n, 0) }\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while true\n        m = m + 1\n        if arr[m - 1][mod(-10 ** m, n)] == 1 then\n            break\n        end\n        arr[m][0] = 1\n        for k in 1 .. n - 1\n            arr[m][k] = [arr[m - 1][k], arr[m - 1][mod(k - 10 ** m, n)]].max\n        end\n    end\n    r = 10 ** m\n    k = mod(-r, n)\n    (m - 1).downto(1) { |j|\n        if arr[j - 1][k] == 0 then\n            r = r + 10 ** j\n            k = mod(k - 10 ** j, n)\n        end\n    }\n    if k == 1 then\n        r = r + 1\n    end\n    return r\nend\n\ntestCases = Array(1 .. 10)\ntestCases.concat(Array(95 .. 105))\ntestCases.concat([297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878])\nfor n in testCases\n    result = getA004290(n)\n    print \"A004290(%d) = %d = %d * %d\\n\" % [n, result, n, result / n]\nend\n", "target": "def getA004290(n):\n    if n < 2:\n        return 1\n    arr = [[0 for _ in range(n)] for _ in range(n)]\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while True:\n        m += 1\n        if arr[m - 1][-10 ** m % n] == 1:\n            break\n        arr[m][0] = 1\n        for k in range(1, n):\n            arr[m][k] = max([arr[m - 1][k], arr[m - 1][k - 10 ** m % n]])\n    r = 10 ** m\n    k = -r % n\n    for j in range((m - 1), 0, -1):\n        if arr[j - 1][k] == 0:\n            r = r + 10 ** j\n            k = (k - 10 ** j) % n   \n    if k == 1:\n        r += 1\n    return r\n \nfor n in [i for i in range(1, 11)] + \\\n          [i for i in range(95, 106)] + \\\n          [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:\n    result = getA004290(n)\n    print(f\"A004290({n}) = {result} = {n} * {result // n})\")\n"}
{"id": 389655, "name": "Magic squares of singly even order", "source": "Translate Ruby to Python: def odd_magic_square(n)\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\ndef single_even_magic_square(n) \n  raise ArgumentError, \"must be even, but not divisible by 4.\" unless (n-2) % 4 == 0\n  raise ArgumentError, \"2x2 magic square not possible.\" if n == 2\n\n  order = (n-2)/4\n  odd_square = odd_magic_square(n/2)\n  to_add = (0..3).map{|f| f*n*n/4}\n  quarts = to_add.map{|f| odd_square.dup.map{|row|row.map{|el| el+f}} }\n\n  sq = []\n  quarts[0].zip(quarts[2]){|d1,d2| sq << [d1,d2].flatten}\n  quarts[3].zip(quarts[1]){|d1,d2| sq << [d1,d2].flatten}\n\n  sq = sq.transpose\n  order.times{|i| sq[i].rotate!(n/2)}\n  swap(sq[0][order], sq[0][-order-1])\n  swap(sq[order][order], sq[order][-order-1])\n  (order-1).times{|i| sq[-(i+1)].rotate!(n/2)}\n  randomize(sq)\nend\n\ndef swap(a,b)\n  a,b = b,a\nend\n\ndef randomize(square)\n  square.shuffle.transpose.shuffle\nend\n\ndef to_string(square)\n  n = square.size\n  fmt = \"%\n  square.inject(\"\"){|str,row| str << fmt % row << \"\\n\"}\nend\n\nputs to_string(single_even_magic_square(6))\n", "target": "import math\nfrom sys import stdout\n\nLOG_10 = 2.302585092994\n\n\n\ndef build_oms(s):\n    if s % 2 == 0:\n        s += 1\n    q = [[0 for j in range(s)] for i in range(s)]\n    p = 1\n    i = s // 2\n    j = 0\n    while p <= (s * s):\n        q[i][j] = p\n        ti = i + 1\n        if ti >= s: ti = 0\n        tj = j - 1\n        if tj < 0: tj = s - 1\n        if q[ti][tj] != 0:\n            ti = i\n            tj = j + 1\n        i = ti\n        j = tj\n        p = p + 1\n\n    return q, s\n\n\n\ndef build_sems(s):\n    if s % 2 == 1:\n        s += 1\n    while s % 4 == 0:\n        s += 2\n\n    q = [[0 for j in range(s)] for i in range(s)]\n    z = s // 2\n    b = z * z\n    c = 2 * b\n    d = 3 * b\n    o = build_oms(z)\n\n    for j in range(0, z):\n        for i in range(0, z):\n            a = o[0][i][j]\n            q[i][j] = a\n            q[i + z][j + z] = a + b\n            q[i + z][j] = a + c\n            q[i][j + z] = a + d\n\n    lc = z // 2\n    rc = lc\n    for j in range(0, z):\n        for i in range(0, s):\n            if i < lc or i > s - rc or (i == lc and j == lc):\n                if not (i == 0 and j == lc):\n                    t = q[i][j]\n                    q[i][j] = q[i][j + z]\n                    q[i][j + z] = t\n\n    return q, s\n\n\ndef format_sqr(s, l):\n    for i in range(0, l - len(s)):\n        s = \"0\" + s\n    return s + \" \"\n\n\ndef display(q):\n    s = q[1]\n    print(\" - {0} x {1}\\n\".format(s, s))\n    k = 1 + math.floor(math.log(s * s) / LOG_10)\n    for j in range(0, s):\n        for i in range(0, s):\n            stdout.write(format_sqr(\"{0}\".format(q[0][i][j]), k))\n        print()\n    print(\"Magic sum: {0}\\n\".format(s * ((s * s) + 1) // 2))\n\n\nstdout.write(\"Singly Even Magic Square\")\ndisplay(build_sems(6))\n"}
{"id": 389656, "name": "Weird numbers", "source": "Translate Ruby to Python: def divisors(n : Int32) : Array(Int32)\n  divs = [1]\n  divs2 = [] of Int32\n\n  i = 2\n  while i * i < n\n    if n % i == 0\n      j = n // i\n      divs << i\n      divs2 << j if i != j\n    end\n\n    i += 1\n  end\n\n  i = divs.size - 1\n\n  \n  while i >= 0\n    divs2 << divs[i]\n    i -= 1\n  end\n\n  divs2\nend\n\ndef abundant(n : Int32, divs : Array(Int32)) : Bool\n  divs.sum > n\nend\n\ndef semiperfect(n : Int32, divs : Array(Int32)) : Bool\n  if divs.size > 0\n    h = divs[0]\n    t = divs[1..]\n\n    return n < h ? semiperfect(n, t) : n == h || semiperfect(n - h, t) || semiperfect(n, t)\n  end\n\n  return false\nend\n\ndef sieve(limit : Int32) : Array(Bool)\n  \n  \n\n  w = Array(Bool).new(limit, false) \n\n  i = 2\n  while i < limit\n    if !w[i]\n      divs = divisors i\n\n      if !abundant(i, divs)\n        w[i] = true\n      elsif semiperfect(i, divs)\n        j = i\n        while j < limit\n          w[j] = true\n          j += i\n        end\n      end\n    end\n\n    i += 2\n  end\n\n  w\nend\n\ndef main\n  w = sieve 17000\n  count = 0\n  max = 25\n\n  print \"The first 25 weird numbers are: \"\n\n  n = 2\n  while count < max\n    if !w[n]\n      print \"\n      count += 1\n    end\n\n    n += 2\n  end\n\n  puts \"\\n\"\nend\n\nrequire \"benchmark\"\nputs Benchmark.measure { main }\n", "target": "\n\nfrom itertools import chain, count, islice, repeat\nfrom functools import reduce\nfrom math import sqrt\nfrom time import time\n\n\n\ndef weirds():\n    \n    def go(n):\n        ds = descPropDivs(n)\n        d = sum(ds) - n\n        return [n] if 0 < d and not hasSum(d, ds) else []\n    return concatMap(go)(count(1))\n\n\n\ndef hasSum(n, xs):\n    \n    def go(n, xs):\n        if xs:\n            h, t = xs[0], xs[1:]\n            if n < h:  \n                return go(n, t)\n            else:\n                \n                \n                \n                \n                return n == h or go(n - h, t) or go(n, t)\n        else:\n            return False\n    return go(n, xs)\n\n\n\ndef descPropDivs(n):\n    \n    root = sqrt(n)\n    intRoot = int(root)\n    blnSqr = root == intRoot\n    lows = [x for x in range(1, 1 + intRoot) if 0 == n % x]\n    return [\n        n // x for x in (\n            lows[1:-1] if blnSqr else lows[1:]\n        )\n    ] + list(reversed(lows))\n\n\n\n\n\ndef main():\n    \n\n    start = time()\n    n = 50\n    xs = take(n)(weirds())\n\n    print(\n        (tabulated('First ' + str(n) + ' weird numbers:\\n')(\n            lambda i: str(1 + i)\n        )(str)(5)(\n            index(xs)\n        )(range(0, n)))\n    )\n    print(\n        '\\nApprox computation time: ' +\n        str(int(1000 * (time() - start))) + ' ms'\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: chain.from_iterable(map(f, xs))\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef paddedMatrix(v):\n    \n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n\ndef paddedRows(n):\n    \n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n\ndef showColumns(n):\n    \n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col))\n\n        q, r = divmod(len(xs), n)\n        return unlines(map(\n            fit,\n            transpose(paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(\n                    xs\n                )\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\n\n\n\n\ndef tabulated(s):\n    \n    def go(xShow, fxShow, intCols, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + fxShow(f(x)) for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, list)\n        else list(islice(xs, n))\n    )\n\n\n\ndef transpose(m):\n    \n    if m:\n        inner = type(m[0])\n        z = zip(*m)\n        return (type(m))(\n            map(inner, z) if tuple != inner else z\n        )\n    else:\n        return m\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\ndef until(p):\n    \n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389657, "name": "ASCII art diagram converter", "source": "Translate Ruby to Python: header = <<HEADER\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                      ID                       |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    QDCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ANCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    NSCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ARCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nHEADER\n\nItem = Struct.new(:name, :bits, :range)\nRE = /\\| *\\w+ */\n\ni = 0\ntable = header.scan(RE).map{|m| Item.new( m.delete(\"^A-Za-z\"), b = m.size/3, i...(i += b)) }\n\nteststr = \"78477bbf5496e12e1bf169a4\"\npadding = table.sum(&:bits)\nbinstr  = teststr.hex.to_s(2).rjust(padding, \"0\")\n\ntable.each{|el| p el.values}; puts\ntable.each{|el| puts \"%7s, %2d bits: %s\" % [el.name, el.bits, binstr[el.range] ]}\n", "target": "\n\ndef validate(diagram):\n\n    \n    \n    rawlines = diagram.splitlines()\n    lines = []\n    for line in rawlines:\n        if line != '':\n            lines.append(line)\n            \n    \n            \n    if len(lines) == 0:\n        print('diagram has no non-empty lines!')\n        return None\n        \n    width = len(lines[0])\n    cols = (width - 1) // 3\n    \n    if cols not in [8, 16, 32, 64]: \n        print('number of columns should be 8, 16, 32 or 64')\n        return None\n        \n    if len(lines)%2 == 0:\n        print('number of non-empty lines should be odd')\n        return None\n    \n    if lines[0] != (('+--' * cols)+'+'):\n            print('incorrect header line')\n            return None\n\n    for i in range(len(lines)):\n        line=lines[i]\n        if i == 0:\n            continue\n        elif i%2 == 0:\n            if line != lines[0]:\n                print('incorrect separator line')\n                return None\n        elif len(line) != width:\n            print('inconsistent line widths')\n            return None\n        elif line[0] != '|' or line[width-1] != '|':\n            print(\"non-separator lines must begin and end with '|'\")    \n            return None\n    \n    return lines\n\n\n\ndef decode(lines):\n    print(\"Name     Bits  Start  End\")\n    print(\"=======  ====  =====  ===\")\n    \n    startbit = 0\n    \n    results = []\n    \n    for line in lines:\n        infield=False\n        for c in line:\n            if not infield and c == '|':\n                infield = True\n                spaces = 0\n                name = ''\n            elif infield:\n                if c == ' ':\n                    spaces += 1\n                elif c != '|':\n                    name += c\n                else:\n                    bits = (spaces + len(name) + 1) // 3\n                    endbit = startbit + bits - 1\n                    print('{0:7}    {1:2d}     {2:2d}   {3:2d}'.format(name, bits, startbit, endbit))\n                    reslist = [name, bits, startbit, endbit]\n                    results.append(reslist)\n                    spaces = 0\n                    name = ''\n                    startbit += bits\n                    \n    return results\n                        \ndef unpack(results, hex):\n    print(\"\\nTest string in hex:\")\n    print(hex)\n    print(\"\\nTest string in binary:\")\n    bin = f'{int(hex, 16):0>{4*len(hex)}b}'\n    print(bin)\n    print(\"\\nUnpacked:\\n\")\n    print(\"Name     Size  Bit pattern\")\n    print(\"=======  ====  ================\")\n    for r in results:\n        name = r[0]\n        size = r[1]\n        startbit = r[2]\n        endbit = r[3]\n        bitpattern = bin[startbit:endbit+1]\n        print('{0:7}    {1:2d}  {2:16}'.format(name, size, bitpattern))\n\n\ndiagram = \n\nlines = validate(diagram)\n\nif lines == None:\n    print(\"No lines returned\")\nelse:\n    print(\" \")\n    print(\"Diagram after trimming whitespace and removal of blank lines:\")\n    print(\" \")\n    for line in lines:\n        print(line)\n        \n    print(\" \")\n    print(\"Decoded:\")\n    print(\" \")\n\n    results = decode(lines)    \n    \n    \n    \n    hex = \"78477bbf5496e12e1bf169a4\" \n    \n    unpack(results, hex)\n"}
{"id": 389658, "name": "Peaceful chess queen armies", "source": "Translate Ruby to Python: class Position\n    attr_reader :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def ==(other)\n        self.x == other.x &&\n        self.y == other.y\n    end\n\n    def to_s\n        '(%d, %d)' % [@x, @y]\n    end\n\n    def to_str\n        to_s\n    end\nend\n\ndef isAttacking(queen, pos)\n    return queen.x == pos.x ||\n           queen.y == pos.y ||\n           (queen.x - pos.x).abs() == (queen.y - pos.y).abs()\nend\n\ndef place(m, n, blackQueens, whiteQueens)\n    if m == 0 then\n        return true\n    end\n    placingBlack = true\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            catch :inner do\n                pos = Position.new(i, j)\n                for queen in blackQueens\n                    if pos == queen || !placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                for queen in whiteQueens\n                    if pos == queen || placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                if placingBlack then\n                    blackQueens << pos\n                    placingBlack = false\n                else\n                    whiteQueens << pos\n                    if place(m - 1, n, blackQueens, whiteQueens) then\n                        return true\n                    end\n                    blackQueens.pop\n                    whiteQueens.pop\n                    placingBlack = true\n                end\n            end\n        end\n    end\n    if !placingBlack then\n        blackQueens.pop\n    end\n    return false\nend\n\ndef printBoard(n, blackQueens, whiteQueens)\n    \n    board = Array.new(n) { Array.new(n) { ' ' } }\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            if i % 2 == j % 2 then\n                board[i][j] = '\u2022'\n            else\n                board[i][j] = '\u25e6'\n            end\n        end\n    end\n\n    \n    for queen in blackQueens\n        board[queen.y][queen.x] = 'B'\n    end\n    for queen in whiteQueens\n        board[queen.y][queen.x] = 'W'\n    end\n\n    \n    for row in board\n        for cell in row\n            print cell, ' '\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\nnms = [\n    [2, 1],\n    [3, 1], [3, 2],\n    [4, 1], [4, 2], [4, 3],\n    [5, 1], [5, 2], [5, 3], [5, 4], [5, 5],\n    [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6],\n    [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7]\n]\nfor nm in nms\n    m = nm[1]\n    n = nm[0]\n    print \"%d black and %d white queens on a %d x %d board:\\n\" % [m, m, n, n]\n\n    blackQueens = []\n    whiteQueens = []\n    if place(m, n, blackQueens, whiteQueens) then\n        printBoard(n, blackQueens, whiteQueens)\n    else\n        print \"No solution exists.\\n\\n\"\n    end\nend\n", "target": "from itertools import combinations, product, count\nfrom functools import lru_cache, reduce\n\n\n_bbullet, _wbullet = '\\u2022\\u25E6'\n_or = set.__or__\n\ndef place(m, n):\n    \"Place m black and white queens, peacefully, on an n-by-n board\"\n    board = set(product(range(n), repeat=2))  \n    placements = {frozenset(c) for c in combinations(board, m)}\n    for blacks in placements:\n        black_attacks = reduce(_or, \n                               (queen_attacks_from(pos, n) for pos in blacks), \n                               set())\n        for whites in {frozenset(c)     \n                       for c in combinations(board - black_attacks, m)}:\n            if not black_attacks & whites:\n                return blacks, whites\n    return set(), set()\n\n@lru_cache(maxsize=None)\ndef queen_attacks_from(pos, n):\n    x0, y0 = pos\n    a = set([pos])    \n    a.update((x, y0) for x in range(n))    \n    a.update((x0, y) for y in range(n))    \n    \n    for x1 in range(n):\n        \n        y1 = y0 -x0 +x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n        \n        y1 = y0 +x0 -x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n    return a\n\ndef pboard(black_white, n):\n    \"Print board\"\n    if black_white is None: \n        blk, wht = set(), set()\n    else:\n        blk, wht = black_white\n    print(f\"\n          f\"on a {n}-by-{n} board:\", end='')\n    for x, y in product(range(n), repeat=2):\n        if y == 0:\n            print()\n        xy = (x, y)\n        ch = ('?' if xy in blk and xy in wht \n              else 'B' if xy in blk\n              else 'W' if xy in wht\n              else _bbullet if (x + y)%2 else _wbullet)\n        print('%s' % ch, end='')\n    print()\n\nif __name__ == '__main__':\n    n=2\n    for n in range(2, 7):\n        print()\n        for m in count(1):\n            ans = place(m, n)\n            if ans[0]:\n                pboard(ans, n)\n            else:\n                print (f\"\n                break\n    \n    print('\\n')\n    m, n = 5, 7\n    ans = place(m, n)\n    pboard(ans, n)\n"}
{"id": 389659, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Ruby to Python: def isPrime(n)\n    return false if n < 2\n    return n == 2 if n % 2 == 0\n    return n == 3 if n % 3 == 0\n\n    k = 5\n    while k * k <= n\n        return false if n % k == 0\n        k = k + 2\n    end\n\n    return true\nend\n\ndef getSmallPrimes(numPrimes)\n    smallPrimes = [2]\n    count = 0\n    n = 3\n    while count < numPrimes\n        if isPrime(n) then\n            smallPrimes << n\n            count = count + 1\n        end\n        n = n + 2\n    end\n    return smallPrimes\nend\n\ndef getDivisorCount(n)\n    count = 1\n    while n % 2 == 0\n        n = (n / 2).floor\n        count = count + 1\n    end\n\n    d = 3\n    while d * d <= n\n        q = (n / d).floor\n        r = n % d\n        dc = 0\n        while r == 0\n            dc = dc + count\n            n = q\n            q = (n / d).floor\n            r = n % d\n        end\n        count = count + dc\n        d = d + 2\n    end\n    if n != 1 then\n        count = 2 * count\n    end\n    return count\nend\n\nMAX = 15\n@smallPrimes = getSmallPrimes(MAX)\n\ndef OEISA073916(n)\n    if isPrime(n) then\n        return @smallPrimes[n - 1] ** (n - 1)\n    end\n\n    count = 0\n    result = 0\n    i = 1\n    while count < n\n        if n % 2 == 1 then\n            \n            root = Math.sqrt(i)\n            if root * root != i then\n                i = i + 1\n                next\n            end\n        end\n        if getDivisorCount(i) == n then\n            count = count + 1\n            result = i\n        end\n        i = i + 1\n    end\n    return result\nend\n\nn = 1\nwhile n <= MAX\n    print \"A073916(\", n, \") = \", OEISA073916(n), \"\\n\"\n    n = n + 1\nend\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef primes():\n    ii = 1\n    while True:\n        ii += 1\n        if is_prime(ii):\n            yield ii\n\n\ndef prime(n):\n    generator = primes()\n    for ii in range(n - 1):\n        generator.__next__()\n    return generator.__next__()\n\n\ndef n_divisors(n):\n    ii = 0\n    while True:\n        ii += 1\n        if len(divisors(ii)) == n:\n            yield ii\n\n\ndef sequence(max_n=None):\n    if max_n is not None:\n        for ii in range(1, max_n + 1):\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n    else:\n        ii = 1\n        while True:\n            ii += 1\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 389660, "name": "Readline interface", "source": "Translate Ruby to Python: require \"readline\"\nrequire \"abbrev\"\n\ncommands = %w[search download open help history quit url prev past]\nReadline.completion_proc = commands.abbrev.to_proc\n\nwhile buf = Readline.readline(\">\", true) \n  exit if buf.strip == \"quit\"\n  p buf\nend\n", "target": "\n\n\n\n\n\n\nimport readline\n\nwhile True:\n    try:\n        print(input('> '))\n    except:\n        break\n"}
{"id": 389661, "name": "Addition chains", "source": "Translate Ruby to Python: def check_seq(pos, seq, n, min_len)\n    if pos > min_len or seq[0] > n then\n        return min_len, 0\n    elsif seq[0] == n then\n        return pos, 1\n    elsif pos < min_len then\n        return try_perm(0, pos, seq, n, min_len)\n    else\n        return min_len, 0\n    end\nend\n\ndef try_perm(i, pos, seq, n, min_len)\n    if i > pos then\n        return min_len, 0\n    end\n\n    res11, res12 = check_seq(pos + 1, [seq[0] + seq[i]] + seq, n, min_len)\n    res21, res22 = try_perm(i + 1, pos, seq, n, res11)\n\n    if res21 < res11 then\n        return res21, res22\n    elsif res21 == res11 then\n        return res21, res12 + res22\n    else\n        raise \"try_perm exception\"\n    end\nend\n\ndef init_try_perm(x)\n    return try_perm(0, 0, [1], x, 12)\nend\n\ndef find_brauer(num)\n    actualMin, brauer = init_try_perm(num)\n    puts\n    print \"N = \", num, \"\\n\"\n    print \"Minimum length of chains: L(n)= \", actualMin, \"\\n\"\n    print \"Number of minimum length Brauer chains: \", brauer, \"\\n\"\nend\n\ndef main\n    nums = [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]\n    for i in nums do\n        find_brauer(i)\n    end\nend\n\nmain()\n", "target": "def prepend(n, seq):\n    return [n] + seq\n\ndef check_seq(pos, seq, n, min_len):\n    if pos > min_len or seq[0] > n:\n        return min_len, 0\n    if seq[0] == n:\n        return pos, 1\n    if pos < min_len:\n        return try_perm(0, pos, seq, n, min_len)\n    return min_len, 0\n\ndef try_perm(i, pos, seq, n, min_len):\n    if i > pos:\n        return min_len, 0\n\n    res1 = check_seq(pos + 1, prepend(seq[0] + seq[i], seq), n, min_len)\n    res2 = try_perm(i + 1, pos, seq, n, res1[0])\n\n    if res2[0] < res1[0]:\n        return res2\n    if res2[0] == res1[0]:\n        return res2[0], res1[1] + res2[1]\n    raise Exception(\"try_perm exception\")\n\ndef init_try_perm(x):\n    return try_perm(0, 0, [1], x, 12)\n\ndef find_brauer(num):\n    res = init_try_perm(num)\n    print\n    print \"N = \", num\n    print \"Minimum length of chains: L(n) = \", res[0]\n    print \"Number of minimum length Brauer chains: \", res[1]\n\n\nnums = [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]\nfor i in nums:\n    find_brauer(i)\n"}
{"id": 389662, "name": "Montgomery reduction", "source": "Translate Ruby to Python: func montgomeryReduce(m, a) {\n    {\n        a += m if a.is_odd\n        a >>= 1\n    } * m.as_bin.len\n\n    a % m\n}\n\nvar m  = 750791094644726559640638407699\nvar t1 = 323165824550862327179367294465482435542970161392400401329100\n\nvar r1 = 440160025148131680164261562101\nvar r2 = 435362628198191204145287283255\n\nvar x1 = 540019781128412936473322405310\nvar x2 = 515692107665463680305819378593\n\nsay(\"Original x1:        \", x1)\nsay(\"Recovererd from r1: \", montgomeryReduce(m, r1))\nsay(\"Original x2:        \", x2)\nsay(\"Recovererd from r2: \", montgomeryReduce(m, r2))\n\nprint(\"\\nMontgomery computation of x1^x2 mod m:    \")\nvar prod = montgomeryReduce(m, t1/x1)\nvar base = montgomeryReduce(m, t1)\n\nfor (var exponent = x2; exponent ; exponent >>= 1) {\n    prod = montgomeryReduce(m, prod * base) if exponent.is_odd\n    base = montgomeryReduce(m, base * base)\n}\n\nsay(montgomeryReduce(m, prod))\nsay(\"Library-based computation of x1^x2 mod m: \", x1.powmod(x2, m))\n", "target": "class Montgomery:\n    BASE = 2\n\n    def __init__(self, m):\n        self.m = m\n        self.n = m.bit_length()\n        self.rrm = (1 << (self.n * 2)) % m\n\n    def reduce(self, t):\n        a = t\n        for i in xrange(self.n):\n            if (a & 1) == 1:\n                a = a + self.m\n            a = a >> 1\n        if a >= self.m:\n            a = a - self.m\n        return a\n\n\nm = 750791094644726559640638407699\nx1 = 540019781128412936473322405310\nx2 = 515692107665463680305819378593\n\nmont = Montgomery(m)\nt1 = x1 * mont.rrm\nt2 = x2 * mont.rrm\n\nr1 = mont.reduce(t1)\nr2 = mont.reduce(t2)\nr = 1 << mont.n\n\nprint \"b\u00a0: \", Montgomery.BASE\nprint \"n\u00a0: \", mont.n\nprint \"r\u00a0: \", r\nprint \"m\u00a0: \", mont.m\nprint \"t1: \", t1\nprint \"t2: \", t2\nprint \"r1: \", r1\nprint \"r2: \", r2\nprint\nprint \"Original x1      \u00a0:\", x1\nprint \"Recovered from r1\u00a0:\", mont.reduce(r1)\nprint \"Original x2      \u00a0:\", x2\nprint \"Recovered from r2\u00a0:\", mont.reduce(r2)\n\nprint \"\\nMontgomery computation of x1 ^ x2 mod m:\"\nprod = mont.reduce(mont.rrm)\nbase = mont.reduce(x1 * mont.rrm)\nexp = x2\nwhile exp.bit_length() > 0:\n    if (exp & 1) == 1:\n        prod = mont.reduce(prod * base)\n    exp = exp >> 1\n    base = mont.reduce(base * base)\nprint mont.reduce(prod)\nprint \"\\nAlternate computation of x1 ^ x2 mod m\u00a0:\"\nprint pow(x1, x2, m)\n"}
{"id": 389663, "name": "Sokoban", "source": "Translate Ruby to Python: require 'set'\n\nclass Sokoban\n  def initialize(level)\n    board = level.each_line.map(&:rstrip)\n    @nrows = board.map(&:size).max\n    board.map!{|line| line.ljust(@nrows)}\n    board.each_with_index do |row, r|\n      row.each_char.with_index do |ch, c|\n        @px, @py = c, r  if ch == '@' or ch == '+'\n      end\n    end\n    @goal = board.join.tr(' .@\n                 .each_char.with_index.select{|ch, c| ch == '.'}\n                 .map(&:last)\n    @board = board.join.tr(' .@\n  end\n  \n  def pos(x, y)\n    y * @nrows + x\n  end\n  \n  def push(x, y, dx, dy, board)         \n    return  if board[pos(x+2*dx, y+2*dy)] != ' '\n    board[pos(x     , y     )] = ' '\n    board[pos(x + dx, y + dy)] = '@'\n    board[pos(x+2*dx, y+2*dy)] = '$'\n  end\n  \n  def solved?(board)\n    @goal.all?{|i| board[i] == '$'}\n  end\n  \n  DIRS = [[0, -1, 'u', 'U'], [ 1, 0, 'r', 'R'], [0,  1, 'd', 'D'], [-1, 0, 'l', 'L']]\n  def solve\n    queue = [[@board, \"\", @px, @py]]\n    visited = Set[@board]\n    \n    until queue.empty?\n      current, csol, x, y = queue.shift\n      \n      for dx, dy, cmove, cpush in DIRS\n        work = current.dup\n        case work[pos(x+dx, y+dy)]      \n        when '$'\n          next  unless push(x, y, dx, dy, work)\n          next  unless visited.add?(work)\n          return csol+cpush  if solved?(work)\n          queue << [work, csol+cpush, x+dx, y+dy]\n        when ' '\n          work[pos(x, y)]       = ' '\n          work[pos(x+dx, y+dy)] = '@'\n          queue << [work, csol+cmove, x+dx, y+dy]  if visited.add?(work)\n        end\n      end\n    end\n    \"No solution\"\n  end\nend\n", "target": "from array import array\nfrom collections import deque\nimport psyco\n\ndata = []\nnrows = 0\npx = py = 0\nsdata = \"\"\nddata = \"\"\n\ndef init(board):\n    global data, nrows, sdata, ddata, px, py\n    data = filter(None, board.splitlines())\n    nrows = max(len(r) for r in data)\n\n    maps = {' ':' ', '.': '.', '@':' ', '\n    mapd = {' ':' ', '.': ' ', '@':'@', '\n\n    for r, row in enumerate(data):\n        for c, ch in enumerate(row):\n            sdata += maps[ch]\n            ddata += mapd[ch]\n            if ch == '@':\n                px = c\n                py = r\n\ndef push(x, y, dx, dy, data):\n    if sdata[(y+2*dy) * nrows + x+2*dx] == '\n       data[(y+2*dy) * nrows + x+2*dx] != ' ':\n        return None\n\n    data2 = array(\"c\", data)\n    data2[y * nrows + x] = ' '\n    data2[(y+dy) * nrows + x+dx] = '@'\n    data2[(y+2*dy) * nrows + x+2*dx] = '*'\n    return data2.tostring()\n\ndef is_solved(data):\n    for i in xrange(len(data)):\n        if (sdata[i] == '.') != (data[i] == '*'):\n            return False\n    return True\n\ndef solve():\n    open = deque([(ddata, \"\", px, py)])\n    visited = set([ddata])\n    dirs = ((0, -1, 'u', 'U'), ( 1, 0, 'r', 'R'),\n            (0,  1, 'd', 'D'), (-1, 0, 'l', 'L'))\n\n    lnrows = nrows\n    while open:\n        cur, csol, x, y = open.popleft()\n\n        for di in dirs:\n            temp = cur\n            dx, dy = di[0], di[1]\n\n            if temp[(y+dy) * lnrows + x+dx] == '*':\n                temp = push(x, y, dx, dy, temp)\n                if temp and temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[3]\n                    open.append((temp, csol + di[3], x+dx, y+dy))\n                    visited.add(temp)\n            else:\n                if sdata[(y+dy) * lnrows + x+dx] == '\n                   temp[(y+dy) * lnrows + x+dx] != ' ':\n                    continue\n\n                data2 = array(\"c\", temp)\n                data2[y * lnrows + x] = ' '\n                data2[(y+dy) * lnrows + x+dx] = '@'\n                temp = data2.tostring()\n\n                if temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[2]\n                    open.append((temp, csol + di[2], x+dx, y+dy))\n                    visited.add(temp)\n\n    return \"No solution\"\n\n\nlevel = \"\"\"\\\n\n\n\n\n\n\n\n\n\npsyco.full()\ninit(level)\nprint level, \"\\n\\n\", solve()\n"}
{"id": 389664, "name": "Zumkeller numbers", "source": "Translate Ruby to Python: class Integer\n  \n  def divisors\n    res = [1, self]\n    (2..Integer.sqrt(self)).each do |n|\n      div, mod = divmod(n)\n      res << n << div if mod.zero?\n    end\n    res.uniq.sort\n  end\n  \n  def zumkeller?\n    divs = divisors\n    sum  = divs.sum\n    return false unless sum.even? && sum >= self*2\n    half = sum / 2\n    max_combi_size = divs.size / 2\n    1.upto(max_combi_size).any? do |combi_size|\n      divs.combination(combi_size).any?{|combi| combi.sum == half}\n    end\n  end\n  \nend\n\ndef p_enum(enum, cols = 10, col_width = 8)\n  enum.each_slice(cols) {|slice| puts \"%\nend\n\nputs \"\np_enum 1.step.lazy.select(&:zumkeller?).take(n), 14, 6\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select(&:zumkeller?).take(n)\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select{|x| x % 5 > 0 && x.zumkeller?}.take(n)\n", "target": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)\n"}
{"id": 389665, "name": "Rare numbers", "source": "Translate Ruby to Python: Term = Struct.new(:coeff, :ix1, :ix2) do\nend\n\nMAX_DIGITS = 16\n\ndef toLong(digits, reverse)\n    sum = 0\n    if reverse then\n        i = digits.length - 1\n        while i >=0\n            sum = sum  *10 + digits[i]\n            i = i - 1\n        end\n    else\n        i = 0\n        while i < digits.length\n            sum = sum * 10 + digits[i]\n            i = i + 1\n        end\n    end\n    return sum\nend\n\ndef isSquare(n)\n    root = Math.sqrt(n).to_i\n    return root * root == n\nend\n\ndef seq(from, to, step)\n    res = []\n    i = from\n    while i <= to\n        res << i\n        i = i + step\n    end\n    return res\nend\n\ndef format_number(number)\n  number.to_s.reverse.gsub(/(\\d{3})(?=\\d)/, '\\\\1,').reverse\nend\n\ndef main\n    pow = 1\n    allTerms = []\n    for i in 0 .. MAX_DIGITS - 2\n        allTerms << []\n    end\n    for r in 2 .. MAX_DIGITS\n        terms = []\n        pow = pow * 10\n        pow1 = pow\n        pow2 = 1\n        i1 = 0\n        i2 = r - 1\n        while i1 < i2\n            terms << Term.new(pow1 - pow2, i1, i2)\n            pow1 = (pow1 / 10).to_i\n            pow2 = pow2 * 10\n            i1 = i1 + 1\n            i2 = i2 - 1\n        end\n        allTerms[r - 2] = terms\n    end\n    \n    fml = {\n        0 =>[[2, 2], [8, 8]],\n        1 =>[[6, 5], [8, 7]],\n        4 =>[[4, 0]],\n        6 =>[[6, 0], [8, 2]]\n    }\n    \n    dmd = {}\n    for i in 0 .. 99\n        a = [(i / 10).to_i, (i % 10)]\n        d = a[0] - a[1]\n        if dmd.include?(d) then\n            dmd[d] << a\n        else\n            dmd[d] = [a]\n        end\n    end\n    fl = [0, 1, 4, 6]\n    dl = seq(-9, 9, 1) \n    zl = [0]           \n    el = seq(-8, 8, 2) \n    ol = seq(-9, 9, 2) \n    il = seq(0, 9, 1)\n    rares = []\n    lists = []\n    for i in 0 .. 3\n        lists << []\n    end\n    fl.each_with_index { |f, i|\n        lists[i] = [[f]]\n    }\n    digits = []\n    count = 0\n\n    \n    \n    fnpr = lambda { |cand, di, dis, indices, nmr, nd, level|\n        if level == dis.length then\n            digits[indices[0][0]] = fml[cand[0]][di[0]][0]\n            digits[indices[0][1]] = fml[cand[0]][di[0]][1]\n            le = di.length\n            if nd % 2 == 1 then\n                le = le - 1\n                digits[(nd / 2).to_i] = di[le]\n            end\n            di[1 .. le - 1].each_with_index { |d, i|\n                digits[indices[i + 1][0]] = dmd[cand[i + 1]][d][0]\n                digits[indices[i + 1][1]] = dmd[cand[i + 1]][d][1]\n            }\n            r = toLong(digits, true)\n            npr = nmr + 2 * r\n            if not isSquare(npr) then\n                return\n            end\n            count = count + 1\n            print \"     R/N %2d:\" % [count]\n            n = toLong(digits, false)\n            print \"  (%s)\\n\" % [format_number(n)]\n            rares << n\n        else\n            for num in dis[level]\n                di[level] = num\n                fnpr.call(cand, di, dis, indices, nmr, nd, level + 1)\n            end\n        end\n    }\n\n    \n    fnmr = lambda { |cand, list, indices, nd, level|\n        if level == list.length then\n            nmr = 0\n            nmr2 = 0\n            allTerms[nd - 2].each_with_index { |t, i|\n                if cand[i] >= 0 then\n                    nmr = nmr + t.coeff * cand[i]\n                else\n                    nmr2 = nmr2 = t.coeff * -cand[i]\n                    if nmr >= nmr2 then\n                        nmr = nmr - nmr2\n                        nmr2 = 0\n                    else\n                        nmr2 = nmr2 - nmr\n                        nmr = 0\n                    end\n                end\n            }\n            if nmr2 >= nmr then\n                return\n            end\n            nmr = nmr - nmr2\n            if not isSquare(nmr) then\n                return\n            end\n            dis = []\n            dis << seq(0, fml[cand[0]].length - 1, 1)\n            for i in 1 .. cand.length - 1\n                dis << seq(0, dmd[cand[i]].length - 1, 1)\n            end\n            if nd % 2 == 1 then\n                dis << il.dup\n            end\n            di = []\n            for i in 0 .. dis.length - 1\n                di << 0\n            end\n            fnpr.call(cand, di, dis, indices, nmr, nd, 0)\n        else\n            for num in list[level]\n                cand[level] = num\n                fnmr.call(cand, list, indices, nd, level + 1)\n            end\n        end\n    }\n\n    \n    for nd in 2 .. 10\n        digits = []\n        for i in 0 .. nd - 1\n            digits << 0\n        end\n        if nd == 4 then\n            lists[0] << zl.dup\n            lists[1] << ol.dup\n            lists[2] << el.dup\n            lists[3] << ol.dup\n        elsif allTerms[nd - 2].length > lists[0].length then\n            for i in 0 .. 3\n                lists[i] << dl.dup\n            end\n        end\n        indices = []\n        for t in allTerms[nd - 2]\n            indices << [t.ix1, t.ix2]\n        end\n        for list in lists\n            cand = []\n            for i in 0 .. list.length - 1\n                cand << 0\n            end\n            fnmr.call(cand, list, indices, nd, 0)\n        end\n        print \"  %2d digits\\n\" % [nd]\n    end\n\n    rares.sort()\n    print \"\\nThe rare numbers with up to %d digits are:\\n\" % [MAX_DIGITS]\n    rares.each_with_index { |rare, i|\n        print \"  %2d:  %25s\\n\" % [i + 1, format_number(rare)]\n    }\nend\n\nmain()\n", "target": "\n\n\n\nfrom math import floor, sqrt\nfrom datetime import datetime\n\ndef main():\n\tstart = datetime.now()\n\tfor i in xrange(1, 10 ** 11):\n\t\tif rare(i):\n\t\t\tprint \"found a rare:\", i\n\tend = datetime.now()\n\tprint \"time elapsed:\", end - start\n\ndef is_square(n):\n\ts = floor(sqrt(n + 0.5))\n\treturn s * s == n\n\ndef reverse(n):\n\treturn int(str(n)[::-1])\n\ndef is_palindrome(n):\n\treturn n == reverse(n)\n\ndef rare(n):\n\tr = reverse(n)\n\treturn ( \n\t\tnot is_palindrome(n) and \n\t\tn > r and\n\t\tis_square(n+r) and is_square(n-r)\n\t)\n\nif __name__ == '__main__':\n\tmain()\n"}
{"id": 389666, "name": "Suffix tree", "source": "Translate Ruby to Python: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "class Node:\n    def __init__(self, sub=\"\", children=None):\n        self.sub = sub\n        self.ch = children or []\n\nclass SuffixTree:\n    def __init__(self, str):\n        self.nodes = [Node()]\n        for i in range(len(str)):\n            self.addSuffix(str[i:])\n\n    def addSuffix(self, suf):\n        n = 0\n        i = 0\n        while i < len(suf):\n            b = suf[i]\n            x2 = 0\n            while True:\n                children = self.nodes[n].ch\n                if x2 == len(children):\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(suf[i:], []))\n                    self.nodes[n].ch.append(n2)\n                    return\n                n2 = children[x2]\n                if self.nodes[n2].sub[0] == b:\n                    break\n                x2 = x2 + 1\n\n            \n            sub2 = self.nodes[n2].sub\n            j = 0\n            while j < len(sub2):\n                if suf[i + j] != sub2[j]:\n                    \n                    n3 = n2\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(sub2[:j], [n3]))\n                    self.nodes[n3].sub = sub2[j:] \n                    self.nodes[n].ch[x2] = n2\n                    break \n                j = j + 1\n            i = i + j   \n            n = n2      \n\n    def visualize(self):\n        if len(self.nodes) == 0:\n            print \"<empty>\"\n            return\n\n        def f(n, pre):\n            children = self.nodes[n].ch\n            if len(children) == 0:\n                print \"--\", self.nodes[n].sub\n                return\n            print \"+-\", self.nodes[n].sub\n            for c in children[:-1]:\n                print pre, \"+-\",\n                f(c, pre + \" | \")\n            print pre, \"+-\",\n            f(children[-1], pre + \"  \")\n\n        f(0, \"\")\n\nSuffixTree(\"banana$\").visualize()\n"}
{"id": 389667, "name": "Suffix tree", "source": "Translate Ruby to Python: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "class Node:\n    def __init__(self, sub=\"\", children=None):\n        self.sub = sub\n        self.ch = children or []\n\nclass SuffixTree:\n    def __init__(self, str):\n        self.nodes = [Node()]\n        for i in range(len(str)):\n            self.addSuffix(str[i:])\n\n    def addSuffix(self, suf):\n        n = 0\n        i = 0\n        while i < len(suf):\n            b = suf[i]\n            x2 = 0\n            while True:\n                children = self.nodes[n].ch\n                if x2 == len(children):\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(suf[i:], []))\n                    self.nodes[n].ch.append(n2)\n                    return\n                n2 = children[x2]\n                if self.nodes[n2].sub[0] == b:\n                    break\n                x2 = x2 + 1\n\n            \n            sub2 = self.nodes[n2].sub\n            j = 0\n            while j < len(sub2):\n                if suf[i + j] != sub2[j]:\n                    \n                    n3 = n2\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(sub2[:j], [n3]))\n                    self.nodes[n3].sub = sub2[j:] \n                    self.nodes[n].ch[x2] = n2\n                    break \n                j = j + 1\n            i = i + j   \n            n = n2      \n\n    def visualize(self):\n        if len(self.nodes) == 0:\n            print \"<empty>\"\n            return\n\n        def f(n, pre):\n            children = self.nodes[n].ch\n            if len(children) == 0:\n                print \"--\", self.nodes[n].sub\n                return\n            print \"+-\", self.nodes[n].sub\n            for c in children[:-1]:\n                print pre, \"+-\",\n                f(c, pre + \" | \")\n            print pre, \"+-\",\n            f(children[-1], pre + \"  \")\n\n        f(0, \"\")\n\nSuffixTree(\"banana$\").visualize()\n"}
{"id": 389668, "name": "Reflection_List properties", "source": "Translate Ruby to Python: class Foo\n  @@xyz = nil\n  def initialize(name, age)\n    @name, @age = name, age\n  end\n  def add_sex(sex)\n    @sex = sex\n  end\nend\n\np foo = Foo.new(\"Angel\", 18)            \np foo.instance_variables                \np foo.instance_variable_defined?(:@age) \np foo.instance_variable_get(:@age)      \np foo.instance_variable_set(:@age, 19)  \np foo                                   \nfoo.add_sex(:woman)\np foo.instance_variables                \np foo                                   \nfoo.instance_variable_set(:@bar, nil)\np foo.instance_variables                \n\np Foo.class_variables                   \np Foo.class_variable_defined?(:@@xyz)   \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@xyz, :xyz)  \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@abc, 123)   \np Foo.class_variables                   \n", "target": "class Parent(object):\n    __priv = 'private'\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __repr__(self):\n        return '%s(%s)' % (type(self).__name__, self.name)\n    \n    def doNothing(self):\n        pass\n\nimport re\n\nclass Child(Parent):\n    \n    __rePrivate = re.compile('^_(Child|Parent)__')\n    \n    __reBleh = re.compile('\\Wbleh$')\n    @property\n    def reBleh(self):\n        return self.__reBleh\n    \n    def __init__(self, name, *args):\n        super(Child, self).__init__(name)\n        self.args = args\n    \n    def __dir__(self):\n        myDir = filter(\n            \n            lambda p: not self.__rePrivate.match(p),\n            list(set( \\\n                sum([dir(base) for base in type(self).__bases__], []) \\\n                + type(self).__dict__.keys() \\\n                + self.__dict__.keys() \\\n            )))\n        return myDir + map(\n            \n            lambda p: p + '_bleh',\n            filter(\n                \n                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),\n                myDir))\n    \n    def __getattr__(self, name):\n        if name[-5:] == '_bleh':\n            \n            return str(getattr(self, name[:-5])) + ' bleh'\n        if hasattr(super(Child, chld), '__getattr__'):\n            return super(Child, self).__getattr__(name)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n    \n    def __setattr__(self, name, value):\n        if name[-5:] == '_bleh':\n            \n            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):\n                setattr(self, name[:-5], self.reBleh.sub('', value))\n        elif hasattr(super(Child, self), '__setattr__'):\n            super(Child, self).__setattr__(name, value)\n        elif hasattr(self, '__dict__'):\n            self.__dict__[name] = value\n    \n    def __repr__(self):\n        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))\n    \n    def doStuff(self):\n        return (1+1.0/1e6) ** 1e6\n\npar = Parent('par')\npar.parent = True\ndir(par)\n\ninspect.getmembers(par)\n\n\nchld = Child('chld', 0, 'I', 'two')\nchld.own = \"chld's own\"\ndir(chld)\n\ninspect.getmembers(chld)\n\n"}
{"id": 389669, "name": "Eertree", "source": "Translate Ruby to Python: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "\nfrom __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)\n"}
{"id": 389670, "name": "Eertree", "source": "Translate Ruby to Python: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "\nfrom __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)\n"}
{"id": 389671, "name": "Base58Check encoding", "source": "Translate Ruby to Python: ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nnums =  [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n\nputs nums.map{|n| n.digits(58).reverse.map{|i| ALPHABET[i]}.join}\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 389672, "name": "Base58Check encoding", "source": "Translate Ruby to Python: ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nnums =  [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n\nputs nums.map{|n| n.digits(58).reverse.map{|i| ALPHABET[i]}.join}\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 389673, "name": "Latin Squares in reduced form", "source": "Translate Ruby to Python: def printSquare(a)\n    for row in a\n        print row, \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndef dList(n, start)\n    start = start - 1 \n    a = Array.new(n) {|i| i}\n    a[0], a[start] = a[start], a[0]\n    a[1..] = a[1..].sort\n    first = a[1]\n\n    r = []\n    recurse = lambda {|last|\n        if last == first then\n            \n            \n            a[1..].each_with_index {|v, j|\n                if j + 1 == v then\n                    return \n                end\n            }\n            \n            b = a.map { |i| i + 1 }\n            r << b\n            return\n        end\n\n        i = last\n        while i >= 1 do\n            a[i], a[last] = a[last], a[i]\n            recurse.call(last - 1)\n            a[i], a[last] = a[last], a[i]\n            i = i - 1\n        end\n    }\n\n    recurse.call(n - 1)\n    return r\nend\n\ndef reducedLatinSquares(n, echo)\n    if n <= 0 then\n        if echo then\n            print \"[]\\n\\n\"\n        end\n        return 0\n    end\n    if n == 1 then\n        if echo then\n            print \"[1]\\n\\n\"\n        end\n        return 1\n    end\n\n    rlatin = Array.new(n) { Array.new(n, Float::NAN)}\n\n    \n    for j in 0 .. n - 1\n        rlatin[0][j] = j + 1\n    end\n\n    count = 0\n    recurse = lambda {|i|\n        rows = dList(n, i)\n\n        for r in 0 .. rows.length - 1\n            rlatin[i - 1] = rows[r].dup\n            catch (:outer) do\n                for k in 0 .. i - 2\n                    for j in 1 .. n - 1\n                        if rlatin[k][j] == rlatin[i - 1][j] then\n                            if r < rows.length - 1 then\n                                throw :outer\n                            end\n                            if i > 2 then\n                                return\n                            end\n                        end\n                    end\n                end\n                if i < n then\n                    recurse.call(i + 1)\n                else\n                    count = count + 1\n                    if echo then\n                        printSquare(rlatin)\n                    end\n                end\n            end\n        end\n    }\n\n    \n    recurse.call(2)\n    return count\nend\n\ndef factorial(n)\n    if n == 0 then\n        return 1\n    end\n    prod = 1\n    for i in 2 .. n\n        prod = prod * i\n    end\n    return prod\nend\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4, true)\n\nprint \"The size of the set of reduced latin squares for the following orders\\n\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in 1 .. 6\n    size = reducedLatinSquares(n, false)\n    f = factorial(n - 1)\n    f = f * f * n * size\n    print \"Order %d Size\u00a0%-4d x %d! x %d! => Total %d\\n\" % [n, size, n, n - 1, f]\nend\n", "target": "def dList(n, start):\n    start -= 1 \n    a = range(n)\n    a[start] = a[0]\n    a[0] = start\n    a[1:] = sorted(a[1:])\n    first = a[1]\n    \n    r = []\n    def recurse(last):\n        if (last == first):\n            \n            \n            \n            for j,v in enumerate(a[1:]):\n                if j + 1 == v:\n                    return \n            b = [x + 1 for x in a]\n            r.append(b)\n            return\n        for i in xrange(last, 0, -1):\n            a[i], a[last] = a[last], a[i]\n            recurse(last - 1)\n            a[i], a[last] = a[last], a[i]\n    recurse(n - 1)\n    return r\n\ndef printSquare(latin,n):\n    for row in latin:\n        print row\n    print\n\ndef reducedLatinSquares(n,echo):\n    if n <= 0:\n        if echo:\n            print []\n        return 0\n    elif n == 1:\n        if echo:\n            print [1]\n        return 1\n\n    rlatin = [None] * n\n    for i in xrange(n):\n        rlatin[i] = [None] * n\n    \n    for j in xrange(0, n):\n        rlatin[0][j] = j + 1\n\n    class OuterScope:\n        count = 0\n    def recurse(i):\n        rows = dList(n, i)\n\n        for r in xrange(len(rows)):\n            rlatin[i - 1] = rows[r]\n            justContinue = False\n            k = 0\n            while not justContinue and k < i - 1:\n                for j in xrange(1, n):\n                    if rlatin[k][j] == rlatin[i - 1][j]:\n                        if r < len(rows) - 1:\n                            justContinue = True\n                            break\n                        if i > 2:\n                            return\n                k += 1\n            if not justContinue:\n                if i < n:\n                    recurse(i + 1)\n                else:\n                    OuterScope.count += 1\n                    if echo:\n                        printSquare(rlatin, n)\n\n    \n    recurse(2)\n    return OuterScope.count\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    prod = 1\n    for i in xrange(2, n + 1):\n        prod *= i\n    return prod\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4,True)\n\nprint \"The size of the set of reduced latin squares for the following orders\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in xrange(1, 7):\n    size = reducedLatinSquares(n, False)\n    f = factorial(n - 1)\n    f *= f * n * size\n    print \"Order %d: Size %-4d x %d! x %d! => Total %d\" % (n, size, n, n - 1, f)\n"}
{"id": 389674, "name": "Kosaraju", "source": "Translate Ruby to Python: func korasaju(Array g) {\n    \n    var vis = g.len.of(false)\n    var L   = []\n    var x   = g.end\n    var t   = g.len.of { [] }\n\n    \n    func visit(u) {\n        if (!vis[u]) {\n            vis[u] = true\n            g[u].each {|v|\n                visit(v)\n                t[v] << u\n            }\n            L[x--] = u\n        }\n    }\n\n    \n    g.range.each {|u|\n        visit(u)\n    }\n\n    var c = []\n\n    \n    func assign(u, root) {\n        if (vis[u]) {\n            vis[u] = false\n            c[u] = root\n            t[u].each {|v|\n                assign(v, root)\n            }\n        }\n    }\n\n    \n    L.each {|u|\n        assign(u, u)\n    }\n\n    return c\n}\n\nvar g = [[1], [2], [0], [1, 2, 4], [3, 5], [2, 6], [5], [4, 6, 7]]\nsay korasaju(g)\n", "target": "def kosaraju(g):\n    class nonlocal: pass\n\n    \n    size = len(g)\n\n    vis = [False]*size \n    l = [0]*size\n    nonlocal.x = size\n    t = [[]]*size   \n\n    def visit(u):\n        if not vis[u]:\n            vis[u] = True\n            for v in g[u]:\n                visit(v)\n                t[v] = t[v] + [u]\n            nonlocal.x = nonlocal.x - 1\n            l[nonlocal.x] = u\n\n    \n    for u in range(len(g)):\n        visit(u)\n    c = [0]*size\n\n    def assign(u, root):\n        if vis[u]:\n            vis[u] = False\n            c[u] = root\n            for v in t[u]:\n                assign(v, root)\n\n    \n    for u in l:\n        assign(u, u)\n\n    return c\n\ng = [[1], [2], [0], [1,2,4], [3,5], [2,6], [5], [4,6,7]]\nprint kosaraju(g)\n"}
{"id": 389675, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Ruby to Python: def cumulative_freq(freq)\n  cf = {}\n  total = 0\n  freq.keys.sort.each do |b|\n    cf[b] = total\n    total += freq[b]\n  end\n  return cf\nend\n\ndef arithmethic_coding(bytes, radix)\n\n  \n  freq = Hash.new(0)\n  bytes.each { |b| freq[b] += 1 }\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  base = bytes.size\n\n  \n  lower = 0\n\n  \n  pf = 1\n\n  \n  \n  bytes.each do |b|\n    lower = lower*base + cf[b]*pf\n    pf *= freq[b]\n  end\n\n  \n  upper = lower+pf\n\n  pow = 0\n  loop do\n    pf /= radix\n    break if pf==0\n    pow += 1\n  end\n\n  enc = ((upper-1) / radix**pow)\n  [enc, pow, freq]\nend\n\ndef arithmethic_decoding(enc, radix, pow, freq)\n\n  \n  enc *= radix**pow;\n\n  \n  base = freq.values.reduce(:+)\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  dict = {}\n  cf.each_pair do |k,v|\n    dict[v] = k\n  end\n\n  \n  lchar = nil\n  (0...base).each do |i|\n    if dict.has_key?(i)\n      lchar = dict[i]\n    elsif lchar != nil\n      dict[i] = lchar\n    end\n  end\n\n  \n  decoded = []\n  (0...base).reverse_each do |i|\n    pow = base**i\n    div = enc/pow\n\n    c  = dict[div]\n    fv = freq[c]\n    cv = cf[c]\n\n    rem = ((enc - pow*cv) / fv)\n\n    enc = rem\n    decoded << c\n  end\n\n  \n  return decoded\nend\n\nradix = 10      \n\n%w(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT).each do |str|\n\n  enc, pow, freq = arithmethic_coding(str.bytes, radix)\n  dec = arithmethic_decoding(enc, radix, pow, freq).map{|b| b.chr }.join\n\n  printf(\"%-25s=> %19s * %d^%s\\n\", str, enc, radix, pow)\n\n  if str != dec\n    raise \"\\tHowever that is incorrect!\"\n  end\nend\n", "target": "from collections import Counter\n\ndef cumulative_freq(freq):\n    cf = {}\n    total = 0\n    for b in range(256):\n        if b in freq:\n            cf[b] = total\n            total += freq[b]\n    return cf\n\ndef arithmethic_coding(bytes, radix):\n\n    \n    freq = Counter(bytes)\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    base = len(bytes)\n\n    \n    lower = 0\n\n    \n    pf = 1\n\n    \n    \n    for b in bytes:\n        lower = lower*base + cf[b]*pf\n        pf *= freq[b]\n\n    \n    upper = lower+pf\n\n    pow = 0\n    while True:\n        pf //= radix\n        if pf==0: break\n        pow += 1\n\n    enc = (upper-1) // radix**pow\n    return enc, pow, freq\n\ndef arithmethic_decoding(enc, radix, pow, freq):\n\n    \n    enc *= radix**pow;\n\n    \n    base = sum(freq.values())\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    dict = {}\n    for k,v in cf.items():\n        dict[v] = k\n\n    \n    lchar = None\n    for i in range(base):\n        if i in dict:\n            lchar = dict[i]\n        elif lchar is not None:\n            dict[i] = lchar\n\n    \n    decoded = bytearray()\n    for i in range(base-1, -1, -1):\n        pow = base**i\n        div = enc//pow\n\n        c  = dict[div]\n        fv = freq[c]\n        cv = cf[c]\n\n        rem = (enc - pow*cv) // fv\n\n        enc = rem\n        decoded.append(c)\n\n    \n    return bytes(decoded)\n\nradix = 10      \n\nfor str in b'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split():\n    enc, pow, freq = arithmethic_coding(str, radix)\n    dec = arithmethic_decoding(enc, radix, pow, freq)\n\n    print(\"%-25s=> %19s * %d^%s\" % (str, enc, radix, pow))\n\n    if str != dec:\n    \traise Exception(\"\\tHowever that is incorrect!\")\n"}
{"id": 389676, "name": "Playfair cipher", "source": "Translate Ruby to Python: class Playfair\n  Size = 5\n  def initialize(key, missing)\n    @missing = missing.upcase\n    alphabet = ('A'..'Z').to_a.join.upcase.delete(@missing).split''\n    extended = key.upcase.gsub(/[^A-Z]/,'').split('') + alphabet\n    grid = extended.uniq[0...Size*Size].each_slice(Size).to_a\n    coords = {}\n    grid.each_with_index do |row, i|\n      row.each_with_index do |letter, j|\n       coords[letter] = [i,j]\n      end\n    end\n    @encode = {}\n    alphabet.product(alphabet).reject { |a,b| a==b }.each do |a, b|\n      i1, j1 = coords[a]\n      i2, j2 = coords[b]\n      if i1 == i2 then\n         j1 = (j1 + 1) % Size\n         j2 = (j2 + 1) % Size\n      elsif j1 == j2 then\n         i1 = (i1 + 1) % Size\n         i2 = (i2 + 1) % Size\n      else\n         j1, j2 = j2, j1\n      end\n      @encode[\"\n      @decode = @encode.invert\n    end\n  end\n\n  def encode(plaintext) \n    plain = plaintext.upcase.gsub(/[^A-Z]/,'')\n    if @missing == 'J' then\n      plain = plain.gsub(/J/, 'I')\n    else\n      plain = plain.gsub(@missing, 'X')\n    end\n    plain = plain.gsub(/(.)\\1/, '\\1X\\1')\n    if plain.length % 2 == 1 then\n      plain += 'X'\n    end\n    return plain.upcase.split('').each_slice(2).map do |pair|\n      @encode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\n\n  def decode(ciphertext) \n    cipher = ciphertext.upcase.gsub(/[^A-Z]/,'')\n    return cipher.upcase.split('').each_slice(2).map do |pair|\n      @decode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\nend\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 389677, "name": "Playfair cipher", "source": "Translate Ruby to Python: class Playfair\n  Size = 5\n  def initialize(key, missing)\n    @missing = missing.upcase\n    alphabet = ('A'..'Z').to_a.join.upcase.delete(@missing).split''\n    extended = key.upcase.gsub(/[^A-Z]/,'').split('') + alphabet\n    grid = extended.uniq[0...Size*Size].each_slice(Size).to_a\n    coords = {}\n    grid.each_with_index do |row, i|\n      row.each_with_index do |letter, j|\n       coords[letter] = [i,j]\n      end\n    end\n    @encode = {}\n    alphabet.product(alphabet).reject { |a,b| a==b }.each do |a, b|\n      i1, j1 = coords[a]\n      i2, j2 = coords[b]\n      if i1 == i2 then\n         j1 = (j1 + 1) % Size\n         j2 = (j2 + 1) % Size\n      elsif j1 == j2 then\n         i1 = (i1 + 1) % Size\n         i2 = (i2 + 1) % Size\n      else\n         j1, j2 = j2, j1\n      end\n      @encode[\"\n      @decode = @encode.invert\n    end\n  end\n\n  def encode(plaintext) \n    plain = plaintext.upcase.gsub(/[^A-Z]/,'')\n    if @missing == 'J' then\n      plain = plain.gsub(/J/, 'I')\n    else\n      plain = plain.gsub(@missing, 'X')\n    end\n    plain = plain.gsub(/(.)\\1/, '\\1X\\1')\n    if plain.length % 2 == 1 then\n      plain += 'X'\n    end\n    return plain.upcase.split('').each_slice(2).map do |pair|\n      @encode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\n\n  def decode(ciphertext) \n    cipher = ciphertext.upcase.gsub(/[^A-Z]/,'')\n    return cipher.upcase.split('').each_slice(2).map do |pair|\n      @decode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\nend\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 389678, "name": "Elementary cellular automaton_Infinite length", "source": "Translate Ruby to Python: def notcell(c)\n  c.tr('01','10')\nend\n\ndef eca_infinite(cells, rule)\n  neighbours2next = Hash[8.times.map{|i|[\"%03b\"%i, \"01\"[rule[i]]]}]\n  c = cells\n  Enumerator.new do |y|\n    loop do\n      y << c\n      c = notcell(c[0])*2 + c + notcell(c[-1])*2        \n      c = (1..c.size-2).map{|i| neighbours2next[c[i-1..i+1]]}.join\n    end\n  end\nend\n\nif __FILE__ == $0\n  lines = 25\n  for rule in [90, 30]\n    puts \"\\nRule: %i\" % rule\n    for i, c in (0...lines).zip(eca_infinite('1', rule))\n      puts '%2i: %s%s' % [i, ' '*(lines - i), c.tr('01', '.\n    end\n  end\nend\n", "target": "def _notcell(c):\n    return '0' if c == '1' else '1'\n\ndef eca_infinite(cells, rule):\n    lencells = len(cells)\n    rulebits = '{0:08b}'.format(rule)\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\n    c = cells\n    while True:\n        yield c\n        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    \n\n        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))\n        \n\nif __name__ == '__main__':\n    lines = 25\n    for rule in (90, 30):\n        print('\\nRule: %i' % rule)\n        for i, c in zip(range(lines), eca_infinite('1', rule)):\n            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '\n"}
{"id": 389679, "name": "Word break problem", "source": "Translate Ruby to Python: def split_text_with_dict(text, dict, splited=[])\n  solutions = []\n  dict.each do |word|\n    if text.start_with? word\n      new_text = text.delete_prefix word\n      new_splited = splited.dup<< word\n      if new_text.empty?\n        solutions << new_splited\n      else\n        sols = split_text_with_dict(new_text, dict, new_splited)\n        sols.each { |s| solutions << s } \n      end\n    end\n  end\n  return solutions\nend\n", "target": "\n\nfrom itertools import (chain)\n\n\n\ndef stringParse(lexicon):\n    \n    return lambda s: Node(s)(\n        tokenTrees(lexicon)(s)\n    )\n\n\n\ndef tokenTrees(wds):\n    \n    def go(s):\n        return [Node(s)([])] if s in wds else (\n            concatMap(nxt(s))(wds)\n        )\n\n    def nxt(s):\n        return lambda w: parse(\n            w, go(s[len(w):])\n        ) if s.startswith(w) else []\n\n    def parse(w, xs):\n        return [Node(w)(xs)] if xs else xs\n\n    return lambda s: go(s)\n\n\n\ndef showParse(tree):\n    \n    def showTokens(x):\n        xs = x['nest']\n        return ' ' + x['root'] + (showTokens(xs[0]) if xs else '')\n    parses = tree['nest']\n    return tree['root'] + ':\\n' + (\n        '\\n'.join(\n            map(showTokens, parses)\n        ) if parses else ' ( Not parseable in terms of these words )'\n    )\n\n\n\n\ndef main():\n    \n\n    lexicon = 'a bc abc cd b'.split()\n    testSamples = 'abcd abbc abcbcd acdbc abcdd'.split()\n\n    print(unlines(\n        map(\n            showParse,\n            map(\n                stringParse(lexicon),\n                testSamples\n            )\n        )\n    ))\n\n\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: list(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 389680, "name": "Create an object_Native demonstration", "source": "Translate Ruby to Python: \n\n\n\n\n\n\n\nclass FencedHash\n\n  \n  \n  \n  \n  \n  \n  \n  def initialize(hash, obj=nil)\n    @default = obj\n    @hash = {}\n    hash.each_pair do |key, value|\n      \n      \n      @hash[key] = [value, value]\n    end\n  end\n\n  def initialize_clone(orig)\n    \n    \n    super\n    copy = {}\n    @hash.each_pair {|key, values| copy[key] = values.clone }\n    @hash = copy\n  end\n\n  def initialize_dup(orig)\n    \n    \n    super\n    copy = {}\n    @hash.each_pair {|key, values| copy[key] = values.dup }\n    @hash = copy\n  end\n\n  \n  \n  def [](key)\n    values = @hash[key]\n    if values\n      values[0]\n    else\n      @default\n    end\n  end\n\n  \n  \n  \n  \n  \n  \n  def []=(key, value)\n    values = @hash[key]\n    if values\n      values[0] = value\n    else\n      raise KeyError, \"fence prevents adding new key: \n    end\n  end\n  alias store []=\n\n  \n  def clear\n    @hash.each_value {|values| values[0] = values[1]}\n    self\n  end\n\n  \n  \n  def delete(key)\n    values = @hash[key]\n    if values\n      old = values[0]\n      values[0] = values[1]\n      old  \n    end    \n  end\n\n  \n  \n  \n  \n  \n  \n  def delete_if\n    if block_given?\n      @hash.each_pair do |key, values|\n        yield(key, values[0]) and values[0] = values[1]\n      end\n      self\n    else\n      enum_for(:delete_if) { @hash.size }\n    end\n  end\n\n  \n  attr_accessor :default\n\n  \n  \n  \n  \n  \n  def each_key(&block)\n    if block\n      @hash.each_key(&block)\n      self\n    else\n      enum_for(:each_key) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  \n  def each_pair\n    if block_given?\n      @hash.each_pair {|key, values| yield [key, values[0]] }\n      self\n    else\n      enum_for(:each_pair) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  def each_value\n    if block_given?\n      @hash.each_value {|values| yield values[0] }\n    else\n      enum_for(:each_value) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  def fetch(*argv)\n    argc = argv.length\n    unless argc.between?(1, 2)\n      raise(ArgumentError,\n            \"wrong number of arguments (\n    end\n    if argc == 2 and block_given?\n      warn(\"\n           \"block supersedes default value argument\")\n    end\n\n    key, default = argv\n    values = @hash[key]\n    if values\n      values[0]\n    elsif block_given?\n      yield key\n    elsif argc == 2\n      default\n    else\n      raise KeyError, \"key not found: \n    end\n  end\n\n  \n  def freeze\n    @hash.each_value {|values| values.freeze }\n    super\n  end\n\n  \n  def has_key?(key)\n    @hash.has_key?(key)\n  end\n  alias include? has_key?\n  alias member? has_key?\n\n  \n  \n  \n  \n  \n  \n  def keep_if\n    if block_given?\n      @hash.each_pair do |key, values|\n        yield(key, values[0]) or values[0] = values[1]\n      end\n      self\n    else\n      enum_for(:keep_if) { @hash.size }\n    end\n  end\n\n  \n  def keys\n    @hash.keys\n  end\n\n  \n  def length\n    @hash.length\n  end\n  alias size length\n\n  \n  def to_h\n    result = Hash.new(@default)\n    @hash.each_pair {|key, values| result[key] = values[0]}\n    result\n  end\n\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n\n  \n  def values\n    @hash.each_value.map {|values| values[0]}\n  end\n\n  \n  def values_at(*keys)\n    keys.map {|key| self[key]}\n  end\nend\n", "target": "from collections import UserDict\nimport copy\n\nclass Dict(UserDict):\n    \n    def __init__(self, dict=None, **kwargs):\n        self.__init = True\n        super().__init__(dict, **kwargs)\n        self.default = copy.deepcopy(self.data)\n        self.__init = False\n    \n    def __delitem__(self, key):\n        if key in self.default:\n            self.data[key] = self.default[key]\n        else:\n            raise NotImplementedError\n\n    def __setitem__(self, key, item):\n        if self.__init:\n            super().__setitem__(key, item)\n        elif key in self.data:\n            self.data[key] = item\n        else:\n            raise KeyError\n\n    def __repr__(self):\n        return \"%s(%s)\" % (type(self).__name__, super().__repr__())\n    \n    def fromkeys(cls, iterable, value=None):\n        if self.__init:\n            super().fromkeys(cls, iterable, value)\n        else:\n            for key in iterable:\n                if key in self.data:\n                    self.data[key] = value\n                else:\n                    raise KeyError\n\n    def clear(self):\n        self.data.update(copy.deepcopy(self.default))\n\n    def pop(self, key, default=None):\n        raise NotImplementedError\n\n    def popitem(self):\n        raise NotImplementedError\n\n    def update(self, E, **F):\n        if self.__init:\n            super().update(E, **F)\n        else:\n            haskeys = False\n            try:\n                keys = E.keys()\n                haskeys = Ture\n            except AttributeError:\n                pass\n            if haskeys:\n                for key in keys:\n                    self[key] = E[key]\n            else:\n                for key, val in E:\n                    self[key] = val\n            for key in F:\n                self[key] = F[key]\n\n    def setdefault(self, key, default=None):\n        if key not in self.data:\n            raise KeyError\n        else:\n            return super().setdefault(key, default)\n"}
{"id": 389681, "name": "Decimal floating point number to binary", "source": "Translate Ruby to Python: def dec2bin(dec, precision=16)    \n  int, df = dec.split(\".\")\n  minus = int.delete!(\"-\")\n  bin = (minus ? \"-\" : \"\") + int.to_i.to_s(2) + \".\"\n  if df and df.to_i>0\n    fp = (\".\"+df).to_f\n    digit = 1\n    until fp.zero? or digit>precision\n      fp *= 2\n      n = fp.to_i\n      bin << n.to_s\n      fp -= n\n      digit += 1\n    end\n  else\n    bin << \"0\"\n  end\n  bin\nend\n\ndef bin2dec(bin)              \n  int, df = bin.split(\".\")\n  minus = int.delete!(\"-\")\n  dec = (minus ? \"-\" : \"\") + int.to_i(2).to_s\n  if df\n    dec << (df.to_i(2) / 2.0**(df.size)).to_s[1..-1]\n  else\n    dec << \".0\"\n  end\nend\n\ndata = %w[23.34375 11.90625 -23.34375 -11.90625]\ndata.each do |dec|\n  bin  = dec2bin(dec)\n  dec2 = bin2dec(bin)\n  puts \"%10s => %12s =>%10s\" % [dec, bin, dec2]\nend\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 389682, "name": "Decimal floating point number to binary", "source": "Translate Ruby to Python: def dec2bin(dec, precision=16)    \n  int, df = dec.split(\".\")\n  minus = int.delete!(\"-\")\n  bin = (minus ? \"-\" : \"\") + int.to_i.to_s(2) + \".\"\n  if df and df.to_i>0\n    fp = (\".\"+df).to_f\n    digit = 1\n    until fp.zero? or digit>precision\n      fp *= 2\n      n = fp.to_i\n      bin << n.to_s\n      fp -= n\n      digit += 1\n    end\n  else\n    bin << \"0\"\n  end\n  bin\nend\n\ndef bin2dec(bin)              \n  int, df = bin.split(\".\")\n  minus = int.delete!(\"-\")\n  dec = (minus ? \"-\" : \"\") + int.to_i(2).to_s\n  if df\n    dec << (df.to_i(2) / 2.0**(df.size)).to_s[1..-1]\n  else\n    dec << \".0\"\n  end\nend\n\ndata = %w[23.34375 11.90625 -23.34375 -11.90625]\ndata.each do |dec|\n  bin  = dec2bin(dec)\n  dec2 = bin2dec(bin)\n  puts \"%10s => %12s =>%10s\" % [dec, bin, dec2]\nend\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 389683, "name": "Free polyominoes enumeration", "source": "Translate Ruby to Python: require 'set'\n\ndef translate2origin(poly)\n  \n  minx = poly.map(&:first).min\n  miny = poly.map(&:last).min\n  poly.map{|x,y| [x - minx, y - miny]}.sort\nend\n\ndef rotate90(x,y) [y, -x] end\ndef reflect(x,y)  [-x, y] end\n\n\ndef rotations_and_reflections(poly)\n  [poly,\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| reflect(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n          poly.map{|x,y| rotate90(x,y)} ]\nend\n\ndef canonical(poly)\n  rotations_and_reflections(poly).map{|pl| translate2origin(pl)}\nend\n\n\ndef contiguous(x,y)\n  [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\nend\n\n\ndef new_points(poly)\n  points = []\n  poly.each{|x,y| contiguous(x,y).each{|point| points << point}}\n  (points - poly).uniq\nend\n\ndef new_polys(polys)\n  pattern = Set.new\n  polys.each_with_object([]) do |poly, polyomino|\n    new_points(poly).each do |point|\n      next if pattern.include?(pl = translate2origin(poly + [point]))\n      polyomino << canonical(pl).each{|p| pattern << p}.min\n    end\n  end\nend\n\n\ndef rank(n)\n  case n\n  when 0 then [[]]\n  when 1 then [[[0,0]]]\n  else        new_polys(rank(n-1))\n  end\nend\n\n\ndef text_representation(poly)\n  table = Hash.new(' ')\n  poly.each{|x,y| table[[x,y]] = '\n  maxx = poly.map(&:first).max\n  maxy = poly.map(&:last).max\n  (0..maxx).map{|x| (0..maxy).map{|y| table[[x,y]]}.join}\nend\n\np (0..10).map{|n| rank(n).size}\nn = ARGV[0] ? ARGV[0].to_i : 5\nputs \"\\nAll free polyominoes of rank %d:\" % n\nrank(n).sort.each{|poly| puts text_representation(poly),\"\"}\n", "target": "from itertools import imap, imap, groupby, chain, imap\nfrom operator import itemgetter\nfrom sys import argv\nfrom array import array\n\ndef concat_map(func, it):\n    return list(chain.from_iterable(imap(func, it)))\n\ndef minima(poly):\n    \n    return (min(pt[0] for pt in poly), min(pt[1] for pt in poly))\n\ndef translate_to_origin(poly):\n    (minx, miny) = minima(poly)\n    return [(x - minx, y - miny) for (x, y) in poly]\n\nrotate90   = lambda (x, y): ( y, -x)\nrotate180  = lambda (x, y): (-x, -y)\nrotate270  = lambda (x, y): (-y,  x)\nreflect    = lambda (x, y): (-x,  y)\n\ndef rotations_and_reflections(poly):\n    \n    return (poly,\n            map(rotate90, poly),\n            map(rotate180, poly),\n            map(rotate270, poly),\n            map(reflect, poly),\n            [reflect(rotate90(pt)) for pt in poly],\n            [reflect(rotate180(pt)) for pt in poly],\n            [reflect(rotate270(pt)) for pt in poly])\n\ndef canonical(poly):\n    return min(sorted(translate_to_origin(pl)) for pl in rotations_and_reflections(poly))\n\ndef unique(lst):\n    lst.sort()\n    return map(next, imap(itemgetter(1), groupby(lst)))\n\n\ncontiguous = lambda (x, y): [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\ndef new_points(poly):\n    \n    return unique([pt for pt in concat_map(contiguous, poly) if pt not in poly])\n\ndef new_polys(poly):\n    return unique([canonical(poly + [pt]) for pt in new_points(poly)])\n\nmonomino = [(0, 0)]\nmonominoes = [monomino]\n\ndef rank(n):\n    \n    assert n >= 0\n    if n == 0: return []\n    if n == 1: return monominoes\n    return unique(concat_map(new_polys, rank(n - 1)))\n\ndef text_representation(poly):\n    \n    min_pt = minima(poly)\n    max_pt = (max(p[0] for p in poly), max(p[1] for p in poly))\n    table = [array('c', ' ') * (max_pt[1] - min_pt[1] + 1)\n             for _ in xrange(max_pt[0] - min_pt[0] + 1)]\n    for pt in poly:\n        table[pt[0] - min_pt[0]][pt[1] - min_pt[1]] = '\n    return \"\\n\".join(row.tostring() for row in table)\n\ndef main():\n    print [len(rank(n)) for n in xrange(1, 11)]\n\n    n = int(argv[1]) if (len(argv) == 2) else 5\n    print \"\\nAll free polyominoes of rank %d:\" % n\n\n    for poly in rank(n):\n        print text_representation(poly), \"\\n\"\n\nmain()\n"}
{"id": 389684, "name": "Natural sorting", "source": "Translate Ruby to Python: ar.sort_by{|str| str.downcase.gsub(/\\Athe |\\Aa |\\Aan /, \"\").lstrip.gsub(/\\s+/, \" \")}\n", "target": "\n\n\n\nfrom itertools import groupby\nfrom unicodedata import decomposition, name\nfrom pprint import pprint as pp\n\ncommonleaders = ['the'] \nreplacements = {u'\u00df': 'ss',  \n                u'\u017f': 's',\n                u'\u0292': 's',\n                }\n\nhexdigits = set('0123456789abcdef')\ndecdigits = set('0123456789')   \n\ndef splitchar(c):\n    ' De-ligature. De-accent a char'\n    de = decomposition(c)\n    if de:\n        \n        de = [d for d in de.split()\n                  if all(c.lower()\n                         in hexdigits for c in d)]\n        n = name(c, c).upper()\n        \n        if len(de)> 1 and 'PRECEDE' in n:\n            \n            de[1], de[0] = de[0], de[1]\n        tmp = [ unichr(int(k, 16)) for k in de]\n        base, others = tmp[0], tmp[1:]\n        if 'LIGATURE' in n:\n            \n            base += others.pop(0)\n    else:\n        base = c\n    return base\n    \n\ndef sortkeygen(s):\n    \n    \n    s = unicode(s).strip()\n    \n    s = ' '.join(s.split())\n    \n    s = s.lower()\n    \n    words = s.split()\n    if len(words) > 1 and words[0] in commonleaders:\n        s = ' '.join( words[1:])\n    \n    s = ''.join(splitchar(c) for c in s)\n    \n    s = ''.join( replacements.get(ch, ch) for ch in s )\n    \n    s = [ int(\"\".join(g)) if isinteger else \"\".join(g)\n          for isinteger,g in groupby(s, lambda x: x in decdigits)]\n\n    return s\n\ndef naturalsort(items):\n    \n    return sorted(items, key=sortkeygen)\n\nif __name__ == '__main__':\n    import string\n    \n    ns = naturalsort\n\n    print '\\n\n    txt = ['%signore leading spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['ignore m.a.s%s spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv.%sspaces: 3%+i' % (ch, i-3)\n           for i,ch in enumerate(reversed(string.whitespace))]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    s = 'CASE INDEPENENT'\n    txt = [s[:i].lower() + s[i:] + ': 3%+i' % (i-3) for i in range(1,5)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['foo100bar99baz0.txt', 'foo100bar10baz0.txt',\n           'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['The Wind in the Willows','The 40th step more',\n                         'The 39 steps', 'Wanda']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv. %s accents: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(u'\\xfd\\xddyY')]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = [u'\\462 ligatured ij', 'no ligature',]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n    \n    print '\\n\n    s = u'\u0292\u017f\u00dfs' \n    txt = ['Start with an %s: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(s)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; print '\\n'.join(sorted(txt))\n    print 'Naturally sorted:'; print '\\n'.join(ns(txt))\n"}
{"id": 389685, "name": "Solve triangle solitare puzzle", "source": "Translate Ruby to Python: \nG = [[0,1,3],[0,2,5],[1,3,6],[1,4,8],[2,4,7],[2,5,9],[3,4,5],[3,6,10],[3,7,12],[4,7,11],[4,8,13],[5,8,12],[5,9,14],[6,7,8],[7,8,9],[10,11,12],[11,12,13],[12,13,14],\n     [3,1,0],[5,2,0],[6,3,1],[8,4,1],[7,4,2],[9,5,2],[5,4,3],[10,6,3],[12,7,3],[11,7,4],[13,8,4],[12,8,5],[14,9,5],[8,7,6],[9,8,7],[12,11,10],[13,12,11],[14,13,12]]\nFORMAT = (1..5).map{|i| \" \"*(5-i)+\"%d \"*i+\"\\n\"}.join+\"\\n\"\ndef solve n,i,g\n  return \"Solved\" if i == 1\n  return false unless n[g[0]]==0 and n[g[1]]==1 and n[g[2]]==1\n    e = n.clone; g.each{|n| e[n] = 1 - e[n]}\n    l=false; G.each{|g| l=solve(e,i-1,g); break if l}\n  return l ? \"\nend\nputs FORMAT % (N=[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1])\nl=false; G.each{|g| l=solve(N,N.inject(:+),g); break if l}\nputs l ? l : \"No solution found\"\n", "target": "\n\n\ndef DrawBoard(board):\n  peg = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n  for n in xrange(1,16):\n    peg[n] = '.'\n    if n in board:\n      peg[n] = \"%X\" % n\n  print \"     %s\" % peg[1]\n  print \"    %s %s\" % (peg[2],peg[3])\n  print \"   %s %s %s\" % (peg[4],peg[5],peg[6])\n  print \"  %s %s %s %s\" % (peg[7],peg[8],peg[9],peg[10])\n  print \" %s %s %s %s %s\" % (peg[11],peg[12],peg[13],peg[14],peg[15])\n\n\n\ndef RemovePeg(board,n):\n  board.remove(n)\n\n\ndef AddPeg(board,n):\n  board.append(n)\n\n\ndef IsPeg(board,n):\n  return n in board\n\n\n\nJumpMoves = { 1: [ (2,4),(3,6) ],  \n              2: [ (4,7),(5,9)  ],\n              3: [ (5,8),(6,10) ],\n              4: [ (2,1),(5,6),(7,11),(8,13) ],\n              5: [ (8,12),(9,14) ],\n              6: [ (3,1),(5,4),(9,13),(10,15) ],\n              7: [ (4,2),(8,9)  ],\n              8: [ (5,3),(9,10) ],\n              9: [ (5,2),(8,7)  ],\n             10: [ (9,8) ],\n             11: [ (12,13) ],\n             12: [ (8,5),(13,14) ],\n             13: [ (8,4),(9,6),(12,11),(14,15) ],\n             14: [ (9,5),(13,12)  ],\n             15: [ (10,6),(14,13) ]\n            }\n\nSolution = []\n\n\n\ndef Solve(board):\n  \n  if len(board) == 1:\n    return board \n  \n  for peg in xrange(1,16): \n    if IsPeg(board,peg):\n      movelist = JumpMoves[peg]\n      for over,land in movelist:\n        if IsPeg(board,over) and not IsPeg(board,land):\n          saveboard = board[:] \n          RemovePeg(board,peg)\n          RemovePeg(board,over)\n          AddPeg(board,land) \n\n          Solution.append((peg,over,land))\n\n          board = Solve(board)\n          if len(board) == 1:\n            return board\n        \n          board = saveboard[:] \n          del Solution[-1] \n  return board\n\n\n\n\ndef InitSolve(empty):\n  board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n  RemovePeg(board,empty_start)\n  Solve(board)\n\n\nempty_start = 1\nInitSolve(empty_start)\n\nboard = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\nRemovePeg(board,empty_start)\nfor peg,over,land in Solution:\n  RemovePeg(board,peg)\n  RemovePeg(board,over)\n  AddPeg(board,land) \n  DrawBoard(board)\n  print \"Peg %X jumped over %X to land on %X\\n\" % (peg,over,land)\n"}
{"id": 389686, "name": "Partition function P", "source": "Translate Ruby to Python: say partitions(6666)   \n", "target": "from itertools import islice\n\ndef posd():\n    \"diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...\"\n    count, odd = 1, 3\n    while True:\n        yield count\n        yield odd\n        count, odd = count + 1, odd + 2\n\ndef pos_gen():\n    \"position numbers. 1 3 2 5 7 4 9 ...\"\n    val = 1\n    diff = posd()\n    while True:\n        yield val\n        val += next(diff)\n                \ndef plus_minus():\n    \"yield (list_offset, sign) or zero for Partition calc\"\n    n, sign = 0, [1, 1]\n    p_gen = pos_gen()\n    out_on = next(p_gen)\n    while True:\n        n += 1\n        if n == out_on:\n            next_sign = sign.pop(0)\n            if not sign:\n                sign = [-next_sign] * 2\n            yield -n, next_sign\n            out_on = next(p_gen)\n        else:\n            yield 0\n            \ndef part(n):\n    \"Partition numbers\"\n    p = [1]\n    p_m = plus_minus()\n    mods = []\n    for _ in range(n):\n        next_plus_minus = next(p_m)\n        if next_plus_minus:\n            mods.append(next_plus_minus)\n        p.append(sum(p[offset] * sign for offset, sign in mods))\n    return p[-1]\n        \nprint(\"(Intermediaries):\")\nprint(\"    posd:\", list(islice(posd(), 10)))\nprint(\"    pos_gen:\", list(islice(pos_gen(), 10)))\nprint(\"    plus_minus:\", list(islice(plus_minus(), 15)))\nprint(\"\\nPartitions:\", [part(x) for x in range(15)])\n"}
{"id": 389687, "name": "Special divisors", "source": "Translate Ruby to Python: class Integer\n  def reverse \n    to_s.reverse.to_i\n  end\n  def divisors\n      res = []\n      (1..Integer.sqrt(self)).each do |cand|\n        div, mod = self.divmod(cand)\n        res << cand << div if mod == 0\n      end\n      res.uniq.sort\n  end\n  def special_divisors?\n    r = self.reverse\n    divisors.all?{|d| r % d.reverse == 0}\n  end\nend\n\np (1..200).select(&:special_divisors?)\n", "target": "\n\ndef reverse(n):\n    u = 0\n    while n:\n        u = 10 * u + n % 10\n        n = int(n / 10)\n    return u\n\nc = 0\nfor n in range(1, 200):\n    u = reverse(n)\n    s = True\n    \n    for d in range (1, n):\n        if n % d == 0:\n            b = reverse(d)\n            if u % b != 0:\n                s = False\n    if s:\n        c = c + 1\n        print(n, end='\\t')\n                \nprint(\"\\nEncontrados \", c, \"divisores especiales.\")\n"}
{"id": 389688, "name": "Double Twin Primes", "source": "Translate Ruby to Python: require 'prime'\n\nres = Prime.each(1000).each_cons(4).select do |p1, p2, p3, p4| \n  p1+2 == p2 && p2+4 == p3 && p3+2 == p4\nend\n\nres.each{|slice| puts slice.join(\", \")}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n    \nif __name__ == \"__main__\":\n    num = 3\n    while num <= 1000:\n        if isPrime(num):\n            if isPrime(num+2):\n                if isPrime(num+6):\n                    if isPrime(num+8):\n                        print(num, num+2, num+6, num+8, sep=\"\\t\")\n        num += 2\n"}
{"id": 389689, "name": "Polynomial synthetic division", "source": "Translate Ruby to Python: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 389690, "name": "Polynomial synthetic division", "source": "Translate Ruby to Python: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 389691, "name": "Color wheel", "source": "Translate Ruby to Python: def settings\n  size(300, 300)\nend\n\ndef setup\n  sketch_title 'Color Wheel'\n  background(0)\n  radius = width / 2.0\n  center = width / 2\n  grid(width, height) do |x, y|\n    rx = x - center\n    ry = y - center\n    sat = Math.hypot(rx, ry) / radius\n    if sat <= 1.0\n      hue = ((Math.atan2(ry, rx) / PI) + 1) / 2.0\n      color_mode(HSB)\n      col = color((hue * 255).to_i, (sat * 255).to_i, 255)\n      set(x, y, col)\n    end\n  end\nend\n", "target": "size(300, 300)\nbackground(0)\nradius = min(width, height) / 2.0\ncx, cy = width / 2, width / 2\nfor x in range(width):\n        for y in range(height):\n            rx = x - cx\n            ry = y - cy\n            s = sqrt(rx ** 2 + ry ** 2) / radius\n            if s <= 1.0:\n                h = ((atan2(ry, rx) / PI) + 1.0) / 2.0\n                colorMode(HSB)\n                c = color(int(h * 255), int(s * 255), 255)\n                set(x, y, c) \n"}
{"id": 389692, "name": "Factorial primes", "source": "Translate Ruby to Python: require 'openssl'\n\nfactorial_primes = Enumerator.new do |y|\n  fact = 1\n  (1..).each do |i|\n    fact *= i\n    y << [i, \"- 1\", fact - 1] if OpenSSL::BN.new(fact - 1).prime?\n    y << [i, \"+ 1\", fact + 1] if OpenSSL::BN.new(fact + 1).prime?\n  end\nend\n\nfactorial_primes.first(30).each do |a|\n  s = a.last.to_s\n  if s.size > 40 then \n    puts \"%d! %s = \" % a.first(2) + \"\n  else\n    puts \"%d! %s = %d\" % a \n  end\nend\n", "target": "from itertools import count\nfrom itertools import islice\nfrom typing import Iterable\nfrom typing import Tuple\n\nimport gmpy2\n\n\ndef factorials() -> Iterable[int]:\n    fact = 1\n    for i in count(1):\n        yield fact\n        fact *= i\n\n\ndef factorial_primes() -> Iterable[Tuple[int, int, str]]:\n    for n, fact in enumerate(factorials()):\n        if gmpy2.is_prime(fact - 1):\n            yield (n, fact - 1, \"-\")\n        if gmpy2.is_prime(fact + 1):\n            yield (n, fact + 1, \"+\")\n\n\ndef print_factorial_primes(limit=10) -> None:\n    print(f\"First {limit} factorial primes.\")\n    for n, fact_prime, op in islice(factorial_primes(), 1, limit + 1):\n        s = str(fact_prime)\n        if len(s) > 40:\n            s = f\"{s[:20]}...{s[-20:]} ({len(s)} digits)\"\n        print(f\"{n}! {op} 1 = {s}\")\n\n\nif __name__ == \"__main__\":\n    import sys\n    print_factorial_primes(int(sys.argv[1]) if len(sys.argv) > 1 else 10)\n"}
{"id": 389693, "name": "URL shortener", "source": "Translate Ruby to Python: require \"kemal\"\n\nCHARS = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars\nentries = Hash(String, String).new\n\npost \"/\" do |env|\n  short = Random::Secure.random_bytes(8).map{|b| CHARS[b % CHARS.size]}.join\n  entries[short] = env.params.json[\"long\"].as(String)\n  \"http://localhost:3000/\nend\n\nget \"/:short\" do |env|\n  if long = entries[env.params.url[\"short\"]]?\n    env.redirect long\n  else\n    env.response.status_code = 404\n  end\nend\n\nerror 404 do\n  \"invalid short url\"\nend\n\nKemal.run\n", "target": "\n\nimport sqlite3\nimport string\nimport random\n\nfrom http import HTTPStatus\n\nfrom flask import Flask\nfrom flask import Blueprint\nfrom flask import abort\nfrom flask import current_app\nfrom flask import g\nfrom flask import jsonify\nfrom flask import redirect\nfrom flask import request\nfrom flask import url_for\n\n\nCHARS = frozenset(string.ascii_letters + string.digits)\nMIN_URL_SIZE = 8\nRANDOM_ATTEMPTS = 3\n\n\ndef create_app(*, db=None, server_name=None) -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        DATABASE=db or \"shorten.sqlite\",\n        SERVER_NAME=server_name,\n    )\n\n    with app.app_context():\n        init_db()\n\n    app.teardown_appcontext(close_db)\n    app.register_blueprint(shortener)\n\n    return app\n\n\ndef get_db():\n    if \"db\" not in g:\n        g.db = sqlite3.connect(current_app.config[\"DATABASE\"])\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db(_):\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    db = get_db()\n\n    with db:\n        db.execute(\n            \"CREATE TABLE IF NOT EXISTS shorten (\"\n            \"url TEXT PRIMARY KEY, \"\n            \"short TEXT NOT NULL UNIQUE ON CONFLICT FAIL)\"\n        )\n\n\nshortener = Blueprint(\"shorten\", \"short\")\n\n\ndef random_short(size=MIN_URL_SIZE):\n    \n    return \"\".join(random.sample(CHARS, size))\n\n\n@shortener.errorhandler(HTTPStatus.NOT_FOUND)\ndef short_url_not_found(_):\n    return \"short url not found\", HTTPStatus.NOT_FOUND\n\n\n@shortener.route(\"/<path:key>\", methods=(\"GET\",))\ndef short(key):\n    db = get_db()\n\n    cursor = db.execute(\"SELECT url FROM shorten WHERE short =\u00a0?\", (key,))\n    row = cursor.fetchone()\n\n    if row is None:\n        abort(HTTPStatus.NOT_FOUND)\n\n    \n    return redirect(row[\"url\"], code=HTTPStatus.FOUND)\n\n\nclass URLExistsError(Exception):\n    \n\n\nclass ShortCollisionError(Exception):\n    \n\n\ndef _insert_short(long_url, short):\n    \n    db = get_db()\n\n    if (\n        db.execute(\"SELECT * FROM shorten WHERE url =\u00a0?\", (long_url,)).fetchone()\n        is not None\n    ):\n        raise URLExistsError(long_url)\n\n    if (\n        db.execute(\"SELECT * FROM shorten WHERE short =\u00a0?\", (short,)).fetchone()\n        is not None\n    ):\n        raise ShortCollisionError(short)\n\n    with db:\n        db.execute(\"INSERT INTO shorten VALUES (?,\u00a0?)\", (long_url, short))\n\n\ndef make_short(long_url):\n    \n    size = MIN_URL_SIZE\n    attempts = 1\n    short = random_short(size=size)\n\n    while True:\n        try:\n            _insert_short(long_url, short)\n        except ShortCollisionError:\n            \n            if not attempts % RANDOM_ATTEMPTS:\n                size += 1\n\n            attempts += 1\n            short = random_short(size=size)\n        else:\n            break\n\n    return short\n\n\n@shortener.route(\"/\", methods=(\"POST\",))\ndef shorten():\n    data = request.get_json()\n\n    if data is None:\n        abort(HTTPStatus.BAD_REQUEST)\n\n    long_url = data.get(\"long\")\n\n    if long_url is None:\n        abort(HTTPStatus.BAD_REQUEST)\n\n    db = get_db()\n\n    \n    cursor = db.execute(\"SELECT short FROM shorten WHERE url =\u00a0?\", (long_url,))\n    row = cursor.fetchone()\n\n    if row is not None:\n        short_url = url_for(\"shorten.short\", _external=True, key=row[\"short\"])\n        status_code = HTTPStatus.OK\n    else:\n        short_url = url_for(\"shorten.short\", _external=True, key=make_short(long_url))\n        status_code = HTTPStatus.CREATED\n\n    mimetype = request.accept_mimetypes.best_match(\n        matches=[\"text/plain\", \"application/json\"], default=\"text/plain\"\n    )\n\n    if mimetype == \"application/json\":\n        return jsonify(long=long_url, short=short_url), status_code\n    else:\n        return short_url, status_code\n\n\nif __name__ == \"__main__\":\n    \n    app = create_app()\n    app.env = \"development\"\n    app.run(debug=True)\n"}
{"id": 389694, "name": "URL shortener", "source": "Translate Ruby to Python: require \"kemal\"\n\nCHARS = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars\nentries = Hash(String, String).new\n\npost \"/\" do |env|\n  short = Random::Secure.random_bytes(8).map{|b| CHARS[b % CHARS.size]}.join\n  entries[short] = env.params.json[\"long\"].as(String)\n  \"http://localhost:3000/\nend\n\nget \"/:short\" do |env|\n  if long = entries[env.params.url[\"short\"]]?\n    env.redirect long\n  else\n    env.response.status_code = 404\n  end\nend\n\nerror 404 do\n  \"invalid short url\"\nend\n\nKemal.run\n", "target": "\n\nimport sqlite3\nimport string\nimport random\n\nfrom http import HTTPStatus\n\nfrom flask import Flask\nfrom flask import Blueprint\nfrom flask import abort\nfrom flask import current_app\nfrom flask import g\nfrom flask import jsonify\nfrom flask import redirect\nfrom flask import request\nfrom flask import url_for\n\n\nCHARS = frozenset(string.ascii_letters + string.digits)\nMIN_URL_SIZE = 8\nRANDOM_ATTEMPTS = 3\n\n\ndef create_app(*, db=None, server_name=None) -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        DATABASE=db or \"shorten.sqlite\",\n        SERVER_NAME=server_name,\n    )\n\n    with app.app_context():\n        init_db()\n\n    app.teardown_appcontext(close_db)\n    app.register_blueprint(shortener)\n\n    return app\n\n\ndef get_db():\n    if \"db\" not in g:\n        g.db = sqlite3.connect(current_app.config[\"DATABASE\"])\n        g.db.row_factory = sqlite3.Row\n\n    return g.db\n\n\ndef close_db(_):\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()\n\n\ndef init_db():\n    db = get_db()\n\n    with db:\n        db.execute(\n            \"CREATE TABLE IF NOT EXISTS shorten (\"\n            \"url TEXT PRIMARY KEY, \"\n            \"short TEXT NOT NULL UNIQUE ON CONFLICT FAIL)\"\n        )\n\n\nshortener = Blueprint(\"shorten\", \"short\")\n\n\ndef random_short(size=MIN_URL_SIZE):\n    \n    return \"\".join(random.sample(CHARS, size))\n\n\n@shortener.errorhandler(HTTPStatus.NOT_FOUND)\ndef short_url_not_found(_):\n    return \"short url not found\", HTTPStatus.NOT_FOUND\n\n\n@shortener.route(\"/<path:key>\", methods=(\"GET\",))\ndef short(key):\n    db = get_db()\n\n    cursor = db.execute(\"SELECT url FROM shorten WHERE short =\u00a0?\", (key,))\n    row = cursor.fetchone()\n\n    if row is None:\n        abort(HTTPStatus.NOT_FOUND)\n\n    \n    return redirect(row[\"url\"], code=HTTPStatus.FOUND)\n\n\nclass URLExistsError(Exception):\n    \n\n\nclass ShortCollisionError(Exception):\n    \n\n\ndef _insert_short(long_url, short):\n    \n    db = get_db()\n\n    if (\n        db.execute(\"SELECT * FROM shorten WHERE url =\u00a0?\", (long_url,)).fetchone()\n        is not None\n    ):\n        raise URLExistsError(long_url)\n\n    if (\n        db.execute(\"SELECT * FROM shorten WHERE short =\u00a0?\", (short,)).fetchone()\n        is not None\n    ):\n        raise ShortCollisionError(short)\n\n    with db:\n        db.execute(\"INSERT INTO shorten VALUES (?,\u00a0?)\", (long_url, short))\n\n\ndef make_short(long_url):\n    \n    size = MIN_URL_SIZE\n    attempts = 1\n    short = random_short(size=size)\n\n    while True:\n        try:\n            _insert_short(long_url, short)\n        except ShortCollisionError:\n            \n            if not attempts % RANDOM_ATTEMPTS:\n                size += 1\n\n            attempts += 1\n            short = random_short(size=size)\n        else:\n            break\n\n    return short\n\n\n@shortener.route(\"/\", methods=(\"POST\",))\ndef shorten():\n    data = request.get_json()\n\n    if data is None:\n        abort(HTTPStatus.BAD_REQUEST)\n\n    long_url = data.get(\"long\")\n\n    if long_url is None:\n        abort(HTTPStatus.BAD_REQUEST)\n\n    db = get_db()\n\n    \n    cursor = db.execute(\"SELECT short FROM shorten WHERE url =\u00a0?\", (long_url,))\n    row = cursor.fetchone()\n\n    if row is not None:\n        short_url = url_for(\"shorten.short\", _external=True, key=row[\"short\"])\n        status_code = HTTPStatus.OK\n    else:\n        short_url = url_for(\"shorten.short\", _external=True, key=make_short(long_url))\n        status_code = HTTPStatus.CREATED\n\n    mimetype = request.accept_mimetypes.best_match(\n        matches=[\"text/plain\", \"application/json\"], default=\"text/plain\"\n    )\n\n    if mimetype == \"application/json\":\n        return jsonify(long=long_url, short=short_url), status_code\n    else:\n        return short_url, status_code\n\n\nif __name__ == \"__main__\":\n    \n    app = create_app()\n    app.env = \"development\"\n    app.run(debug=True)\n"}
{"id": 389695, "name": "Retrieve and search chat history", "source": "Translate Ruby to Python: \nrequire 'net/http'\nrequire 'time'\n\ndef gen_url(i)\n  day = Time.now + i*60*60*24\n  \n  \n  old_tz = ENV['TZ']\n  ENV['TZ'] = 'Europe/Berlin'\n  url = day.strftime('http://tclers.tk/conferences/tcl/%Y-%m-%d.tcl')\n  ENV['TZ'] = old_tz\n  url\nend\n\ndef main\n  back = 10\n  needle = ARGV[0]\n  (-back..0).each do |i|\n    url = gen_url(i)\n    haystack = Net::HTTP.get(URI(url)).split(\"\\n\")\n    mentions = haystack.select { |x| x.include? needle }\n    if !mentions.empty?\n      puts \"\n    end\n  end\nend\n\nmain\n", "target": "\nimport datetime\nimport re\nimport urllib.request\nimport sys\n\ndef get(url):\n    with urllib.request.urlopen(url) as response:\n       html = response.read().decode('utf-8')\n    if re.match(r'<!Doctype HTML[\\s\\S]*<Title>URL Not Found</Title>', html):\n        return None\n    return html\n\ndef main():\n    template = 'http://tclers.tk/conferences/tcl/%Y-%m-%d.tcl'\n    today = datetime.datetime.utcnow()\n    back = 10\n    needle = sys.argv[1]\n    \n    \n    \n    for i in range(-back, 2):\n        day = today + datetime.timedelta(days=i)\n        url = day.strftime(template)\n        haystack = get(url)\n        if haystack:\n            mentions = [x for x in haystack.split('\\n') if needle in x]\n            if mentions:\n                print('{}\\n------\\n{}\\n------\\n'\n                          .format(url, '\\n'.join(mentions)))\n\nmain()\n"}
{"id": 389696, "name": "Find duplicate files", "source": "Translate Ruby to Python: require 'digest/md5'\n\ndef find_duplicate_files(dir)\n  puts \"\\nDirectory\u00a0: \n  Dir.chdir(dir) do\n    file_size = Dir.foreach('.').select{|f| FileTest.file?(f)}.group_by{|f| File.size(f)}\n    file_size.each do |size, files|\n      next if files.size==1\n      files.group_by{|f| Digest::MD5.file(f).to_s}.each do |md5,fs|\n        next if fs.size==1\n        puts \"  --------------------------------------------\"\n        fs.each{|file| puts \"  \n      end\n    end\n  end\nend\n\nfind_duplicate_files(\"/Windows/System32\")\n", "target": "from __future__ import print_function\nimport os\nimport hashlib\nimport datetime\n\ndef FindDuplicateFiles(pth, minSize = 0, hashName = \"md5\"):\n    knownFiles = {}\n\n    \n    for root, dirs, files in os.walk(pth):\n        for fina in files:\n            fullFina = os.path.join(root, fina)\n            isSymLink = os.path.islink(fullFina)\n            if isSymLink:\n                continue \n            si = os.path.getsize(fullFina)\n            if si < minSize:\n                continue\n            if si not in knownFiles:\n                knownFiles[si] = {}\n            h = hashlib.new(hashName)\n            h.update(open(fullFina, \"rb\").read())\n            hashed = h.digest()\n            if hashed in knownFiles[si]:\n                fileRec = knownFiles[si][hashed]\n                fileRec.append(fullFina)\n            else:\n                knownFiles[si][hashed] = [fullFina]\n\n    \n    sizeList = list(knownFiles.keys())\n    sizeList.sort(reverse=True)\n    for si in sizeList:\n        filesAtThisSize = knownFiles[si]\n        for hashVal in filesAtThisSize:\n            if len(filesAtThisSize[hashVal]) < 2:\n                continue\n            fullFinaLi = filesAtThisSize[hashVal]\n            print (\"=======Duplicate=======\")\n            for fullFina in fullFinaLi:\n                st = os.stat(fullFina)\n                isHardLink = st.st_nlink > 1 \n                infoStr = []\n                if isHardLink:\n                    infoStr.append(\"(Hard linked)\")\n                fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')\n                print (fmtModTime, si, os.path.relpath(fullFina, pth), \" \".join(infoStr))\n\nif __name__==\"__main__\":\n\n    FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)\n"}
{"id": 389697, "name": "Legendre prime counting function", "source": "Translate Ruby to Python: require 'prime'\n\ndef pi(n)\n  @pr = Prime.each(Integer.sqrt(n)).to_a\n  a = @pr.size\n  case n\n    when 0,1 then 0\n    when 2 then 1\n    else phi(n,a) + a - 1\n  end\nend\n\ndef phi(x,a)\n  case a\n    when 0 then x\n    when 1 then x-(x>>1)\n    else  \n    pa = @pr[a-1]\n    return 1 if x <= pa\n    phi(x, a-1)- phi(x/pa, a-1)\n  end\nend\n\n(0..9).each {|n| puts \"10E\n", "target": "from primesieve import primes\nfrom math import isqrt\nfrom functools import cache\n\np = primes(isqrt(1_000_000_000))\n\n@cache\ndef phi(x, a):\n    res = 0\n    while True:\n        if not a or not x:\n            return x + res\n    \n        a -= 1\n        res -= phi(x//p[a], a) \n\ndef legpi(n):\n    if n < 2: return 0\n\n    a = legpi(isqrt(n))\n    return phi(n, a) + a - 1\n\nfor e in range(10):\n    print(f'10^{e}', legpi(10**e))\n"}
{"id": 389698, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Ruby to Python: require \"open-uri\"\nrequire \"cgi\" \n\ntasks  = [\"Greatest_common_divisor\", \"Greatest_element_of_a_list\", \"Greatest_subsequential_sum\"]\npart_uri  = \"http://rosettacode.org/wiki?action=raw&title=\"\nReport = Struct.new(:count, :tasks)\nresult = Hash.new{|h,k| h[k] = Report.new(0, [])}\n\ntasks.each do |task|\n  puts \"processing \n  current_lang = \"no language\"\n  open(part_uri + CGI.escape(task)).each_line do |line|\n    current_lang = Regexp.last_match[\"lang\"] if /==\\{\\{header\\|(?<lang>.+)\\}\\}==/ =~ line \n    num_no_langs = line.scan(/<lang\\s*>/).size\n    if num_no_langs > 0 then\n      result[current_lang].count += num_no_langs\n      result[current_lang].tasks << task\n    end\n  end\nend\n\nputs \"\\n\nresult.each{|k,v| puts \"\n", "target": "\n\nfrom __future__ import annotations\n\nimport functools\nimport gzip\nimport json\nimport logging\nimport platform\nimport re\n\nfrom collections import Counter\nfrom collections import defaultdict\n\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\n\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlunparse\nfrom urllib.parse import quote_plus\n\nimport urllib.error\nimport urllib.request\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\n\n\n\n\n\nRE_SPEC = [\n    (\"NOWIKI\", r\"<\\s*nowiki\\s*>.*?</\\s*nowiki\\s*>\"),\n    (\"PRE\", r\"<\\s*pre\\s*>.*?</\\s*pre\\s*>\"),\n    (\"LANG\", r\"<\\s*lang\\s+.+?>.*?</\\s*lang\\s*>\"),\n    (\"HEAD\", r\"==\\{\\{\\s*header\\s*\\|\\s*(?P<header>.+?)\\s*}}==\"),\n    (\"BARE\", r\"<\\s*lang\\s*>.*?</\\s*lang\\s*>\"),\n]\n\nRE_BARE_LANG = re.compile(\n    \"|\".join(rf\"(?P<{name}>{pattern})\" for name, pattern in RE_SPEC),\n    re.DOTALL | re.IGNORECASE,\n)\n\n\n\nRE_MULTI_HEADER = re.compile(r\"(}|(\\{\\{\\s*header\\s*\\|\\s*))\", re.IGNORECASE)\n\n\ndef find_bare_lang_section_headers(wiki_text: str) -> Iterator[str]:\n    \n    current_heading = \"no language\"\n\n    for match in RE_BARE_LANG.finditer(wiki_text):\n        kind = match.lastgroup\n\n        if kind == \"HEAD\":\n            current_heading = RE_MULTI_HEADER.sub(\"\", match.group(\"header\"))\n        elif kind == \"BARE\":\n            yield current_heading\n\n\nclass Error(Exception):\n    \n\n\nclass TagCounter:\n    \n\n    def __init__(self):\n        self.counter = Counter()\n        self.pages = defaultdict(set)\n        self.total = 0\n\n    def __len__(self):\n        return len(self.counter)\n\n    @classmethod\n    def from_section_headers(\n        cls, page_title: str, section_headers: Iterable[str]\n    ) -> TagCounter:\n        \n        counter = cls()\n\n        for heading in section_headers:\n            counter.add(page_title, heading)\n\n        return counter\n\n    @classmethod\n    def from_wiki_text(cls, page_title: str, wiki_text: str) -> TagCounter:\n        \n        return cls.from_section_headers(\n            page_title,\n            find_bare_lang_section_headers(wiki_text),\n        )\n\n    def add(self, page_title: str, section_heading: str):\n        \n        self.counter[section_heading] += 1\n        self.pages[section_heading].add(page_title)\n        self.total += 1\n\n    def update(self, other):\n        \n        assert isinstance(other, TagCounter)\n\n        self.counter.update(other.counter)\n\n        for section_heading, pages in other.pages.items():\n            self.pages[section_heading].update(pages)\n\n        self.total += other.total\n\n    def most_common(self, n=None) -> str:\n        \n        buf = [f\"{sum(self.counter.values())} bare lang tags.\\n\"]\n\n        for section_heading, count in self.counter.most_common(n=n):\n            pages = list(self.pages[section_heading])\n            buf.append(f\"{count} in {section_heading} {pages}\")\n\n        return \"\\n\".join(buf)\n\n\ndef quote_underscore(string, safe=\"\", encoding=None, errors=None):\n    \n    string = quote_plus(string, safe, encoding, errors)\n    return string.replace(\"+\", \"_\")\n\n\nclass URL(NamedTuple):\n    \n\n    scheme: str\n    netloc: str\n    path: str\n    params: str\n    query: str\n    fragment: str\n\n    def __str__(self):\n        return urlunparse(self)\n\n    def with_query(self, query: Mapping[str, Any]) -> URL:\n        query_string = urlencode(query, safe=\":\", quote_via=quote_underscore)\n        return self._replace(query=query_string)\n\n\nAPI_BASE_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/api.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\nUGLY_RAW_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/index.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\n\nDEFAULT_HEADERS = {\n    \"User-agent\": f\"python/{platform.python_version()}\",\n    \"Accept-encoding\": \"gzip, deflate\",\n    \"Accept\": \"*/*\",\n    \"Connection\": \"keep-alive\",\n}\n\n\nclass Response(NamedTuple):\n    headers: Mapping[str, str]\n    body: bytes\n\n\ndef get(url: URL, headers=DEFAULT_HEADERS) -> Response:\n    \n    logger.debug(f\"GET {url}\")\n    request = urllib.request.Request(str(url), headers=headers)\n\n    try:\n        with urllib.request.urlopen(request) as response:\n            return Response(\n                headers=dict(response.getheaders()),\n                body=response.read(),\n            )\n    except urllib.error.HTTPError as e:\n        logging.debug(e.code)\n        logging.debug(gzip.decompress(e.read()))\n        raise\n\n\ndef raise_for_header(headers: Mapping[str, str], header: str, expect: str):\n    got = headers.get(header)\n    if got != expect:\n        raise Error(f\"expected '{expect}', got '{got}'\")\n\n\nraise_for_content_type = functools.partial(raise_for_header, header=\"Content-Type\")\n\n\nclass CMContinue(NamedTuple):\n    continue_: str\n    cmcontinue: str\n\n\nPages = Tuple[List[str], Optional[CMContinue]]\n\n\ndef get_wiki_page_titles(chunk_size: int = 500, continue_: CMContinue = None) -> Pages:\n    \n    query = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtitle\": \"Category:Programming_Tasks\",\n        \"cmlimit\": chunk_size,\n        \"format\": \"json\",\n        \"continue\": \"\",\n    }\n\n    if continue_:\n        query[\"continue\"] = continue_.continue_\n        query[\"cmcontinue\"] = continue_.cmcontinue\n\n    response = get(API_BASE_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"application/json; charset=utf-8\")\n    raise_for_header(response.headers, \"Content-Encoding\", \"gzip\")\n\n    data = json.loads(gzip.decompress(response.body))\n    page_titles = [p[\"title\"] for p in data[\"query\"][\"categorymembers\"]]\n\n    if data.get(\"continue\", {}).get(\"cmcontinue\"):\n        _continue = CMContinue(\n            data[\"continue\"][\"continue\"],\n            data[\"continue\"][\"cmcontinue\"],\n        )\n    else:\n        _continue = None\n\n    return (page_titles, _continue)\n\n\ndef get_wiki_page_markup(page_title: str) -> str:\n    \n    query = {\"action\": \"raw\", \"title\": page_title}\n    response = get(UGLY_RAW_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"text/x-wiki; charset=UTF-8\")\n\n    return response.body.decode()\n\n\ndef example(limit=30):\n    \n    page_titles, continue_ = get_wiki_page_titles()\n\n    \n    while continue_ is not None:\n        more_page_titles, continue_ = get_wiki_page_titles(continue_=continue_)\n        page_titles.extend(more_page_titles)\n\n    \n    counter = TagCounter()\n\n    for i, page_title in enumerate(page_titles):\n        if i > limit:\n            break\n\n        \n        wiki_text = get_wiki_page_markup(page_title)\n        counts = TagCounter.from_wiki_text(page_title, wiki_text)\n        counter.update(counts)\n\n    \n    print(counter.most_common())\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(format=\"%(asctime)s %(message)s\", level=logging.DEBUG)\n    example()\n"}
{"id": 389699, "name": "Wagstaff primes", "source": "Translate Ruby to Python: require 'prime'\nrequire 'gmp'\n\nwagstaffs = Enumerator.new do |y|\n  odd_primes = Prime.each\n  odd_primes.next \n  loop do\n    p = odd_primes.next\n    candidate = (2 ** p + 1)/3\n    y << [p, candidate] unless GMP::Z.new(candidate).probab_prime?.zero?\n  end\nend\n\n10.times{puts \"%5d - %s\" % wagstaffs.next}\n14.times{puts \"%5d\" % wagstaffs.next.first}\n", "target": "\n\nfrom sympy import isprime\n\ndef wagstaff(N):\n    \n    pri, wcount = 1, 0\n    while wcount < N:\n        pri += 2\n        if isprime(pri):\n            wag = (2**pri + 1) // 3\n            if isprime(wag):\n                wcount += 1\n                print(f'{wcount: 3}: {pri: 5} => ', \n                      f'{wag:,}' if wcount < 11 else f'[{len(str(wag))} digit number]')\n\n\nwagstaff(24)\n"}
{"id": 389700, "name": "Wagstaff primes", "source": "Translate Ruby to Python: require 'prime'\nrequire 'gmp'\n\nwagstaffs = Enumerator.new do |y|\n  odd_primes = Prime.each\n  odd_primes.next \n  loop do\n    p = odd_primes.next\n    candidate = (2 ** p + 1)/3\n    y << [p, candidate] unless GMP::Z.new(candidate).probab_prime?.zero?\n  end\nend\n\n10.times{puts \"%5d - %s\" % wagstaffs.next}\n14.times{puts \"%5d\" % wagstaffs.next.first}\n", "target": "\n\nfrom sympy import isprime\n\ndef wagstaff(N):\n    \n    pri, wcount = 1, 0\n    while wcount < N:\n        pri += 2\n        if isprime(pri):\n            wag = (2**pri + 1) // 3\n            if isprime(wag):\n                wcount += 1\n                print(f'{wcount: 3}: {pri: 5} => ', \n                      f'{wag:,}' if wcount < 11 else f'[{len(str(wag))} digit number]')\n\n\nwagstaff(24)\n"}
{"id": 389701, "name": "Penta-power prime seeds", "source": "Translate Ruby to Python: require 'openssl'\n\npent_pow_primes = (1..).lazy.select{|n| (0..4).all?{|exp| OpenSSL::BN.new(n**exp + n + 1).prime?} }\n\nn = 30\nputs \"The first \npent_pow_primes.take(n).each_slice(10){|s| puts \"%8s\"*s.size % s}\n", "target": "from sympy import isprime\n\ndef ispentapowerprime(n):\n    return all(isprime(i) for i in [n + 2, n + n + 1, n**2 + n + 1, n**3 + n + 1, n**4 + n + 1])\n\nppprimes = [i for i in range(10_400_000) if ispentapowerprime(i)]\n\nfor i in range(50):\n    print(f'{ppprimes[i]: 11,}', end='\\n' if (i + 1) % 10 == 0 else '')\n\nfor n in range(1_000_000, 10_000_001, 1_000_000):\n    proot = next(filter(lambda x: x > n, ppprimes))\n    print(f'The first penta-power prime seed over {n:,} is {proot:,}')\n"}
{"id": 389702, "name": "Penta-power prime seeds", "source": "Translate Ruby to Python: require 'openssl'\n\npent_pow_primes = (1..).lazy.select{|n| (0..4).all?{|exp| OpenSSL::BN.new(n**exp + n + 1).prime?} }\n\nn = 30\nputs \"The first \npent_pow_primes.take(n).each_slice(10){|s| puts \"%8s\"*s.size % s}\n", "target": "from sympy import isprime\n\ndef ispentapowerprime(n):\n    return all(isprime(i) for i in [n + 2, n + n + 1, n**2 + n + 1, n**3 + n + 1, n**4 + n + 1])\n\nppprimes = [i for i in range(10_400_000) if ispentapowerprime(i)]\n\nfor i in range(50):\n    print(f'{ppprimes[i]: 11,}', end='\\n' if (i + 1) % 10 == 0 else '')\n\nfor n in range(1_000_000, 10_000_001, 1_000_000):\n    proot = next(filter(lambda x: x > n, ppprimes))\n    print(f'The first penta-power prime seed over {n:,} is {proot:,}')\n"}
{"id": 389703, "name": "Palindromic gapful numbers", "source": "Translate Ruby to Python: def palindromesgapful(digit, pow)\n  r1 = (10_u64**pow + 1) * digit\n  r2 = 10_u64**pow * (digit + 1)\n  nn = digit * 11\n  (r1...r2).select { |i| n = i.to_s; n == n.reverse && i.divisible_by?(nn) }\nend\n\ndef digitscount(digit, count)\n  pow  = 2\n  nums = [] of UInt64\n  while nums.size < count\n    nums += palindromesgapful(digit, pow)\n    pow += 1\n  end\n  nums[0...count]\nend\n\ncount = 20\nputs \"First 20 palindromic gapful numbers ending with:\"\n(1..9).each { |digit| print \"\n\ncount = 100\nputs \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n\ncount = 1000\nputs \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 389704, "name": "Palindromic gapful numbers", "source": "Translate Ruby to Python: def palindromesgapful(digit, pow)\n  r1 = (10_u64**pow + 1) * digit\n  r2 = 10_u64**pow * (digit + 1)\n  nn = digit * 11\n  (r1...r2).select { |i| n = i.to_s; n == n.reverse && i.divisible_by?(nn) }\nend\n\ndef digitscount(digit, count)\n  pow  = 2\n  nums = [] of UInt64\n  while nums.size < count\n    nums += palindromesgapful(digit, pow)\n    pow += 1\n  end\n  nums[0...count]\nend\n\ncount = 20\nputs \"First 20 palindromic gapful numbers ending with:\"\n(1..9).each { |digit| print \"\n\ncount = 100\nputs \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n\ncount = 1000\nputs \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 389705, "name": "Chernick's Carmichael numbers", "source": "Translate Ruby to Python: func chernick_carmichael_factors (n, m) {\n    [6*m + 1, 12*m + 1, {|i| 2**i * 9*m + 1 }.map(1 .. n-2)...]\n}\n\nfunc is_chernick_carmichael (n, m) {\n    (n == 2) ? (is_prime(6*m + 1) && is_prime(12*m + 1))\n             : (is_prime(2**(n-2) * 9*m + 1) && __FUNC__(n-1, m))\n}\n\nfunc chernick_carmichael_number(n, callback) {\n    var multiplier = (n>4 ? 2**(n-4) : 1)\n    var m = (1..Inf -> first {|m| is_chernick_carmichael(n, m * multiplier) })\n    var f = chernick_carmichael_factors(n, m * multiplier)\n    callback(f...)\n}\n\nfor n in (3..9) {\n    chernick_carmichael_number(n, {|*f| say \"a(\n}\n", "target": "\n\n\n\nfrom sympy import isprime\n\n\n\ndef primality_pretest(k):\n    if not (k % 3) or not (k % 5) or not (k % 7) or not (k % 11) or not(k % 13) or not (k % 17) or not (k % 19) or not (k % 23):\n        return (k <= 23)\n        \n    return True\n\ndef is_chernick(n, m):\n\n    t = 9 * m\n    \n    if not primality_pretest(6 * m + 1):\n        return False\n        \n    if not primality_pretest(12 * m + 1):\n        return False\n        \n    for i in range(1,n-1):\n        if not primality_pretest((t << i) + 1):\n            return False\n        \n    if not isprime(6 * m + 1):\n        return False\n        \n    if not isprime(12 * m + 1):\n        return False\n        \n    for i in range(1,n - 1):\n        if not isprime((t << i) + 1):\n            return False\n        \n    return True\n    \nfor n in range(3,10):\n\n    if n > 4:\n        multiplier = 1 << (n - 4)\n    else:\n        multiplier = 1\n    \n    if n > 5:\n        multiplier *= 5\n        \n        \n    k = 1\n    \n    while True:\n        m = k * multiplier\n        \n        if is_chernick(n, m): \n            print(\"a(\"+str(n)+\") has m = \"+str(m))\n            break\n            \n        k += 1\n"}
{"id": 389706, "name": "Quad-power prime seeds", "source": "Translate Ruby to Python: require 'openssl'\n\nquad_pow_primes = (1..).lazy.select{|n| (1..4).all?{|exp| OpenSSL::BN.new(n**exp + n + 1).prime?} }\n\nn = 50\nputs \"The first \nquad_pow_primes.take(n).each_slice(10){|s| puts \"%8s\"*s.size % s}\n", "target": "\n\nfrom sympy import isprime\n\n\ndef isquadpowerprime(cand):\n    \n    return all(isprime(i) for i in\n               [cand + cand + 1, cand**2 + cand + 1, cand**3 + cand + 1, cand**4 + cand + 1])\n\n\nqpprimes = [k for k in range(10_100_000) if isquadpowerprime(k)]\n\nfor i in range(50):\n    print(f'{qpprimes[i]: 9,}', end='\\n' if (i + 1) % 10 == 0 else '')\n\n\nfor j in range(1_000_000, 10_000_001, 1_000_000):\n    for p in qpprimes:\n        if p > j:\n            print(f'The first quad-power prime seed over {j:,} is {p:,}')\n            break\n"}
{"id": 389707, "name": "Quad-power prime seeds", "source": "Translate Ruby to Python: require 'openssl'\n\nquad_pow_primes = (1..).lazy.select{|n| (1..4).all?{|exp| OpenSSL::BN.new(n**exp + n + 1).prime?} }\n\nn = 50\nputs \"The first \nquad_pow_primes.take(n).each_slice(10){|s| puts \"%8s\"*s.size % s}\n", "target": "\n\nfrom sympy import isprime\n\n\ndef isquadpowerprime(cand):\n    \n    return all(isprime(i) for i in\n               [cand + cand + 1, cand**2 + cand + 1, cand**3 + cand + 1, cand**4 + cand + 1])\n\n\nqpprimes = [k for k in range(10_100_000) if isquadpowerprime(k)]\n\nfor i in range(50):\n    print(f'{qpprimes[i]: 9,}', end='\\n' if (i + 1) % 10 == 0 else '')\n\n\nfor j in range(1_000_000, 10_000_001, 1_000_000):\n    for p in qpprimes:\n        if p > j:\n            print(f'The first quad-power prime seed over {j:,} is {p:,}')\n            break\n"}
{"id": 389708, "name": "The sieve of Sundaram", "source": "Translate Ruby to Python: def sieve_of_sundaram(upto)\n  n = (2.4 * upto * Math.log(upto)) / 2\n  k = (n - 3) / 2 + 1\n  bools = [true] * k\n  (0..(Integer.sqrt(n) - 3) / 2 + 1).each do |i|\n    p = 2*i + 3\n    s = (p*p - 3) / 2\n    (s..k).step(p){|j| bools[j] = false}\n  end\n  bools.filter_map.each_with_index {|b, i| (i + 1) * 2 + 1 if b }\nend\n\np sieve_of_sundaram(100)\nn = 1_000_000\nputs \"\\nThe \n", "target": "from numpy import log\n\ndef sieve_of_Sundaram(nth, print_all=True):\n    \n    assert nth > 0, \"nth must be a positive integer\"\n    k = int((2.4 * nth * log(nth)) // 2)  \n    integers_list = [True] * k\n    for i in range(1, k):\n        j = i\n        while i + j + 2 * i * j < k:\n            integers_list[i + j + 2 * i * j] = False\n            j += 1\n    pcount = 0\n    for i in range(1, k + 1):\n        if integers_list[i]:\n            pcount += 1\n            if print_all:\n                print(f\"{2 * i + 1:4}\", end=' ')\n                if pcount % 10 == 0:\n                    print()\n\n            if pcount == nth:\n                print(f\"\\nSundaram primes start with 3. The {nth}th Sundaram prime is {2 * i + 1}.\\n\")\n                break\n\n\n\nsieve_of_Sundaram(100, True)\n\nsieve_of_Sundaram(1000000, False)\n"}
{"id": 389709, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Ruby to Python: require \"prime\"\nlimit = 1_000_000\n\nputs \"First found longest run of ascending prime gaps up to \np  Prime.each(limit).each_cons(2).chunk_while{|(i1,i2), (j1,j2)| j1-i1 < j2-i2 }.max_by(&:size).flatten.uniq\nputs  \"\\nFirst found longest run of descending prime gaps up to \np  Prime.each(limit).each_cons(2).chunk_while{|(i1,i2), (j1,j2)| j1-i1 > j2-i2 }.max_by(&:size).flatten.uniq\n", "target": "from sympy import sieve\n\nprimelist = list(sieve.primerange(2,1000000))\n\nlistlen = len(primelist)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff > old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff < old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n"}
{"id": 389710, "name": "Padovan n-step number sequences", "source": "Translate Ruby to Python: func padovan(N) {\n    Enumerator({|callback|\n        var n = 2\n        var pn = [1, 1, 1]\n        loop {\n            pn << sum(pn[n-N .. (n++-1) -> grep { _ >= 0 }])\n            callback(pn[-4])\n        }\n    })\n}\n\nfor n in (2..8) {\n    say \"n = \n}\n", "target": "def pad_like(max_n=8, t=15):\n    \n    start = [[], [1, 1, 1]]     \n    for n in range(2, max_n+1):\n        this = start[n-1][:n+1]     \n        while len(this) < t:\n            this.append(sum(this[i] for i in range(-2, -n - 2, -1)))\n        start.append(this)\n    return start[2:]\n\ndef pr(p):\n    print(.strip())\n    for n, seq in enumerate(p, 2):\n        print(f\"| {n:2} || {str(seq)[1:-1].replace(' ', '')+', ...'}\\n|-\")\n    print('|}')\n\nif __name__ == '__main__':\n    p = pad_like()\n    pr(p)\n"}
{"id": 389711, "name": "Sphenic numbers", "source": "Translate Ruby to Python: require 'prime'\n\nclass Integer\n  def sphenic? = prime_division.map(&:last) == [1, 1, 1]\nend\n\nsphenics = (1..).lazy.select(&:sphenic?)\n\nn = 1000\nputs \"Sphenic numbers less than \np sphenics.take_while{|s| s < n}.to_a\n\nn = 10_000\nputs \"\\nSphenic triplets less than \nsps = sphenics.take_while{|s| s < n}.to_a\nsps.each_cons(3).select{|a, b, c| a + 2 == c}.each{|ar| p ar}\n\nn = 1_000_000\nsphenics_below10E6 = sphenics.take_while{|s| s < n}.to_a\nputs \"\\nThere are \ntarget = sphenics_below10E6[200_000-1]\nputs \"\\nThe 200000th sphenic number is \ntriplets = sphenics_below10E6.each_cons(3).select{|a,b,c|a+2 == c}\nputs \"\\nThe 5000th sphenic triplet is \n", "target": "\n\n\nfrom sympy import factorint\n\nsphenics1m, sphenic_triplets1m = [], []\n\nfor i in range(3, 1_000_000):\n    d = factorint(i)\n    if len(d) == 3 and sum(d.values()) == 3:\n        sphenics1m.append(i)\n        if len(sphenics1m) > 2 and i - sphenics1m[-3] == 2 and i - sphenics1m[-2] == 1:\n            sphenic_triplets1m.append(i)\n\nprint('Sphenic numbers less than 1000:')\nfor i, n in enumerate(sphenics1m):\n    if n < 1000:\n        print(f'{n : 5}', end='\\n' if (i + 1) % 15 == 0 else '')\n    else:\n        break\n\nprint('\\n\\nSphenic triplets less than 10_000:')\nfor i, n in enumerate(sphenic_triplets1m):\n    if n < 10_000:\n        print(f'({n - 2} {n - 1} {n})', end='\\n' if (i + 1) % 3 == 0 else '  ')\n    else:\n        break\n\nprint('\\nThere are', len(sphenics1m), 'sphenic numbers and', len(sphenic_triplets1m),\n      'sphenic triplets less than 1 million.')\n\nS2HK = sphenics1m[200_000 - 1]\nT5K = sphenic_triplets1m[5000 - 1]\nprint(f'The 200_000th sphenic number is {S2HK}, with prime factors {list(factorint(S2HK).keys())}.')\nprint(f'The 5000th sphenic triplet is ({T5K - 2} {T5K - 1} {T5K}).')\n"}
{"id": 389712, "name": "XML validation", "source": "Translate Ruby to Python: require('XML::LibXML')\n\nfunc is_valid_xml(str, schema) {\n\n    var parser    = %O<XML::LibXML>.new\n    var xmlschema = %O<XML::LibXML::Schema>.new(string => schema)\n\n    try {\n        xmlschema.validate(parser.parse_string(str))\n        true\n    } catch {\n        false\n    }\n}\n\nvar good_xml = '<a>5</a>'\nvar bad_xml  = '<a>5<b>foobar</b></a>'\n\nvar xmlschema_markup = <<'END'\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\n[good_xml, bad_xml].each { |xml|\n    say \"is_valid_xml(\n}\n", "target": "\nfrom __future__ import print_function\nimport lxml\nfrom lxml import etree\n\nif __name__==\"__main__\":\n\n\tparser = etree.XMLParser(dtd_validation=True)\n\tschema_root = etree.XML()\n\tschema = etree.XMLSchema(schema_root)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5</a>\", parser)\n\t\tprint (\"Finished validating good xml\")\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5<b>foobar</b></a>\", parser)\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n"}
{"id": 389713, "name": "Own digits power sum", "source": "Translate Ruby to Python: DIGITS = (0..9).to_a\nrange  = (3..18)\n\nres = range.map do |s|\n  powers = {}\n  DIGITS.each{|n| powers[n] = n**s}\n  DIGITS.repeated_combination(s).filter_map do |combi| \n    sum = powers.values_at(*combi).sum\n    sum if sum.digits.sort == combi.sort\n  end.sort\nend\n\nputs \"Own digits power sums for N = \n", "target": "\n\ndef isowndigitspowersum(integer):\n    \n    digits = [int(c) for c in str(integer)]\n    exponent = len(digits)\n    return sum(x ** exponent for x in digits) == integer\n\nprint(\"Own digits power sums for N = 3 to 9 inclusive:\")\nfor i in range(100, 1000000000):\n    if isowndigitspowersum(i):\n        print(i)\n"}
{"id": 389714, "name": "Metallic ratios", "source": "Translate Ruby to Python: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "from itertools import count, islice\nfrom _pydecimal import getcontext, Decimal\n\ndef metallic_ratio(b):\n    m, n = 1, 1\n    while True:\n        yield m, n\n        m, n = m*b + n, m\n\ndef stable(b, prec):\n    def to_decimal(b):\n        for m,n in metallic_ratio(b):\n            yield Decimal(m)/Decimal(n)\n\n    getcontext().prec = prec\n    last = 0\n    for i,x in zip(count(), to_decimal(b)):\n        if x == last:\n            print(f'after {i} iterations:\\n\\t{x}')\n            break\n        last = x\n\nfor b in range(4):\n    coefs = [n for _,n in islice(metallic_ratio(b), 15)]\n    print(f'\\nb = {b}: {coefs}')\n    stable(b, 32)\n\nprint(f'\\nb = 1 with 256 digits:')\nstable(1, 256)\n"}
{"id": 389715, "name": "Metallic ratios", "source": "Translate Ruby to Python: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "from itertools import count, islice\nfrom _pydecimal import getcontext, Decimal\n\ndef metallic_ratio(b):\n    m, n = 1, 1\n    while True:\n        yield m, n\n        m, n = m*b + n, m\n\ndef stable(b, prec):\n    def to_decimal(b):\n        for m,n in metallic_ratio(b):\n            yield Decimal(m)/Decimal(n)\n\n    getcontext().prec = prec\n    last = 0\n    for i,x in zip(count(), to_decimal(b)):\n        if x == last:\n            print(f'after {i} iterations:\\n\\t{x}')\n            break\n        last = x\n\nfor b in range(4):\n    coefs = [n for _,n in islice(metallic_ratio(b), 15)]\n    print(f'\\nb = {b}: {coefs}')\n    stable(b, 32)\n\nprint(f'\\nb = 1 with 256 digits:')\nstable(1, 256)\n"}
{"id": 389716, "name": "Repunit primes", "source": "Translate Ruby to Python: require 'prime'\nrequire 'gmp'\n\n(2..16).each do |base|\n  res = Prime.each(1000).select {|n| GMP::Z((\"1\" * n).to_i(base)).probab_prime? > 0}\n  puts \"Base \nend\n", "target": "from sympy import isprime\nfor b in range(2, 17):\n    print(b, [n for n in range(2, 1001) if isprime(n) and isprime(int('1'*n, base=b))])\n"}
{"id": 389717, "name": "Repunit primes", "source": "Translate Ruby to Python: require 'prime'\nrequire 'gmp'\n\n(2..16).each do |base|\n  res = Prime.each(1000).select {|n| GMP::Z((\"1\" * n).to_i(base)).probab_prime? > 0}\n  puts \"Base \nend\n", "target": "from sympy import isprime\nfor b in range(2, 17):\n    print(b, [n for n in range(2, 1001) if isprime(n) and isprime(int('1'*n, base=b))])\n"}
{"id": 389718, "name": "Earliest difference between prime gaps", "source": "Translate Ruby to Python: func prime_gap_records(upto) {\n\n    var gaps = []\n    var p = 3\n\n    each_prime(p.next_prime, upto, {|q|\n        gaps[q-p] := p\n        p = q\n    })\n\n    gaps.grep { defined(_) }\n}\n\nvar gaps = prime_gap_records(1e8)\n\nfor m in (1 .. gaps.max.len) {\n    gaps.each_cons(2, {|p,q|\n        if (abs(q-p) > 10**m) {\n            say \"10^\n            p.next_prime-p}, \n            break\n        }\n    })\n}\n", "target": "\n\nfrom primesieve import primes\n\nLIMIT = 10**9\npri = primes(LIMIT * 5)\ngapstarts = {}\nfor i in range(1, len(pri)):\n    if pri[i] - pri[i - 1] not in gapstarts:\n        gapstarts[pri[i] - pri[i - 1]] = pri[i - 1]\n\nPM, GAP1, = 10, 2\nwhile True:\n    while GAP1 not in gapstarts:\n        GAP1 += 2\n    start1 = gapstarts[GAP1]\n    GAP2 = GAP1 + 2\n    if GAP2 not in gapstarts:\n        GAP1 = GAP2 + 2\n        continue\n    start2 = gapstarts[GAP2]\n    diff = abs(start2 - start1)\n    if diff > PM:\n        print(f\"Earliest difference >{PM: ,} between adjacent prime gap starting primes:\")\n        print(f\"Gap {GAP1} starts at{start1: ,}, gap {GAP2} starts at{start2: ,}, difference is{diff: ,}.\\n\")\n        if PM == LIMIT:\n            break\n        PM *= 10\n    else:\n        GAP1 = GAP2\n"}
{"id": 389719, "name": "Monads_Writer monad", "source": "Translate Ruby to Python: \nclass Writer\n  attr_reader :value, :log\n\n  def initialize(value, log = \"New\")\n    @value = value\n    if value.is_a? Proc\n      @log = log\n    else\n      @log = log + \": \" + @value.to_s \n    end\n  end\n\n  def self.unit(value, log)\n    Writer.new(value, log)\n  end\n\n  def bind(mwriter)\n    new_value = mwriter.value.call(@value)\n    new_log = @log + \"\\n\" + mwriter.log\n    self.class.new(new_value, new_log)\n  end\nend\n\nlam_sqrt = ->(number) { Math.sqrt(number) }\nlam_add_one = ->(number) { number + 1 }\nlam_half = ->(number) { number / 2.0 }\n\nsqrt = Writer.unit( lam_sqrt, \"Took square root\")\nadd_one = Writer.unit( lam_add_one, \"Added one\")\nhalf = Writer.unit( lam_half, \"Divided by 2\")\n\nm1 = Writer.unit(5, \"Initial value\")\nm2 = m1.bind(sqrt).bind(add_one).bind(half)\n\nputs \"The final value is \nputs \"This value was derived as follows:\"\nputs m2.log\n", "target": "\nfrom __future__ import annotations\n\nimport functools\nimport math\nimport os\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import List\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Writer(Generic[T]):\n    def __init__(self, value: Union[T, Writer[T]], *msgs: str):\n        if isinstance(value, Writer):\n            self.value: T = value.value\n            self.msgs: List[str] = value.msgs + list(msgs)\n        else:\n            self.value = value\n            self.msgs = list(f\"{msg}: {self.value}\" for msg in msgs)\n\n    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        writer = func(self.value)\n        return Writer(writer, *self.msgs)\n\n    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        return self.bind(func)\n\n    def __str__(self):\n        return f\"{self.value}\\n{os.linesep.join(reversed(self.msgs))}\"\n\n    def __repr__(self):\n        return f\"Writer({self.value}, \\\"{', '.join(reversed(self.msgs))}\\\")\"\n\n\ndef lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:\n    \n\n    @functools.wraps(func)\n    def wrapped(value):\n        return Writer(func(value), msg)\n\n    return wrapped\n\n\nif __name__ == \"__main__\":\n    square_root = lift(math.sqrt, \"square root\")\n    add_one = lift(lambda x: x + 1, \"add one\")\n    half = lift(lambda x: x / 2, \"div two\")\n\n    print(Writer(5, \"initial\") >> square_root >> add_one >> half)\n"}
{"id": 389720, "name": "Word ladder", "source": "Translate Ruby to Python: require \"set\"\n\nWords = File.open(\"unixdict.txt\").read.split(\"\\n\").\n  group_by { |w| w.length }.map { |k, v| [k, Set.new(v)] }.\n  to_h\n\ndef word_ladder(from, to)\n  raise \"Length mismatch\" unless from.length == to.length\n  sized_words = Words[from.length]\n  work_queue = [[from]]\n  used = Set.new [from]\n  while work_queue.length > 0\n    new_q = []\n    work_queue.each do |words|\n      last_word = words[-1]\n      new_tails = Enumerator.new do |enum|\n        (\"a\"..\"z\").each do |replacement_letter|\n          last_word.length.times do |i|\n            new_word = last_word.clone\n            new_word[i] = replacement_letter\n            next unless sized_words.include? new_word and\n                        not used.include? new_word\n            enum.yield new_word\n            used.add new_word\n            return words + [new_word] if new_word == to\n          end\n        end\n      end\n      new_tails.each do |t|\n        new_q.push(words + [t])\n      end\n    end\n    work_queue = new_q\n  end\nend\n\n[%w<boy man>, %w<girl lady>, %w<john jane>, %w<child adult>].each do |from, to|\n  if ladder = word_ladder(from, to)\n    puts ladder.join \" \u2192 \"\n  else\n    puts \"\n  end\nend\n", "target": "import os,sys,zlib,urllib.request\n\ndef h ( str,x=9 ):\n    for c in str :\n        x = ( x*33 + ord( c )) & 0xffffffffff\n    return x  \n\ndef cache ( func,*param ):\n    n = 'cache_%x.bin'%abs( h( repr( param )))\n    try    : return eval( zlib.decompress( open( n,'rb' ).read()))\n    except : pass\n    s = func( *param )\n    open( n,'wb' ).write( zlib.compress( bytes( repr( s ),'ascii' )))\n    return s\n\ndico_url  = 'https://raw.githubusercontent.com/quinnj/Rosetta-Julia/master/unixdict.txt'\nread_url  = lambda url   : urllib.request.urlopen( url ).read()\nload_dico = lambda url   : tuple( cache( read_url,url ).split( b'\\n'))\nisnext    = lambda w1,w2 : len( w1 ) == len( w2 ) and len( list( filter( lambda l : l[0]!=l[1] , zip( w1,w2 )))) == 1\n\ndef build_map ( words ):\n    map = [(w.decode('ascii'),[]) for w in words]\n    for i1,(w1,n1) in enumerate( map ):\n        for i2,(w2,n2) in enumerate( map[i1+1:],i1+1 ):\n            if isnext( w1,w2 ):\n                n1.append( i2 )\n                n2.append( i1 )\n    return map\n\ndef find_path ( words,w1,w2 ):\n    i = [w[0] for w in words].index( w1 )\n    front,done,res  = [i],{i:-1},[]\n    while front :\n        i = front.pop(0)\n        word,next = words[i]\n        for n in next :\n            if n in done : continue\n            done[n] = i\n            if words[n][0] == w2 :\n                while n >= 0 :\n                    res = [words[n][0]] + res\n                    n = done[n]\n                return ' '.join( res )\n            front.append( n )\n    return '%s can not be turned into %s'%( w1,w2 )\n\nfor w in ('boy man','girl lady','john jane','alien drool','child adult'):\n    print( find_path( cache( build_map,load_dico( dico_url )),*w.split()))\n"}
{"id": 389721, "name": "Separate the house number from the street name", "source": "Translate Ruby to Python: var re = %r[\n    ( .*? )\n    (?:\n        \\s+\n        (\n        | \\d+ (?: \\- | \\/ ) \\d+\n        | (?! 1940 | 1945) \\d+ [ a-z I . / \\x20 ]* \\d*\n        )\n    )?\n$]x\n\nARGF.each { |line|\n    line.chomp!\n    if (var m = line.match(re)) {\n        printf(\"%-25s split as (\n    }\n    else {\n        warn \"Can't parse: \u00ab\n    }\n}\n", "target": "Plataanstraat 5           split as (Plataanstraat, 5)\nStraat 12                 split as (Straat, 12)\nStraat 12 II              split as (Straat, 12 II)\nDr. J. Straat   12        split as (Dr. J. Straat  , 12)\nDr. J. Straat 12 a        split as (Dr. J. Straat, 12 a)\nDr. J. Straat 12-14       split as (Dr. J. Straat, 12-14)\nLaan 1940 \u2013 1945 37       split as (Laan 1940 \u2013 1945, 37)\nPlein 1940 2              split as (Plein 1940, 2)\n1213-laan 11              split as (1213-laan, 11)\n16 april 1944 Pad 1       split as (16 april 1944 Pad, 1)\n1e Kruisweg 36            split as (1e Kruisweg, 36)\nLaan 1940-\u201945 66          split as (Laan 1940-\u201945, 66)\nLaan \u201940-\u201945              split as (Laan \u201940-\u201945,)\nLangelo\u00ebrduinen 3 46      split as (Langelo\u00ebrduinen, 3 46)\nMarienwaerdt 2e Dreef 2   split as (Marienwaerdt 2e Dreef, 2)\nProvincialeweg N205 1     split as (Provincialeweg N205, 1)\nRivium 2e Straat 59.      split as (Rivium 2e Straat, 59.)\nNieuwe gracht 20rd        split as (Nieuwe gracht, 20rd)\nNieuwe gracht 20rd 2      split as (Nieuwe gracht, 20rd 2)\nNieuwe gracht 20zw /2     split as (Nieuwe gracht, 20zw /2)\nNieuwe gracht 20zw/3      split as (Nieuwe gracht, 20zw/3)\nNieuwe gracht 20 zw/4     split as (Nieuwe gracht, 20 zw/4)\nBahnhofstr. 4             split as (Bahnhofstr., 4)\nWertstr. 10               split as (Wertstr., 10)\nLindenhof 1               split as (Lindenhof, 1)\nNordesch 20               split as (Nordesch, 20)\nWeilstr. 6                split as (Weilstr., 6)\nHarthauer Weg 2           split as (Harthauer Weg, 2)\nMainaustr. 49             split as (Mainaustr., 49)\nAugust-Horch-Str. 3       split as (August-Horch-Str., 3)\nMarktplatz 31             split as (Marktplatz, 31)\nSchmidener Weg 3          split as (Schmidener Weg, 3)\nKarl-Weysser-Str. 6       split as (Karl-Weysser-Str., 6)''')\n"}
{"id": 389722, "name": "Smallest numbers", "source": "Translate Ruby to Python: memo = Hash.new{|h, k| h[k] = (k**k).to_s }\nres = (0..50).map{|n| (1..).detect{|m| memo[m].include? n.to_s} }\nres.each_slice(10){|slice| puts \"%4d\"*slice.size % slice }\n", "target": "\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage\u00a0: python \" + sys.argv[0] + \" <whole number>\")\n    exit()\n\nnumLimit = int(sys.argv[1])\n\nresultSet = {}\n\nbase = 1\n\nwhile len(resultSet)!=numLimit:\n    result = base**base\n\n    for i in range(0,numLimit):\n        if str(i) in str(result) and i not in resultSet:\n            resultSet[i] = base\n\n    base+=1\n\n[print(resultSet[i], end=' ') for i in sorted(resultSet)]\n"}
{"id": 389723, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to Python: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 389724, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to Python: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 389725, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Ruby to Python: func adaptive_Simpson_quadrature(f, left, right, \u03b5 = 1e-9) {\n\n    func quadrature_mid(l, lf, r, rf) {\n        var mid = (l+r)/2\n        var midf = f(mid)\n        (mid, midf, abs(r-l)/6 * (lf + 4*midf + rf))\n    }\n\n    func recursive_asr(a, fa, b, fb, \u03b5, whole, m, fm) {\n        var (lm, flm, left)  = quadrature_mid(a, fa, m, fm)\n        var (rm, frm, right) = quadrature_mid(m, fm, b, fb)\n        var \u0394 = (left + right - whole)\n        abs(\u0394) <= 15*\u03b5\n            ? (left + right + \u0394/15)\n            : (__FUNC__(a, fa, m, fm, \u03b5/2, left,  lm, flm) +\n               __FUNC__(m, fm, b, fb, \u03b5/2, right, rm, frm))\n    }\n\n    var (lf = f(left), rf = f(right))\n    var (mid, midf, whole) = quadrature_mid(left, lf, right, rf)\n    recursive_asr(left, lf, right, rf, \u03b5, whole, mid, midf)\n}\n\nvar (a = 0, b = 1)\nvar area = adaptive_Simpson_quadrature({ .sin }, a, b, 1e-15).round(-15)\nsay \"Simpson's integration of sine from \n", "target": "\n\n\n\nimport math\n\nimport collections\ntriple = collections.namedtuple('triple', 'm fm simp')\n\ndef _quad_simpsons_mem(f: callable, a: float , fa: float, b: float, fb: float)->tuple:\n    \n    m = a + (b - a) / 2\n    fm = f(m)\n    simp = abs(b - a) / 6 * (fa + 4*fm + fb)\n    return triple(m, fm, simp,)\n \ndef _quad_asr(f: callable, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:\n    \n    lt = _quad_simpsons_mem(f, a, fa, m, fm)\n    rt = _quad_simpsons_mem(f, m, fm, b, fb)\n    delta = lt.simp + rt.simp - whole\n    return (lt.simp + rt.simp + delta/15\n        if (abs(delta) <= eps * 15) else\n            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +\n            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)\n    )\n\ndef quad_asr(f: callable, a: float, b: float, eps: float)->float:\n    \n    fa = f(a)\n    fb = f(b)\n    t = _quad_simpsons_mem(f, a, fa, b, fb)\n    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)\n\ndef main():\n    (a, b,) = (0.0, 1.0,)\n    sinx = quad_asr(math.sin, a, b, 1e-09);\n    print(\"Simpson's integration of sine from {} to {} = {}\\n\".format(a, b, sinx))\n\nmain()\n"}
{"id": 389726, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Ruby to Python: func adaptive_Simpson_quadrature(f, left, right, \u03b5 = 1e-9) {\n\n    func quadrature_mid(l, lf, r, rf) {\n        var mid = (l+r)/2\n        var midf = f(mid)\n        (mid, midf, abs(r-l)/6 * (lf + 4*midf + rf))\n    }\n\n    func recursive_asr(a, fa, b, fb, \u03b5, whole, m, fm) {\n        var (lm, flm, left)  = quadrature_mid(a, fa, m, fm)\n        var (rm, frm, right) = quadrature_mid(m, fm, b, fb)\n        var \u0394 = (left + right - whole)\n        abs(\u0394) <= 15*\u03b5\n            ? (left + right + \u0394/15)\n            : (__FUNC__(a, fa, m, fm, \u03b5/2, left,  lm, flm) +\n               __FUNC__(m, fm, b, fb, \u03b5/2, right, rm, frm))\n    }\n\n    var (lf = f(left), rf = f(right))\n    var (mid, midf, whole) = quadrature_mid(left, lf, right, rf)\n    recursive_asr(left, lf, right, rf, \u03b5, whole, mid, midf)\n}\n\nvar (a = 0, b = 1)\nvar area = adaptive_Simpson_quadrature({ .sin }, a, b, 1e-15).round(-15)\nsay \"Simpson's integration of sine from \n", "target": "\n\n\n\nimport math\n\nimport collections\ntriple = collections.namedtuple('triple', 'm fm simp')\n\ndef _quad_simpsons_mem(f: callable, a: float , fa: float, b: float, fb: float)->tuple:\n    \n    m = a + (b - a) / 2\n    fm = f(m)\n    simp = abs(b - a) / 6 * (fa + 4*fm + fb)\n    return triple(m, fm, simp,)\n \ndef _quad_asr(f: callable, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:\n    \n    lt = _quad_simpsons_mem(f, a, fa, m, fm)\n    rt = _quad_simpsons_mem(f, m, fm, b, fb)\n    delta = lt.simp + rt.simp - whole\n    return (lt.simp + rt.simp + delta/15\n        if (abs(delta) <= eps * 15) else\n            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +\n            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)\n    )\n\ndef quad_asr(f: callable, a: float, b: float, eps: float)->float:\n    \n    fa = f(a)\n    fb = f(b)\n    t = _quad_simpsons_mem(f, a, fa, b, fb)\n    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)\n\ndef main():\n    (a, b,) = (0.0, 1.0,)\n    sinx = quad_asr(math.sin, a, b, 1e-09);\n    print(\"Simpson's integration of sine from {} to {} = {}\\n\".format(a, b, sinx))\n\nmain()\n"}
{"id": 389727, "name": "Colorful numbers", "source": "Translate Ruby to Python: def colorful?(ar)\n  products = []\n  (1..ar.size).all? do |chunk_size|\n    ar.each_cons(chunk_size) do |chunk|\n      product = chunk.inject(&:*)\n      return false if products.include?(product)\n      products << product\n    end\n  end\nend\n\nbelow100 = (0..100).select{|n| colorful?(n.digits)}\nputs \"The colorful numbers less than 100 are:\", below100.join(\" \"), \"\"\nputs \"Largest colorful number: \n\ntotal = 0\n(1..8).each do |numdigs|\n   digits = (numdigs == 1 ? (0..9).to_a : (2..9).to_a)\n   count  = digits.permutation(numdigs).count{|perm| colorful?(perm)}\n   puts \"\n   total += count\nend\n\nputs \"\\nTotal colorful numbers: \n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 389728, "name": "Colorful numbers", "source": "Translate Ruby to Python: def colorful?(ar)\n  products = []\n  (1..ar.size).all? do |chunk_size|\n    ar.each_cons(chunk_size) do |chunk|\n      product = chunk.inject(&:*)\n      return false if products.include?(product)\n      products << product\n    end\n  end\nend\n\nbelow100 = (0..100).select{|n| colorful?(n.digits)}\nputs \"The colorful numbers less than 100 are:\", below100.join(\" \"), \"\"\nputs \"Largest colorful number: \n\ntotal = 0\n(1..8).each do |numdigs|\n   digits = (numdigs == 1 ? (0..9).to_a : (2..9).to_a)\n   count  = digits.permutation(numdigs).count{|perm| colorful?(perm)}\n   puts \"\n   total += count\nend\n\nputs \"\\nTotal colorful numbers: \n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 389729, "name": "Generate random chess position", "source": "Translate Ruby to Python: def hasNK(board, a, b)\n    (-1..1).each do |g|\n        (-1..1).each do |f|\n            aa = a + f; bb = b + g\n            if (0..7).includes?(aa) && (0..7).includes?(bb)\n                p = board[aa + 8 * bb]\n                return true if p == \"K\" || p == \"k\"\n            end \n        end\n    end\n    return false\nend\n\ndef generateBoard(board, pieces)\n    pieces.each_char do |p|\n        while true\n            a = rand(8); b = rand(8)\n            next  if ( (b == 0 || b == 7) && (p == \"P\" || p == \"p\") ) || \n               ( (p == \"k\" || p == \"K\") && hasNK(board, a, b) )\n            break if board[a + b * 8] == '.'\n        end\n        board[a + b * 8] = p\n    end\nend\n\npieces = \"ppppppppkqrrbbnnPPPPPPPPKQRRBBNN\"\n11.times do\n    e = pieces.size - 1\n    while e > 0\n        p = rand(e); t = pieces[e]\n        \n        pieces = pieces.sub(e, pieces[p])             \n        pieces = pieces.sub(p, t); e -= 1             \n    end\nend\n\n\nboard = Array.new(64, '.'); generateBoard(board, pieces)\nputs\ne = 0\n8.times do |j| row_j = j * 8\n    8.times do |i| \n        board[row_j + i ] == '.' ? (e += 1) :\n            ( (print(e); e = 0) if e > 0\n            print board[row_j + i] )\n    end\n    (print(e); e = 0) if e > 0\n    print(\"/\") if j < 7\nend\n\nprint(\" w - - 0 1\\n\")\n8.times do |j| row_j = j * 8\n  8.times { |i| board[row_j + i] == '.' ? print(\".\") : print(board[row_j + i]) }\n  puts\nend\n\n\n8.times{ |row| puts board[row*8..row*8 + 7].join(\"\") }\n", "target": "import random\n\nboard = [[\" \" for x in range(8)] for y in range(8)]\npiece_list = [\"R\", \"N\", \"B\", \"Q\", \"P\"]\n\n\ndef place_kings(brd):\n\twhile True:\n\t\trank_white, file_white, rank_black, file_black = random.randint(0,7), random.randint(0,7), random.randint(0,7), random.randint(0,7)\n\t\tdiff_list = [abs(rank_white - rank_black),  abs(file_white - file_black)]\n\t\tif sum(diff_list) > 2 or set(diff_list) == set([0, 2]):\n\t\t\tbrd[rank_white][file_white], brd[rank_black][file_black] = \"K\", \"k\"\n\t\t\tbreak\n\ndef populate_board(brd, wp, bp):\n\tfor x in range(2):\n\t\tif x == 0:\n\t\t\tpiece_amount = wp\n\t\t\tpieces = piece_list\n\t\telse:\n\t\t\tpiece_amount = bp\n\t\t\tpieces = [s.lower() for s in piece_list]\n\t\twhile piece_amount != 0:\n\t\t\tpiece_rank, piece_file = random.randint(0, 7), random.randint(0, 7)\n\t\t\tpiece = random.choice(pieces)\n\t\t\tif brd[piece_rank][piece_file] == \" \" and pawn_on_promotion_square(piece, piece_rank) == False:\n\t\t\t\tbrd[piece_rank][piece_file] = piece\n\t\t\t\tpiece_amount -= 1\n\ndef fen_from_board(brd):\n\tfen = \"\"\n\tfor x in brd:\n\t\tn = 0\n\t\tfor y in x:\n\t\t\tif y == \" \":\n\t\t\t\tn += 1\n\t\t\telse:\n\t\t\t\tif n != 0:\n\t\t\t\t\tfen += str(n)\n\t\t\t\tfen += y\n\t\t\t\tn = 0\n\t\tif n != 0:\n\t\t\tfen += str(n)\n\t\tfen += \"/\" if fen.count(\"/\") < 7 else \"\"\n\tfen += \" w - - 0 1\\n\"\n\treturn fen\n\ndef pawn_on_promotion_square(pc, pr):\n\tif pc == \"P\" and pr == 0:\n\t\treturn True\n\telif pc == \"p\" and pr == 7:\n\t\treturn True\n\treturn False\n\n\ndef start():\n\tpiece_amount_white, piece_amount_black = random.randint(0, 15), random.randint(0, 15)\n\tplace_kings(board)\n\tpopulate_board(board, piece_amount_white, piece_amount_black)\n\tprint(fen_from_board(board))\n\tfor x in board:\n\t\tprint(x)\n\n\nstart()\n"}
{"id": 389730, "name": "Special factorials", "source": "Translate Ruby to Python: func sf(n) { 1..n -> prod {|k| k! } }\nfunc H(n)  { 1..n -> prod {|k| k**k } }\nfunc af(n) { 1..n -> sum  {|k| (-1)**(n-k) * k! } }\nfunc ef(n) { 1..n -> reduce({|a,b| b**a }, 1) }\n\nfunc factorial_valuation(n,p) {\n    (n - n.sumdigits(p)) / (p-1)\n}\n\nfunc p_adic_inverse (p, k) {\n\n    var n = (k * (p - 1))\n\n    while (factorial_valuation(n, p) < k) {\n        n -= (n % p)\n        n += p\n    }\n\n    return n\n}\n\nfunc rf(f) {\n\n    return nil if (f < 0)\n    return 0   if (f <= 1)\n\n    var t = valuation(f, 2) || return nil\n    var n = p_adic_inverse(2, t)\n    var d = factor(n + 1)[-1]\n\n    if (f.valuation(d) == factorial_valuation(n+1, d)) {\n        ++n\n    }\n\n    for p in (primes(2, n)) {\n        var v = factorial_valuation(n, p)\n        f.valuation(p) == v || return nil\n        f /= p**v\n    }\n\n    (f == 1) ? n : nil\n}\n\nsay ('sf\u00a0: ', 10.of(sf).join(' '))\nsay ('H \u00a0: ', 10.of(H).join(' '))\nsay ('af\u00a0: ', 10.of(af).join(' '))\nsay ('ef\u00a0: ', 5.of(ef).join(' '))\n\nsay \"ef(5) has \n\nsay ('rf\u00a0: ', [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800].map(rf))\nsay ('rf(119) = ', rf(119) \\\\ 'nil')\nsay ('rf is defined for: ', 8.by { defined(rf(_)) }.join(', ' ) + ', ...')\n", "target": "\n\nfrom math import prod\n\ndef superFactorial(n):\n    return prod([prod(range(1,i+1)) for i in range(1,n+1)])\n\ndef hyperFactorial(n):\n    return prod([i**i for i in range(1,n+1)])\n\ndef alternatingFactorial(n):\n    return sum([(-1)**(n-i)*prod(range(1,i+1)) for i in range(1,n+1)])\n\ndef exponentialFactorial(n):\n    if n in [0,1]:\n        return 1\n    else:\n        return n**exponentialFactorial(n-1)\n        \ndef inverseFactorial(n):\n    i = 1\n    while True:\n        if n == prod(range(1,i)):\n            return i-1\n        elif n < prod(range(1,i)):\n            return \"undefined\"\n        i+=1\n\nprint(\"Superfactorials for [0,9]\u00a0:\")\nprint({\"sf(\" + str(i) + \") \" : superFactorial(i) for i in range(0,10)})\n\nprint(\"\\nHyperfactorials for [0,9]\u00a0:\")\nprint({\"H(\" + str(i) + \") \"  : hyperFactorial(i) for i in range(0,10)})\n\nprint(\"\\nAlternating factorials for [0,9]\u00a0:\")\nprint({\"af(\" + str(i) + \") \" : alternatingFactorial(i) for i in range(0,10)})\n\nprint(\"\\nExponential factorials for [0,4]\u00a0:\")\nprint({str(i) + \"$ \" : exponentialFactorial(i) for i in range(0,5)})\n\nprint(\"\\nDigits in 5$\u00a0: \" , len(str(exponentialFactorial(5))))\n\nfactorialSet = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nprint(\"\\nInverse factorials for \" , factorialSet)\nprint({\"rf(\" + str(i) + \") \":inverseFactorial(i) for i in factorialSet})\n\nprint(\"\\nrf(119)\u00a0: \" + inverseFactorial(119))\n"}
{"id": 389731, "name": "Sierpinski square curve", "source": "Translate Ruby to Python: var rules = Hash(\n    x => 'xF-F+F-xF+F+xF-F+F-x',\n)\n\nvar lsys = LSystem(\n    width:  510,\n    height: 510,\n\n    xoff: -505,\n    yoff: -254,\n\n    len:   4,\n    angle: 90,\n    color: 'dark green',\n)\n\nlsys.execute('F+xF+F+xF', 5, \"sierpi\u0144ski_square_curve.png\", rules)\n", "target": "import matplotlib.pyplot as plt\nimport math\n\n\ndef nextPoint(x, y, angle):\n    a = math.pi * angle / 180\n    x2 = (int)(round(x + (1 * math.cos(a))))\n    y2 = (int)(round(y + (1 * math.sin(a))))\n    return x2, y2\n\n\ndef expand(axiom, rules, level):\n    for l in range(0, level):\n        a2 = \"\"\n        for c in axiom:\n            if c in rules:\n                a2 += rules[c]\n            else:\n                a2 += c\n        axiom = a2\n    return axiom\n\n\ndef draw_lsystem(axiom, rules, angle, iterations):\n    xp = [1]\n    yp = [1]\n    direction = 0\n    for c in expand(axiom, rules, iterations):\n        if c == \"F\":\n            xn, yn = nextPoint(xp[-1], yp[-1], direction)\n            xp.append(xn)\n            yp.append(yn)\n        elif c == \"-\":\n            direction = direction - angle\n            if direction < 0:\n                direction = 360 + direction\n        elif c == \"+\":\n            direction = (direction + angle) % 360\n\n    plt.plot(xp, yp)\n    plt.show()\n\n\nif __name__ == '__main__':\n    \n    s_axiom = \"F+XF+F+XF\"\n    s_rules = {\"X\": \"XF-F+F-XF+F+XF-F+F-X\"}\n    s_angle = 90\n\n    draw_lsystem(s_axiom, s_rules, s_angle, 3)\n"}
{"id": 389732, "name": "Super-Poulet numbers", "source": "Translate Ruby to Python: require 'prime'\n\nclass Integer\n  def proper_divisors\n    return [] if self == 1\n    primes = prime_division.flat_map{|prime, freq| [prime] * freq}\n    (1...primes.size).each_with_object([1]) do |n, res|\n      primes.combination(n).map{|combi| res << combi.inject(:*)}\n    end.flatten.uniq.sort\n  end\nend\n\nsuper_poulets = (1..).lazy.select do |n|\n  n.prime? == false  && \n  2.pow(n-1, n) == 1 && \n  n.proper_divisors[1..].all?{|d| 2.pow(d, d) == 2} \nend \n\nm = 20\nputs \"First \n\n[1_000_000, 10_000_000].each do |m|\n  puts \"\\nValue and index of first super-Poulet number greater than \n  puts \"%d is \nend\n", "target": "from sympy import isprime, divisors\n \ndef is_super_Poulet(n):\n    return not isprime(n) and 2**(n - 1) % n == 1 and all((2**d - 2) % d == 0 for d in divisors(n))\n\nspoulets = [n for n in range(1, 1_100_000) if is_super_Poulet(n)]\n\nprint('The first 20 super-Poulet numbers are:', spoulets[:20])\n\nidx1m, val1m = next((i, v) for i, v in enumerate(spoulets) if v > 1_000_000)\nprint(f'The first super-Poulet number over 1 million is the {idx1m}th one, which is {val1m}')\n"}
{"id": 389733, "name": "Permutations with some identical elements", "source": "Translate Ruby to Python: require 'set' \n\ndef permutations_with_identical_elements(reps, elements=nil)\n  elements ||= (1..reps.size)\n  all = elements.zip(reps).flat_map{|el, r| [el]*r}\n  all.permutation.inject(Set.new){|s, perm| s << perm.join}\nend\n\npermutations_with_identical_elements([2,3,1]).each_slice(10) {|slice| puts slice.join(\" \")}\n\np permutations_with_identical_elements([2,1], [\"A\", \"B\"])\n", "target": "\n\nfrom itertools import permutations\n\nnumList = [2,3,1]\n\nbaseList = []\n\nfor i in numList:\n    for j in range(0,i):\n        baseList.append(i)\n\nstringDict = {'A':2,'B':3,'C':1}\n\nbaseString=\"\"\n\nfor i in stringDict:\n    for j in range(0,stringDict[i]):\n        baseString+=i\n\nprint(\"Permutations for \" + str(baseList) + \"\u00a0: \")\n[print(i) for i in set(permutations(baseList))]\n\nprint(\"Permutations for \" + baseString + \"\u00a0: \")\n[print(i) for i in set(permutations(baseString))]\n"}
{"id": 389734, "name": "Pisano period", "source": "Translate Ruby to Python: func pisano_period_pp(p,k) is cached {\n\n    assert(k.is_pos,   \"k = \n    assert(p.is_prime, \"p = \n\n    var (a, b, n) = (0, 1, p**k)\n\n    1..Inf -> first_by {\n        (a, b) = (b, (a+b) % n)\n        (a == 0) && (b == 1)\n    }\n}\n\nfunc pisano_period(n) {\n    n.factor_map {|p,k| pisano_period_pp(p, k) }.lcm\n}\n\nsay \"Pisano periods for squares of primes p <= 15:\"\nsay  15.primes.map {|p| pisano_period_pp(p, 2) }\n\nsay \"\\nPisano periods for primes p <= 180:\"\nsay 180.primes.map {|p| pisano_period_pp(p, 1) }\n\nsay \"\\nPisano periods for integers n from 1 to 180:\"\nsay pisano_period.map(1..180)\n", "target": "from sympy import isprime, lcm, factorint, primerange\nfrom functools import reduce\n\n\ndef pisano1(m):\n    \"Simple definition\"\n    if m < 2:\n        return 1\n    lastn, n = 0, 1\n    for i in range(m ** 2):\n        lastn, n = n, (lastn + n) % m\n        if lastn == 0 and n == 1:\n            return i + 1\n    return 1\n\ndef pisanoprime(p, k):\n    \"Use conjecture \u03c0(p ** k) == p ** (k \u2212 1) * \u03c0(p) for prime p and int k > 1\"\n    assert isprime(p) and k > 0\n    return p ** (k - 1) * pisano1(p)\n\ndef pisano_mult(m, n):\n    \"pisano(m*n) where m and n assumed coprime integers\"\n    return lcm(pisano1(m), pisano1(n))\n\ndef pisano2(m):\n    \"Uses prime factorization of m\"\n    return reduce(lcm, (pisanoprime(prime, mult)\n                        for prime, mult in factorint(m).items()), 1)\n\n\nif __name__ == '__main__':\n    for n in range(1, 181):\n        assert pisano1(n) == pisano2(n), \"Wall-Sun-Sun prime exists??!!\"\n    print(\"\\nPisano period (p, 2) for primes less than 50\\n \",\n          [pisanoprime(prime, 2) for prime in primerange(1, 50)])\n    print(\"\\nPisano period (p, 1) for primes less than 180\\n \",\n          [pisanoprime(prime, 1) for prime in primerange(1, 180)])\n    print(\"\\nPisano period (p) for integers 1 to 180\")\n    for i in range(1, 181):\n        print(\" %3d\" % pisano2(i), end=\"\" if i % 10 else \"\\n\")\n"}
{"id": 389735, "name": "Welch's t-test", "source": "Translate Ruby to Python: def calculate_p_value(array1, array2)\n  return 1.0 if array1.size <= 1\n  return 1.0 if array2.size <= 1\n  mean1 = array1.sum / array1.size\n  mean2 = array2.sum / array2.size\n  return 1.0 if mean1 == mean2\n  variance1 = 0.0\n  variance2 = 0.0\n  array1.each do |x|\n    variance1 += (mean1 - x)**2\n  end\n  array2.each do |x|\n    variance2 += (mean2 - x)**2\n  end\n  return 1.0 if variance1 == 0.0 && variance2 == 0.0\n  variance1 /= (array1.size - 1)\n  variance2 /= (array2.size - 1)\n  welch_t_statistic = (mean1 - mean2) / Math.sqrt(variance1 / array1.size + variance2 / array2.size)\n  degrees_of_freedom = ((variance1 / array1.size + variance2 / array2.size)**2)\t/\t(\n  (variance1 * variance1) / (array1.size * array1.size * (array1.size - 1)) +\n  (variance2 * variance2) / (array2.size * array2.size * (array2.size - 1)))\n  a = degrees_of_freedom / 2\n  value = degrees_of_freedom / (welch_t_statistic**2 + degrees_of_freedom)\n  beta = Math.lgamma(a)[0] + 0.57236494292470009 - Math.lgamma(a + 0.5)[0]\n  acu = 10**-15\n  return value if a <= 0\n  return value if value < 0.0 || value > 1.0\n  return value if (value == 0) || (value == 1.0)\n  psq = a + 0.5\n  cx = 1.0 - value\n  if a < psq * value\n    xx = cx\n    cx = value\n    pp = 0.5\n    qq = a\n    indx = 1\n  else\n    xx = value\n    pp = a\n    qq = 0.5\n    indx = 0\n  end\n  term = 1.0\n  ai = 1.0\n  value = 1.0\n  ns = (qq + cx * psq).to_i\n  \n  rx = xx / cx\n  temp = qq - ai\n  loop do\n    term = term * temp * rx / (pp + ai)\n    value += term\n    temp = term.abs\n    if temp <= acu && temp <= acu * value\n      value = value * Math.exp(pp * Math.log(xx) + (qq - 1.0) * Math.log(cx) - beta) / pp\n      value = 1.0 - value\n      value = 1.0 - value if indx == 0\n      break\n    end\n    ai += 1.0\n    ns -= 1\n    if ns >= 0\n      temp = qq - ai\n      rx = xx if ns == 0\n    else\n      temp = psq\n      psq += 1.0\n    end\n  end\n  value\nend\n\nd1 = [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4]\nd2 = [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4]\nd3 = [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8]\nd4 = [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8]\nd5 = [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0]\nd6 = [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2]\nd7 = [30.02, 29.99, 30.11, 29.97, 30.01, 29.99]\nd8 = [29.89, 29.93, 29.72, 29.98, 30.02, 29.98]\nx = [3.0, 4.0, 1.0, 2.1]\ny = [490.2, 340.0, 433.9]\ns1 = [1.0 / 15, 10.0 / 62.0]\ns2 = [1.0 / 10, 2 / 50.0]\nv1 = [0.010268, 0.000167, 0.000167]\nv2 = [0.159258, 0.136278, 0.122389]\nz1 = [9 / 23.0, 21 / 45.0, 0 / 38.0]\nz2 = [0 / 44.0, 42 / 94.0, 0 / 22.0]\n\nCORRECT_ANSWERS = [0.021378001462867, 0.148841696605327, 0.0359722710297968,\n                   0.090773324285671, 0.0107515611497845, 0.00339907162713746, 0.52726574965384, 0.545266866977794].freeze\n\npvalue = calculate_p_value(d1, d2)\nerror = (pvalue - CORRECT_ANSWERS[0]).abs\nprintf(\"Test sets 1 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d3, d4)\nerror += (pvalue - CORRECT_ANSWERS[1]).abs\nprintf(\"Test sets 2 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d5, d6)\nerror += (pvalue - CORRECT_ANSWERS[2]).abs\nprintf(\"Test sets 3 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d7, d8)\nerror += (pvalue - CORRECT_ANSWERS[3]).abs\nprintf(\"Test sets 4 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(x, y)\nerror += (pvalue - CORRECT_ANSWERS[4]).abs\nprintf(\"Test sets 5 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(v1, v2)\nerror += (pvalue - CORRECT_ANSWERS[5]).abs\nprintf(\"Test sets 6 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(s1, s2)\nerror += (pvalue - CORRECT_ANSWERS[6]).abs\nprintf(\"Test sets 7 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(z1, z2)\nerror += (pvalue - CORRECT_ANSWERS[7]).abs\nprintf(\"Test sets z p-value =\u00a0%.14g\\n\", pvalue)\n\nprintf(\"the cumulative error is %g\\n\", error)\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 389736, "name": "Welch's t-test", "source": "Translate Ruby to Python: def calculate_p_value(array1, array2)\n  return 1.0 if array1.size <= 1\n  return 1.0 if array2.size <= 1\n  mean1 = array1.sum / array1.size\n  mean2 = array2.sum / array2.size\n  return 1.0 if mean1 == mean2\n  variance1 = 0.0\n  variance2 = 0.0\n  array1.each do |x|\n    variance1 += (mean1 - x)**2\n  end\n  array2.each do |x|\n    variance2 += (mean2 - x)**2\n  end\n  return 1.0 if variance1 == 0.0 && variance2 == 0.0\n  variance1 /= (array1.size - 1)\n  variance2 /= (array2.size - 1)\n  welch_t_statistic = (mean1 - mean2) / Math.sqrt(variance1 / array1.size + variance2 / array2.size)\n  degrees_of_freedom = ((variance1 / array1.size + variance2 / array2.size)**2)\t/\t(\n  (variance1 * variance1) / (array1.size * array1.size * (array1.size - 1)) +\n  (variance2 * variance2) / (array2.size * array2.size * (array2.size - 1)))\n  a = degrees_of_freedom / 2\n  value = degrees_of_freedom / (welch_t_statistic**2 + degrees_of_freedom)\n  beta = Math.lgamma(a)[0] + 0.57236494292470009 - Math.lgamma(a + 0.5)[0]\n  acu = 10**-15\n  return value if a <= 0\n  return value if value < 0.0 || value > 1.0\n  return value if (value == 0) || (value == 1.0)\n  psq = a + 0.5\n  cx = 1.0 - value\n  if a < psq * value\n    xx = cx\n    cx = value\n    pp = 0.5\n    qq = a\n    indx = 1\n  else\n    xx = value\n    pp = a\n    qq = 0.5\n    indx = 0\n  end\n  term = 1.0\n  ai = 1.0\n  value = 1.0\n  ns = (qq + cx * psq).to_i\n  \n  rx = xx / cx\n  temp = qq - ai\n  loop do\n    term = term * temp * rx / (pp + ai)\n    value += term\n    temp = term.abs\n    if temp <= acu && temp <= acu * value\n      value = value * Math.exp(pp * Math.log(xx) + (qq - 1.0) * Math.log(cx) - beta) / pp\n      value = 1.0 - value\n      value = 1.0 - value if indx == 0\n      break\n    end\n    ai += 1.0\n    ns -= 1\n    if ns >= 0\n      temp = qq - ai\n      rx = xx if ns == 0\n    else\n      temp = psq\n      psq += 1.0\n    end\n  end\n  value\nend\n\nd1 = [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4]\nd2 = [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4]\nd3 = [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8]\nd4 = [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8]\nd5 = [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0]\nd6 = [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2]\nd7 = [30.02, 29.99, 30.11, 29.97, 30.01, 29.99]\nd8 = [29.89, 29.93, 29.72, 29.98, 30.02, 29.98]\nx = [3.0, 4.0, 1.0, 2.1]\ny = [490.2, 340.0, 433.9]\ns1 = [1.0 / 15, 10.0 / 62.0]\ns2 = [1.0 / 10, 2 / 50.0]\nv1 = [0.010268, 0.000167, 0.000167]\nv2 = [0.159258, 0.136278, 0.122389]\nz1 = [9 / 23.0, 21 / 45.0, 0 / 38.0]\nz2 = [0 / 44.0, 42 / 94.0, 0 / 22.0]\n\nCORRECT_ANSWERS = [0.021378001462867, 0.148841696605327, 0.0359722710297968,\n                   0.090773324285671, 0.0107515611497845, 0.00339907162713746, 0.52726574965384, 0.545266866977794].freeze\n\npvalue = calculate_p_value(d1, d2)\nerror = (pvalue - CORRECT_ANSWERS[0]).abs\nprintf(\"Test sets 1 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d3, d4)\nerror += (pvalue - CORRECT_ANSWERS[1]).abs\nprintf(\"Test sets 2 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d5, d6)\nerror += (pvalue - CORRECT_ANSWERS[2]).abs\nprintf(\"Test sets 3 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d7, d8)\nerror += (pvalue - CORRECT_ANSWERS[3]).abs\nprintf(\"Test sets 4 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(x, y)\nerror += (pvalue - CORRECT_ANSWERS[4]).abs\nprintf(\"Test sets 5 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(v1, v2)\nerror += (pvalue - CORRECT_ANSWERS[5]).abs\nprintf(\"Test sets 6 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(s1, s2)\nerror += (pvalue - CORRECT_ANSWERS[6]).abs\nprintf(\"Test sets 7 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(z1, z2)\nerror += (pvalue - CORRECT_ANSWERS[7]).abs\nprintf(\"Test sets z p-value =\u00a0%.14g\\n\", pvalue)\n\nprintf(\"the cumulative error is %g\\n\", error)\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 389737, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to Python: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 389738, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to Python: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 389739, "name": "Cyclotomic polynomial", "source": "Translate Ruby to Python: say \"First 30 cyclotomic polynomials:\"\nfor k in (1..30) {\n    say (\"\u03a6(\n}\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\"\nfor n in (1..10) {  \n    var k = (1..Inf -> first {|k|\n        cyclotomic(k).coeffs.any { .tail.abs == n }\n    })\n    say \"\u03a6(\n}\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 389740, "name": "Cyclotomic polynomial", "source": "Translate Ruby to Python: say \"First 30 cyclotomic polynomials:\"\nfor k in (1..30) {\n    say (\"\u03a6(\n}\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\"\nfor n in (1..10) {  \n    var k = (1..Inf -> first {|k|\n        cyclotomic(k).coeffs.any { .tail.abs == n }\n    })\n    say \"\u03a6(\n}\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 389741, "name": "Ramanujan's constant", "source": "Translate Ruby to Python: require \"bigdecimal/math\"\ninclude BigMath\n\ne, pi = E(200), PI(200)\n[19, 43, 67, 163].each do |x|\n  puts \"\nend\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 389742, "name": "Ramanujan's constant", "source": "Translate Ruby to Python: require \"bigdecimal/math\"\ninclude BigMath\n\ne, pi = E(200), PI(200)\n[19, 43, 67, 163].each do |x|\n  puts \"\nend\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 389743, "name": "Most frequent k chars distance", "source": "Translate Ruby to Python: func _MostFreqKHashing(string, k) {\n\n    var seen = Hash()\n    var chars = string.chars\n    var freq = chars.freq\n    var schars = freq.keys.sort_by {|c| -freq{c} }\n\n    var mfkh = []\n    for i in ^k {\n        chars.each { |c|\n            seen{c} && next\n            if (freq{c} == freq{schars[i]}) {\n                seen{c} = true\n                mfkh << Hash(c => c, f => freq{c})\n                break\n            }\n        }\n    }\n\n    mfkh << (k-seen.len -> of { Hash(c => :NULL, f => 0) }...)\n    mfkh\n}\n\nfunc MostFreqKSDF(a, b, k, d) {\n\n    var mfkh_a = _MostFreqKHashing(a, k);\n    var mfkh_b = _MostFreqKHashing(b, k);\n\n    d - gather {\n        mfkh_a.each { |s|\n            s{:c} == :NULL && next\n            mfkh_b.each { |t|\n                s{:c} == t{:c} &&\n                    take(s{:f} + (s{:f} == t{:f} ? 0 : t{:f}))\n            }\n        }\n    }.sum\n}\n\nfunc MostFreqKHashing(string, k) {\n    gather {\n        _MostFreqKHashing(string, k).each { |h|\n            take(\"%s%d\" % (h{:c}, h{:f}))\n        }\n    }.join\n}\n\n\nvar str1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\"\nvar str2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\"\n\nsay \"str1 = \nsay \"str2 = \n\nsay ''\n\nsay(\"MostFreqKHashing(str1, 2) = \", MostFreqKHashing(str1, 2))\nsay(\"MostFreqKHashing(str2, 2) = \", MostFreqKHashing(str2, 2))\nsay(\"MostFreqKSDF(str1, str2, 2, 100) = \", MostFreqKSDF(str1, str2, 2, 100))\n\nsay ''\n\nvar arr = [\n    %w(night nacht),\n    %w(my a),\n    %w(research research),\n    %w(aaaaabbbb ababababa),\n    %w(significant capabilities),\n]\n\nvar k = 2\nvar limit = 10\n\nfor s,t in arr {\n    \"mfkh(%s, %s, \n        s.dump, t.dump,\n        MostFreqKHashing(s, k).dump,\n        MostFreqKHashing(t, k).dump,\n        MostFreqKSDF(s, t, k, limit),\n    )\n}\n", "target": "import collections\ndef MostFreqKHashing(inputString, K):\n    occuDict = collections.defaultdict(int)\n    for c in inputString:\n        occuDict[c] += 1\n    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)\n    outputStr = ''.join(c + str(cnt) for c, cnt in occuList[:K])\n    return outputStr \n\n\ndef MostFreqKSimilarity(inputStr1, inputStr2):\n    similarity = 0\n    for i in range(0, len(inputStr1), 2):\n        c = inputStr1[i]\n        cnt1 = int(inputStr1[i + 1])\n        for j in range(0, len(inputStr2), 2):\n            if inputStr2[j] == c:\n                cnt2 = int(inputStr2[j + 1])\n                similarity += cnt1 + cnt2\n                break\n    return similarity\n\ndef MostFreqKSDF(inputStr1, inputStr2, K, maxDistance):\n    return maxDistance - MostFreqKSimilarity(MostFreqKHashing(inputStr1,K), MostFreqKHashing(inputStr2,K))\n"}
{"id": 389744, "name": "Distance and Bearing", "source": "Translate Ruby to Python: require 'open-uri'\nrequire 'csv'\ninclude Math\n\nRADIUS = 6372.8  \n\ndef spherical_distance(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  2 * RADIUS * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))\nend\n\ndef bearing(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  dlon = long2 - long1\n  atan2(sin(dlon) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon))\nend\n\ndef deg2rad(lat, long)\n  [lat * PI / 180, long * PI / 180]\nend\n\nuri = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\"\nheaders = %i(airportID\n    name\n    city\n    country\n    iata\n    icao\n    latitude\n    longitude\n    altitude\n    timezone\n    dst\n    tzOlson\n    type\n    source)\ndata = CSV.parse(URI.open(uri), headers: headers, converters: :numeric)\n\nposition = [51.514669, 2.198581]\n\ndata.each{|r| r[:dist] = (spherical_distance(position, [r[:latitude], r[:longitude]])/1.852).round(1)}\nclosest =  data.min_by(20){|row| row[:dist] }\nclosest.each do |r|\n  bearing = (bearing(position,[r[:latitude], r[:longitude]])*180/PI).round % 360\n  puts \"%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\" % (r.values_at(:name, :country, :ICAO, :dist) << bearing)\nend\n", "target": "\n\nfrom math import radians, degrees, sin, cos, asin, atan2, sqrt\nfrom pandas import read_csv\n\n\nEARTH_RADIUS_KM = 6372.8\nTASK_CONVERT_NM =  0.0094174\nAIRPORT_DATA_FILE = 'airports.dat.txt'\n\nQUERY_LATITUDE, QUERY_LONGITUDE = 51.514669, 2.198581\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    \n    rlat1, rlon1, rlat2, rlon2 = [radians(x) for x in [lat1, lon1, lat2, lon2]]\n    dlat = rlat2 - rlat1\n    dlon = rlon2 - rlon1\n    arc = sin(dlat / 2) ** 2 + cos(rlat1) * cos(rlat2) * sin(dlon / 2) ** 2\n    clen = 2.0 * degrees(asin(sqrt(arc)))\n    theta = atan2(sin(dlon) * cos(rlat2),\n                  cos(rlat1) * sin(rlat2) - sin(rlat1) * cos(rlat2) * cos(dlon))\n    theta = (degrees(theta) + 360) % 360\n    return EARTH_RADIUS_KM * clen * TASK_CONVERT_NM, theta\n\n\ndef find_nearest_airports(latitude, longitude, wanted=20, csv=AIRPORT_DATA_FILE):\n    \n    airports = read_csv(csv, header=None, usecols=[1, 3, 5, 6, 7], names=[\n                        'Name', 'Country', 'ICAO', 'Latitude', 'Longitude'])\n    airports['Distance'] = 0.0\n    airports['Bearing'] = 0\n    for (idx, row) in enumerate(airports.itertuples()):\n        distance, bearing = haversine(\n            latitude, longitude, row.Latitude, row.Longitude)\n        airports.at[idx, 'Distance'] = round(distance, ndigits=1)\n        airports.at[idx, 'Bearing'] = int(round(bearing))\n\n    airports.sort_values(by=['Distance'], ignore_index=True, inplace=True)\n    return airports.loc[0:wanted-1, ['Name', 'Country', 'ICAO', 'Distance', 'Bearing']]\n\n\nprint(find_nearest_airports(QUERY_LATITUDE, QUERY_LONGITUDE))\n"}
{"id": 389745, "name": "Distance and Bearing", "source": "Translate Ruby to Python: require 'open-uri'\nrequire 'csv'\ninclude Math\n\nRADIUS = 6372.8  \n\ndef spherical_distance(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  2 * RADIUS * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))\nend\n\ndef bearing(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  dlon = long2 - long1\n  atan2(sin(dlon) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon))\nend\n\ndef deg2rad(lat, long)\n  [lat * PI / 180, long * PI / 180]\nend\n\nuri = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\"\nheaders = %i(airportID\n    name\n    city\n    country\n    iata\n    icao\n    latitude\n    longitude\n    altitude\n    timezone\n    dst\n    tzOlson\n    type\n    source)\ndata = CSV.parse(URI.open(uri), headers: headers, converters: :numeric)\n\nposition = [51.514669, 2.198581]\n\ndata.each{|r| r[:dist] = (spherical_distance(position, [r[:latitude], r[:longitude]])/1.852).round(1)}\nclosest =  data.min_by(20){|row| row[:dist] }\nclosest.each do |r|\n  bearing = (bearing(position,[r[:latitude], r[:longitude]])*180/PI).round % 360\n  puts \"%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\" % (r.values_at(:name, :country, :ICAO, :dist) << bearing)\nend\n", "target": "\n\nfrom math import radians, degrees, sin, cos, asin, atan2, sqrt\nfrom pandas import read_csv\n\n\nEARTH_RADIUS_KM = 6372.8\nTASK_CONVERT_NM =  0.0094174\nAIRPORT_DATA_FILE = 'airports.dat.txt'\n\nQUERY_LATITUDE, QUERY_LONGITUDE = 51.514669, 2.198581\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    \n    rlat1, rlon1, rlat2, rlon2 = [radians(x) for x in [lat1, lon1, lat2, lon2]]\n    dlat = rlat2 - rlat1\n    dlon = rlon2 - rlon1\n    arc = sin(dlat / 2) ** 2 + cos(rlat1) * cos(rlat2) * sin(dlon / 2) ** 2\n    clen = 2.0 * degrees(asin(sqrt(arc)))\n    theta = atan2(sin(dlon) * cos(rlat2),\n                  cos(rlat1) * sin(rlat2) - sin(rlat1) * cos(rlat2) * cos(dlon))\n    theta = (degrees(theta) + 360) % 360\n    return EARTH_RADIUS_KM * clen * TASK_CONVERT_NM, theta\n\n\ndef find_nearest_airports(latitude, longitude, wanted=20, csv=AIRPORT_DATA_FILE):\n    \n    airports = read_csv(csv, header=None, usecols=[1, 3, 5, 6, 7], names=[\n                        'Name', 'Country', 'ICAO', 'Latitude', 'Longitude'])\n    airports['Distance'] = 0.0\n    airports['Bearing'] = 0\n    for (idx, row) in enumerate(airports.itertuples()):\n        distance, bearing = haversine(\n            latitude, longitude, row.Latitude, row.Longitude)\n        airports.at[idx, 'Distance'] = round(distance, ndigits=1)\n        airports.at[idx, 'Bearing'] = int(round(bearing))\n\n    airports.sort_values(by=['Distance'], ignore_index=True, inplace=True)\n    return airports.loc[0:wanted-1, ['Name', 'Country', 'ICAO', 'Distance', 'Bearing']]\n\n\nprint(find_nearest_airports(QUERY_LATITUDE, QUERY_LONGITUDE))\n"}
{"id": 389746, "name": "Sunflower fractal", "source": "Translate Ruby to Python: require('Imager')\n\nfunc draw_sunflower(seeds=3000) {\n    var img = %O<Imager>.new(\n        xsize => 400,\n        ysize => 400,\n    )\n\n    var c = (sqrt(1.25) + 0.5)\n    { |i|\n        var r = (i**c / seeds)\n        var \u03b8 = (2 * Num.pi * c * i)\n        var x = (r * sin(\u03b8) + 200)\n        var y = (r * cos(\u03b8) + 200)\n        img.circle(x => x, y => y, r => i/(5*seeds))\n    } * seeds\n\n    return img\n}\n\nvar img = draw_sunflower()\nimg.write(file => \"sunflower.png\")\n", "target": "from turtle import *\nfrom math import *\n\n\n\niter = 3000\ndiskRatio = .5\n\nfactor = .5 + sqrt(1.25)\n\nscreen = getscreen()\n\n(winWidth, winHeight) = screen.screensize()\n\n\n\n\n\nx = 0.0\ny = 0.0\n\nmaxRad = pow(iter,factor)/iter;\n\nbgcolor(\"light blue\")\n\nhideturtle()\n\ntracer(0, 0)\n\nfor i in range(iter+1):\n    r = pow(i,factor)/iter;\n    \n    if r/maxRad < diskRatio:\n        pencolor(\"black\")\n    else:\n        pencolor(\"yellow\")\n \n    theta = 2*pi*factor*i;\n        \n    up()\n    \n    setposition(x + r*sin(theta), y + r*cos(theta))\n    \n    down()\n       \n    circle(10.0 * i/(1.0*iter))\n    \nupdate()\n\ndone()\n"}
{"id": 389747, "name": "Practical numbers", "source": "Translate Ruby to Python: say is_practical(2**128 + 1)   \nsay is_practical(2**128 + 4)   \n", "target": "from itertools import chain, cycle, accumulate, combinations\nfrom typing import List, Tuple\n\n\n\ndef factors5(n: int) -> List[int]:\n    \n    def prime_powers(n):\n        \n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d + (p,)\n            yield(d)\n        if n > 1: yield((n,))\n\n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r[:-1]\n\n\n\ndef powerset(s: List[int]) -> List[Tuple[int, ...]]:\n    \n    return chain.from_iterable(combinations(s, r) for r in range(1, len(s)+1))\n\n\n\ndef is_practical(x: int) -> bool:\n    \n    if x == 1:\n        return True\n    if x %2:\n        return False  \n    f = factors5(x)\n    ps = powerset(f)\n    found = {y for y in {sum(i) for i in ps}\n             if 1 <= y < x}\n    return len(found) == x - 1\n\n\nif __name__ == '__main__':\n    n = 333\n    p = [x for x in range(1, n + 1) if is_practical(x)]\n    print(f\"There are {len(p)} Practical numbers from 1 to {n}:\")\n    print(' ', str(p[:10])[1:-1], '...', str(p[-10:])[1:-1])\n    x = 666\n    print(f\"\\nSTRETCH GOAL: {x} is {'not ' if not is_practical(x) else ''}Practical.\")\n"}
{"id": 389748, "name": "Penrose tiling", "source": "Translate Ruby to Python: var rules = Hash(\n    a => 'cE++dE----bE[-cE----aE]++',\n    b => '+cE--dE[---aE--bE]+',\n    c => '-aE++bE[+++cE++dE]-',\n    d => '--cE++++aE[+dE++++bE]--bE',\n    E => '',\n)\n\nvar lsys = LSystem(\n    width:  1000,\n    height: 1000,\n\n    scale: 1,\n    xoff: -500,\n    yoff: -500,\n\n    len:   40,\n    angle: 36,\n    color: 'dark blue',\n)\n\nlsys.execute('[b]++[b]++[b]++[b]++[b]', 5, \"penrose_tiling.png\", rules)\n", "target": "def penrose(depth):\n    print(\t<g id=\"A{d+1}\" transform=\"translate(100, 0) scale(0.6180339887498949)\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\n\t<g id=\"B{d+1}\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\t<g id=\"G\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\n  </defs>\n  <g transform=\"scale(2, 2)\">\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n  </g>\n</svg>''')\n\npenrose(6)\n"}
{"id": 389749, "name": "HTTPS_Client-authenticated", "source": "Translate Ruby to Python: require 'uri'\nrequire 'net/http'\n\nuri = URI.parse('https://www.example.com')\npem = File.read(\"/path/to/my.pem\")\ncert = OpenSSL::X509::Certificate.new(pem)\nkey = OpenSSL::PKey::RSA.new(pem)\nresponse = Net::HTTP.start(uri.host, uri.port, use_ssl: true,\n                           cert: cert, key: key) do |http|\n  request = Net::HTTP::Get.new uri\n  http.request request\nend\n", "target": "import httplib\n\nconnection = httplib.HTTPSConnection('www.example.com',cert_file='myCert.PEM')\nconnection.request('GET','/index.html')\nresponse = connection.getresponse()\ndata = response.read()\n"}
{"id": 389750, "name": "SQL-based authentication", "source": "Translate Ruby to Python: require 'mysql2'\nrequire 'securerandom'\nrequire 'digest'\n\ndef connect_db(host, port = nil, username, password, db)\n  Mysql2::Client.new(\n    host: host,\n    port: port,\n    username: username,\n    password: password,\n    database: db\n  )\nend\n\ndef create_user(client, username, password)\n  salt = SecureRandom.random_bytes(16)\n  password_md5 = Digest::MD5.hexdigest(salt + password)\n\n  statement = client.prepare('INSERT INTO users (username, pass_salt, pass_md5) VALUES (?,\u00a0?,\u00a0?)')\n  statement.execute(username, salt, password_md5)\n  statement.last_id\nend\n\ndef authenticate_user(client, username, password)\n  user_record = client.prepare(\"SELECT SELECT pass_salt, pass_md5 FROM users WHERE username = '\n  return false unless user_record\n\n  password_md5 = Digest::MD5.hexdigest(user_record['pass_salt'] + password)\n  password_md5 == user_record['pass_md5']\nend\n", "target": "import mysql.connector \nimport hashlib\n \nimport sys\t \nimport random\t \n \nDB_HOST = \"localhost\"\t \nDB_USER = \"devel\" \nDB_PASS = \"devel\"\t \nDB_NAME = \"test\"\t \n \ndef connect_db():\t \n    \t \n    try:\t \n        return mysql.connector.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME)\t \n    except:\t \n        return False\t \n \ndef create_user(username, passwd):\t \n    \t \n    db = connect_db()\t \n    if not db:\t \n        print \"Can't connect MySQL!\"\n        return None\n \n    cursor = db.cursor()\t \n \n    salt = randomValue(16)\t \t \n    passwd_md5 = hashlib.md5(salt+passwd).hexdigest()\t \n \n    \n    try:\t \n        cursor.execute(\"INSERT INTO users (`username`, `pass_salt`, `pass_md5`) VALUES (%s, %s, %s)\", (username, salt, passwd_md5)) \n        cursor.execute(\"SELECT userid FROM users WHERE username=%s\", (username,) ) \n        id = cursor.fetchone()\n        db.commit()\n        cursor.close()\n        db.close()\n        return id[0]\t \n    except:\t \n        print 'Username was already taken. Please select another'\t \n        return None\n \ndef authenticate_user(username, passwd):\t \n    db = connect_db()\t \n    if not db:\t \n        print \"Can't connect MySQL!\"\n        return False\n \n    cursor = db.cursor()\t \n \n    cursor.execute(\"SELECT pass_salt, pass_md5 FROM users WHERE username=%s\", (username,))\n\n    row = cursor.fetchone()\n    cursor.close()\n    db.close()\n    if row is None:     \n        return False\n    salt = row[0]\n    correct_md5 = row[1]\n    tried_md5 = hashlib.md5(salt+passwd).hexdigest()\n    return correct_md5 == tried_md5\n \ndef randomValue(length):\t \n    \t \n    salt_chars = 'abcdefghijklmnopqrstuvwxyz0123456789'\n\n    return ''.join(random.choice(salt_chars) for x in range(length))\n \nif __name__ == '__main__':\t \n    user = randomValue(10)\n    passwd = randomValue(16)\t \n \n    new_user_id = create_user(user, passwd)\n    if new_user_id is None:\n        print 'Failed to create user %s' % user\n        sys.exit(1)\n    auth = authenticate_user(user, passwd)\t \n    if auth:\t \n        print 'User %s authenticated successfully' % user\t \n    else:\t \n        print 'User %s failed' % user\n"}
{"id": 389751, "name": "Bitmap_PPM conversion through a pipe", "source": "Translate Ruby to Python: class Pixmap\n  PIXMAP_FORMATS = [\"P3\", \"P6\"]   \n  PIXMAP_BINARY_FORMATS = [\"P6\"]  \n\n  def write_ppm(ios, format=\"P6\")\n    if not PIXMAP_FORMATS.include?(format)\n      raise NotImplementedError, \"pixmap format \n    end\n    ios.puts format, \"\n    ios.binmode if PIXMAP_BINARY_FORMATS.include?(format)\n    @height.times do |y|\n      @width.times do |x|\n        case format\n        when \"P3\" then ios.print @data[x][y].values.join(\" \"),\"\\n\"\n        when \"P6\" then ios.print @data[x][y].values.pack('C3')\n        end\n      end\n    end\n  end\n\n  def save(filename, opts={:format=>\"P6\"})\n    File.open(filename, 'w') do |f|\n      write_ppm(f, opts[:format])\n    end\n  end\n\n  def print(opts={:format=>\"P6\"})\n    write_ppm($stdout, opts[:format])\n  end\n\n  def save_as_jpeg(filename, quality=75)\n    pipe = IO.popen(\"convert ppm:- -quality \n    write_ppm(pipe)\n    pipe.close\n  end\nend\n\nimage = Pixmap.open('file.ppm')\nimage.save_as_jpeg('file.jpg')\n", "target": "\n\nfrom PIL import Image\n\nim = Image.open(\"boxes_1.ppm\")\nim.save(\"boxes_1.jpg\")\n"}
{"id": 389752, "name": "Tarjan", "source": "Translate Ruby to Python: func tarjan (k) {\n\n    var(:onstack, :index, :lowlink, *stack, *connected)\n\n    func strong_connect (vertex, i=0) {\n\n         index{vertex}   = i\n         lowlink{vertex} = i+1\n         onstack{vertex} = true\n         stack << vertex\n\n         for connection in (k{vertex}) {\n             if (index{connection} == nil) {\n                 strong_connect(connection, i+1)\n                 lowlink{vertex} `min!` lowlink{connection}\n             }\n             elsif (onstack{connection}) {\n                 lowlink{vertex} `min!` index{connection}\n             }\n        }\n\n        if (lowlink{vertex} == index{vertex}) {\n            var *node\n            do {\n                node << stack.pop\n                onstack{node.tail} = false\n            } while (node.tail != vertex)\n            connected << node\n        }\n    }\n\n    { strong_connect(_) if !index{_} } << k.keys\n\n    return connected\n}\n\nvar tests = [\n    Hash(\n         0 => <1>,\n         1 => <2>,\n         2 => <0>,\n         3 => <1 2 4>,\n         4 => <3 5>,\n         5 => <2 6>,\n         6 => <5>,\n         7 => <4 6 7>,\n    ),\n    Hash(\n        :Andy => <Bart>,\n        :Bart => <Carl>,\n        :Carl => <Andy>,\n        :Dave => <Bart Carl Earl>,\n        :Earl => <Dave Fred>,\n        :Fred => <Carl Gary>,\n        :Gary => <Fred>,\n        :Hank => <Earl Gary Hank>,\n    )\n]\n\ntests.each {|t|\n    say (\"Strongly connected components: \", tarjan(t).map{.sort}.sort)\n}\n", "target": "from collections import defaultdict\n\ndef from_edges(edges):\n    \n\n    class Node:\n        def __init__(self):\n            \n            \n            \n            \n            self.root = None\n            self.succ = []\n\n    nodes = defaultdict(Node)\n    for v,w in edges:\n        nodes[v].succ.append(nodes[w])\n\n    for i,v in nodes.items(): \n        v.id = i\n\n    return nodes.values()\n\ndef trajan(V):\n    def strongconnect(v, S):\n        v.root = pos = len(S)\n        S.append(v)\n\n        for w in v.succ:\n            if w.root is None:  \n                yield from strongconnect(w, S)\n\n            if w.root >= 0:  \n                v.root = min(v.root, w.root)\n\n        if v.root == pos:  \n            res, S[pos:] = S[pos:], []\n            for w in res:\n                w.root = -1\n            yield [r.id for r in res]\n\n    for v in V:\n        if v.root is None:\n            yield from strongconnect(v, [])\n\n\ntables = [  \n            [(1,2), (3,1), (3,6), (6,7), (7,6), (2,3), (4,2),\n             (4,3), (4,5), (5,6), (5,4), (8,5), (8,7), (8,6)],\n\n            \n            [('A', 'B'), ('B', 'C'), ('C', 'A'), ('A', 'Other')]]\n\nfor table in (tables):\n    for g in trajan(from_edges(table)):\n        print(g)\n    print()\n"}
{"id": 389753, "name": "Powerful numbers", "source": "Translate Ruby to Python: func powerful(n, k=2) {\n\n    var list = []\n\n    func (m,r) {\n        if (r < k) {\n            list << m\n            return nil\n        }\n        for a in (1 .. iroot(idiv(n,m), r)) {\n            if (r > k) {\n                a.is_coprime(m) || next\n                a.is_squarefree || next\n            }\n            __FUNC__(m * a**r, r-1)\n        }\n    }(1, 2*k - 1)\n\n    return list.sort\n}\n\nfor k in (2..10) {\n    var a = powerful(10**k, k)\n    var h = a.head(5).join(', ')\n    var t = a.tail(5).join(', ')\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", k, a.len, h, t)\n}\n", "target": "from primesieve import primes \nimport math\n\ndef primepowers(k, upper_bound):\n    ub = int(math.pow(upper_bound, 1/k) + .5)\n    res = [(1,)]\n\n    for p in primes(ub):\n        a = [p**k]\n        u = upper_bound // a[-1]\n        while u >= p:\n            a.append(a[-1]*p)\n            u //= p\n        res.append(tuple(a))\n\n    return res\n\ndef kpowerful(k, upper_bound, count_only=True):\n    ps = primepowers(k, upper_bound)\n\n    def accu(i, ub):\n        c = 0 if count_only else [] \n        for p in ps[i]:\n            u = ub//p\n            if not u: break\n\n            c += 1 if count_only else [p]\n\n            for j in range(i + 1, len(ps)):\n                if u < ps[j][0]:\n                    break\n                c += accu(j, u) if count_only else [p*x for x in accu(j, u)]\n        return c\n\n    res = accu(0, upper_bound)\n    return res if count_only else sorted(res)\n\nfor k in range(2, 11):\n    res = kpowerful(k, 10**k, count_only=False)\n    print(f'{len(res)} {k}-powerfuls up to 10^{k}:',\n        ' '.join(str(x) for x in res[:5]),\n        '...',\n        ' '.join(str(x) for x in res[-5:])\n        )\n\nfor k in range(2, 11):\n    res = [kpowerful(k, 10**n) for n in range(k+10)]\n    print(f'{k}-powerful up to 10^{k+10}:',\n        ' '.join(str(x) for x in res))\n"}
{"id": 389754, "name": "Powerful numbers", "source": "Translate Ruby to Python: func powerful(n, k=2) {\n\n    var list = []\n\n    func (m,r) {\n        if (r < k) {\n            list << m\n            return nil\n        }\n        for a in (1 .. iroot(idiv(n,m), r)) {\n            if (r > k) {\n                a.is_coprime(m) || next\n                a.is_squarefree || next\n            }\n            __FUNC__(m * a**r, r-1)\n        }\n    }(1, 2*k - 1)\n\n    return list.sort\n}\n\nfor k in (2..10) {\n    var a = powerful(10**k, k)\n    var h = a.head(5).join(', ')\n    var t = a.tail(5).join(', ')\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", k, a.len, h, t)\n}\n", "target": "from primesieve import primes \nimport math\n\ndef primepowers(k, upper_bound):\n    ub = int(math.pow(upper_bound, 1/k) + .5)\n    res = [(1,)]\n\n    for p in primes(ub):\n        a = [p**k]\n        u = upper_bound // a[-1]\n        while u >= p:\n            a.append(a[-1]*p)\n            u //= p\n        res.append(tuple(a))\n\n    return res\n\ndef kpowerful(k, upper_bound, count_only=True):\n    ps = primepowers(k, upper_bound)\n\n    def accu(i, ub):\n        c = 0 if count_only else [] \n        for p in ps[i]:\n            u = ub//p\n            if not u: break\n\n            c += 1 if count_only else [p]\n\n            for j in range(i + 1, len(ps)):\n                if u < ps[j][0]:\n                    break\n                c += accu(j, u) if count_only else [p*x for x in accu(j, u)]\n        return c\n\n    res = accu(0, upper_bound)\n    return res if count_only else sorted(res)\n\nfor k in range(2, 11):\n    res = kpowerful(k, 10**k, count_only=False)\n    print(f'{len(res)} {k}-powerfuls up to 10^{k}:',\n        ' '.join(str(x) for x in res[:5]),\n        '...',\n        ' '.join(str(x) for x in res[-5:])\n        )\n\nfor k in range(2, 11):\n    res = [kpowerful(k, 10**n) for n in range(k+10)]\n    print(f'{k}-powerful up to 10^{k+10}:',\n        ' '.join(str(x) for x in res))\n"}
{"id": 389755, "name": "Distribution of 0 digits in factorial series", "source": "Translate Ruby to Python: [100, 1000, 10_000].each do |n|\n  v = 1\n  total_proportion = (1..n).sum do |k|\n    v *= k\n    digits =  v.digits\n    Rational(digits.count(0),  digits.size)\n  end\n  puts \"The mean proportion of 0 in factorials from 1 to \nend\n", "target": "def facpropzeros(N, verbose = True):\n    proportions = [0.0] * N\n    fac, psum = 1, 0.0\n    for i in range(N):\n        fac *= i + 1\n        d = list(str(fac))\n        psum += sum(map(lambda x: x == '0', d)) / len(d)\n        proportions[i] = psum / (i + 1)\n\n    if verbose:\n        print(\"The mean proportion of 0 in factorials from 1 to {} is {}.\".format(N, psum / N))\n\n    return proportions\n\n\nfor n in [100, 1000, 10000]:\n    facpropzeros(n)\n\nprops = facpropzeros(47500, False)\nn = (next(i for i in reversed(range(len(props))) if props[i] > 0.16))\n\nprint(\"The mean proportion dips permanently below 0.16 at {}.\".format(n + 2))\n"}
{"id": 389756, "name": "Checksumcolor", "source": "Translate Ruby to Python: var ansi = frequire(\"Term::ANSIColor\")\n\nfunc colorhash(hash) {\n    hash.split(2).map{|s| ansi.colored(s, \"ansi\" + s.hex) }.join\n}\n\nARGF.each {|line|\n    if (STDOUT.is_on_tty && (line =~ /^([[:xdigit:]]+)(.*)/)) {|m|\n        say (colorhash(m[0]), m[1])\n    }\n    else {\n        say line\n    }\n}\n", "target": "\n\n\nfrom __future__ import unicode_literals\n\nimport argparse\nimport fileinput\nimport os\nimport sys\n\nfrom functools import partial\nfrom itertools import count\nfrom itertools import takewhile\n\n\nANSI_RESET = \"\\u001b[0m\"\n\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nMAGENTA = (255, 0, 255)\nCYAN = (0, 255, 255)\n\nANSI_PALETTE = {\n    RED: \"\\u001b[31m\",\n    GREEN: \"\\u001b[32m\",\n    YELLOW: \"\\u001b[33m\",\n    BLUE: \"\\u001b[34m\",\n    MAGENTA: \"\\u001b[35m\",\n    CYAN: \"\\u001b[36m\",\n}\n\n\n\n_8BIT_PALETTE = {\n    (0xAF, 0x00, 0x00): \"\\u001b[38;5;124m\",\n    (0xAF, 0x00, 0x5F): \"\\u001b[38;5;125m\",\n    (0xAF, 0x00, 0x87): \"\\u001b[38;5;126m\",\n    (0xAF, 0x00, 0xAF): \"\\u001b[38;5;127m\",\n    (0xAF, 0x00, 0xD7): \"\\u001b[38;5;128m\",\n    (0xAF, 0x00, 0xFF): \"\\u001b[38;5;129m\",\n    (0xAF, 0x5F, 0x00): \"\\u001b[38;5;130m\",\n    (0xAF, 0x5F, 0x5F): \"\\u001b[38;5;131m\",\n    (0xAF, 0x5F, 0x87): \"\\u001b[38;5;132m\",\n    (0xAF, 0x5F, 0xAF): \"\\u001b[38;5;133m\",\n    (0xAF, 0x5F, 0xD7): \"\\u001b[38;5;134m\",\n    (0xAF, 0x5F, 0xFF): \"\\u001b[38;5;135m\",\n    (0xAF, 0x87, 0x00): \"\\u001b[38;5;136m\",\n    (0xAF, 0x87, 0x5F): \"\\u001b[38;5;137m\",\n    (0xAF, 0x87, 0x87): \"\\u001b[38;5;138m\",\n    (0xAF, 0x87, 0xAF): \"\\u001b[38;5;139m\",\n    (0xAF, 0x87, 0xD7): \"\\u001b[38;5;140m\",\n    (0xAF, 0x87, 0xFF): \"\\u001b[38;5;141m\",\n    (0xAF, 0xAF, 0x00): \"\\u001b[38;5;142m\",\n    (0xAF, 0xAF, 0x5F): \"\\u001b[38;5;143m\",\n    (0xAF, 0xAF, 0x87): \"\\u001b[38;5;144m\",\n    (0xAF, 0xAF, 0xAF): \"\\u001b[38;5;145m\",\n    (0xAF, 0xAF, 0xD7): \"\\u001b[38;5;146m\",\n    (0xAF, 0xAF, 0xFF): \"\\u001b[38;5;147m\",\n    (0xAF, 0xD7, 0x00): \"\\u001b[38;5;148m\",\n    (0xAF, 0xD7, 0x5F): \"\\u001b[38;5;149m\",\n    (0xAF, 0xD7, 0x87): \"\\u001b[38;5;150m\",\n    (0xAF, 0xD7, 0xAF): \"\\u001b[38;5;151m\",\n    (0xAF, 0xD7, 0xD7): \"\\u001b[38;5;152m\",\n    (0xAF, 0xD7, 0xFF): \"\\u001b[38;5;153m\",\n    (0xAF, 0xFF, 0x00): \"\\u001b[38;5;154m\",\n    (0xAF, 0xFF, 0x5F): \"\\u001b[38;5;155m\",\n    (0xAF, 0xFF, 0x87): \"\\u001b[38;5;156m\",\n    (0xAF, 0xFF, 0xAF): \"\\u001b[38;5;157m\",\n    (0xAF, 0xFF, 0xD7): \"\\u001b[38;5;158m\",\n    (0xAF, 0xFF, 0xFF): \"\\u001b[38;5;159m\",\n}\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(os.linesep)\n    sys.exit(1)\n\n\ndef rgb(group):\n    \n    nibbles_per_channel = len(group) // 3\n    max_val = 16 ** nibbles_per_channel - 1\n    nibbles = chunked(group, nibbles_per_channel)\n\n    \n    return tuple((int(n, 16) * 255) // max_val for n in nibbles)\n\n\ndef distance(color, other):\n    \n    return sum((o - s) ** 2 for s, o in zip(color, other))\n\n\ndef chunked(seq, n):\n    \n    return takewhile(len, (seq[i : i + n] for i in count(0, n)))\n\n\ndef escape(group, palette):\n    \n    key = partial(distance, other=rgb(group.ljust(3, \"0\")))\n    ansi_color = min(palette, key=key)\n    return \"\".join([palette[ansi_color], group, ANSI_RESET])\n\n\ndef colorize(line, group_size=3, palette=ANSI_PALETTE):\n    \n    checksum, filename = line.split(None, 1)\n    escaped = [escape(group, palette) for group in chunked(checksum, group_size)]\n    sys.stdout.write(\"  \".join([\"\".join(escaped), filename]))\n\n\ndef html_colorize(checksum, group_size=3, palette=ANSI_PALETTE):\n    \n\n    def span(group):\n        key = partial(distance, other=rgb(group.ljust(3, \"0\")))\n        ansi_color = min(palette, key=key)\n        int_val = int.from_bytes(ansi_color, byteorder=\"big\")\n        hex_val = hex(int_val)[2:].rjust(6, \"0\")\n        return '<span style=\"color:\n\n    checksum, filename = line.split(None, 1)\n    escaped = [span(group) for group in chunked(checksum, group_size)]\n    sys.stdout.write(\"  \".join([\"\".join(escaped), filename]))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"Color checksum.\")\n\n    parser.add_argument(\n        \"-n\",\n        type=int,\n        default=3,\n        help=\"Color the checksum in groups of size N. Defaults to 3.\",\n    )\n\n    parser.add_argument(\n        \"-e\",\n        \"--extended-palette\",\n        action=\"store_true\",\n        help=\"Use the extended 8-bit palette. Defaults to False.\",\n    )\n\n    parser.add_argument(\n        \"--html\",\n        action=\"store_true\",\n        help=\"Output checksum groups wrapped with 'span' tags instead of ANSI escape sequences.\",\n    )\n\n    parser.add_argument(\"files\", nargs=\"*\", default=\"-\", metavar=\"FILE\")\n\n    args = parser.parse_args()\n\n    if sys.stdout.isatty():\n\n        palette = ANSI_PALETTE\n        if args.extended_palette:\n            palette = _8BIT_PALETTE\n\n        colorize_func = colorize\n        if args.html:\n            colorize_func = html_colorize\n\n        for line in fileinput.input(files=args.files):\n            colorize_func(line, group_size=args.n, palette=palette)\n    else:\n        \n        for line in fileinput.input(files=args.files):\n            sys.stdout.write(line)\n"}
{"id": 389757, "name": "Run as a daemon or service", "source": "Translate Ruby to Python: var block = {\n    for n in (1..100) {\n        STDOUT.say(n)\n        Sys.sleep(0.5)\n    }\n}\n\nif (ARGV[0] == 'daemon') {\n    STDERR.say(\"Daemon mode\")\n    STDOUT{:fh} = %f'foo.txt'.open_w(){:fh}\n    STDOUT.autoflush(true)\n    block.fork\n    STDERR.say(\"Exiting\")\n    Sys.exit(0)\n}\n\nSTDERR.say(\"Normal mode\")\nblock.run\n", "target": "\nimport posix\nimport os\nimport sys\n\npid = posix.fork()\nif pid != 0:\n    print(\"Child process detached with pid %s\" % pid)\n    sys.exit(0)\n\nold_stdin = sys.stdin\nold_stdout = sys.stdout\nold_stderr = sys.stderr\n\nsys.stdin = open('/dev/null', 'rt')\nsys.stdout = open('/tmp/dmn.log', 'wt')\nsys.stderr = sys.stdout\n\nold_stdin.close()\nold_stdout.close()\nold_stderr.close()\n\nposix.setsid()\n\nimport time\nt = time.time()\nwhile time.time() < t + 10:\n    print(\"timer running, %s seconds\" % str(time.time() - t))\n    time.sleep(1)\n"}
{"id": 424981, "name": "10001th prime", "source": "Translate Ruby to Java: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "public class NthPrime {\n    public static void main(String[] args) {\n        System.out.printf(\"The 10,001st prime is\u00a0%,d.\\n\", nthPrime(10001));\n    }\n\n    private static int nthPrime(int n) {\n        assert n > 0;\n        PrimeGenerator primeGen = new PrimeGenerator(10000, 100000);\n        int prime = primeGen.nextPrime();\n        while (--n > 0)\n            prime = primeGen.nextPrime();\n        return prime;\n    }\n}\n"}
{"id": 424982, "name": "10001th prime", "source": "Translate Ruby to Java: require \"prime\"\nputs  Prime.lazy.drop(10_000).next\n", "target": "public class NthPrime {\n    public static void main(String[] args) {\n        System.out.printf(\"The 10,001st prime is\u00a0%,d.\\n\", nthPrime(10001));\n    }\n\n    private static int nthPrime(int n) {\n        assert n > 0;\n        PrimeGenerator primeGen = new PrimeGenerator(10000, 100000);\n        int prime = primeGen.nextPrime();\n        while (--n > 0)\n            prime = primeGen.nextPrime();\n        return prime;\n    }\n}\n"}
{"id": 424983, "name": "Next special primes", "source": "Translate Ruby to Java: func special_primes(upto) {\n\n    var gap  = 0\n    var prev = 2\n    var list = [[prev, gap]]\n\n    loop {\n        var n = prev+gap\n        n = n.next_prime\n        break if (n > upto)\n        gap = n-prev\n        list << [n, gap]\n        prev = n\n    }\n\n    return list\n}\n\nspecial_primes(1050).each_2d {|p,gap|\n    say \"\n}\n", "target": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}\n"}
{"id": 424984, "name": "Next special primes", "source": "Translate Ruby to Java: func special_primes(upto) {\n\n    var gap  = 0\n    var prev = 2\n    var list = [[prev, gap]]\n\n    loop {\n        var n = prev+gap\n        n = n.next_prime\n        break if (n > upto)\n        gap = n-prev\n        list << [n, gap]\n        prev = n\n    }\n\n    return list\n}\n\nspecial_primes(1050).each_2d {|p,gap|\n    say \"\n}\n", "target": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}\n"}
{"id": 424985, "name": "Largest number divisible by its digits", "source": "Translate Ruby to Java: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 424986, "name": "Largest number divisible by its digits", "source": "Translate Ruby to Java: magic_number = 9*8*7\ndiv          = (9876432 // magic_number) * magic_number\ncandidates   = div.step(to: 0, by: -magic_number)\n\nres = candidates.find do |c|\n  digits = c.to_s.chars.map(&.to_i)\n  (digits & [0,5]).empty? && digits == digits.uniq\nend\n\nputs \"Largest decimal number is \n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 424987, "name": "Jacobi symbol", "source": "Translate Ruby to Java: def jacobi(a, n)\n  raise ArgumentError.new \"n must b positive and odd\" if n < 1 || n.even?\n  res = 1\n  until (a %= n) == 0\n    while a.even?\n      a >>= 1\n      res = -res if [3, 5].includes? n % 8\n    end\n    a, n = n, a\n    res = -res if a % 4 == n % 4 == 3\n  end\n  n == 1 ? res : 0\nend\n\nputs \"Jacobian symbols for jacobi(a, n)\"\nputs \"n\\\\a  0  1  2  3  4  5  6  7  8  9 10\"\nputs \"------------------------------------\"\n1.step(to: 17, by: 2) do |n|\n   printf(\"%2d \", n)\n   (0..10).each { |a| printf(\"\u00a0% 2d\", jacobi(a, n)) }\n   puts\nend\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 424988, "name": "Jacobi symbol", "source": "Translate Ruby to Java: def jacobi(a, n)\n  raise ArgumentError.new \"n must b positive and odd\" if n < 1 || n.even?\n  res = 1\n  until (a %= n) == 0\n    while a.even?\n      a >>= 1\n      res = -res if [3, 5].includes? n % 8\n    end\n    a, n = n, a\n    res = -res if a % 4 == n % 4 == 3\n  end\n  n == 1 ? res : 0\nend\n\nputs \"Jacobian symbols for jacobi(a, n)\"\nputs \"n\\\\a  0  1  2  3  4  5  6  7  8  9 10\"\nputs \"------------------------------------\"\n1.step(to: 17, by: 2) do |n|\n   printf(\"%2d \", n)\n   (0..10).each { |a| printf(\"\u00a0% 2d\", jacobi(a, n)) }\n   puts\nend\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 424989, "name": "Determinant and permanent", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  \n  def permanent\n    r = (0...row_count).to_a \n    r.permutation.inject(0) do |sum, sigma|\n       sum += sigma.zip(r).inject(1){|prod, (row, col)| prod *= self[row, col] }\n    end\n  end\nend\n\nm1 = Matrix[[1,2],[3,4]] \n\nm2 = Matrix[[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n\nm3 = Matrix[[0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9],\n            [10, 11, 12, 13, 14],\n            [15, 16, 17, 18, 19], \n            [20, 21, 22, 23, 24]]\n\n[m1, m2, m3].each do |m|\n  puts \"determinant:\\t \n  puts \nend\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 424990, "name": "Determinant and permanent", "source": "Translate Ruby to Java: require 'matrix'\n\nclass Matrix\n  \n  def permanent\n    r = (0...row_count).to_a \n    r.permutation.inject(0) do |sum, sigma|\n       sum += sigma.zip(r).inject(1){|prod, (row, col)| prod *= self[row, col] }\n    end\n  end\nend\n\nm1 = Matrix[[1,2],[3,4]] \n\nm2 = Matrix[[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10], [10, 11, 12, 13]]\n\nm3 = Matrix[[0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9],\n            [10, 11, 12, 13, 14],\n            [15, 16, 17, 18, 19], \n            [20, 21, 22, 23, 24]]\n\n[m1, m2, m3].each do |m|\n  puts \"determinant:\\t \n  puts \nend\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 424991, "name": "Sattolo cycle", "source": "Translate Ruby to Java: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 424992, "name": "Sattolo cycle", "source": "Translate Ruby to Java: > class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> \n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 424993, "name": "Sorting algorithms_Cycle sort", "source": "Translate Ruby to Java: def cycleSort!(array)\n  writes = 0\n  \n  \n  for cycleStart in 0 .. array.size-2\n    item = array[cycleStart]\n    \n    \n    pos = cycleStart\n    for i in cycleStart+1 ... array.size\n      pos += 1  if array[i] < item\n    end\n    \n    \n    next  if pos == cycleStart\n    \n    \n    pos += 1  while item == array[pos]\n    array[pos], item = item, array[pos]\n    writes += 1\n    \n    \n    while pos != cycleStart\n      \n      \n      pos = cycleStart\n      for i in cycleStart+1 ... array.size\n        pos += 1  if array[i] < item\n      end\n      \n      \n      pos += 1  while item == array[pos]\n      array[pos], item = item, array[pos]\n      writes += 1\n    end\n  end\n  writes\nend \n\np a = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\nputs \"writes\u00a0: \np a\n", "target": "import java.util.Arrays;\n\npublic class CycleSort {\n\n    public static void main(String[] args) {\n        int[] arr = {5, 0, 1, 2, 2, 3, 5, 1, 1, 0, 5, 6, 9, 8, 0, 1};\n\n        System.out.println(Arrays.toString(arr));\n\n        int writes = cycleSort(arr);\n        System.out.println(Arrays.toString(arr));\n        System.out.println(\"writes: \" + writes);\n    }\n\n    static int cycleSort(int[] a) {\n        int writes = 0;\n\n        for (int cycleStart = 0; cycleStart < a.length - 1; cycleStart++) {\n            int val = a[cycleStart];\n\n            \n            \n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < a.length; i++)\n                if (a[i] < val)\n                    pos++;\n\n            \n            if (pos == cycleStart)\n                continue;\n\n            \n            while (val == a[pos])\n                pos++;\n\n            \n            int tmp = a[pos];\n            a[pos] = val;\n            val = tmp;\n            writes++;\n\n            \n            \n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < a.length; i++)\n                    if (a[i] < val)\n                        pos++;\n\n                while (val == a[pos])\n                    pos++;\n\n                tmp = a[pos];\n                a[pos] = val;\n                val = tmp;\n                writes++;\n            }\n        }\n        return writes;\n    }\n}\n"}
{"id": 424994, "name": "Sorting algorithms_Cycle sort", "source": "Translate Ruby to Java: def cycleSort!(array)\n  writes = 0\n  \n  \n  for cycleStart in 0 .. array.size-2\n    item = array[cycleStart]\n    \n    \n    pos = cycleStart\n    for i in cycleStart+1 ... array.size\n      pos += 1  if array[i] < item\n    end\n    \n    \n    next  if pos == cycleStart\n    \n    \n    pos += 1  while item == array[pos]\n    array[pos], item = item, array[pos]\n    writes += 1\n    \n    \n    while pos != cycleStart\n      \n      \n      pos = cycleStart\n      for i in cycleStart+1 ... array.size\n        pos += 1  if array[i] < item\n      end\n      \n      \n      pos += 1  while item == array[pos]\n      array[pos], item = item, array[pos]\n      writes += 1\n    end\n  end\n  writes\nend \n\np a = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\nputs \"writes\u00a0: \np a\n", "target": "import java.util.Arrays;\n\npublic class CycleSort {\n\n    public static void main(String[] args) {\n        int[] arr = {5, 0, 1, 2, 2, 3, 5, 1, 1, 0, 5, 6, 9, 8, 0, 1};\n\n        System.out.println(Arrays.toString(arr));\n\n        int writes = cycleSort(arr);\n        System.out.println(Arrays.toString(arr));\n        System.out.println(\"writes: \" + writes);\n    }\n\n    static int cycleSort(int[] a) {\n        int writes = 0;\n\n        for (int cycleStart = 0; cycleStart < a.length - 1; cycleStart++) {\n            int val = a[cycleStart];\n\n            \n            \n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < a.length; i++)\n                if (a[i] < val)\n                    pos++;\n\n            \n            if (pos == cycleStart)\n                continue;\n\n            \n            while (val == a[pos])\n                pos++;\n\n            \n            int tmp = a[pos];\n            a[pos] = val;\n            val = tmp;\n            writes++;\n\n            \n            \n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < a.length; i++)\n                    if (a[i] < val)\n                        pos++;\n\n                while (val == a[pos])\n                    pos++;\n\n                tmp = a[pos];\n                a[pos] = val;\n                val = tmp;\n                writes++;\n            }\n        }\n        return writes;\n    }\n}\n"}
{"id": 424995, "name": "Twin primes", "source": "Translate Ruby to Java: require 'prime'\n\n(1..8).each do |n|\n  count = Prime.each(10**n).each_cons(2).count{|p1, p2| p2-p1 == 2}\n  puts \"Twin primes below 10**\nend\n", "target": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class twinPrimes {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Search Size: \");\n        BigInteger max = input.nextBigInteger();\n        int counter = 0;\n        for(BigInteger x = new BigInteger(\"3\"); x.compareTo(max) <= 0; x = x.add(BigInteger.ONE)){\n            BigInteger sqrtNum = x.sqrt().add(BigInteger.ONE);\n            if(x.add(BigInteger.TWO).compareTo(max) <= 0) {\n                counter += findPrime(x.add(BigInteger.TWO), x.add(BigInteger.TWO).sqrt().add(BigInteger.ONE)) && findPrime(x, sqrtNum) ? 1 : 0;\n            }\n        }\n        System.out.println(counter + \" twin prime pairs.\");\n    }\n    public static boolean findPrime(BigInteger x, BigInteger sqrtNum){\n        for(BigInteger divisor = BigInteger.TWO; divisor.compareTo(sqrtNum) <= 0; divisor = divisor.add(BigInteger.ONE)){\n            if(x.remainder(divisor).compareTo(BigInteger.ZERO) == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 424996, "name": "Brazilian numbers", "source": "Translate Ruby to Java: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 424997, "name": "Brazilian numbers", "source": "Translate Ruby to Java: def sameDigits(n,b)\n    f = n % b\n    while (n /= b) > 0 do\n        if n % b != f then\n            return false\n        end\n    end\n    return true\nend\n\ndef isBrazilian(n)\n    if n < 7 then\n        return false\n    end\n    if n % 2 == 0 then\n        return true\n    end\n    for b in 2 .. n - 2 do\n        if sameDigits(n, b) then\n            return true\n        end\n    end\n    return false\nend\n\ndef isPrime(n)\n    if n < 2 then\n        return false\n    end\n    if n % 2 == 0 then\n        return n == 2\n    end\n    if n % 3 == 0 then\n        return n == 3\n    end\n    d = 5\n    while d * d <= n do\n        if n % d == 0 then\n            return false\n        end\n        d = d + 2\n\n        if n % d == 0 then\n            return false\n        end\n        d = d + 4\n    end\n    return true\nend\n\ndef main\n    for kind in [\"\", \"odd \", \"prime \"] do\n        quiet = false\n        bigLim = 99999\n        limit = 20\n        puts \"First %d %sBrazilian numbers:\" % [limit, kind]\n        c = 0\n        n = 7\n        while c < bigLim do\n            if isBrazilian(n) then\n                if not quiet then\n                    print \"%d \" % [n]\n                end\n                c = c + 1\n                if c == limit then\n                    puts\n                    puts\n                    quiet = true\n                end\n            end\n            if quiet and kind != \"\" then\n                next\n            end\n            if kind == \"\" then\n                n = n + 1\n            elsif kind == \"odd \" then\n                n = n + 2\n            elsif kind == \"prime \" then\n                loop do\n                    n = n + 2\n                    if isPrime(n) then\n                        break\n                    end\n                end\n            else\n                raise \"Unexpected\"\n            end\n        end\n        if kind == \"\" then\n            puts \"The %dth Brazillian number is: %d\" % [bigLim + 1, n]\n            puts\n        end\n    end\nend\n\nmain()\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 424998, "name": "Create a file on magnetic tape", "source": "Translate Ruby to Java: filename = {% if flag?(:win32) %}\n    \"TAPE.FILE\"\n  {% else\u00a0%}   \n    \"/dev/tape\"\n  {% end %}        \nFile.write filename, \"howdy, planet!\"\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\npublic class CreateFile {\n    public static void main(String[] args) throws IOException {\n        String os = System.getProperty(\"os.name\");\n        if (os.contains(\"Windows\")) {\n            Path path = Paths.get(\"tape.file\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        } else {\n            Path path = Paths.get(\"/dev/tape\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        }\n    }\n}\n"}
{"id": 424999, "name": "Recaman's sequence", "source": "Translate Ruby to Java: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 425000, "name": "Recaman's sequence", "source": "Translate Ruby to Java: require 'set'\n\na = [0]\nused = Set[0]\nused1000 = Set[0]\nfoundDup = false\nn = 1\nwhile n <= 15 or not foundDup or used1000.size < 1001\n    nxt = a[n - 1] - n\n    if nxt < 1 or used === nxt then\n        nxt = nxt + 2 * n\n    end\n    alreadyUsed = used === nxt\n    a << nxt\n    if not alreadyUsed then\n        used << nxt\n        if nxt >= 0 and nxt <= 1000 then\n            used1000 << nxt\n        end\n    end\n    if n == 14 then\n        print \"The first 15 terms of the Recaman's sequence are \", a, \"\\n\"\n    end\n    if not foundDup and alreadyUsed then\n        print \"The first duplicated term is a[\", n, \"] = \", nxt, \"\\n\"\n        foundDup = true\n    end\n    if used1000.size == 1001 then\n        print \"Terms up to a[\", n, \"] are needed to generate 0 to 1000\\n\"\n    end\n    n = n + 1\nend\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 425001, "name": "Y combinator", "source": "Translate Ruby to Java: y = lambda do |f|\n  lambda {|g| g[g]}[lambda do |g|\n      f[lambda {|*args| g[g][*args]}]\n    end]\nend\n\nfac = lambda{|f| lambda{|n| n < 2 ? 1 : n * f[n-1]}}\np Array.new(10) {|i| y[fac][i]}   \n\nfib = lambda{|f| lambda{|n| n < 2 ? n : f[n-1] + f[n-2]}}\np Array.new(10) {|i| y[fib][i]}   \n", "target": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n"}
{"id": 425002, "name": "Total circles area", "source": "Translate Ruby to Java: circles = [\n  [ 1.6417233788,  1.6121789534, 0.0848270516],\n  [-1.4944608174,  1.2077959613, 1.1039549836],\n  [ 0.6110294452, -0.6907087527, 0.9089162485],\n  [ 0.3844862411,  0.2923344616, 0.2375743054],\n  [-0.2495892950, -0.3832854473, 1.0845181219],\n  [ 1.7813504266,  1.6178237031, 0.8162655711],\n  [-0.1985249206, -0.8343333301, 0.0538864941],\n  [-1.7011985145, -0.1263820964, 0.4776976918],\n  [-0.4319462812,  1.4104420482, 0.7886291537],\n  [ 0.2178372997, -0.9499557344, 0.0357871187],\n  [-0.6294854565, -1.3078893852, 0.7653357688],\n  [ 1.7952608455,  0.6281269104, 0.2727652452],\n  [ 1.4168575317,  1.0683357171, 1.1016025378],\n  [ 1.4637371396,  0.9463877418, 1.1846214562],\n  [-0.5263668798,  1.7315156631, 1.4428514068],\n  [-1.2197352481,  0.9144146579, 1.0727263474],\n  [-0.1389358881,  0.1092805780, 0.7350208828],\n  [ 1.5293954595,  0.0030278255, 1.2472867347],\n  [-0.5258728625,  1.3782633069, 1.3495508831],\n  [-0.1403562064,  0.2437382535, 1.3804956588],\n  [ 0.8055826339, -0.0482092025, 0.3327165165],\n  [-0.6311979224,  0.7184578971, 0.2491045282],\n  [ 1.4685857879, -0.8347049536, 1.3670667538],\n  [-0.6855727502,  1.6465021616, 1.0593087096],\n  [ 0.0152957411,  0.0638919221, 0.9771215985],\n]\n\ndef minmax_circle(circles)\n  xmin = circles.map {|xc, yc, radius| xc - radius}.min\n  xmax = circles.map {|xc, yc, radius| xc + radius}.max\n  ymin = circles.map {|xc, yc, radius| yc - radius}.min\n  ymax = circles.map {|xc, yc, radius| yc + radius}.max\n  [xmin, xmax, ymin, ymax]\nend\n\n\ndef select_circle(circles)\n  circles = circles.sort_by{|cx,cy,r| -r}\n  size = circles.size\n  select = [*0...size]\n  for i in 0...size-1\n    xi,yi,ri = circles[i].to_a\n    for j in i+1...size\n      xj,yj,rj = circles[j].to_a\n      select -= [j]  if (xi-xj)**2 + (yi-yj)**2 <= (ri-rj)**2\n    end\n  end\n  circles.values_at(*select)\nend\ncircles = select_circle(circles)\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 425003, "name": "Total circles area", "source": "Translate Ruby to Java: circles = [\n  [ 1.6417233788,  1.6121789534, 0.0848270516],\n  [-1.4944608174,  1.2077959613, 1.1039549836],\n  [ 0.6110294452, -0.6907087527, 0.9089162485],\n  [ 0.3844862411,  0.2923344616, 0.2375743054],\n  [-0.2495892950, -0.3832854473, 1.0845181219],\n  [ 1.7813504266,  1.6178237031, 0.8162655711],\n  [-0.1985249206, -0.8343333301, 0.0538864941],\n  [-1.7011985145, -0.1263820964, 0.4776976918],\n  [-0.4319462812,  1.4104420482, 0.7886291537],\n  [ 0.2178372997, -0.9499557344, 0.0357871187],\n  [-0.6294854565, -1.3078893852, 0.7653357688],\n  [ 1.7952608455,  0.6281269104, 0.2727652452],\n  [ 1.4168575317,  1.0683357171, 1.1016025378],\n  [ 1.4637371396,  0.9463877418, 1.1846214562],\n  [-0.5263668798,  1.7315156631, 1.4428514068],\n  [-1.2197352481,  0.9144146579, 1.0727263474],\n  [-0.1389358881,  0.1092805780, 0.7350208828],\n  [ 1.5293954595,  0.0030278255, 1.2472867347],\n  [-0.5258728625,  1.3782633069, 1.3495508831],\n  [-0.1403562064,  0.2437382535, 1.3804956588],\n  [ 0.8055826339, -0.0482092025, 0.3327165165],\n  [-0.6311979224,  0.7184578971, 0.2491045282],\n  [ 1.4685857879, -0.8347049536, 1.3670667538],\n  [-0.6855727502,  1.6465021616, 1.0593087096],\n  [ 0.0152957411,  0.0638919221, 0.9771215985],\n]\n\ndef minmax_circle(circles)\n  xmin = circles.map {|xc, yc, radius| xc - radius}.min\n  xmax = circles.map {|xc, yc, radius| xc + radius}.max\n  ymin = circles.map {|xc, yc, radius| yc - radius}.min\n  ymax = circles.map {|xc, yc, radius| yc + radius}.max\n  [xmin, xmax, ymin, ymax]\nend\n\n\ndef select_circle(circles)\n  circles = circles.sort_by{|cx,cy,r| -r}\n  size = circles.size\n  select = [*0...size]\n  for i in 0...size-1\n    xi,yi,ri = circles[i].to_a\n    for j in i+1...size\n      xj,yj,rj = circles[j].to_a\n      select -= [j]  if (xi-xj)**2 + (yi-yj)**2 <= (ri-rj)**2\n    end\n  end\n  circles.values_at(*select)\nend\ncircles = select_circle(circles)\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 425004, "name": "Factorions", "source": "Translate Ruby to Java: def factorion?(n, base)\n  n.digits(base).sum{|digit| (1..digit).inject(1, :*)} == n \nend\n\n(9..12).each do |base|\n  puts \"Base \nend\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 425005, "name": "Factorions", "source": "Translate Ruby to Java: def factorion?(n, base)\n  n.digits(base).sum{|digit| (1..digit).inject(1, :*)} == n \nend\n\n(9..12).each do |base|\n  puts \"Base \nend\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 425006, "name": "Sum of divisors", "source": "Translate Ruby to Java: def divisor_sum(n)\n    total = 1\n    power = 2\n    \n    while (n & 1) == 0\n        total = total + power\n\n        power = power << 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n\n        sum = 1\n\n        power = p\n        while n % p == 0\n            sum = sum + power\n\n            power = power * p\n            n = (n / p).floor\n        end\n        total = total * sum\n\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * (n + 1)\n    end\n    return total\nend\n\nLIMIT = 100\nprint \"Sum of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%4d\" % [divisor_sum(n)]\n    if n % 10 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425007, "name": "Sum of divisors", "source": "Translate Ruby to Java: def divisor_sum(n)\n    total = 1\n    power = 2\n    \n    while (n & 1) == 0\n        total = total + power\n\n        power = power << 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n\n        sum = 1\n\n        power = p\n        while n % p == 0\n            sum = sum + power\n\n            power = power * p\n            n = (n / p).floor\n        end\n        total = total * sum\n\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * (n + 1)\n    end\n    return total\nend\n\nLIMIT = 100\nprint \"Sum of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%4d\" % [divisor_sum(n)]\n    if n % 10 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425008, "name": "Order by pair comparisons", "source": "Translate Ruby to Java: items = [\"violet\", \"red\", \"green\", \"indigo\", \"blue\", \"yellow\", \"orange\"]\ncount = 0\nsortedItems = []\nitems.each {|item|\n  puts \"Inserting '\n  spotToInsert = sortedItems.bsearch_index{|x|\n    count += 1\n    print \"(\n    gets.start_with?('y')\n  } || sortedItems.length \n  sortedItems.insert(spotToInsert, item)\n}\np sortedItems\n", "target": "import java.util.*;\n\npublic class SortComp1 {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"violet\", \"red\", \"green\", \"indigo\", \"blue\", \"yellow\", \"orange\");\n        List<String> sortedItems = new ArrayList<>();\n        Comparator<String> interactiveCompare = new Comparator<String>() {\n                int count = 0;\n                Scanner s = new Scanner(System.in);\n                public int compare(String s1, String s2) {\n                    System.out.printf(\"(%d) Is %s <, =, or > %s. Answer -1, 0, or 1: \", ++count, s1, s2);\n                    return s.nextInt();\n                }\n            };\n        for (String item : items) {\n            System.out.printf(\"Inserting '%s' into %s\\n\", item, sortedItems);\n            int spotToInsert = Collections.binarySearch(sortedItems, item, interactiveCompare);\n            \n            \n            if (spotToInsert < 0) spotToInsert = ~spotToInsert;\n            sortedItems.add(spotToInsert, item);\n        }\n        System.out.println(sortedItems);\n    }\n}\n"}
{"id": 425009, "name": "Fermat numbers", "source": "Translate Ruby to Java: require \"big\"\n\ndef factors(n)\n    factors = `factor \n    factors.group_by(&.itself).map { |prime, exp| [prime, exp.size] }\nend\n\ndef fermat(n); (1.to_big_i << (1 << n)) | 1 end\n\nputs \"Value for each Fermat Number F0 .. F9.\"\n(0..9).each { |n| puts \"F\nputs\nputs \"Factors for each Fermat Number F0 .. F8.\"\n(0..8).each { |n| puts \"F\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class FermatNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 Fermat numbers:\");\n        for ( int i = 0 ; i < 10 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, fermat(i));\n        }\n        System.out.printf(\"%nFirst 12 Fermat numbers factored:%n\");\n        for ( int i = 0 ; i < 13 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, getString(getFactors(i, fermat(i))));\n        }\n    }\n    \n    private static String getString(List<BigInteger> factors) {\n        if ( factors.size() == 1 ) {\n            return factors.get(0) + \" (PRIME)\";\n        }\n        return factors.stream().map(v -> v.toString()).map(v -> v.startsWith(\"-\") ? \"(C\" + v.replace(\"-\", \"\") + \")\" : v).collect(Collectors.joining(\" * \"));\n    }\n\n    private static Map<Integer, String> COMPOSITE = new HashMap<>();\n    static {\n        COMPOSITE.put(9, \"5529\");\n        COMPOSITE.put(10, \"6078\");\n        COMPOSITE.put(11, \"1037\");\n        COMPOSITE.put(12, \"5488\");\n        COMPOSITE.put(13, \"2884\");\n    }\n\n    private static List<BigInteger> getFactors(int fermatIndex, BigInteger n) {\n        List<BigInteger> factors = new ArrayList<>();\n        BigInteger factor = BigInteger.ONE;\n        while ( true ) {\n            if ( n.isProbablePrime(100) ) {\n                factors.add(n);\n                break;\n            }\n            else {\n                if ( COMPOSITE.containsKey(fermatIndex) ) {\n                    String stop = COMPOSITE.get(fermatIndex);\n                    if ( n.toString().startsWith(stop) ) {\n                        factors.add(new BigInteger(\"-\" + n.toString().length()));\n                        break;\n                    }\n                }\n                factor = pollardRhoFast(n);\n                if ( factor.compareTo(BigInteger.ZERO) == 0 ) {\n                    factors.add(n);\n                    break;\n                }\n                else {\n                    factors.add(factor);\n                    n = n.divide(factor);\n                }\n            }\n        }\n        return factors;\n    }\n    \n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    \n    private static BigInteger fermat(int n) {\n        return TWO.pow((int)Math.pow(2, n)).add(BigInteger.ONE);\n    }\n        \n    \n    @SuppressWarnings(\"unused\")\n    private static BigInteger pollardRho(BigInteger n) {\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        while ( d.compareTo(BigInteger.ONE) == 0 ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs().gcd(n);\n        }\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n    \n    \n    \n    \n    \n    \n    private static BigInteger pollardRhoFast(BigInteger n) {\n        long start = System.currentTimeMillis();\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        int count = 0;\n        BigInteger z = BigInteger.ONE;\n        while ( true ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs();\n            z = z.multiply(d).mod(n);\n            count++;\n            if ( count == 100 ) {\n                d = z.gcd(n);\n                if ( d.compareTo(BigInteger.ONE) != 0 ) {\n                    break;\n                }\n                z = BigInteger.ONE;\n                count = 0;\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"    Pollard rho try factor %s elapsed time = %d ms (factor = %s).%n\", n, (end-start), d);\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n\n    private static BigInteger pollardRhoG(BigInteger x, BigInteger n) {\n        return x.multiply(x).add(BigInteger.ONE).mod(n);\n    }\n\n}\n"}
{"id": 425010, "name": "Sorting algorithms_Bead sort", "source": "Translate Ruby to Java: class Array\n  def beadsort\n    map {|e| [1] * e}.columns.columns.map(&:length)\n  end\n  \n  def columns\n    y = length\n    x = map(&:length).max\n    Array.new(x) do |row|\n      Array.new(y) { |column| self[column][row] }.compact \n    end\n  end\nend\n\n\np [5,3,1,7,4,1,1].beadsort\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 425011, "name": "Casting out nines", "source": "Translate Ruby to Java: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 425012, "name": "Casting out nines", "source": "Translate Ruby to Java: N = 2\nbase = 10\nc1 = 0\nc2 = 0\n\nfor k in 1 .. (base ** N) - 1\n    c1 = c1 + 1\n    if k % (base - 1) == (k * k) % (base - 1) then\n        c2 = c2 + 1\n        print \"%d \" % [k]\n    end\nend\n\nputs\nprint \"Trying %d numbers instead of %d numbers saves %f%%\" % [c2, c1, 100.0 - 100.0 * c2 / c1]\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 425013, "name": "Simple database", "source": "Translate Ruby to Java: require 'date'\nrequire 'json'\nrequire 'securerandom'\n\nclass SimpleDatabase\n  def initialize(dbname, *fields)\n    @dbname = dbname\n    @filename = @dbname + \".dat\"\n    @fields = fields\n    @maxl = @fields.collect {|f| f.length}.max\n    @data = {\n      'fields' => fields,\n      'items' => {},\n      'history' => [],\n      'tags' => {},\n    }\n  end\n  attr_reader :dbname, :fields\n\n  def self.open(dbname)\n    db = new(dbname)\n    db.read\n    db\n  end\n\n  def read()\n    if not File.exists?(@filename)\n      raise ArgumentError, \"Database \n    end\n    @data = JSON.parse(File.read(@filename))\n    @fields = @data['fields']\n    @maxl = @fields.collect {|f| f.length}.max\n  end\n\n  def write()\n    File.open(@filename, 'w') {|f| f.write(JSON.generate(@data))}\n  end\n\n  def add(*values)\n    id = SecureRandom.uuid\n    @data['items'][id] = Hash[ @fields.zip(values) ]\n    @data['history'] << [Time.now.to_f, id]\n    id\n  end\n\n  def tag(id, *tags)\n    tags.each do |tag|\n      if @data['tags'][tag].nil?\n        @data['tags'][tag] = [id]\n      else\n        @data['tags'][tag] << id\n      end\n    end\n    id\n  end\n\n  def latest\n    @data['history'].sort_by {|val| val[0]}.last.last\n  end\n\n  def get_item(id)\n    @data['items'][id]\n  end\n\n  def tags()\n    @data['tags'].keys.sort\n  end\n\n  def ids_for_tag(tag)\n    @data['tags'][tag]\n  end\n\n  def tags_for_id(id)\n    @data['tags'].keys.inject([]) do |tags, tag| \n      tags << tag if @data['tags'][tag].include?(id)\n      tags\n    end\n  end\n\n  def display(id)\n    item = get_item(id)\n    fmt = \"%\n    puts fmt % ['id', id]\n    @fields.each {|f| print fmt % [f, item[f]]}\n    puts fmt % ['tags', tags_for_id(id).join(',')]\n    added = @data['history'].find {|x| x[1] == id}.first\n    puts fmt % ['date added', Time.at(added).ctime]\n    puts \"\"\n  end\n\n  def each()\n    @data['history'].each {|time, id| yield id}\n  end\n\n  def each_item_with_tag(tag)\n    @data['tags'][tag].each {|id| yield id}\n  end\nend\ndef usage()\n  puts <<END\nusage: \n\ncommands:\n  help \n  create dbname field ...\n  fields dbname\n  add dbname value ...\n  tag dbname id tag ...\n  tags dbname\n  list dbname [tag ...]\n  latest dbname\n  latest_by_tag dbname\nEND\nend\n\ndef open_database(args)\n  dbname = args.shift\n  begin\n    SimpleDatabase.open(dbname)\n  rescue ArgumentError => e\n    STDERR.puts e.message\n    exit 1\n  end\nend\n\ndef process_command_line(command, *args)\n  case command\n  when 'help'\n    usage\n\n  when 'create'\n    db = SimpleDatabase.new(*args)\n    db.write\n    puts \"Database \n\n  when 'fields'\n    db = open_database(args)\n    puts \"Database \n    puts db.fields.join(',')\n\n  when 'add'\n    db = open_database(args)\n    id = db.add(*args)\n    db.write\n    puts \"Database \n\n  when 'tag'\n    db = open_database(args)\n    id = args.shift\n    db.tag(id, *args)\n    db.write\n    db.display(id)\n    \n  when 'tags'\n    db = open_database(args)\n    puts \"Database \n    puts db.tags.join(',')\n\n  when 'list'\n    db = open_database(args)\n    if args.empty?\n      db.each {|id| db.display(id)}\n    else\n      args.each do |tag| \n        puts \"Items tagged \n        db.each_item_with_tag(tag) {|id| db.display(id)}\n      end\n    end\n\n  when 'latest'\n    db = open_database(args)\n    db.display(db.latest)\n\n  when 'latest_by_tag'\n    db = open_database(args)\n    db.tags.each do |tag|\n      puts tag\n      db.display(db.ids_for_tag(tag).last)\n    end\n\n  else\n    puts \"Error: unknown command '\n    usage\n  end\nend\n\nprocess_command_line *ARGV\n", "target": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class SimpleDatabase {\n\n    final static String filename = \"simdb.csv\";\n\n    public static void main(String[] args) {\n        if (args.length < 1 || args.length > 3) {\n            printUsage();\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"add\":\n                addItem(args);\n                break;\n            case \"latest\":\n                printLatest(args);\n                break;\n            case \"all\":\n                printAll();\n                break;\n            default:\n                printUsage();\n                break;\n        }\n    }\n\n    private static class Item implements Comparable<Item>{\n        final String name;\n        final String date;\n        final String category;\n\n        Item(String n, String d, String c) {\n            name = n;\n            date = d;\n            category = c;\n        }\n\n        @Override\n        public int compareTo(Item item){\n            return date.compareTo(item.date);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s,%s,%s%n\", name, date, category);\n        }\n    }\n\n    private static void addItem(String[] input) {\n        if (input.length < 2) {\n            printUsage();\n            return;\n        }\n        List<Item> db = load();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String date = sdf.format(new Date());\n        String cat = (input.length == 3) ? input[2] : \"none\";\n        db.add(new Item(input[1], date, cat));\n        store(db);\n    }\n\n    private static void printLatest(String[] a) {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        if (a.length == 2) {\n            for (Item item : db)\n                if (item.category.equals(a[1]))\n                    System.out.println(item);\n        } else {\n            System.out.println(db.get(0));\n        }\n    }\n\n    private static void printAll() {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        for (Item item : db)\n            System.out.println(item);\n    }\n\n    private static List<Item> load() {\n        List<Item> db = new ArrayList<>();\n        try (Scanner sc = new Scanner(new File(filename))) {\n            while (sc.hasNext()) {\n                String[] item = sc.nextLine().split(\",\");\n                db.add(new Item(item[0], item[1], item[2]));\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return db;\n    }\n\n    private static void store(List<Item> db) {\n        try (FileWriter fw = new FileWriter(filename)) {\n            for (Item item : db)\n                fw.write(item.toString());\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    private static void printUsage() {\n         System.out.println(\"Usage:\");\n         System.out.println(\"  simdb cmd [categoryName]\");\n         System.out.println(\"  add     add item, followed by optional category\");\n         System.out.println(\"  latest  print last added item(s), followed by \"\n                 + \"optional category\");\n         System.out.println(\"  all     print all\");\n         System.out.println(\"  For instance: add \\\"some item name\\\" \"\n                 + \"\\\"some category name\\\"\");\n    }\n}\n"}
{"id": 425014, "name": "Keyboard macros", "source": "Translate Ruby to Java: Shoes.app do\n  @info = para \"NO KEY is PRESSED.\"\n  keypress do |k|\n    @info.replace \"\n  end\nend\n", "target": "package keybord.macro.demo;\n\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\nclass KeyboardMacroDemo {\n    public static void main( String [] args ) {\n        final JFrame frame = new JFrame();\n        \n        String directions = \"<html><b>Ctrl-S</b> to show frame title<br>\"\n                                 +\"<b>Ctrl-H</b> to hide it</html>\";\n                                 \n        frame.add( new JLabel(directions));\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        \n        frame.addKeyListener( new KeyAdapter(){\n            public void keyReleased( KeyEvent e ) {\n                if( e.isControlDown() && e.getKeyCode() == KeyEvent.VK_S){\n                    frame.setTitle(\"Hello there\");\n                }else if( e.isControlDown() && e.getKeyCode() == KeyEvent.VK_H){\n                    frame.setTitle(\"\");\n                }\n            }\n        });\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n"}
{"id": 425015, "name": "Tau function", "source": "Translate Ruby to Java: require 'prime'\n\ndef tau(n) = n.prime_division.inject(1){|res, (d, exp)| res *= exp + 1}\n\n(1..100).map{|n| tau(n).to_s.rjust(3) }.each_slice(20){|ar| puts ar.join}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425016, "name": "Tau function", "source": "Translate Ruby to Java: require 'prime'\n\ndef tau(n) = n.prime_division.inject(1){|res, (d, exp)| res *= exp + 1}\n\n(1..100).map{|n| tau(n).to_s.rjust(3) }.each_slice(20){|ar| puts ar.join}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425017, "name": "M\u00f6bius function", "source": "Translate Ruby to Java: require 'prime'\n\ndef \u03bc(n)\n  pd = n.prime_division\n  return 0 unless pd.map(&:last).all?(1)\n  pd.size.even? ? 1 : -1\nend\n\n([\"  \"] + (1..199).map{|n|\"%2s\" % \u03bc(n)}).each_slice(20){|line| puts line.join(\" \") }\n", "target": "public class M\u00f6biusFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the m\u00f6bius function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", m\u00f6biusFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n    }\n    \n    private static int MU_MAX = 1_000_000;\n    private static int[] MU = null;\n    \n    \n    private static int m\u00f6biusFunction(int n) {\n        if ( MU != null ) {\n            return MU[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n        }\n        return MU[n];\n    }\n\n}\n"}
{"id": 425018, "name": "Execute Brain____", "source": "Translate Ruby to Java: define tape_length = 50_000;\ndefine eof_val = -1;\ndefine unbalanced_exit_code = 1;\n\nvar cmd = 0;\nvar cell = 0;\nvar code = [];\nvar loops = [];\nvar tape = tape_length.of(0);\n\nfunc get_input {\n    static input_buffer = [];\n    input_buffer.len || (input_buffer = ((STDIN.readline \\\\ return eof_val).chomp.chars.map{.ord}));\n    input_buffer.shift \\\\ eof_val;\n}\n\nfunc jump {\n    var depth = 0;\n    while (depth >= 0) {\n        ++cmd < code.len || Sys.exit(unbalanced_exit_code);\n        if (code[cmd] == '[') {\n            ++depth;\n        }\n        elsif (code[cmd] == ']') {\n            --depth;\n        }\n    }\n}\n\nvar commands = Hash.new(\n    '>' => { ++cell },\n    '<' => { --cell },\n    '+' => { ++tape[cell] },\n    '-' => { --tape[cell] },\n    '.' => { tape[cell].chr.print },\n    ',' => { tape[cell] = get_input() },\n    '[' => { tape[cell] ? loops.append(cmd) : jump() },\n    ']' => { cmd = (loops.pop - 1) },\n);\n\nSTDOUT.autoflush(1);\ncode = ARGF.slurp.chars.grep {|c| commands.exists(c)};\nvar code_len = code.len;\n\nwhile (cmd < code_len) {\n    commands{code[cmd]}.run;\n    cmd++;\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 425019, "name": "Execute Brain____", "source": "Translate Ruby to Java: define tape_length = 50_000;\ndefine eof_val = -1;\ndefine unbalanced_exit_code = 1;\n\nvar cmd = 0;\nvar cell = 0;\nvar code = [];\nvar loops = [];\nvar tape = tape_length.of(0);\n\nfunc get_input {\n    static input_buffer = [];\n    input_buffer.len || (input_buffer = ((STDIN.readline \\\\ return eof_val).chomp.chars.map{.ord}));\n    input_buffer.shift \\\\ eof_val;\n}\n\nfunc jump {\n    var depth = 0;\n    while (depth >= 0) {\n        ++cmd < code.len || Sys.exit(unbalanced_exit_code);\n        if (code[cmd] == '[') {\n            ++depth;\n        }\n        elsif (code[cmd] == ']') {\n            --depth;\n        }\n    }\n}\n\nvar commands = Hash.new(\n    '>' => { ++cell },\n    '<' => { --cell },\n    '+' => { ++tape[cell] },\n    '-' => { --tape[cell] },\n    '.' => { tape[cell].chr.print },\n    ',' => { tape[cell] = get_input() },\n    '[' => { tape[cell] ? loops.append(cmd) : jump() },\n    ']' => { cmd = (loops.pop - 1) },\n);\n\nSTDOUT.autoflush(1);\ncode = ARGF.slurp.chars.grep {|c| commands.exists(c)};\nvar code_len = code.len;\n\nwhile (cmd < code_len) {\n    commands{code[cmd]}.run;\n    cmd++;\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 425020, "name": "Mertens function", "source": "Translate Ruby to Java: require 'prime'\n\ndef \u03bc(n)\n  return 1 if self == 1\n  pd = n.prime_division\n  return 0 unless pd.map(&:last).all?(1)\n  pd.size.even? ? 1 : -1\nend\n\ndef M(n)\n  (1..n).sum{|n| \u03bc(n)}\nend\n\n([\"  \"] + (1..199).map{|n|\"%2s\" % M(n)}).each_slice(20){|line| puts line.join(\" \") }\n\nar = (1..1000).map{|n| M(n)}\nputs \"\\nThe Mertens function is zero \nputs \"it crosses zero \n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 425021, "name": "Product of divisors", "source": "Translate Ruby to Java: def divisor_count(n)\n    total = 1\n    \n    while n % 2 == 0 do\n        total = total + 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n do\n        count = 1\n        while n % p == 0 do\n            count = count + 1\n            n = n / p\n        end\n        total = total * count\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * 2\n    end\n    return total\nend\n\ndef divisor_product(n)\n    return (n ** (divisor_count(n) / 2.0)).floor\nend\n\nLIMIT = 50\nprint \"Product of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%11d\" % [divisor_product(n)]\n    if n % 5 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425022, "name": "Product of divisors", "source": "Translate Ruby to Java: def divisor_count(n)\n    total = 1\n    \n    while n % 2 == 0 do\n        total = total + 1\n        n = n >> 1\n    end\n    \n    p = 3\n    while p * p <= n do\n        count = 1\n        while n % p == 0 do\n            count = count + 1\n            n = n / p\n        end\n        total = total * count\n        p = p + 2\n    end\n    \n    if n > 1 then\n        total = total * 2\n    end\n    return total\nend\n\ndef divisor_product(n)\n    return (n ** (divisor_count(n) / 2.0)).floor\nend\n\nLIMIT = 50\nprint \"Product of divisors for the first \", LIMIT, \" positive integers:\\n\"\nfor n in 1 .. LIMIT\n    print \"%11d\" % [divisor_product(n)]\n    if n % 5 == 0 then\n        print \"\\n\"\n    end\nend\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425023, "name": "Erd\u0151s-primes", "source": "Translate Ruby to Java: func is_erdos_prime(p) {\n\n    return true  if p==2\n    return false if !p.is_prime\n\n    var f = 1\n\n    for (var k = 2; f < p; k++) {\n        p - f -> is_composite || return false\n        f *= k\n    }\n\n    return true\n}\n\nsay (\"Erd\u0151s primes <= 2500: \", 1..2500 -> grep(is_erdos_prime))\nsay (\"The 7875th Erd\u0151s prime is: \", is_erdos_prime.nth(7875))\n", "target": "import java.util.*;\n\npublic class ErdosPrimes {\n    public static void main(String[] args) {\n        boolean[] sieve = primeSieve(1000000);\n        int maxPrint = 2500;\n        int maxCount = 7875;\n        System.out.printf(\"Erd\\u0151s primes less than %d:\\n\", maxPrint);\n        for (int count = 0, prime = 1; count < maxCount; ++prime) {\n            if (erdos(sieve, prime)) {\n                ++count;\n                if (prime < maxPrint) {\n                    System.out.printf(\"%6d\", prime);\n                    if (count % 10 == 0)\n                        System.out.println();\n                }\n                if (count == maxCount)\n                    System.out.printf(\"\\n\\nThe %dth Erd\\u0151s prime is %d.\\n\", maxCount, prime);\n            }\n        }\n    }\n\n    private static boolean erdos(boolean[] sieve, int p) {\n        if (!sieve[p])\n            return false;\n        for (int k = 1, f = 1; f < p; ++k, f *= k) {\n            if (sieve[p - f])\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 425024, "name": "Erd\u0151s-primes", "source": "Translate Ruby to Java: func is_erdos_prime(p) {\n\n    return true  if p==2\n    return false if !p.is_prime\n\n    var f = 1\n\n    for (var k = 2; f < p; k++) {\n        p - f -> is_composite || return false\n        f *= k\n    }\n\n    return true\n}\n\nsay (\"Erd\u0151s primes <= 2500: \", 1..2500 -> grep(is_erdos_prime))\nsay (\"The 7875th Erd\u0151s prime is: \", is_erdos_prime.nth(7875))\n", "target": "import java.util.*;\n\npublic class ErdosPrimes {\n    public static void main(String[] args) {\n        boolean[] sieve = primeSieve(1000000);\n        int maxPrint = 2500;\n        int maxCount = 7875;\n        System.out.printf(\"Erd\\u0151s primes less than %d:\\n\", maxPrint);\n        for (int count = 0, prime = 1; count < maxCount; ++prime) {\n            if (erdos(sieve, prime)) {\n                ++count;\n                if (prime < maxPrint) {\n                    System.out.printf(\"%6d\", prime);\n                    if (count % 10 == 0)\n                        System.out.println();\n                }\n                if (count == maxCount)\n                    System.out.printf(\"\\n\\nThe %dth Erd\\u0151s prime is %d.\\n\", maxCount, prime);\n            }\n        }\n    }\n\n    private static boolean erdos(boolean[] sieve, int p) {\n        if (!sieve[p])\n            return false;\n        for (int k = 1, f = 1; f < p; ++k, f *= k) {\n            if (sieve[p - f])\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 425025, "name": "Playing cards", "source": "Translate Ruby to Java: class Card\n  \n  SUITS = %i[ Clubs Hearts Spades Diamonds ]\n  PIPS  = %i[ 2 3 4 5 6 7 8 9 10 Jack Queen King Ace ]\n  \n  \n  @@suit_value = Hash[ SUITS.each_with_index.to_a ]\n  @@pip_value  = Hash[ PIPS.each_with_index.to_a ]\n  \n  attr_reader :pip, :suit\n  \n  def initialize(pip,suit)\n    @pip = pip\n    @suit = suit\n  end\n  \n  def to_s\n    \"\n  end\n  \n  \n  def <=>(other)\n    (@@suit_value[@suit] <=> @@suit_value[other.suit]).nonzero? or\n    @@pip_value[@pip] <=> @@pip_value[other.pip]\n  end\nend\n\nclass Deck\n  def initialize\n    @deck = Card::SUITS.product(Card::PIPS).map{|suit,pip| Card.new(pip,suit)}\n  end\n  \n  def to_s\n    @deck.inspect\n  end\n  \n  def shuffle!\n    @deck.shuffle!\n    self\n  end\n  \n  def deal(*args)\n    @deck.shift(*args)\n  end\nend\n\ndeck = Deck.new.shuffle!\nputs card = deck.deal\nhand = deck.deal(5)\nputs hand.join(\", \")\nputs hand.sort.join(\", \")\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 425026, "name": "Perfect totient numbers", "source": "Translate Ruby to Java: require \"prime\"\n\nclass Integer \n\n  def \u03c6\n    prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \n  end\n\n  def perfect_totient?\n    f, sum = self, 0\n    until f == 1 do\n      f = f.\u03c6\n      sum += f\n    end\n    self == sum\n  end\n\nend\n\nputs (1..).lazy.select(&:perfect_totient?).first(20).join(\", \")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 425027, "name": "Perfect totient numbers", "source": "Translate Ruby to Java: require \"prime\"\n\nclass Integer \n\n  def \u03c6\n    prime_division.inject(1) {|res, (pr, exp)| res *= (pr-1) * pr**(exp-1) } \n  end\n\n  def perfect_totient?\n    f, sum = self, 0\n    until f == 1 do\n      f = f.\u03c6\n      sum += f\n    end\n    self == sum\n  end\n\nend\n\nputs (1..).lazy.select(&:perfect_totient?).first(20).join(\", \")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 425028, "name": "Lah numbers", "source": "Translate Ruby to Java: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 425029, "name": "Lah numbers", "source": "Translate Ruby to Java: def fact(n) = n.zero? ? 1 :  1.upto(n).inject(&:*)\n\ndef lah(n, k)\n  case k\n    when 1 then fact(n)\n    when n then 1\n    when (..1),(n..) then 0\n    else n<1 ? 0 : (fact(n)*fact(n-1)) / (fact(k)*fact(k-1)) / fact(n-k)\n  end\nend\n      \nr = (0..12)\nputs \"Unsigned Lah numbers: L(n, k):\"\nputs \"n/k \n\nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n\nputs \"\\nMaximum value from the L(100, *) row:\";\nputs (1..100).map{|a| lah(100,a)}.max\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 425030, "name": "Two sum", "source": "Translate Ruby to Java: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 425031, "name": "Two sum", "source": "Translate Ruby to Java: def two_sum(numbers, sum)\n  numbers.each_with_index do |x,i|\n    if j = numbers.index(sum - x) then return [i,j] end\n  end\n  []\nend\n\nnumbers = [0, 2, 11, 19, 90]\np two_sum(numbers, 21)\np two_sum(numbers, 25)\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 425032, "name": "Unprimeable numbers", "source": "Translate Ruby to Java: require 'prime'\n\ndef unprimable?(n)\n  digits = %w(0 1 2 3 4 5 6 7 8 9)\n  s = n.to_s\n  size = s.size\n  (size-1).downto(0) do |i|\n    digits.each do |d|\n      cand = s.dup\n      cand[i]=d\n      return false if cand.to_i.prime?\n    end\n  end\n  true\nend\nups = Enumerator.new {|y| (1..).each{|n| y << n if unprimable?(n)} }\n\nar = ups.first(600)\nputs \"First 35 unprimables:\", ar[0,35].join(\" \")\nputs \"\\n600th unprimable:\", ar.last, \"\"\n(0..9).each do |d|\n  print \"First unprimeable with last digit \n  puts (1..).detect{|k| unprimable?(k*10+d)}*10 + d\nend\n", "target": "public class UnprimeableNumbers {\n\n    private static int MAX = 10_000_000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 35 unprimeable numbers:\");\n        displayUnprimeableNumbers(35);\n        int n = 600;\n        System.out.printf(\"%nThe %dth unprimeable number =\u00a0%,d%n%n\", n, nthUnprimeableNumber(n));\n        int[] lowest = genLowest();\n        System.out.println(\"Least unprimeable number that ends in:\");\n        for ( int i = 0 ; i <= 9 ; i++ ) {\n            System.out.printf(\" %d is\u00a0%,d%n\", i, lowest[i]);\n        }\n    }\n    \n    private static int[] genLowest() {\n        int[] lowest = new int[10];\n        int count = 0;\n        int test = 1;\n        while ( count < 10 ) {\n            test++;\n            if ( unPrimable(test) && lowest[test % 10] == 0 ) {\n                lowest[test % 10] = test;\n                count++;\n            }\n        }\n        return lowest;\n    }\n\n    private static int nthUnprimeableNumber(int maxCount) {\n        int test = 1;\n        int count = 0;\n        int result = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                result = test;\n            }\n        }\n        return result;\n    }\n\n    private static void displayUnprimeableNumbers(int maxCount) {\n        int test = 1;\n        int count = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                System.out.printf(\"%d \", test);\n            }\n        }\n        System.out.println();\n    }\n    \n    private static boolean unPrimable(int test) {\n        if ( primes[test] ) {\n            return false;\n        }\n        String s = test + \"\";\n        for ( int i = 0 ; i < s.length() ; i++ ) {\n            for ( int j = 0 ; j <= 9 ; j++ ) {\n                if ( primes[Integer.parseInt(replace(s, i, j))] ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static String replace(String str, int position, int value) {\n        char[] sChar = str.toCharArray();\n        sChar[position] = (char) value;\n        return str.substring(0, position) + value + str.substring(position + 1);\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 425033, "name": "Tau number", "source": "Translate Ruby to Java: require 'prime'\n\ntaus = Enumerator.new do |y|\n  (1..).each do |n|\n    num_divisors = n.prime_division.inject(1){|prod, n| prod *= n[1] + 1 }\n    y << n if n % num_divisors == 0\n  end\nend\n\np taus.take(100)\n", "target": "public class Tau {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"The first %d tau numbers are:%n\", limit);\n        long count = 0;\n        for (long n = 1; count < limit; ++n) {\n            if (n % divisorCount(n) == 0) {\n                System.out.printf(\"%6d\", n);\n                ++count;\n                if (count % 10 == 0) {\n                    System.out.println();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425034, "name": "Primes whose sum of digits is 25", "source": "Translate Ruby to Java: require 'prime'\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum += n % 10\n        n /= 10\n    end\n    return sum\nend\n\nfor p in Prime.take_while { |p| p < 5000 }\n    if digitSum(p) == 25 then\n        print p, \"  \"\n    end\nend\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 425035, "name": "Primes whose sum of digits is 25", "source": "Translate Ruby to Java: require 'prime'\n\ndef digitSum(n)\n    sum = 0\n    while n > 0\n        sum += n % 10\n        n /= 10\n    end\n    return sum\nend\n\nfor p in Prime.take_while { |p| p < 5000 }\n    if digitSum(p) == 25 then\n        print p, \"  \"\n    end\nend\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 425036, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to Java: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "public class PrimeDigits {\n    private static boolean primeDigitsSum13(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int r = n % 10;\n            if (r != 2 && r != 3 && r != 5 && r != 7) {\n                return false;\n            }\n            n /= 10;\n            sum += r;\n        }\n        return sum == 13;\n    }\n\n    public static void main(String[] args) {\n        \n        int c = 0;\n        for (int i = 1; i < 1_000_000; i++) {\n            if (primeDigitsSum13(i)) {\n                System.out.printf(\"%6d \", i);\n                if (c++ == 10) {\n                    c = 0;\n                    System.out.println();\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 425037, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Ruby to Java: def primeDigitsSum13(n)\n    sum = 0\n    while n > 0\n        r = n % 10\n        if r != 2 and r != 3 and r != 5 and r != 7 then\n            return false\n        end\n        n = (n / 10).floor\n        sum = sum + r\n    end\n    return sum == 13\nend\n\nc = 0\nfor i in 1 .. 1000000\n    if primeDigitsSum13(i) then\n        print \"%6d \" % [i]\n        if c == 10 then\n            c = 0\n            print \"\\n\"\n        else\n            c = c + 1\n        end\n    end\nend\nprint \"\\n\"\n", "target": "public class PrimeDigits {\n    private static boolean primeDigitsSum13(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int r = n % 10;\n            if (r != 2 && r != 3 && r != 5 && r != 7) {\n                return false;\n            }\n            n /= 10;\n            sum += r;\n        }\n        return sum == 13;\n    }\n\n    public static void main(String[] args) {\n        \n        int c = 0;\n        for (int i = 1; i < 1_000_000; i++) {\n            if (primeDigitsSum13(i)) {\n                System.out.printf(\"%6d \", i);\n                if (c++ == 10) {\n                    c = 0;\n                    System.out.println();\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 425038, "name": "Deepcopy", "source": "Translate Ruby to Java: \norig = { :num => 1, :ary => [2, 3] }\norig[:cycle] = orig\t\n\n\ncopy = Marshal.load(Marshal.dump orig)\n\n\n\norig[:ary] << 4\norig[:rng] = (5..6)\n\n\n\np orig\t\np copy\t\n\n\n\np [(orig.equal? orig[:cycle]),\n   (copy.equal? copy[:cycle]),\n   (not orig.equal? copy)]\t\n", "target": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class DeepCopy {\n\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        Person p2 = p1;\n        \n        System.out.printf(\"Demonstrate shallow copy.  Both are the same object.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on both objects is changed.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        p2 = new Person(p1);\n        System.out.printf(\"%nDemonstrate copy constructor.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n\n        p2 = (Person) deepCopy(p1);\n        System.out.printf(\"%nDemonstrate serialization.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p2 = (Person) p1.clone();\n        System.out.printf(\"%nDemonstrate cloning.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n    }\n\n    \n    private static Object deepCopy(Object object) {\n        try {\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            ObjectOutputStream outputStrm = new ObjectOutputStream(outputStream);\n            outputStrm.writeObject(object);\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());\n            ObjectInputStream objInputStream = new ObjectInputStream(inputStream);\n            return objInputStream.readObject();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    public static class Address implements Serializable, Cloneable {\n\n        private static final long serialVersionUID = -7073778041809445593L;\n\n        private String street;\n        private String city;\n        private String state;\n        private String postalCode;\n        public String getStreet() {\n            return street;\n        }\n        public String getCity() {\n            return city;\n        }\n        public void setCity(String city) {\n            this.city = city;\n        }\n        public String getState() {\n            return state;\n        }\n        public String getPostalCode() {\n            return postalCode;\n        }\n        \n        @Override\n        public String toString() {\n            return \"[street=\" + street + \", city=\" + city + \", state=\" + state + \", code=\" + postalCode + \"]\";\n        }\n        \n        public Address(String s, String c, String st, String p) {\n            street = s;\n            city = c;\n            state = st;\n            postalCode = p;\n        }\n        \n        \n        public Address(Address add) {\n            street    = add.street;\n            city       = add.city;\n            state      = add.state;\n            postalCode = add.postalCode;\n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Address(this);\n        }\n        \n    }\n    \n    public static class Person implements Serializable, Cloneable {\n        private static final long serialVersionUID = -521810583786595050L;\n        private String firstName;\n        private String lastName;\n        private Address address;\n        public String getFirstName() {\n            return firstName;\n        }\n        public String getLastName() {\n            return lastName;\n        }\n        public Address getAddress() {\n            return address;\n        }\n\n        @Override\n        public String toString() {\n            return \"[first name=\" + firstName + \", last name=\" + lastName + \", address=\" + address + \"]\";\n        }\n\n        public Person(String fn, String ln, Address add) {\n            firstName = fn;\n            lastName = ln;\n            address = add;\n        }\n        \n        \n        public Person(Person person) {\n            firstName = person.firstName;\n            lastName = person.lastName;\n            address = new Address(person.address);  \n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Person(this);\n        }\n    }\n}\n"}
{"id": 425039, "name": "Circular primes", "source": "Translate Ruby to Java: require 'gmp'\nrequire 'prime'\ncandidate_primes = Enumerator.new do |y|\n  DIGS = [1,3,7,9]\n  [2,3,5,7].each{|n| y << n.to_s}\n  (2..).each do |size|\n    DIGS.repeated_permutation(size) do |perm|\n      y << perm.join if (perm == min_rotation(perm)) && GMP::Z(perm.join).probab_prime? > 0\n    end\n  end\nend\n\ndef min_rotation(ar) = Array.new(ar.size){|n| ar.rotate(n)}.min\n\ndef circular?(num_str)\n  chars = num_str.chars\n  return GMP::Z(num_str).probab_prime? > 0 if chars.all?(\"1\")\n  chars.size.times.all? do \n   GMP::Z(chars.rotate!.join).probab_prime? > 0\n   \n  end\nend\n\nputs \"First 19 circular primes:\"\nputs candidate_primes.lazy.select{|cand| circular?(cand)}.take(19).to_a.join(\", \"),\"\"\nputs \"First 5 prime repunits:\"\nreps = Prime.each.lazy.select{|pr| circular?(\"1\"*pr)}.take(5).to_a\nputs  reps.map{|r| \"R\" + r.to_s}.join(\", \"), \"\"\n[5003, 9887, 15073, 25031].each {|rep| puts \"R\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class CircularPrimes {\n    public static void main(String[] args) {\n        System.out.println(\"First 19 circular primes:\");\n        int p = 2;\n        for (int count = 0; count < 19; ++p) {\n            if (isCircularPrime(p)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.print(p);\n                ++count;\n            }\n        }\n        System.out.println();\n        System.out.println(\"Next 4 circular primes:\");\n        int repunit = 1, digits = 1;\n        for (; repunit < p; ++digits)\n            repunit = 10 * repunit + 1;\n        BigInteger bignum = BigInteger.valueOf(repunit);\n        for (int count = 0; count < 4; ) {\n            if (bignum.isProbablePrime(15)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.printf(\"R(%d)\", digits);\n                ++count;\n            }\n            ++digits;\n            bignum = bignum.multiply(BigInteger.TEN);\n            bignum = bignum.add(BigInteger.ONE);\n        }\n        System.out.println();\n        testRepunit(5003);\n        testRepunit(9887);\n        testRepunit(15073);\n        testRepunit(25031);\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n\n    private static int cycle(int n) {\n        int m = n, p = 1;\n        while (m >= 10) {\n            p *= 10;\n            m /= 10;\n        }\n        return m + 10 * (n % p);\n    }\n\n    private static boolean isCircularPrime(int p) {\n        if (!isPrime(p))\n            return false;\n        int p2 = cycle(p);\n        while (p2 != p) {\n            if (p2 < p || !isPrime(p2))\n                return false;\n            p2 = cycle(p2);\n        }\n        return true;\n    }\n\n    private static void testRepunit(int digits) {\n        BigInteger repunit = repunit(digits);\n        if (repunit.isProbablePrime(15))\n            System.out.printf(\"R(%d) is probably prime.\\n\", digits);\n        else\n            System.out.printf(\"R(%d) is not prime.\\n\", digits);\n    }\n\n    private static BigInteger repunit(int digits) {\n        char[] ch = new char[digits];\n        Arrays.fill(ch, '1');\n        return new BigInteger(new String(ch));\n    }\n}\n"}
{"id": 425040, "name": "Frobenius numbers", "source": "Translate Ruby to Java: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "public class Frobenius {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        System.out.printf(\"Frobenius numbers less than %d (asterisk marks primes):\\n\", limit);\n        PrimeGenerator primeGen = new PrimeGenerator(1000, 100000);\n        int prime1 = primeGen.nextPrime();\n        for (int count = 1; ; ++count) {\n            int prime2 = primeGen.nextPrime();\n            int frobenius = prime1 * prime2 - prime1 - prime2;\n            if (frobenius >= limit)\n                break;\n            System.out.printf(\"%6d%c%c\", frobenius,\n                    isPrime(frobenius) ? '*' : ' ',\n                    count % 10 == 0 ? '\\n' : ' ');\n            prime1 = prime2;\n        }\n        System.out.println();\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 425041, "name": "Frobenius numbers", "source": "Translate Ruby to Java: require 'prime'\n\nPrime.each_cons(2) do |p1, p2|\n  f = p1*p2-p1-p2\n  break if f > 10_000\n  puts f\nend\n", "target": "public class Frobenius {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        System.out.printf(\"Frobenius numbers less than %d (asterisk marks primes):\\n\", limit);\n        PrimeGenerator primeGen = new PrimeGenerator(1000, 100000);\n        int prime1 = primeGen.nextPrime();\n        for (int count = 1; ; ++count) {\n            int prime2 = primeGen.nextPrime();\n            int frobenius = prime1 * prime2 - prime1 - prime2;\n            if (frobenius >= limit)\n                break;\n            System.out.printf(\"%6d%c%c\", frobenius,\n                    isPrime(frobenius) ? '*' : ' ',\n                    count % 10 == 0 ? '\\n' : ' ');\n            prime1 = prime2;\n        }\n        System.out.println();\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 425042, "name": "Sorting algorithms_Permutation sort", "source": "Translate Ruby to Java: class Array\n  def permutationsort\n    permutation.each{|perm| return perm if perm.sorted?}\n  end\n  \n  def sorted?\n    each_cons(2).all? {|a, b| a <= b}\n  end\nend\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class PermutationSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tint[] a={3,2,1,8,9,4,6};\n\t\tSystem.out.println(\"Unsorted: \" + Arrays.toString(a));\n\t\ta=pSort(a);\n\t\tSystem.out.println(\"Sorted: \" + Arrays.toString(a));\n\t}\n\tpublic static int[] pSort(int[] a)\n\t{\n\t\tList<int[]> list=new ArrayList<int[]>();\n\t\tpermute(a,a.length,list);\n\t\tfor(int[] x : list)\n\t\t\tif(isSorted(x))\n\t\t\t\treturn x;\n\t\treturn a;\n\t}\n\tprivate static void permute(int[] a, int n, List<int[]> list) \n\t{\n\t\tif (n == 1) \n\t\t{\n\t\t\tint[] b=new int[a.length];\n\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\tlist.add(b);\n\t\t    return;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t        swap(a, i, n-1);\n\t\t        permute(a, n-1, list);\n\t\t        swap(a, i, n-1);\n\t\t }\n\t}\n\tprivate static boolean isSorted(int[] a)\n\t{\n\t\tfor(int i=1;i<a.length;i++)\n\t\t\tif(a[i-1]>a[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tprivate static void swap(int[] arr,int i, int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n}\n"}
{"id": 425043, "name": "Integer roots", "source": "Translate Ruby to Java: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 425044, "name": "Integer roots", "source": "Translate Ruby to Java: def root(a,b)\n  return b if b<2\n  a1, c = a-1, 1\n  f = -> x {(a1*x+b/(x**a1))/a}  \n  d = f[c]\n  e = f[d]\n  c, d, e = d, e, f[e] until [d,e].include?(c)\n  [d,e].min\nend\n\nputs \"First 2,001 digits of the square root of two:\"\nputs root(2, 2*100**2000)\n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 425045, "name": "Modulinos", "source": "Translate Ruby to Java: \n\ndef meaning_of_life\n  42\nend\n\nif __FILE__ == $0\n  puts \"Main: The meaning of life is \nend\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 425046, "name": "Modulinos", "source": "Translate Ruby to Java: \n\ndef meaning_of_life\n  42\nend\n\nif __FILE__ == $0\n  puts \"Main: The meaning of life is \nend\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 425047, "name": "Nice primes", "source": "Translate Ruby to Java: require 'prime'\n\nclass Integer\n  def dig_root = (1+(self-1).remainder(9))\n  def nice? = prime? && dig_root.prime?\nend\n\np (500..1000).select(&:nice?)\n", "target": "public class NicePrimes {\n    private static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n % 2 == 0L) {\n            return n == 2L;\n        }\n        if (n % 3 == 0L) {\n            return n == 3L;\n        }\n\n        var p = 5L;\n        while (p * p <= n) {\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 2;\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 4;\n        }\n        return true;\n    }\n\n    private static long digitalRoot(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        return 1 + (n - 1) % 9;\n    }\n\n    public static void main(String[] args) {\n        final long from = 500;\n        final long to = 1000;\n        int count = 0;\n\n        System.out.printf(\"Nice primes between %d and %d%n\", from, to);\n        long n = from;\n        while (n < to) {\n            if (isPrime(digitalRoot(n)) && isPrime(n)) {\n                count++;\n                System.out.print(n);\n                if (count % 10 == 0) {\n                    System.out.println();\n                } else {\n                    System.out.print(' ');\n                }\n            }\n\n            n++;\n        }\n        System.out.println();\n        System.out.printf(\"%d nice primes found.%n\", count);\n    }\n}\n"}
{"id": 425048, "name": "Find the last Sunday of each month", "source": "Translate Ruby to Java: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 425049, "name": "Find the last Sunday of each month", "source": "Translate Ruby to Java: require 'date'\n\ndef last_sundays_of_year(year = Date.today.year)\n  (1..12).map do |month|\n    d = Date.new(year, month, -1) \n    d - d.wday\n  end\nend\n\nputs last_sundays_of_year(2013)\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 425050, "name": "Random Latin squares", "source": "Translate Ruby to Java: N = 5\n\ndef generate_square\n  perms  =  (1..N).to_a.permutation(N).to_a.shuffle\n  square = []\n  N.times do\n    square << perms.pop\n    perms.reject!{|perm| perm.zip(square.last).any?{|el1, el2| el1 == el2} }\n  end\n  square\nend\n\ndef print_square(square)\n  cell_size = N.digits.size + 1\n  strings = square.map!{|row| row.map!{|el| el.to_s.rjust(cell_size)}.join }\n  puts strings, \"\\n\"\nend\n\n2.times{print_square( generate_square)}\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class RandomLatinSquares {\n    private static void printSquare(List<List<Integer>> latin) {\n        for (List<Integer> row : latin) {\n            Iterator<Integer> it = row.iterator();\n\n            System.out.print(\"[\");\n            if (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(col);\n            }\n            while (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(\", \");\n                System.out.print(col);\n            }\n            System.out.println(\"]\");\n        }\n        System.out.println();\n    }\n\n    private static void latinSquare(int n) {\n        if (n <= 0) {\n            System.out.println(\"[]\");\n            return;\n        }\n\n        List<List<Integer>> latin = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            List<Integer> inner = new ArrayList<>(n);\n            for (int j = 0; j < n; ++j) {\n                inner.add(j);\n            }\n            latin.add(inner);\n        }\n        \n        Collections.shuffle(latin.get(0));\n\n        \n        for (int i = 1; i < n - 1; ++i) {\n            boolean shuffled = false;\n            shuffling:\n            while (!shuffled) {\n                Collections.shuffle(latin.get(i));\n                for (int k = 0; k < i; ++k) {\n                    for (int j = 0; j < n; ++j) {\n                        if (Objects.equals(latin.get(k).get(j), latin.get(i).get(j))) {\n                            continue shuffling;\n                        }\n                    }\n                }\n                shuffled = true;\n            }\n        }\n\n        \n        for (int j = 0; j < n; ++j) {\n            List<Boolean> used = new ArrayList<>(n);\n            for (int i = 0; i < n; ++i) {\n                used.add(false);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                used.set(latin.get(i).get(j), true);\n            }\n            for (int k = 0; k < n; ++k) {\n                if (!used.get(k)) {\n                    latin.get(n - 1).set(j, k);\n                    break;\n                }\n            }\n        }\n\n        printSquare(latin);\n    }\n\n    public static void main(String[] args) {\n        latinSquare(5);\n        latinSquare(5);\n        latinSquare(10);\n    }\n}\n"}
{"id": 425051, "name": "Teacup rim text", "source": "Translate Ruby to Java: lists = [\"unixdict.txt\", \"wordlist.10000\", \"woordenlijst.txt\"]\n\nlists.each do |list|\n  words = open(list).readlines( chomp: true).reject{|w| w.size < 3 }\n  grouped_by_size = words.group_by(&:size)\n  tea_words = words.filter_map do |word|\n    chars = word.chars\n    next unless chars.none?{|c| c < chars.first }\n    next if chars.uniq.size == 1\n    rotations = word.size.times.map {|i| chars.rotate(i).join }\n    rotations if rotations.all?{|rot| grouped_by_size[rot.size].include? rot }\n  end\n  puts \"\", list + \":\"\n  tea_words.uniq(&:to_set).each{|ar| puts ar.join(\", \") }\nend\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Teacup {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"usage: java Teacup dictionary\");\n            System.exit(1);\n        }\n        try {\n            findTeacupWords(loadDictionary(args[0]));\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n\n    \n    private static Set<String> loadDictionary(String fileName) throws IOException {\n        Set<String> words = new TreeSet<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String word;\n            while ((word = reader.readLine()) != null)\n                words.add(word);\n            return words;\n        }\n    }\n\n    private static void findTeacupWords(Set<String> words) {\n        List<String> teacupWords = new ArrayList<>();\n        Set<String> found = new HashSet<>();\n        for (String word : words) {\n            int len = word.length();\n            if (len < 3 || found.contains(word))\n                continue;\n            teacupWords.clear();\n            teacupWords.add(word);\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < len - 1; ++i) {\n                String rotated = new String(rotate(chars));\n                if (rotated.equals(word) || !words.contains(rotated))\n                    break;\n                teacupWords.add(rotated);\n            }\n            if (teacupWords.size() == len) {\n                found.addAll(teacupWords);\n                System.out.print(word);\n                for (int i = 1; i < len; ++i)\n                    System.out.print(\" \" + teacupWords.get(i));\n                System.out.println();\n            }\n        }\n    }\n\n    private static char[] rotate(char[] ch) {\n        char c = ch[0];\n        System.arraycopy(ch, 1, ch, 0, ch.length - 1);\n        ch[ch.length - 1] = c;\n        return ch;\n    }\n}\n"}
{"id": 425052, "name": "Fairshare between two and more", "source": "Translate Ruby to Java: def turn(base, n)\n    sum = 0\n    while n != 0 do\n        rem = n % base\n        n = n / base\n        sum = sum + rem\n    end\n    return sum % base\nend\n\ndef fairshare(base, count)\n    print \"Base %2d: \" % [base]\n    for i in 0 .. count - 1 do\n        t = turn(base, i)\n        print \" %2d\" % [t]\n    end\n    print \"\\n\"\nend\n\ndef turnCount(base, count)\n    cnt = Array.new(base, 0)\n\n    for i in 0 .. count - 1 do\n        t = turn(base, i)\n        cnt[t] = cnt[t] + 1\n    end\n\n    minTurn = base * count\n    maxTurn = -1\n    portion = 0\n    for i in 0 .. base - 1 do\n        if cnt[i] > 0 then\n            portion = portion + 1\n        end\n        if cnt[i] < minTurn then\n            minTurn = cnt[i]\n        end\n        if cnt[i] > maxTurn then\n            maxTurn = cnt[i]\n        end\n    end\n\n    print \"  With %d people: \" % [base]\n    if 0 == minTurn then\n        print \"Only %d have a turn\\n\" % portion\n    elsif minTurn == maxTurn then\n        print \"%d\\n\" % [minTurn]\n    else\n        print \"%d or %d\\n\" % [minTurn, maxTurn]\n    end\nend\n\ndef main\n    fairshare(2, 25)\n    fairshare(3, 25)\n    fairshare(5, 25)\n    fairshare(11, 25)\n\n    puts \"How many times does each get a turn in 50000 iterations?\"\n    turnCount(191, 50000)\n    turnCount(1377, 50000)\n    turnCount(49999, 50000)\n    turnCount(50000, 50000)\n    turnCount(50001, 50000)\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class FairshareBetweenTwoAndMore {\n\n    public static void main(String[] args) {\n        for ( int base : Arrays.asList(2, 3, 5, 11) ) {\n            System.out.printf(\"Base %d = %s%n\", base, thueMorseSequence(25, base));\n        }\n    }\n    \n    private static List<Integer> thueMorseSequence(int terms, int base) {\n        List<Integer> sequence = new ArrayList<Integer>();\n        for ( int i = 0 ; i < terms ; i++ ) {\n            int sum = 0;\n            int n = i;\n            while ( n > 0 ) {\n                \n                sum += n % base;\n                n /= base;\n            }\n            \n            sequence.add(sum % base);\n        }\n        return sequence;\n    }\n\n}\n"}
{"id": 425053, "name": "Esthetic numbers", "source": "Translate Ruby to Java: def isEsthetic(n, b)\n    if n == 0 then\n        return false\n    end\n\n    i = n % b\n    n2 = (n / b).floor\n    while n2 > 0\n        j = n2 % b\n        if (i - j).abs != 1 then\n            return false\n        end\n        n2 = n2 / b\n        i = j\n    end\n    return true\nend\n\ndef listEsths(n, n2, m, m2, perLine, all)\n    esths = Array.new\n    dfs = lambda {|n, m, i|\n        if n <= i and i <= m then\n            esths << i\n        end\n        if i == 0 or i > m then\n            return\n        end\n        d = i % 10\n        i1 = i * 10 + d - 1\n        i2 = i1 + 2\n        if d == 0 then\n            dfs[n, m, i2]\n        elsif d == 9 then\n            dfs[n, m, i1]\n        else\n            dfs[n, m, i1]\n            dfs[n, m, i2]\n        end\n    }\n\n    for i in 0..9\n        dfs[n2, m2, i]\n    end\n\n    le = esths.length\n    print \"Base 10: %d esthetic numbers between %d and %d:\\n\" % [le, n, m]\n    if all then\n        esths.each_with_index { |esth, idx|\n            print \"%d \" % [esth]\n            if (idx + 1) % perLine == 0 then\n                print \"\\n\"\n            end\n        }\n        print \"\\n\"\n    else\n        for i in 0 .. perLine - 1\n            print \"%d \" % [esths[i]]\n        end\n        print \"\\n............\\n\"\n        for i in le - perLine .. le - 1\n            print \"%d \" % [esths[i]]\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndef main\n    for b in 2..16\n        print \"Base %d: %dth to %dth esthetic numbers:\\n\" % [b, 4 * b, 6 * b]\n        n = 1\n        c = 0\n        while c < 6 * b\n            if isEsthetic(n, b) then\n                c = c + 1\n                if c >= 4 * b then\n                    print \"%s \" % [n.to_s(b)]\n                end\n            end\n            n = n + 1\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\n\n    listEsths(1000, 1010, 9999, 9898, 16, true)\n    listEsths(1e8, 101010101, 13 * 1e7, 123456789, 9, true)\n    listEsths(1e11, 101010101010, 13 * 1e10, 123456789898, 7, false)\n    listEsths(1e14, 101010101010101, 13 * 1e13, 123456789898989, 5, false)\n    listEsths(1e17, 101010101010101010, 13 * 1e16, 123456789898989898, 4, false)\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\n\npublic class EstheticNumbers {\n    interface RecTriConsumer<A, B, C> {\n        void accept(RecTriConsumer<A, B, C> f, A a, B b, C c);\n    }\n\n    private static boolean isEsthetic(long n, long b) {\n        if (n == 0) {\n            return false;\n        }\n        var i = n % b;\n        var n2 = n / b;\n        while (n2 > 0) {\n            var j = n2 % b;\n            if (Math.abs(i - j) != 1) {\n                return false;\n            }\n            n2 /= b;\n            i = j;\n        }\n        return true;\n    }\n\n    private static void listEsths(long n, long n2, long m, long m2, int perLine, boolean all) {\n        var esths = new ArrayList<Long>();\n        var dfs = new RecTriConsumer<Long, Long, Long>() {\n            public void accept(Long n, Long m, Long i) {\n                accept(this, n, m, i);\n            }\n\n            @Override\n            public void accept(RecTriConsumer<Long, Long, Long> f, Long n, Long m, Long i) {\n                if (n <= i && i <= m) {\n                    esths.add(i);\n                }\n                if (i == 0 || i > m) {\n                    return;\n                }\n                var d = i % 10;\n                var i1 = i * 10 + d - 1;\n                var i2 = i1 + 2;\n                if (d == 0) {\n                    f.accept(f, n, m, i2);\n                } else if (d == 9) {\n                    f.accept(f, n, m, i1);\n                } else {\n                    f.accept(f, n, m, i1);\n                    f.accept(f, n, m, i2);\n                }\n            }\n        };\n\n        LongStream.range(0, 10).forEach(i -> dfs.accept(n2, m2, i));\n\n        var le = esths.size();\n        System.out.printf(\"Base 10: %d esthetic numbers between %d and %d:%n\", le, n, m);\n        if (all) {\n            for (int i = 0; i < esths.size(); i++) {\n                System.out.printf(\"%d \", esths.get(i));\n                if ((i + 1) % perLine == 0) {\n                    System.out.println();\n                }\n            }\n        } else {\n            for (int i = 0; i < perLine; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n            System.out.println();\n            System.out.println(\"............\");\n            for (int i = le - perLine; i < le; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n        }\n        System.out.println();\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(2, 16).forEach(b -> {\n            System.out.printf(\"Base %d: %dth to %dth esthetic numbers:%n\", b, 4 * b, 6 * b);\n            var n = 1L;\n            var c = 0L;\n            while (c < 6 * b) {\n                if (isEsthetic(n, b)) {\n                    c++;\n                    if (c >= 4 * b) {\n                        System.out.printf(\"%s \", Long.toString(n, b));\n                    }\n                }\n                n++;\n            }\n            System.out.println();\n        });\n        System.out.println();\n\n        \n        listEsths(1000, 1010, 9999, 9898, 16, true);\n        listEsths((long) 1e8, 101_010_101, 13 * (long) 1e7, 123_456_789, 9, true);\n        listEsths((long) 1e11, 101_010_101_010L, 13 * (long) 1e10, 123_456_789_898L, 7, false);\n        listEsths((long) 1e14, 101_010_101_010_101L, 13 * (long) 1e13, 123_456_789_898_989L, 5, false);\n        listEsths((long) 1e17, 101_010_101_010_101_010L, 13 * (long) 1e16, 123_456_789_898_989_898L, 4, false);\n    }\n}\n"}
{"id": 425054, "name": "Permutations by swapping", "source": "Translate Ruby to Java: def perms(n)\n  p = Array.new(n+1){|i| -i}\n  s = 1\n  loop do\n    yield p[1..-1].map(&:abs), s\n    k = 0\n    for i in 2..n\n      k = i if p[i] < 0 and p[i].abs > p[i-1].abs and p[i].abs > p[k].abs\n    end\n    for i in 1...n\n      k = i if p[i] > 0 and p[i].abs > p[i+1].abs and  p[i].abs > p[k].abs\n    end\n    break if k.zero?\n    for i in 1..n\n      p[i] *= -1 if p[i].abs > p[k].abs\n    end\n    i = k + (p[k] <=> 0)\n    p[k], p[i] = p[i], p[k]\n    s = -s\n  end\nend\n\nfor i in 3..4\n  perms(i){|perm, sign| puts \"Perm: \n  puts\nend\n", "target": "package org.rosettacode.java;\n\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class HeapsAlgorithm {\n\n\tpublic static void main(String[] args) {\n\t\tObject[] array = IntStream.range(0, 4)\n\t\t\t\t.boxed()\n\t\t\t\t.toArray();\n\t\tHeapsAlgorithm algorithm = new HeapsAlgorithm();\n\t\talgorithm.recursive(array);\n\t\tSystem.out.println();\n\t\talgorithm.loop(array);\n\t}\n\n\tvoid recursive(Object[] array) {\n\t\trecursive(array, array.length, true);\n\t}\n\n\tvoid recursive(Object[] array, int n, boolean plus) {\n\t\tif (n == 1) {\n\t\t\toutput(array, plus);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trecursive(array, n - 1, i == 0);\n\t\t\t\tswap(array, n % 2 == 0 ? i : 0, n - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid output(Object[] array, boolean plus) {\n\t\tSystem.out.println(Arrays.toString(array) + (plus ? \" +1\" : \" -1\"));\n\t}\n\n\tvoid swap(Object[] array, int a, int b) {\n\t\tObject o = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = o;\n\t}\n\n\tvoid loop(Object[] array) {\n\t\tloop(array, array.length);\n\t}\n\n\tvoid loop(Object[] array, int n) {\n\t\tint[] c = new int[n];\n\t\toutput(array, true);\n\t\tboolean plus = false;\n\t\tfor (int i = 0; i < n; ) {\n\t\t\tif (c[i] < i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tswap(array, 0, i);\n\t\t\t\t} else {\n\t\t\t\t\tswap(array, c[i], i);\n\t\t\t\t}\n\t\t\t\toutput(array, plus);\n\t\t\t\tplus = !plus;\n\t\t\t\tc[i]++;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tc[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 425055, "name": "RPG attributes generator", "source": "Translate Ruby to Java: def roll_stat\n  dices = Array(Int32).new(4) { rand(1..6) }\n  dices.sum - dices.min\nend\n\ndef roll_character\n  loop do\n    stats = Array(Int32).new(6) { roll_stat }\n    return stats if stats.sum >= 75 && stats.count(&.>=(15)) >= 2\n  end\nend\n\n10.times do\n  stats = roll_character\n  puts \"stats: \nend\n", "target": "import java.util.List;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\nimport static java.util.stream.Collectors.toList;\n\npublic class Rpg {\n\n    private static final Random random = new Random();\n \n    public static int genAttribute() {\n        return random.ints(1, 6 + 1) \n            .limit(4) \n            .sorted() \n            .limit(3) \n            .sum();   \n    }\n \n    public static void main(String[] args) {\n        while (true) {\n            List<Integer> stats =\n                Stream.generate(Rpg::genAttribute) \n                    .limit(6) \n                    .collect(toList()); \n            int sum = stats.stream().mapToInt(Integer::intValue).sum();\n            long count = stats.stream().filter(v -> v >= 15).count();\n            if (count >= 2 && sum >= 75) {\n                System.out.printf(\"The 6 random numbers generated are: %s\\n\", stats);\n                System.out.printf(\"Their sum is %s and %s of them are >= 15\\n\", sum, count);\n                return;\n            }      \n        }\n    }\n}\n"}
{"id": 425056, "name": "Kolakoski sequence", "source": "Translate Ruby to Java: def create_generator(ar)\n  Enumerator.new do |y|\n    cycle = ar.cycle\n    s = []\n    loop do\n      t = cycle.next\n      s.push(t)\n      v = s.shift\n      y << v\n      (v-1).times{s.push(t)}\n    end\n  end\nend\n\ndef rle(ar)\n  ar.slice_when{|a,b| a != b}.map(&:size)\nend\n\n[[20, [1,2]], \n [20, [2,1]], \n [30, [1,3,1,2]],\n [30, [1,3,2,1]]].each do |num,ar|\n  puts \"\\nFirst \n  p res = create_generator(ar).take(num)\n  puts \"Possible Kolakoski sequence? \nend\n", "target": "import java.util.Arrays;\n\npublic class Kolakoski {\n    private static class Crutch {\n        final int len;\n        int[] s;\n        int i;\n\n        Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        void repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    private static int nextInCycle(final int[] self, int index) {\n        return self[index % self.length];\n    }\n\n    private static int[] kolakoski(final int[] self, int len) {\n        Crutch c = new Crutch(len);\n\n        int k = 0;\n        while (c.i < len) {\n            c.s[c.i] = nextInCycle(self, k);\n            if (c.s[k] > 1) {\n                c.repeat(c.s[k] - 1);\n            }\n            if (++c.i == len) return c.s;\n            k++;\n        }\n        return c.s;\n    }\n\n    private static boolean possibleKolakoski(final int[] self) {\n        int[] rle = new int[self.length];\n        int prev = self[0];\n        int count = 1;\n        int pos = 0;\n        for (int i = 1; i < self.length; i++) {\n            if (self[i] == prev) {\n                count++;\n            } else {\n                rle[pos++] = count;\n                count = 1;\n                prev = self[i];\n            }\n        }\n        \n        for (int i = 0; i < pos; i++) {\n            if (rle[i] != self[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[][] ias = new int[][]{\n            new int[]{1, 2},\n            new int[]{2, 1},\n            new int[]{1, 3, 1, 2},\n            new int[]{1, 3, 2, 1}\n        };\n        int[] lens = new int[]{20, 20, 30, 30};\n\n        for (int i=0; i<ias.length; i++) {\n            int len = lens[i];\n            int[] kol = kolakoski(ias[i], len);\n\n            System.out.printf(\"First %d members of the sequence generated by %s: \\n\", len, Arrays.toString(ias[i]));\n            System.out.printf(\"%s\\n\", Arrays.toString(kol));\n            System.out.printf(\"Possible Kolakoski sequence? %s\\n\\n\", possibleKolakoski(kol));\n        }\n    }\n}\n"}
{"id": 425057, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Ruby to Java: require 'prime'\n \ndef num_divisors(n)\n  n.prime_division.inject(1){|prod, (_p,n)| prod *= (n + 1) } \nend\n\ndef first_with_num_divs(n)\n  (1..).detect{|i| num_divisors(i) == n }\nend\n\np (1..15).map{|n| first_with_num_divs(n) }\n", "target": "import java.util.Arrays;\n\npublic class OEIS_A005179 {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        int[] seq = new int[max];\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, n = 0; n < max; ++i) {\n            int k = count_divisors(i);\n            if (k <= max && seq[k - 1] == 0) {        \n                seq[k- 1] = i;\n                n++;\n            }\n        }\n        System.out.println(Arrays.toString(seq));\n    }\n}\n"}
{"id": 425058, "name": "Sparkline in unicode", "source": "Translate Ruby to Java: bar = ('\u2581'..'\u2588').to_a \nloop {print 'Numbers please separated by space/commas: '\n  numbers = gets.split(/[\\s,]+/).map(&:to_f)\n  min, max = numbers.minmax\n  puts \"min: %5f; max: %5f\"% [min, max]\n  div = (max - min) / (bar.size - 1)\n  puts min == max ? bar.last*numbers.size : numbers.map{|num| bar[((num - min) / div).to_i]}.join\n}\n", "target": "public class Sparkline \n{\n\tString bars=\"\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\";\n\tpublic static void main(String[] args)\n\t{\n\t\tSparkline now=new Sparkline();\n\t\tfloat[] arr={1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1};\n\t\tnow.display1D(arr);\n\t\tSystem.out.println(now.getSparkline(arr));\n\t\tfloat[] arr1={1.5f, 0.5f, 3.5f, 2.5f, 5.5f, 4.5f, 7.5f, 6.5f};\n\t\tnow.display1D(arr1);\n\t\tSystem.out.println(now.getSparkline(arr1));\n\t}\n\tpublic void display1D(float[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tpublic String getSparkline(float[] arr)\n\t{\n\t\tfloat min=Integer.MAX_VALUE;\n\t\tfloat max=Integer.MIN_VALUE;\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tif(arr[i]<min)\n\t\t\t\tmin=arr[i];\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t}\n\t\tfloat range=max-min;\n\t\tint num=bars.length()-1;\n\t\tString line=\"\";\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\t\n\t\t\tline+=bars.charAt((int)Math.ceil(((arr[i]-min)/range*num)));\n\t\t}\n\t\treturn line;\n\t}\n}\n"}
{"id": 425059, "name": "Levenshtein distance_Alignment", "source": "Translate Ruby to Java: require 'lcs'\n\ndef levenshtein_align(a, b)\n  apos, bpos = LCS.new(a, b).backtrack2\n  \n  c = \"\"\n  d = \"\"\n  x0 = y0 = -1\n  dx = dy = 0\n  apos.zip(bpos) do |x,y|\n    diff = x + dx - y - dy\n    if diff < 0\n      dx -= diff\n      c += \"-\" * (-diff)\n    elsif diff > 0\n      dy += diff\n      d += \"-\" * diff\n    end\n    c += a[x0+1..x]\n    x0 = x\n    d += b[y0+1..y]\n    y0 = y\n  end\n  \n  c += a[x0+1..-1]\n  d += b[y0+1..-1]\n  diff = a.length + y0 - b.length - x0\n  if diff < 0\n    c += \"-\" * (-diff)\n  elsif diff > 0\n    d += \"-\" * diff\n  end\n  [c, d]\nend\n\nputs levenshtein_align(\"rosettacode\", \"raisethysword\")\n", "target": "public class LevenshteinAlignment {\n\n    public static String[] alignment(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int[][] costs = new int[a.length()+1][b.length()+1];\n        for (int j = 0; j <= b.length(); j++)\n            costs[0][j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            costs[i][0] = i;\n            for (int j = 1; j <= b.length(); j++) {\n                costs[i][j] = Math.min(1 + Math.min(costs[i-1][j], costs[i][j-1]), a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1);\n            }\n        }\n\n\t\n\tStringBuilder aPathRev = new StringBuilder();\n\tStringBuilder bPathRev = new StringBuilder();\n\tfor (int i = a.length(), j = b.length(); i != 0 && j != 0; ) {\n\t    if (costs[i][j] == (a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1)) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append(b.charAt(--j));\n\t    } else if (costs[i][j] == 1 + costs[i-1][j]) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append('-');\n\t    } else if (costs[i][j] == 1 + costs[i][j-1]) {\n\t\taPathRev.append('-');\n\t\tbPathRev.append(b.charAt(--j));\n\t    }\n\t}\n        return new String[]{aPathRev.reverse().toString(), bPathRev.reverse().toString()};\n    }\n\n    public static void main(String[] args) {\n\tString[] result = alignment(\"rosettacode\", \"raisethysword\");\n\tSystem.out.println(result[0]);\n\tSystem.out.println(result[1]);\n    }\n}\n"}
{"id": 425060, "name": "Longest increasing subsequence", "source": "Translate Ruby to Java: Node = Struct.new(:val, :back)\n\ndef lis(n)\n  pileTops = []\n  \n  for x in n\n    \n    low, high = 0, pileTops.size-1\n    while low <= high\n      mid = low + (high - low) / 2\n      if pileTops[mid].val >= x\n        high = mid - 1\n      else\n        low = mid + 1\n      end\n    end\n    i = low\n    node = Node.new(x)\n    node.back = pileTops[i-1]  if i > 0\n    pileTops[i] = node\n  end\n  \n  result = []\n  node = pileTops.last\n  while node\n    result.unshift(node.val)\n    node = node.back\n  end\n  result\nend\n\np lis([3, 2, 6, 4, 5, 1])\np lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])\n", "target": "import java.util.*;\n\npublic class LIS {\n    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {\n        List<Node<E>> pileTops = new ArrayList<Node<E>>();\n        \n        for (E x : n) {\n\t    Node<E> node = new Node<E>();\n\t    node.value = x;\n            int i = Collections.binarySearch(pileTops, node);\n            if (i < 0) i = ~i;\n\t    if (i != 0)\n\t\tnode.pointer = pileTops.get(i-1);\n            if (i != pileTops.size())\n                pileTops.set(i, node);\n            else\n                pileTops.add(node);\n        }\n\t\n\tList<E> result = new ArrayList<E>();\n\tfor (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);\n                node != null; node = node.pointer)\n\t    result.add(node.value);\n\tCollections.reverse(result);\n\treturn result;\n    }\n\n    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {\n\tpublic E value;\n\tpublic Node<E> pointer;\n        public int compareTo(Node<E> y) { return value.compareTo(y.value); }\n    }\n\n    public static void main(String[] args) {\n\tList<Integer> d = Arrays.asList(3,2,6,4,5,1);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n        d = Arrays.asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n    }\n}\n"}
{"id": 425061, "name": "Words from neighbour ones", "source": "Translate Ruby to Java: new_word_size = 9\nwell_sized  = File.readlines(\"unixdict.txt\", chomp: true).reject{|word| word.size < new_word_size}\nlist = well_sized.each_cons(new_word_size).filter_map do |slice|\n  candidate = (0...new_word_size).inject(\"\"){|res, idx| res << slice[idx][idx] }\n  candidate if well_sized.include?(candidate)\nend\nputs list.uniq\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class NeighbourWords {\n    public static void main(String[] args) {\n        try {\n            int minLength = 9;\n            List<String> words = new ArrayList<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() >= minLength)\n                        words.add(line);\n                }\n            }\n            Collections.sort(words);\n            String previousWord = null;\n            int count = 0;\n            for (int i = 0, n = words.size(); i + minLength <= n; ++i) {\n                StringBuilder sb = new StringBuilder(minLength);\n                for (int j = 0; j < minLength; ++j)\n                    sb.append(words.get(i + j).charAt(j));\n                String word = sb.toString();\n                if (word.equals(previousWord))\n                    continue;\n                if (Collections.binarySearch(words, word) >= 0)\n                    System.out.printf(\"%2d. %s\\n\", ++count, word);\n                previousWord = word;\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 425062, "name": "Dynamic variable names", "source": "Translate Ruby to Java: p \"Enter a variable name\"\nx = \"@\" + gets.chomp!\ninstance_variable_set x, 42\np \"The value of \n", "target": "public static void main(String... args){\n        HashMap<String, Integer> vars = new HashMap<String, Integer>();\n        \n        \n        \n        vars.put(\"Variable name\", 3); \n        vars.put(\"Next variable name\", 5);\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        vars.put(str, sc.nextInt()); \n        \n        System.out.println(vars.get(\"Variable name\")); \n        System.out.println(vars.get(str));\n}\n"}
{"id": 425063, "name": "Brilliant numbers", "source": "Translate Ruby to Java: func is_briliant_number(n) {\n    n.is_semiprime && (n.factor.map{.len}.uniq.len == 1)\n}\n\nfunc brilliant_numbers_count(n) {\n\n    var count = 0\n    var len = n.isqrt.len\n\n    for k in (1 .. len-1) {\n        var pi = prime_count(10**(k-1), 10**k - 1)\n        count += binomial(pi, 2)+pi\n    }\n\n    var min = (10**(len - 1))\n    var max = (10**len - 1)\n\n    each_prime(min, max, {|p|\n        count += prime_count(p, max `min` idiv(n, p))\n    })\n\n    return count\n}\n\nsay \"First 100 brilliant numbers:\"\n\n100.by(is_briliant_number).each_slice(10, {|*a|\n    say a.map { '%4s' % _}.join(' ')\n})\n\nsay ''\n\nfor n in (1 .. 12) {\n    var v = (10**n .. Inf -> first_by(is_briliant_number))\n    printf(\"First brilliant number >= 10^%d is %s\", n, v)\n    printf(\" at position %s\\n\", brilliant_numbers_count(v))\n}\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 425064, "name": "Brilliant numbers", "source": "Translate Ruby to Java: func is_briliant_number(n) {\n    n.is_semiprime && (n.factor.map{.len}.uniq.len == 1)\n}\n\nfunc brilliant_numbers_count(n) {\n\n    var count = 0\n    var len = n.isqrt.len\n\n    for k in (1 .. len-1) {\n        var pi = prime_count(10**(k-1), 10**k - 1)\n        count += binomial(pi, 2)+pi\n    }\n\n    var min = (10**(len - 1))\n    var max = (10**len - 1)\n\n    each_prime(min, max, {|p|\n        count += prime_count(p, max `min` idiv(n, p))\n    })\n\n    return count\n}\n\nsay \"First 100 brilliant numbers:\"\n\n100.by(is_briliant_number).each_slice(10, {|*a|\n    say a.map { '%4s' % _}.join(' ')\n})\n\nsay ''\n\nfor n in (1 .. 12) {\n    var v = (10**n .. Inf -> first_by(is_briliant_number))\n    printf(\"First brilliant number >= 10^%d is %s\", n, v)\n    printf(\" at position %s\\n\", brilliant_numbers_count(v))\n}\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 425065, "name": "Order disjoint list items", "source": "Translate Ruby to Java: def order_disjoint(m,n)\n  print \"\n  m, n = m.split, n.split\n  from = 0\n  n.each_slice(2) do |x,y|\n    next unless y\n    sd = m[from..-1]\n    if x > y && (sd.include? x) && (sd.include? y) && (sd.index(x) > sd.index(y))\n      new_from = m.index(x)+1\n      m[m.index(x)+from], m[m.index(y)+from] = m[m.index(y)+from], m[m.index(x)+from]\n      from = new_from\n    end\n  end\n  puts m.join(' ')\nend\n\n[\n  ['the cat sat on the mat', 'mat cat'],\n  ['the cat sat on the mat', 'cat mat'],\n  ['A B C A B C A B C'     , 'C A C A'],\n  ['A B C A B D A B E'     , 'E A D A'],\n  ['A B'                   , 'B'      ],\n  ['A B'                   , 'B A'    ],\n  ['A B B A'               , 'B A'    ]\n].each {|m,n| order_disjoint(m,n)}\n", "target": "import java.util.Arrays;\nimport java.util.BitSet;\nimport org.apache.commons.lang3.ArrayUtils;\n\npublic class OrderDisjointItems {\n\n    public static void main(String[] args) {\n        final String[][] MNs = {{\"the cat sat on the mat\", \"mat cat\"},\n        {\"the cat sat on the mat\", \"cat mat\"},\n        {\"A B C A B C A B C\", \"C A C A\"}, {\"A B C A B D A B E\", \"E A D A\"},\n        {\"A B\", \"B\"}, {\"A B\", \"B A\"}, {\"A B B A\", \"B A\"}, {\"X X Y\", \"X\"}};\n\n        for (String[] a : MNs) {\n            String[] r = orderDisjointItems(a[0].split(\" \"), a[1].split(\" \"));\n            System.out.printf(\"%s | %s -> %s%n\", a[0], a[1], Arrays.toString(r));\n        }\n    }\n\n    \n    static String[] orderDisjointItems(String[] m, String[] n) {\n        for (String e : n) {\n            int idx = ArrayUtils.indexOf(m, e);\n            if (idx != -1)\n                m[idx] = null;\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (m[i] == null)\n                m[i] = n[j++];\n        }\n        return m;\n    }\n\n    \n    static String[] orderDisjointItems2(String[] m, String[] n) {\n        BitSet bitSet = new BitSet(m.length);\n        for (String e : n) {\n            int idx = -1;\n            do {\n                idx = ArrayUtils.indexOf(m, e, idx + 1);\n            } while (idx != -1 && bitSet.get(idx));\n            if (idx != -1)\n                bitSet.set(idx);\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (bitSet.get(i))\n                m[i] = n[j++];\n        }\n        return m;\n    }\n}\n"}
{"id": 425066, "name": "Sort stability", "source": "Translate Ruby to Java: ary = [[\"UK\", \"London\"],\n       [\"US\", \"New York\"],\n       [\"US\", \"Birmingham\"],\n       [\"UK\", \"Birmingham\"]]\np ary.sort {|a,b| a[1] <=> b[1]}\n\n\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class RJSortStability {\n\n  public static void main(String[] args) {\n    String[] cityList = { \"UK  London\", \"US  New York\", \"US  Birmingham\", \"UK  Birmingham\", };\n\n    String[] cn = cityList.clone();\n    System.out.println(\"\\nBefore sort:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    \n    Arrays.sort(cn, new Comparator<String>() {\n      public int compare(String lft, String rgt) {\n        return lft.substring(4).compareTo(rgt.substring(4));\n      }\n    });\n\n    System.out.println(\"\\nAfter sort on city:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    cn = cityList.clone();\n    System.out.println(\"\\nBefore sort:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    \n    Arrays.sort(cn, new Comparator<String>() {\n      public int compare(String lft, String rgt) {\n        return lft.substring(0, 2).compareTo(rgt.substring(0, 2));\n      }\n    });\n\n    System.out.println(\"\\nAfter sort on country:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    System.out.println();\n  }\n}\n"}
{"id": 425067, "name": "Interactive programming (repl)", "source": "Translate Ruby to Java: $ irb\nirb(main):001:0> def f(string1, string2, separator)\nirb(main):002:1>     [string1, '', string2].join(separator)\nirb(main):003:1> end\n=> :f\nirb(main):004:0> f('Rosetta', 'Code', ':')\n=> \"Rosetta::Code\"\nirb(main):005:0> exit\n$\n", "target": "public static void main(String[] args) {\n    System.out.println(concat(\"Rosetta\", \"Code\", \":\"));\n}\n\npublic static String concat(String a, String b, String c) {\n   return a + c + c + b;\n}\n\nRosetta::Code\n"}
{"id": 425068, "name": "Runtime evaluation_In an environment", "source": "Translate Ruby to Java: def bind_x_to_value(x)\n  binding\nend\n\ndef eval_with_x(code, a, b)\n  eval(code, bind_x_to_value(b)) - eval(code, bind_x_to_value(a))\nend\n\nputs eval_with_x('2 ** x', 3, 5) \n", "target": "import java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.Arrays;\nimport javax.tools.JavaCompiler;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.ToolProvider;\n\npublic class Eval {\n    private static final String CLASS_NAME = \"TempPleaseDeleteMe\";\n\n    private static class StringCompiler\n            extends SimpleJavaFileObject {\n        final String m_sourceCode;\n\n        private StringCompiler( final String sourceCode ) {\n            super( URI.create( \"string:\n            m_sourceCode = sourceCode;\n        }\n\n        @Override\n        public CharSequence getCharContent( final boolean ignoreEncodingErrors ) {\n            return m_sourceCode;\n        }\n\n        private boolean compile() {\n            final JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n\n            return javac.getTask( null, javac.getStandardFileManager( null, null, null ),\n                null, null, null, Arrays.asList( this )\n            ).call();\n        }\n\n        private double callEval( final double x )\n                throws Exception {\n            final Class<?> clarse = Class.forName( CLASS_NAME );\n            final Method   eval   = clarse.getMethod( \"eval\", double.class );\n\n            return ( Double ) eval.invoke( null, x );\n        }\n    }\n\n    public static double evalWithX( final String code, final double x )\n            throws Exception {\n        final StringCompiler sc = new StringCompiler(\n            \"class \"\n                + CLASS_NAME\n                + \"{public static double eval(double x){return (\"\n                + code\n                + \");}}\"\n            );\n\n        if ( ! sc.compile() ) throw new RuntimeException( \"Compiler error\" );\n        return sc.callEval( x );\n    }\n\n    public static void main( final String [] args ) \n            throws Exception  {\n        final String expression = args [ 0 ];\n        final double x1         = Double.parseDouble( args [ 1 ] );\n        final double x2         = Double.parseDouble( args [ 2 ] );\n\n        System.out.println(\n            evalWithX( expression, x1 )\n            - evalWithX( expression, x2 )\n        );\n    }\n}\n"}
{"id": 425069, "name": "Runtime evaluation_In an environment", "source": "Translate Ruby to Java: def bind_x_to_value(x)\n  binding\nend\n\ndef eval_with_x(code, a, b)\n  eval(code, bind_x_to_value(b)) - eval(code, bind_x_to_value(a))\nend\n\nputs eval_with_x('2 ** x', 3, 5) \n", "target": "import java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.Arrays;\nimport javax.tools.JavaCompiler;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.ToolProvider;\n\npublic class Eval {\n    private static final String CLASS_NAME = \"TempPleaseDeleteMe\";\n\n    private static class StringCompiler\n            extends SimpleJavaFileObject {\n        final String m_sourceCode;\n\n        private StringCompiler( final String sourceCode ) {\n            super( URI.create( \"string:\n            m_sourceCode = sourceCode;\n        }\n\n        @Override\n        public CharSequence getCharContent( final boolean ignoreEncodingErrors ) {\n            return m_sourceCode;\n        }\n\n        private boolean compile() {\n            final JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n\n            return javac.getTask( null, javac.getStandardFileManager( null, null, null ),\n                null, null, null, Arrays.asList( this )\n            ).call();\n        }\n\n        private double callEval( final double x )\n                throws Exception {\n            final Class<?> clarse = Class.forName( CLASS_NAME );\n            final Method   eval   = clarse.getMethod( \"eval\", double.class );\n\n            return ( Double ) eval.invoke( null, x );\n        }\n    }\n\n    public static double evalWithX( final String code, final double x )\n            throws Exception {\n        final StringCompiler sc = new StringCompiler(\n            \"class \"\n                + CLASS_NAME\n                + \"{public static double eval(double x){return (\"\n                + code\n                + \");}}\"\n            );\n\n        if ( ! sc.compile() ) throw new RuntimeException( \"Compiler error\" );\n        return sc.callEval( x );\n    }\n\n    public static void main( final String [] args ) \n            throws Exception  {\n        final String expression = args [ 0 ];\n        final double x1         = Double.parseDouble( args [ 1 ] );\n        final double x2         = Double.parseDouble( args [ 2 ] );\n\n        System.out.println(\n            evalWithX( expression, x1 )\n            - evalWithX( expression, x2 )\n        );\n    }\n}\n"}
{"id": 425070, "name": "Reverse the gender of a string", "source": "Translate Ruby to Java: var male2female = <<'EOD'\n  maleS femaleS, maleness femaleness, him her, himself herself, his her, his\n  hers, he she, Mr Mrs, Mister Missus, Ms Mr, Master Miss, MasterS MistressES,\n  uncleS auntS, nephewS nieceS, sonS daughterS, grandsonS granddaughterS,\n  brotherS sisterS, man woman, men women, boyS girlS, paternal maternal,\n  grandfatherS grandmotherS, GodfatherS GodmotherS, GodsonS GoddaughterS,\n  fianc\u00e9S fianc\u00e9eS, husband wife, husbands wives, fatherS motherS, bachelorS\n  spinsterS, bridegroomS brideS, widowerS widowS, KnightS DameS, Sir DameS,\n  KingS QueenS, DukeS DuchessES, PrinceS PrincessES, Lord Lady, Lords Ladies,\n  MarquessES MarchionessES, EarlS CountessES, ViscountS ViscountessES, ladS\n  lassES, sir madam, gentleman lady, gentlemen ladies, BaronS BaronessES,\n  stallionS mareS, ramS eweS, coltS fillieS, billy nanny, billies nannies,\n  bullS cowS, godS goddessES, heroS heroineS, shirtS blouseS, undies nickers,\n  sweat glow, jackarooS jillarooS, gigoloS hookerS, landlord landlady,\n  landlords landladies, manservantS maidservantS, actorS actressES, CountS\n  CountessES, EmperorS EmpressES, giantS giantessES, heirS heiressES, hostS\n  hostessES, lionS lionessES, managerS manageressES, murdererS murderessES,\n  priestS priestessES, poetS poetessES, shepherdS shepherdessES, stewardS\n  stewardessES, tigerS tigressES, waiterS waitressES, cockS henS, dogS bitchES,\n  drakeS henS, dogS vixenS, tomS tibS, boarS sowS, buckS roeS, peacockS\n  peahenS, gander goose, ganders geese, friarS nunS, monkS nunS\nEOD\n\u00a0\nvar m2f = male2female.split(/,\\s*/).map { |tok| tok.words}\n\u00a0\nvar re_plural = /E?S\\z/\nvar re_ES = /ES\\z/\n\u00a0\nfunc gen_pluralize(m, f) {\n    [\n        [m - re_plural, f - re_plural],\n        [m.sub(re_ES, 'es'), f.sub(re_ES, 'es')],\n        [m.sub(re_plural, 's'), f.sub(re_plural, 's')],\n    ]\n}\n\u00a0\nvar dict = Hash()\n\u00a0\nfor m,f in m2f {\n    for x,y in gen_pluralize(m, f).map{.map{.lc}} {\n        if (x ~~ dict) {\n            dict{y} = x\n        } else {\n            dict{x, y} = (y, x)\n        }\n    }\n}\n\u00a0\nvar gen_re = Regex.new('\\b(' + dict.keys.join('|') + ')\\b', 'i')\n\u00a0\nfunc copy_case(orig, repl) {\n    var a = orig.chars\n    var b = repl.chars\n\u00a0\n    var uc = 0\n    var min = [a, b].map{.len}.min\n    for i in ^min {\n        if (a[i] ~~ /^[[:upper:]]/) {\n            b[i].uc!\n            ++uc\n        }\n    }\n\u00a0\n    uc == min\u00a0? repl.uc\u00a0: b.join('')\n}\n\u00a0\nfunc reverse_gender(text) {\n    text.gsub(gen_re, { |a| copy_case(a, dict{a.lc}) })\n}\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 425071, "name": "Reverse the gender of a string", "source": "Translate Ruby to Java: var male2female = <<'EOD'\n  maleS femaleS, maleness femaleness, him her, himself herself, his her, his\n  hers, he she, Mr Mrs, Mister Missus, Ms Mr, Master Miss, MasterS MistressES,\n  uncleS auntS, nephewS nieceS, sonS daughterS, grandsonS granddaughterS,\n  brotherS sisterS, man woman, men women, boyS girlS, paternal maternal,\n  grandfatherS grandmotherS, GodfatherS GodmotherS, GodsonS GoddaughterS,\n  fianc\u00e9S fianc\u00e9eS, husband wife, husbands wives, fatherS motherS, bachelorS\n  spinsterS, bridegroomS brideS, widowerS widowS, KnightS DameS, Sir DameS,\n  KingS QueenS, DukeS DuchessES, PrinceS PrincessES, Lord Lady, Lords Ladies,\n  MarquessES MarchionessES, EarlS CountessES, ViscountS ViscountessES, ladS\n  lassES, sir madam, gentleman lady, gentlemen ladies, BaronS BaronessES,\n  stallionS mareS, ramS eweS, coltS fillieS, billy nanny, billies nannies,\n  bullS cowS, godS goddessES, heroS heroineS, shirtS blouseS, undies nickers,\n  sweat glow, jackarooS jillarooS, gigoloS hookerS, landlord landlady,\n  landlords landladies, manservantS maidservantS, actorS actressES, CountS\n  CountessES, EmperorS EmpressES, giantS giantessES, heirS heiressES, hostS\n  hostessES, lionS lionessES, managerS manageressES, murdererS murderessES,\n  priestS priestessES, poetS poetessES, shepherdS shepherdessES, stewardS\n  stewardessES, tigerS tigressES, waiterS waitressES, cockS henS, dogS bitchES,\n  drakeS henS, dogS vixenS, tomS tibS, boarS sowS, buckS roeS, peacockS\n  peahenS, gander goose, ganders geese, friarS nunS, monkS nunS\nEOD\n\u00a0\nvar m2f = male2female.split(/,\\s*/).map { |tok| tok.words}\n\u00a0\nvar re_plural = /E?S\\z/\nvar re_ES = /ES\\z/\n\u00a0\nfunc gen_pluralize(m, f) {\n    [\n        [m - re_plural, f - re_plural],\n        [m.sub(re_ES, 'es'), f.sub(re_ES, 'es')],\n        [m.sub(re_plural, 's'), f.sub(re_plural, 's')],\n    ]\n}\n\u00a0\nvar dict = Hash()\n\u00a0\nfor m,f in m2f {\n    for x,y in gen_pluralize(m, f).map{.map{.lc}} {\n        if (x ~~ dict) {\n            dict{y} = x\n        } else {\n            dict{x, y} = (y, x)\n        }\n    }\n}\n\u00a0\nvar gen_re = Regex.new('\\b(' + dict.keys.join('|') + ')\\b', 'i')\n\u00a0\nfunc copy_case(orig, repl) {\n    var a = orig.chars\n    var b = repl.chars\n\u00a0\n    var uc = 0\n    var min = [a, b].map{.len}.min\n    for i in ^min {\n        if (a[i] ~~ /^[[:upper:]]/) {\n            b[i].uc!\n            ++uc\n        }\n    }\n\u00a0\n    uc == min\u00a0? repl.uc\u00a0: b.join('')\n}\n\u00a0\nfunc reverse_gender(text) {\n    text.gsub(gen_re, { |a| copy_case(a, dict{a.lc}) })\n}\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 425072, "name": "Runtime evaluation", "source": "Translate Ruby to Java: a, b = 5, -7\nans = eval \"(a * b).abs\"  \n", "target": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URI;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.tools.FileObject;\nimport javax.tools.ForwardingJavaFileManager;\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileObject;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.StandardJavaFileManager;\nimport javax.tools.StandardLocation;\nimport javax.tools.ToolProvider;\n\npublic class Evaluator{\n    public static void main(String[] args){\n        new Evaluator().eval(\n            \"SayHello\",\n            \"public class SayHello{public void speak(){System.out.println(\\\"Hello world\\\");}}\",\n            \"speak\"\n        );\n    }\n\n    void eval(String className, String classCode, String methodName){\n        Map<String, ByteArrayOutputStream> classCache = new HashMap<>();\n        JavaCompiler                       compiler   = ToolProvider.getSystemJavaCompiler();\n\n        if ( null == compiler )\n            throw new RuntimeException(\"Could not get a compiler.\");\n\n        StandardJavaFileManager                            sfm  = compiler.getStandardFileManager(null, null, null);\n        ForwardingJavaFileManager<StandardJavaFileManager> fjfm = new ForwardingJavaFileManager<StandardJavaFileManager>(sfm){\n            @Override\n            public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling)\n                    throws IOException{\n                if (StandardLocation.CLASS_OUTPUT == location && JavaFileObject.Kind.CLASS == kind)\n                    return new SimpleJavaFileObject(URI.create(\"mem:\n                        @Override\n                        public OutputStream openOutputStream()\n                                throws IOException{\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            classCache.put(className, baos);\n                            return baos;\n                        }\n                    };\n                else\n                    throw new IllegalArgumentException(\"Unexpected output file requested: \" + location + \", \" + className + \", \" + kind);\n            }\n        };\n        List<JavaFileObject> files = new LinkedList<JavaFileObject>(){{\n            add(\n                new SimpleJavaFileObject(URI.create(\"string:\n                    @Override\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors){\n                        return classCode;\n                    }\n                }\n            );\n        }};\n\n        \n        compiler.getTask(null, fjfm, null, null, null, files).call();\n\n        try{\n            Class<?> clarse = new ClassLoader(){\n                @Override\n                public Class<?> findClass(String name){\n                    if (! name.startsWith(className))\n                        throw new IllegalArgumentException(\"This class loader is for \" + className + \" - could not handle \\\"\" + name + '\"');\n                    byte[] bytes = classCache.get(name).toByteArray();\n                    return defineClass(name, bytes, 0, bytes.length);\n                }\n            }.loadClass(className);\n\n            \n            clarse.getMethod(methodName).invoke(clarse.newInstance());\n\n        }catch(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException x){\n            throw new RuntimeException(\"Run failed: \" + x, x);\n        }\n    }\n}\n"}
{"id": 425073, "name": "Runtime evaluation", "source": "Translate Ruby to Java: a, b = 5, -7\nans = eval \"(a * b).abs\"  \n", "target": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URI;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.tools.FileObject;\nimport javax.tools.ForwardingJavaFileManager;\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileObject;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.StandardJavaFileManager;\nimport javax.tools.StandardLocation;\nimport javax.tools.ToolProvider;\n\npublic class Evaluator{\n    public static void main(String[] args){\n        new Evaluator().eval(\n            \"SayHello\",\n            \"public class SayHello{public void speak(){System.out.println(\\\"Hello world\\\");}}\",\n            \"speak\"\n        );\n    }\n\n    void eval(String className, String classCode, String methodName){\n        Map<String, ByteArrayOutputStream> classCache = new HashMap<>();\n        JavaCompiler                       compiler   = ToolProvider.getSystemJavaCompiler();\n\n        if ( null == compiler )\n            throw new RuntimeException(\"Could not get a compiler.\");\n\n        StandardJavaFileManager                            sfm  = compiler.getStandardFileManager(null, null, null);\n        ForwardingJavaFileManager<StandardJavaFileManager> fjfm = new ForwardingJavaFileManager<StandardJavaFileManager>(sfm){\n            @Override\n            public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling)\n                    throws IOException{\n                if (StandardLocation.CLASS_OUTPUT == location && JavaFileObject.Kind.CLASS == kind)\n                    return new SimpleJavaFileObject(URI.create(\"mem:\n                        @Override\n                        public OutputStream openOutputStream()\n                                throws IOException{\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            classCache.put(className, baos);\n                            return baos;\n                        }\n                    };\n                else\n                    throw new IllegalArgumentException(\"Unexpected output file requested: \" + location + \", \" + className + \", \" + kind);\n            }\n        };\n        List<JavaFileObject> files = new LinkedList<JavaFileObject>(){{\n            add(\n                new SimpleJavaFileObject(URI.create(\"string:\n                    @Override\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors){\n                        return classCode;\n                    }\n                }\n            );\n        }};\n\n        \n        compiler.getTask(null, fjfm, null, null, null, files).call();\n\n        try{\n            Class<?> clarse = new ClassLoader(){\n                @Override\n                public Class<?> findClass(String name){\n                    if (! name.startsWith(className))\n                        throw new IllegalArgumentException(\"This class loader is for \" + className + \" - could not handle \\\"\" + name + '\"');\n                    byte[] bytes = classCache.get(name).toByteArray();\n                    return defineClass(name, bytes, 0, bytes.length);\n                }\n            }.loadClass(className);\n\n            \n            clarse.getMethod(methodName).invoke(clarse.newInstance());\n\n        }catch(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException x){\n            throw new RuntimeException(\"Run failed: \" + x, x);\n        }\n    }\n}\n"}
{"id": 425074, "name": "Index finite lists of positive integers", "source": "Translate Ruby to Java: def rank(arr)\n  arr.join('a').to_i(11)\nend\n\ndef unrank(n)\n  n.to_s(11).split('a').map(&:to_i)\nend\n\nl = [1, 2, 3, 10, 100, 987654321]\np l\nn = rank(l)\np n\nl = unrank(n)\np l\n", "target": "import java.math.BigInteger;\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.Collectors.*;\n\npublic class Test3 {\n    static BigInteger rank(int[] x) {\n        String s = stream(x).mapToObj(String::valueOf).collect(joining(\"F\"));\n        return new BigInteger(s, 16);\n    }\n\n    static List<BigInteger> unrank(BigInteger n) {\n        BigInteger sixteen = BigInteger.valueOf(16);\n        String s = \"\";\n        while (!n.equals(BigInteger.ZERO)) {\n            s = \"0123456789ABCDEF\".charAt(n.mod(sixteen).intValue()) + s;\n            n = n.divide(sixteen);\n        }\n        return stream(s.split(\"F\")).map(x -> new BigInteger(x)).collect(toList());\n    }\n\n    public static void main(String[] args) {\n        int[] s = {1, 2, 3, 10, 100, 987654321};\n        System.out.println(Arrays.toString(s));\n        System.out.println(rank(s));\n        System.out.println(unrank(rank(s)));\n    }\n}\n"}
{"id": 425075, "name": "Generate random numbers without repeating a value", "source": "Translate Ruby to Java: nums = (1..20).to_a\n5.times{ puts nums.shuffle.join(\" \") }\n", "target": "import java.util.*;\n\npublic class RandomShuffle {\n    public static void main(String[] args) {\n        Random rand = new Random();\n        List<Integer> list = new ArrayList<>();\n        for (int j = 1; j <= 20; ++j)\n            list.add(j);\n        Collections.shuffle(list, rand);\n        System.out.println(list);\n    }\n}\n"}
{"id": 425076, "name": "Read a file character by character_UTF8", "source": "Translate Ruby to Java: File.open(\"input.txt\") do |file|\n  file.each_char { |c| p c }\nend\n", "target": "import java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n    \tfinal int endOfFile = -1;\n    \t\n        try ( FileReader reader = new FileReader(\"input.txt\", StandardCharsets.UTF_8) ) {\n\t\t\twhile ( true ) {\n\t\t\t    int ch = reader.read();\n\t\t\t    if ( ch == endOfFile ) {\n\t\t\t    \tbreak;\n\t\t\t    }\n\t\t\t    \n\t\t\t    System.out.print(Character.toChars(ch));\n\t\t\t}\n\t\t}\n    }\n}\n"}
{"id": 425077, "name": "Galton box animation", "source": "Translate Ruby to Java: $rows_of_pins = 12\n$width = $rows_of_pins * 10 + ($rows_of_pins+1)*14\n\nShoes.app(\n    :width => $width + 14,\n    :title => \"Galton Box\"\n) do\n  @bins = Array.new($rows_of_pins+1, 0)\n\n  @x_coords = Array.new($rows_of_pins) {Array.new}\n  @y_coords = Array.new($rows_of_pins)\n  stack(:width => $width) do\n    stroke gray\n    fill gray\n    1.upto($rows_of_pins) do |row|\n      y = 14 + 24*row\n      @y_coords[row-1] = y\n      row.times do |i|\n        x = $width / 2 + (i - 0.5*row)*24 + 14\n        @x_coords[row-1] << x\n        oval x+2, y, 6\n      end\n    end\n  end\n  @y_coords << @y_coords[-1] + 24\n  @x_coords << @x_coords[-1].map {|x| x-12} + [@x_coords[-1][-1]+12]\n\n  @balls = stack(:width => $width) do\n    stroke red\n    fill red\n  end.move(0,0)\n\n  @histogram = stack(:width => $width) do\n    nostroke\n    fill black\n  end.move(0, @y_coords[-1] + 10)\n\n  @paused = false\n  keypress do |key|\n    case key\n    when \"\\x11\", :control_q\n      exit\n    when \"\\x10\", :control_p\n      @paused = !@paused\n    end\n  end\n\n  @ball_row = 0\n  @ball_col = 0\n  animate(2*$rows_of_pins) do\n    if not @paused\n      y = @y_coords[@ball_row] - 12\n      x = @x_coords[@ball_row][@ball_col]\n      @balls.clear {oval x, y, 10}\n      @ball_row += 1\n      if @ball_row <= $rows_of_pins\n        @ball_col += 1 if rand >= 0.5\n      else\n        @bins[@ball_col] += 1\n        @ball_row = @ball_col = 0\n        update_histogram\n      end\n    end\n  end\n\n  def update_histogram\n    y = @y_coords[-1] + 10\n    @histogram.clear do\n      @bins.each_with_index do |num, i|\n        if num > 0\n          x = @x_coords[-1][i]\n          rect x-6, 0, 24, num\n        end\n      end\n    end\n  end\nend\n", "target": "import java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GaltonBox {\n    public static void main( final String[] args ) {\n        new GaltonBox( 8, 200 ).run();\n    }\n\n    private final int        m_pinRows;\n    private final int        m_startRow;\n    private final Position[] m_balls;\n    private final Random     m_random = new Random();\n\n    public GaltonBox( final int pinRows, final int ballCount ) {\n        m_pinRows  = pinRows;\n        m_startRow = pinRows + 1;\n        m_balls    = new Position[ ballCount ];\n\n        for ( int ball = 0; ball < ballCount; ball++ )\n            m_balls[ ball ] = new Position( m_startRow, 0, 'o' );\n    }\n\n    private static class Position {\n        int  m_row;\n        int  m_col;\n        char m_char;\n\n        Position( final int row, final int col, final char ch ) {\n            m_row  = row;\n            m_col  = col;\n            m_char = ch;\n        }\n    }\n\n    public void run() {\n        for ( int ballsInPlay = m_balls.length; ballsInPlay > 0;  ) {\n            ballsInPlay = dropBalls();\n            print();\n        }\n    }\n\n    private int dropBalls() {\n        int ballsInPlay = 0;\n        int ballToStart = -1;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( m_balls[ ball ].m_row == m_startRow )\n                ballToStart = ball;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( ball == ballToStart ) {\n                m_balls[ ball ].m_row = m_pinRows;\n                ballsInPlay++;\n            }\n            else if ( m_balls[ ball ].m_row > 0 && m_balls[ ball ].m_row != m_startRow ) {\n                m_balls[ ball ].m_row -= 1;\n                m_balls[ ball ].m_col += m_random.nextInt( 2 );\n                if ( 0 != m_balls[ ball ].m_row )\n                    ballsInPlay++;\n            }\n\n        return ballsInPlay;\n    }\n\n    private void print() {\n        for ( int row = m_startRow; row --> 1;  ) {\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == row )\n                    printBall( m_balls[ ball ] );\n            System.out.println();\n            printPins( row );\n        }\n        printCollectors();\n        System.out.println();\n    }\n\n    private static void printBall( final Position pos ) {\n        for ( int col = pos.m_row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = 0; col < pos.m_col; col++ )\n            System.out.print( \"  \" );\n        System.out.print( pos.m_char );\n    }\n\n    private void printPins( final int row ) {\n        for ( int col = row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = m_startRow - row; col --> 0;  )\n            System.out.print( \". \" );\n        System.out.println();\n    }\n\n    private void printCollectors() {\n        final List<List<Position>> collectors = new ArrayList<List<Position>>();\n\n        for ( int col = 0; col < m_startRow; col++ ) {\n            final List<Position> collector = new ArrayList<Position>();\n\n            collectors.add( collector );\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == 0 && m_balls[ ball ].m_col == col )\n                    collector.add( m_balls[ ball ] );\n        }\n\n        for ( int row = 0, rows = longest( collectors ); row < rows; row++ ) {\n            for ( int col = 0; col < m_startRow; col++ ) {\n                final List<Position> collector = collectors.get( col );\n                final int            pos       = row + collector.size() - rows;\n\n                System.out.print( '|' );\n                if ( pos >= 0 )\n                    System.out.print( collector.get( pos ).m_char );\n                else\n                    System.out.print( ' ' );\n            }\n            System.out.println( '|' );\n        }\n    }\n\n    private static final int longest( final List<List<Position>> collectors ) {\n        int result = 0;\n\n        for ( final List<Position> collector : collectors )\n            result = Math.max( collector.size(), result );\n\n        return result;\n    }\n}\n"}
{"id": 425078, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Ruby to Java: var maxsum = 99\nvar primes = maxsum.primes\n\nvar descendants = (maxsum+1).of { [] }\nvar ancestors   = (maxsum+1).of { [] }\n\nfor p in (primes) {\n    descendants[p] << p\n    for s in (1 .. descendants.end-p) {\n        descendants[s + p] << descendants[s].map {|q| p*q }...\n    }\n}\n\nfor p in (primes + [4]) {\n    descendants[p].pop\n}\n\nvar total = 0\n\nfor s in (1 .. maxsum) {\n\n    descendants[s].sort!\n\n    total += (var dsclen = descendants[s].len)\n    var idx = descendants[s].first_index {|x| x > maxsum }\n\n    for d in (descendants[s].slice(0, idx)) {\n        ancestors[d] = (ancestors[s] + [s])\n    }\n\n    if ((s <= 20) || (s ~~ [46, 74, 99])) {\n        printf(\"%2d: %d Ancestor(s):\u00a0%-15s %5s Descendant(s): %s\\n\", s,\n            ancestors[s].len, \"[\n            dsclen <= 10 ? descendants[s] : \"[\n    }\n}\n\nsay \"\\nTotal descendants: \n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class PrimeDescendants {\n    public static void main(String[] args) {\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(System.out))) {\n            printPrimeDesc(writer, 100);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private static void printPrimeDesc(Writer writer, int limit) throws IOException {\n        List<Long> primes = findPrimes(limit);\n\n        List<Long> ancestor = new ArrayList<>(limit);\n        List<List<Long>> descendants = new ArrayList<>(limit);\n        for (int i = 0; i < limit; ++i) {\n            ancestor.add(Long.valueOf(0));\n            descendants.add(new ArrayList<Long>());\n        }\n\n        for (Long prime : primes) {\n            int p = prime.intValue();\n            descendants.get(p).add(prime);\n            for (int i = 0; i + p < limit; ++i) {\n                int s = i + p;\n                for (Long n : descendants.get(i)) {\n                    Long prod = n * p;\n                    descendants.get(s).add(prod);\n                    if (prod < limit)\n                        ancestor.set(prod.intValue(), Long.valueOf(s));\n                }\n            }\n        }\n\n        \n        int totalDescendants = 0;\n        for (int i = 1; i < limit; ++i) {\n            List<Long> ancestors = getAncestors(ancestor, i);\n            writer.write(\"[\" + i + \"] Level: \" + ancestors.size() + \"\\n\");\n            writer.write(\"Ancestors: \");\n            Collections.sort(ancestors);\n            print(writer, ancestors);\n\n            writer.write(\"Descendants: \");\n            List<Long> desc = descendants.get(i);\n            if (!desc.isEmpty()) {\n                Collections.sort(desc);\n                if (desc.get(0) == i)\n                    desc.remove(0);\n            }\n            writer.write(desc.size() + \"\\n\");\n            totalDescendants += desc.size();\n            if (!desc.isEmpty())\n                print(writer, desc);\n            writer.write(\"\\n\");\n        }\n        writer.write(\"Total descendants: \" + totalDescendants + \"\\n\");\n    }\n\n    \n    private static List<Long> findPrimes(int limit) {\n        boolean[] isprime = new boolean[limit];\n        Arrays.fill(isprime, true);\n        isprime[0] = isprime[1] = false;\n        for (int p = 2; p * p < limit; ++p) {\n            if (isprime[p]) {\n                for (int i = p * p; i < limit; i += p)\n                    isprime[i] = false;\n            }\n        }\n        List<Long> primes = new ArrayList<>();\n        for (int p = 2; p < limit; ++p) {\n            if (isprime[p])\n                primes.add(Long.valueOf(p));\n        }\n        return primes;\n    }\n\n    \n    private static List<Long> getAncestors(List<Long> ancestor, int n) {\n        List<Long> result = new ArrayList<>();\n        for (Long a = ancestor.get(n); a != 0 && a != n; ) {\n            n = a.intValue();\n            a = ancestor.get(n);\n            result.add(Long.valueOf(n));\n        }\n        return result;\n    }\n\n    private static void print(Writer writer, List<Long> list) throws IOException {\n        if (list.isEmpty()) {\n            writer.write(\"none\\n\");\n            return;\n        }\n        int i = 0;\n        writer.write(String.valueOf(list.get(i++)));\n        for (; i != list.size(); ++i)\n            writer.write(\", \" + list.get(i));\n        writer.write(\"\\n\");\n    }\n}\n"}
{"id": 425079, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Ruby to Java: class Array\n  def circle_sort!\n    while _circle_sort!(0, size-1) > 0\n    end\n    self\n  end\n  \n  private\n  def _circle_sort!(lo, hi, swaps=0)\n    return swaps if lo == hi\n    low, high = lo, hi\n    mid = (lo + hi) / 2\n    while lo < hi\n      if self[lo] > self[hi]\n        self[lo], self[hi] = self[hi], self[lo]\n        swaps += 1\n      end\n      lo += 1\n      hi -= 1\n    end\n    if lo == hi && self[lo] > self[hi+1]\n      self[lo], self[hi+1] = self[hi+1], self[lo]\n      swaps += 1\n    end\n    swaps + _circle_sort!(low, mid) + _circle_sort!(mid+1, high)\n  end\nend\n\nary = [6, 7, 8, 9, 2, 5, 3, 4, 1]\nputs \"before sort: \nputs \" after sort: \n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 425080, "name": "Brace expansion", "source": "Translate Ruby to Java: def getitem(s, depth=0)\n  out = [\"\"]\n  until s.empty?\n    c = s[0]\n    break  if depth>0 and (c == ',' or c == '}')\n    if c == '{' and x = getgroup(s[1..-1], depth+1)\n      out = out.product(x[0]).map{|a,b| a+b}\n      s = x[1]\n    else\n      s, c = s[1..-1], c + s[1]  if c == '\\\\' and s.size > 1\n      out, s = out.map{|a| a+c}, s[1..-1]\n    end\n  end\n  return out, s\nend\n\ndef getgroup(s, depth)\n  out, comma = [], false\n  until s.empty?\n    g, s = getitem(s, depth)\n    break  if s.empty?\n    out += g\n    case s[0]\n      when '}' then return (comma ? out : out.map{|a| \"{\n      when ',' then comma, s = true, s[1..-1]\n    end\n  end\nend\n\nstrs = <<'EOS'\n~/{Downloads,Pictures}/*.{jpg,gif,png}\nIt{{em,alic}iz,erat}e{d,}, please.\n{,{,gotta have{ ,\\, again\\, }}more }cowbell!\n{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\nEOS\n\nstrs.each_line do |s|\n  puts s.chomp!\n  puts getitem(s)[0].map{|str| \"\\t\"+str}\n  puts\nend\n", "target": "public class BraceExpansion {\n\n    public static void main(String[] args) {\n        for (String s : new String[]{\"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\",\n            \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"}) {\n            System.out.println();\n            expand(s);\n        }\n    }\n\n    public static void expand(String s) {\n        expandR(\"\", s, \"\");\n    }\n\n    private static void expandR(String pre, String s, String suf) {\n        int i1 = -1, i2 = 0;\n        String noEscape = s.replaceAll(\"([\\\\\\\\]{2}|[\\\\\\\\][,}{])\", \"  \");\n        StringBuilder sb = null;\n\n        outer:\n        while ((i1 = noEscape.indexOf('{', i1 + 1)) != -1) {\n            i2 = i1 + 1;\n            sb = new StringBuilder(s);\n            for (int depth = 1; i2 < s.length() && depth > 0; i2++) {\n                char c = noEscape.charAt(i2);\n                depth = (c == '{') ? ++depth : depth;\n                depth = (c == '}') ? --depth : depth;\n                if (c == ',' && depth == 1) {\n                    sb.setCharAt(i2, '\\u0000');\n                } else if (c == '}' && depth == 0 && sb.indexOf(\"\\u0000\") != -1)\n                    break outer;\n            }\n        }\n        if (i1 == -1) {\n            if (suf.length() > 0)\n                expandR(pre + s, suf, \"\");\n            else\n                System.out.printf(\"%s%s%s%n\", pre, s, suf);\n        } else {\n            for (String m : sb.substring(i1 + 1, i2).split(\"\\u0000\", -1))\n                expandR(pre + s.substring(0, i1), m, s.substring(i2 + 1) + suf);\n        }\n    }\n}\n"}
{"id": 425081, "name": "Intersecting number wheels", "source": "Translate Ruby to Java: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 425082, "name": "Intersecting number wheels", "source": "Translate Ruby to Java: groups = [{A: [1, 2, 3]},\n          {A: [1, :B, 2], B: [3, 4]},\n          {A: [1, :D, :D], D: [6, 7, 8]},\n          {A: [1, :B, :C], B: [3, 4], C: [5, :B]} ]\n\ngroups.each do |group|\n  p group\n  wheels = group.transform_values(&:cycle) \n  res = 20.times.map do\n    el = wheels[:A].next\n    el = wheels[el].next until el.is_a?(Integer)\n    el\n  end\n  puts res.join(\" \"),\"\"\nend\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 425083, "name": "Color of a screen pixel", "source": "Translate Ruby to Java: module Screen\n  IMPORT_COMMAND = '/usr/bin/import'\n\n  \n  def self.pixel(x, y)\n    if m = `\n      m[1..3].map(&:to_i)\n    else\n      false\n    end\n  end\nend\n", "target": "public static Color getColorAt(int x, int y){\n   return new Robot().getPixelColor(x, y);\n}\n"}
{"id": 425084, "name": "Yahoo! search interface", "source": "Translate Ruby to Java: require 'open-uri'\nrequire 'hpricot'\n\nSearchResult = Struct.new(:url, :title, :content)\n\nclass SearchYahoo\n  @@urlinfo = [nil, 'ca.search.yahoo.com', 80, '/search', nil, nil]\n\n  def initialize(term)\n    @term = term\n    @page = 1\n    @results = nil\n    @url = URI::HTTP.build(@@urlinfo)\n  end\n\n  def next_result\n    if not @results\n      @results = []\n      fetch_results\n    elsif @results.empty?\n      next_page\n    end\n    @results.shift\n  end\n\n  def fetch_results\n    @url.query = URI.escape(\"p=%s&b=%d\" % [@term, @page])\n    doc = open(@url) { |f| Hpricot(f) }  \n    parse_html(doc)\n  end\n\n  def next_page\n    @page += 10\n    fetch_results\n  end\n\n  def parse_html(doc)\n    doc.search(\"div\n      next unless div.has_attribute?(\"class\") and div.get_attribute(\"class\").index(\"res\") == 0\n      result = SearchResult.new\n      div.search(\"a\").each do |link|\n        next unless link.has_attribute?(\"class\") and link.get_attribute(\"class\") == \"yschttl spt\"\n        result.url = link.get_attribute(\"href\")\n        result.title = link.inner_text\n      end\n      div.search(\"div\").each do |abstract|\n        next unless abstract.has_attribute?(\"class\") and abstract.get_attribute(\"class\").index(\"abstr\")\n        result.content = abstract.inner_text\n      end\n      @results << result\n    end\n  end\nend\n\ns = SearchYahoo.new(\"test\")\n15.times do |i|\n  result = s.next_result\n  puts i+1\n  puts result.title\n  puts result.url\n  puts result.content\n  puts\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass YahooSearch {\n    private String query;\n    \n    private int page = 1;\n    \n    private static final Pattern pattern = Pattern.compile(\n        \"<a class=\\\"yschttl spt\\\" href=\\\"[^*]+?\\\\*\\\\*([^\\\"]+?)\\\">(.+?)</a></h3>.*?<div class=\\\"(?:sm-abs|abstr)\\\">(.+?)</div>\");\n\n    public YahooSearch(String query) {\n        this.query = query;\n    }\n\n    public List<YahooResult> search() throws MalformedURLException, URISyntaxException, IOException {\n        \n        \n        StringBuilder searchUrl = new StringBuilder(\"http:\n        searchUrl.append(\"p=\").append(URLEncoder.encode(query, \"UTF-8\"));\n        if (page > 1) {searchUrl.append(\"&b=\").append((page - 1) * 10 + 1);}\n        \n        URL url = new URL(searchUrl.toString());\n        List<YahooResult> result = new ArrayList<YahooResult>();\n        StringBuilder sb = new StringBuilder();\n        \n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(url.openStream()));\n            \n            String line = in.readLine();\n            while (line != null) {\n                sb.append(line);\n                line = in.readLine();\n            }\n        }\n        catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        finally {\n            try {in.close();} catch (Exception ignoreMe) {}\n        }\n        String searchResult = sb.toString();\n        \n        Matcher matcher = pattern.matcher(searchResult);\n        while (matcher.find()) {\n            \n            String resultUrl = URLDecoder.decode(matcher.group(1), \"UTF-8\");\n            String resultTitle = matcher.group(2).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            String resultContent = matcher.group(3).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            \n            result.add(new YahooResult(resultUrl, resultTitle, resultContent));\n        }\n        return result;\n    }\n\n    public List<YahooResult> search(int page) throws MalformedURLException, URISyntaxException, IOException {\n        \n        this.page = page;\n        return search();\n    }\n\n    public List<YahooResult> nextPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        page++;\n        return search();\n    }\n\n    public List<YahooResult> previousPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        if (page > 1) {\n            page--;\n            return search();\n        } else return new ArrayList<YahooResult>();\n    }\n}\n\nclass YahooResult {\n    private URL url;\n    private String title;\n    private String content;\n\n    public URL getUrl() {\n        return url;\n    }\n\n    public void setUrl(URL url) {\n        this.url = url;\n    }\n\n    public void setUrl(String url) throws MalformedURLException {\n        this.url = new URL(url);\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public YahooResult(URL url, String title, String content) {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    public YahooResult(String url, String title, String content) throws MalformedURLException {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (title != null) {\n            sb.append(\",title=\").append(title);\n        }\n        if (url != null) {\n            sb.append(\",url=\").append(url);\n        }\n        return sb.charAt(0) == ',' ? sb.substring(1) : sb.toString();\n    }\n}\n\npublic class TestYahooSearch {\n    public static void main(String[] args) throws MalformedURLException, URISyntaxException, IOException {\n        \n        YahooSearch search = new YahooSearch(\"Rosetta code\");\n        \n        List<YahooResult> results = search.search();\n        \n        for (YahooResult result : results) {\n            System.out.println(result.toString());\n        }\n    }\n}\n"}
{"id": 425085, "name": "Circles of given radius through two points", "source": "Translate Ruby to Java: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425086, "name": "Circles of given radius through two points", "source": "Translate Ruby to Java: Pt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  \n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  \n  q = Math.hypot(dx, dy)\n  \n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  \n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  \n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  \n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425087, "name": "Vampire number", "source": "Translate Ruby to Java: def factor_pairs n\n  first = n / (10 ** (n.to_s.size / 2) - 1)\n  (first .. n ** 0.5).map { |i| [i, n / i] if n % i == 0 }.compact\nend\n\ndef vampire_factors n\n  return [] if n.to_s.size.odd?\n  half = n.to_s.size / 2\n  factor_pairs(n).select do |a, b|\n    a.to_s.size == half && b.to_s.size == half &&\n    [a, b].count {|x| x%10 == 0} != 2          &&\n    \"\n  end\nend\n\ni = vamps = 0\nuntil vamps == 25\n  vf = vampire_factors(i += 1)\n  unless vf.empty?\n    puts \"\n    vamps += 1\n  end\nend\n\n[16758243290880, 24959017348650, 14593825548650].each do |n|\n  if (vf = vampire_factors n).empty?\n    puts \"\n  else\n    puts \"\n  end\nend\n", "target": "import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class VampireNumbers{\n    private static int numDigits(long num){\n        return Long.toString(Math.abs(num)).length();\n    }\n\n    private static boolean fangCheck(long orig, long fang1, long fang2){\n        if(Long.toString(fang1).endsWith(\"0\") && Long.toString(fang2).endsWith(\"0\")) return false;\n\n        int origLen = numDigits(orig);\n        if(numDigits(fang1) != origLen / 2 || numDigits(fang2) != origLen / 2) return false;\n\n        byte[] origBytes = Long.toString(orig).getBytes();\n        byte[] fangBytes = (Long.toString(fang1) + Long.toString(fang2)).getBytes();\n        Arrays.sort(origBytes);\n        Arrays.sort(fangBytes);\n        return Arrays.equals(origBytes, fangBytes);\n    }\n\n    public static void main(String[] args){\n        HashSet<Long> vamps = new HashSet<Long>();\n        for(long i = 10; vamps.size() <= 25; i++ ){\n            if((numDigits(i) % 2) != 0) {i = i * 10 - 1; continue;}\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        vamps.add(i);\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n        Long[] nums = {16758243290880L, 24959017348650L, 14593825548650L};\n        for(Long i : nums){\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425088, "name": "Cistercian numerals", "source": "Translate Ruby to Java: def initN\n    n = Array.new(15){Array.new(11, ' ')}\n    for i in 1..15\n        n[i - 1][5] = 'x'\n    end\n    return n\nend\n\ndef horiz(n, c1, c2, r)\n    for c in c1..c2\n        n[r][c] = 'x'\n    end\nend\n\ndef verti(n, r1, r2, c)\n    for r in r1..r2\n        n[r][c] = 'x'\n    end\nend\n\ndef diagd(n, c1, c2, r)\n    for c in c1..c2\n        n[r+c-c1][c] = 'x'\n    end\nend\n\ndef diagu(n, c1, c2, r)\n    for c in c1..c2\n        n[r-c+c1][c] = 'x'\n    end\nend\n\ndef initDraw\n    draw = []\n\n    draw[1] = lambda do |n| horiz(n, 6, 10, 0) end\n    draw[2] = lambda do |n| horiz(n, 6, 10, 4) end\n    draw[3] = lambda do |n| diagd(n, 6, 10, 0) end\n    draw[4] = lambda do |n| diagu(n, 6, 10, 4) end\n    draw[5] = lambda do |n|\n        draw[1].call(n)\n        draw[4].call(n)\n    end\n    draw[6] = lambda do |n| verti(n, 0, 4, 10) end\n    draw[7] = lambda do |n|\n        draw[1].call(n)\n        draw[6].call(n)\n    end\n    draw[8] = lambda do |n|\n        draw[2].call(n)\n        draw[6].call(n)\n    end\n    draw[9] = lambda do |n|\n        draw[1].call(n)\n        draw[8].call(n)\n    end\n\n    draw[10] = lambda do |n| horiz(n, 0, 4, 0) end\n    draw[20] = lambda do |n| horiz(n, 0, 4, 4) end\n    draw[30] = lambda do |n| diagu(n, 0, 4, 4) end\n    draw[40] = lambda do |n| diagd(n, 0, 4, 0) end\n    draw[50] = lambda do |n|\n        draw[10].call(n)\n        draw[40].call(n)\n    end\n    draw[60] = lambda do |n| verti(n, 0, 4, 0) end\n    draw[70] = lambda do |n|\n        draw[10].call(n)\n        draw[60].call(n)\n    end\n    draw[80] = lambda do |n|\n        draw[20].call(n)\n        draw[60].call(n)\n    end\n    draw[90] = lambda do |n|\n        draw[10].call(n)\n        draw[80].call(n)\n    end\n\n    draw[100] = lambda do |n| horiz(n, 6, 10, 14) end\n    draw[200] = lambda do |n| horiz(n, 6, 10, 10) end\n    draw[300] = lambda do |n| diagu(n, 6, 10, 14) end\n    draw[400] = lambda do |n| diagd(n, 6, 10, 10) end\n    draw[500] = lambda do |n|\n        draw[100].call(n)\n        draw[400].call(n)\n    end\n    draw[600] = lambda do |n| verti(n, 10, 14, 10) end\n    draw[700] = lambda do |n|\n        draw[100].call(n)\n        draw[600].call(n)\n    end\n    draw[800] = lambda do |n|\n        draw[200].call(n)\n        draw[600].call(n)\n    end\n    draw[900] = lambda do |n|\n        draw[100].call(n)\n        draw[800].call(n)\n    end\n\n    draw[1000] = lambda do |n| horiz(n, 0, 4, 14) end\n    draw[2000] = lambda do |n| horiz(n, 0, 4, 10) end\n    draw[3000] = lambda do |n| diagd(n, 0, 4, 10) end\n    draw[4000] = lambda do |n| diagu(n, 0, 4, 14) end\n    draw[5000] = lambda do |n|\n        draw[1000].call(n)\n        draw[4000].call(n)\n    end\n    draw[6000] = lambda do |n| verti(n, 10, 14, 0) end\n    draw[7000] = lambda do |n|\n        draw[1000].call(n)\n        draw[6000].call(n)\n    end\n    draw[8000] = lambda do |n|\n        draw[2000].call(n)\n        draw[6000].call(n)\n    end\n    draw[9000] = lambda do |n|\n        draw[1000].call(n)\n        draw[8000].call(n)\n    end\n\n    return draw\nend\n\ndef printNumeral(n)\n    for a in n\n        for b in a\n            print b\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndraw = initDraw()\nfor number in [0, 1, 20, 300, 4000, 5555, 6789, 9999]\n    n = initN()\n    print number, \":\\n\"\n\n    thousands = (number / 1000).floor\n    number = number % 1000\n\n    hundreds = (number / 100).floor\n    number = number % 100\n\n    tens = (number / 10).floor\n    ones = number % 10\n\n    if thousands > 0 then\n        draw[thousands * 1000].call(n)\n    end\n    if hundreds > 0 then\n        draw[hundreds * 100].call(n)\n    end\n    if tens > 0 then\n        draw[tens * 10].call(n)\n    end\n    if ones > 0 then\n        draw[ones].call(n)\n    end\n    printNumeral(n)\nend\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Cistercian {\n    private static final int SIZE = 15;\n    private final char[][] canvas = new char[SIZE][SIZE];\n\n    public Cistercian(int n) {\n        initN();\n        draw(n);\n    }\n\n    public void initN() {\n        for (var row : canvas) {\n            Arrays.fill(row, ' ');\n            row[5] = 'x';\n        }\n    }\n\n    private void horizontal(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void vertical(int r1, int r2, int c) {\n        for (int r = r1; r <= r2; r++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void diagd(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r + c - c1][c] = 'x';\n        }\n    }\n\n    private void diagu(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r - c + c1][c] = 'x';\n        }\n    }\n\n    private void draw(int v) {\n        var thousands = v / 1000;\n        v %= 1000;\n\n        var hundreds = v / 100;\n        v %= 100;\n\n        var tens = v / 10;\n        var ones = v % 10;\n\n        drawPart(1000 * thousands);\n        drawPart(100 * hundreds);\n        drawPart(10 * tens);\n        drawPart(ones);\n    }\n\n    private void drawPart(int v) {\n        switch (v) {\n            case 1:\n                horizontal(6, 10, 0);\n                break;\n            case 2:\n                horizontal(6, 10, 4);\n                break;\n            case 3:\n                diagd(6, 10, 0);\n                break;\n            case 4:\n                diagu(6, 10, 4);\n                break;\n            case 5:\n                drawPart(1);\n                drawPart(4);\n                break;\n            case 6:\n                vertical(0, 4, 10);\n                break;\n            case 7:\n                drawPart(1);\n                drawPart(6);\n                break;\n            case 8:\n                drawPart(2);\n                drawPart(6);\n                break;\n            case 9:\n                drawPart(1);\n                drawPart(8);\n                break;\n\n            case 10:\n                horizontal(0, 4, 0);\n                break;\n            case 20:\n                horizontal(0, 4, 4);\n                break;\n            case 30:\n                diagu(0, 4, 4);\n                break;\n            case 40:\n                diagd(0, 4, 0);\n                break;\n            case 50:\n                drawPart(10);\n                drawPart(40);\n                break;\n            case 60:\n                vertical(0, 4, 0);\n                break;\n            case 70:\n                drawPart(10);\n                drawPart(60);\n                break;\n            case 80:\n                drawPart(20);\n                drawPart(60);\n                break;\n            case 90:\n                drawPart(10);\n                drawPart(80);\n                break;\n\n            case 100:\n                horizontal(6, 10, 14);\n                break;\n            case 200:\n                horizontal(6, 10, 10);\n                break;\n            case 300:\n                diagu(6, 10, 14);\n                break;\n            case 400:\n                diagd(6, 10, 10);\n                break;\n            case 500:\n                drawPart(100);\n                drawPart(400);\n                break;\n            case 600:\n                vertical(10, 14, 10);\n                break;\n            case 700:\n                drawPart(100);\n                drawPart(600);\n                break;\n            case 800:\n                drawPart(200);\n                drawPart(600);\n                break;\n            case 900:\n                drawPart(100);\n                drawPart(800);\n                break;\n\n            case 1000:\n                horizontal(0, 4, 14);\n                break;\n            case 2000:\n                horizontal(0, 4, 10);\n                break;\n            case 3000:\n                diagd(0, 4, 10);\n                break;\n            case 4000:\n                diagu(0, 4, 14);\n                break;\n            case 5000:\n                drawPart(1000);\n                drawPart(4000);\n                break;\n            case 6000:\n                vertical(10, 14, 0);\n                break;\n            case 7000:\n                drawPart(1000);\n                drawPart(6000);\n                break;\n            case 8000:\n                drawPart(2000);\n                drawPart(6000);\n                break;\n            case 9000:\n                drawPart(1000);\n                drawPart(8000);\n                break;\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        for (var row : canvas) {\n            builder.append(row);\n            builder.append('\\n');\n        }\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        for (int number : List.of(0, 1, 20, 300, 4000, 5555, 6789, 9999)) {\n            System.out.printf(\"%d:\\n\", number);\n            var c = new Cistercian(number);\n            System.out.println(c);\n        }\n    }\n}\n"}
{"id": 425089, "name": "Cistercian numerals", "source": "Translate Ruby to Java: def initN\n    n = Array.new(15){Array.new(11, ' ')}\n    for i in 1..15\n        n[i - 1][5] = 'x'\n    end\n    return n\nend\n\ndef horiz(n, c1, c2, r)\n    for c in c1..c2\n        n[r][c] = 'x'\n    end\nend\n\ndef verti(n, r1, r2, c)\n    for r in r1..r2\n        n[r][c] = 'x'\n    end\nend\n\ndef diagd(n, c1, c2, r)\n    for c in c1..c2\n        n[r+c-c1][c] = 'x'\n    end\nend\n\ndef diagu(n, c1, c2, r)\n    for c in c1..c2\n        n[r-c+c1][c] = 'x'\n    end\nend\n\ndef initDraw\n    draw = []\n\n    draw[1] = lambda do |n| horiz(n, 6, 10, 0) end\n    draw[2] = lambda do |n| horiz(n, 6, 10, 4) end\n    draw[3] = lambda do |n| diagd(n, 6, 10, 0) end\n    draw[4] = lambda do |n| diagu(n, 6, 10, 4) end\n    draw[5] = lambda do |n|\n        draw[1].call(n)\n        draw[4].call(n)\n    end\n    draw[6] = lambda do |n| verti(n, 0, 4, 10) end\n    draw[7] = lambda do |n|\n        draw[1].call(n)\n        draw[6].call(n)\n    end\n    draw[8] = lambda do |n|\n        draw[2].call(n)\n        draw[6].call(n)\n    end\n    draw[9] = lambda do |n|\n        draw[1].call(n)\n        draw[8].call(n)\n    end\n\n    draw[10] = lambda do |n| horiz(n, 0, 4, 0) end\n    draw[20] = lambda do |n| horiz(n, 0, 4, 4) end\n    draw[30] = lambda do |n| diagu(n, 0, 4, 4) end\n    draw[40] = lambda do |n| diagd(n, 0, 4, 0) end\n    draw[50] = lambda do |n|\n        draw[10].call(n)\n        draw[40].call(n)\n    end\n    draw[60] = lambda do |n| verti(n, 0, 4, 0) end\n    draw[70] = lambda do |n|\n        draw[10].call(n)\n        draw[60].call(n)\n    end\n    draw[80] = lambda do |n|\n        draw[20].call(n)\n        draw[60].call(n)\n    end\n    draw[90] = lambda do |n|\n        draw[10].call(n)\n        draw[80].call(n)\n    end\n\n    draw[100] = lambda do |n| horiz(n, 6, 10, 14) end\n    draw[200] = lambda do |n| horiz(n, 6, 10, 10) end\n    draw[300] = lambda do |n| diagu(n, 6, 10, 14) end\n    draw[400] = lambda do |n| diagd(n, 6, 10, 10) end\n    draw[500] = lambda do |n|\n        draw[100].call(n)\n        draw[400].call(n)\n    end\n    draw[600] = lambda do |n| verti(n, 10, 14, 10) end\n    draw[700] = lambda do |n|\n        draw[100].call(n)\n        draw[600].call(n)\n    end\n    draw[800] = lambda do |n|\n        draw[200].call(n)\n        draw[600].call(n)\n    end\n    draw[900] = lambda do |n|\n        draw[100].call(n)\n        draw[800].call(n)\n    end\n\n    draw[1000] = lambda do |n| horiz(n, 0, 4, 14) end\n    draw[2000] = lambda do |n| horiz(n, 0, 4, 10) end\n    draw[3000] = lambda do |n| diagd(n, 0, 4, 10) end\n    draw[4000] = lambda do |n| diagu(n, 0, 4, 14) end\n    draw[5000] = lambda do |n|\n        draw[1000].call(n)\n        draw[4000].call(n)\n    end\n    draw[6000] = lambda do |n| verti(n, 10, 14, 0) end\n    draw[7000] = lambda do |n|\n        draw[1000].call(n)\n        draw[6000].call(n)\n    end\n    draw[8000] = lambda do |n|\n        draw[2000].call(n)\n        draw[6000].call(n)\n    end\n    draw[9000] = lambda do |n|\n        draw[1000].call(n)\n        draw[8000].call(n)\n    end\n\n    return draw\nend\n\ndef printNumeral(n)\n    for a in n\n        for b in a\n            print b\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndraw = initDraw()\nfor number in [0, 1, 20, 300, 4000, 5555, 6789, 9999]\n    n = initN()\n    print number, \":\\n\"\n\n    thousands = (number / 1000).floor\n    number = number % 1000\n\n    hundreds = (number / 100).floor\n    number = number % 100\n\n    tens = (number / 10).floor\n    ones = number % 10\n\n    if thousands > 0 then\n        draw[thousands * 1000].call(n)\n    end\n    if hundreds > 0 then\n        draw[hundreds * 100].call(n)\n    end\n    if tens > 0 then\n        draw[tens * 10].call(n)\n    end\n    if ones > 0 then\n        draw[ones].call(n)\n    end\n    printNumeral(n)\nend\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Cistercian {\n    private static final int SIZE = 15;\n    private final char[][] canvas = new char[SIZE][SIZE];\n\n    public Cistercian(int n) {\n        initN();\n        draw(n);\n    }\n\n    public void initN() {\n        for (var row : canvas) {\n            Arrays.fill(row, ' ');\n            row[5] = 'x';\n        }\n    }\n\n    private void horizontal(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void vertical(int r1, int r2, int c) {\n        for (int r = r1; r <= r2; r++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void diagd(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r + c - c1][c] = 'x';\n        }\n    }\n\n    private void diagu(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r - c + c1][c] = 'x';\n        }\n    }\n\n    private void draw(int v) {\n        var thousands = v / 1000;\n        v %= 1000;\n\n        var hundreds = v / 100;\n        v %= 100;\n\n        var tens = v / 10;\n        var ones = v % 10;\n\n        drawPart(1000 * thousands);\n        drawPart(100 * hundreds);\n        drawPart(10 * tens);\n        drawPart(ones);\n    }\n\n    private void drawPart(int v) {\n        switch (v) {\n            case 1:\n                horizontal(6, 10, 0);\n                break;\n            case 2:\n                horizontal(6, 10, 4);\n                break;\n            case 3:\n                diagd(6, 10, 0);\n                break;\n            case 4:\n                diagu(6, 10, 4);\n                break;\n            case 5:\n                drawPart(1);\n                drawPart(4);\n                break;\n            case 6:\n                vertical(0, 4, 10);\n                break;\n            case 7:\n                drawPart(1);\n                drawPart(6);\n                break;\n            case 8:\n                drawPart(2);\n                drawPart(6);\n                break;\n            case 9:\n                drawPart(1);\n                drawPart(8);\n                break;\n\n            case 10:\n                horizontal(0, 4, 0);\n                break;\n            case 20:\n                horizontal(0, 4, 4);\n                break;\n            case 30:\n                diagu(0, 4, 4);\n                break;\n            case 40:\n                diagd(0, 4, 0);\n                break;\n            case 50:\n                drawPart(10);\n                drawPart(40);\n                break;\n            case 60:\n                vertical(0, 4, 0);\n                break;\n            case 70:\n                drawPart(10);\n                drawPart(60);\n                break;\n            case 80:\n                drawPart(20);\n                drawPart(60);\n                break;\n            case 90:\n                drawPart(10);\n                drawPart(80);\n                break;\n\n            case 100:\n                horizontal(6, 10, 14);\n                break;\n            case 200:\n                horizontal(6, 10, 10);\n                break;\n            case 300:\n                diagu(6, 10, 14);\n                break;\n            case 400:\n                diagd(6, 10, 10);\n                break;\n            case 500:\n                drawPart(100);\n                drawPart(400);\n                break;\n            case 600:\n                vertical(10, 14, 10);\n                break;\n            case 700:\n                drawPart(100);\n                drawPart(600);\n                break;\n            case 800:\n                drawPart(200);\n                drawPart(600);\n                break;\n            case 900:\n                drawPart(100);\n                drawPart(800);\n                break;\n\n            case 1000:\n                horizontal(0, 4, 14);\n                break;\n            case 2000:\n                horizontal(0, 4, 10);\n                break;\n            case 3000:\n                diagd(0, 4, 10);\n                break;\n            case 4000:\n                diagu(0, 4, 14);\n                break;\n            case 5000:\n                drawPart(1000);\n                drawPart(4000);\n                break;\n            case 6000:\n                vertical(10, 14, 0);\n                break;\n            case 7000:\n                drawPart(1000);\n                drawPart(6000);\n                break;\n            case 8000:\n                drawPart(2000);\n                drawPart(6000);\n                break;\n            case 9000:\n                drawPart(1000);\n                drawPart(8000);\n                break;\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        for (var row : canvas) {\n            builder.append(row);\n            builder.append('\\n');\n        }\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        for (int number : List.of(0, 1, 20, 300, 4000, 5555, 6789, 9999)) {\n            System.out.printf(\"%d:\\n\", number);\n            var c = new Cistercian(number);\n            System.out.println(c);\n        }\n    }\n}\n"}
{"id": 425090, "name": "Poker hand analyser", "source": "Translate Ruby to Java: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 425091, "name": "Poker hand analyser", "source": "Translate Ruby to Java: class Card\n  include Comparable\n  attr_accessor :ordinal\n  attr_reader :suit, :face \n  \n  SUITS = %i(\u2665 \u2666 \u2663 \u2660)\n  FACES = %i(2 3 4 5 6 7 8 9 10 j q k a)\n  \n  def initialize(str)\n    @face, @suit = parse(str)\n    @ordinal = FACES.index(@face)\n  end\n  \n  def <=> (other) \n    self.ordinal <=> other.ordinal\n  end\n  \n  def to_s\n    \"\n  end\n  \n  private\n  def parse(str)\n    face, suit = str.chop.to_sym, str[-1].to_sym\n    raise ArgumentError, \"invalid card: \n    [face, suit]\n  end\nend\n\nclass Hand\n  include Comparable\n  attr_reader :cards, :rank\n  \n  RANKS       = %i(high-card one-pair two-pair three-of-a-kind straight flush\n                   full-house four-of-a-kind straight-flush five-of-a-kind)\n  WHEEL_FACES = %i(2 3 4 5 a)\n  \n  def initialize(str_of_cards)\n    @cards = str_of_cards.downcase.tr(',',' ').split.map{|str| Card.new(str)}\n    grouped = @cards.group_by(&:face).values\n    @face_pattern = grouped.map(&:size).sort\n    @rank = categorize\n    @rank_num = RANKS.index(@rank)\n    @tiebreaker = grouped.map{|ar| [ar.size, ar.first.ordinal]}.sort.reverse\n  end\n  \n  def <=> (other)    \n    self.compare_value <=> other.compare_value\n  end\n  \n  def to_s\n    @cards.map(&:to_s).join(\" \")\n  end\n  \n  protected          \n  def compare_value\n    [@rank_num, @tiebreaker]\n  end\n  \n  private\n  def one_suit?\n    @cards.map(&:suit).uniq.size == 1\n  end\n  \n  def consecutive?\n    sort.each_cons(2).all? {|c1,c2| c2.ordinal - c1.ordinal == 1 }\n  end\n  \n  def sort\n    if @cards.sort.map(&:face) == WHEEL_FACES\n      @cards.detect {|c| c.face == :a}.ordinal = -1\n    end \n    @cards.sort\n  end\n  \n  def categorize\n    if consecutive?\n      one_suit? ? :'straight-flush' : :straight\n    elsif one_suit?\n      :flush\n    else\n      case @face_pattern\n        when [1,1,1,1,1] then :'high-card'\n        when [1,1,1,2]   then :'one-pair'\n        when [1,2,2]     then :'two-pair'\n        when [1,1,3]     then :'three-of-a-kind'\n        when [2,3]       then :'full-house'\n        when [1,4]       then :'four-of-a-kind'\n        when [5]         then :'five-of-a-kind'\n      end\n    end\n  end\nend\n\n\ntest_hands = <<EOS\n2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\n2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\na\u2665 2\u2666 3\u2663 4\u2663 5\u2666\n2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\n2\u2665 6\u2665 2\u2666 3\u2663 3\u2666\n10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\n4\u2665 4\u2660 k\u2660 2\u2666 10\u2660\n4\u2665 4\u2660 k\u2660 3\u2666 10\u2660\nq\u2663 10\u2663 7\u2663 6\u2663 4\u2663\nq\u2663 10\u2663 7\u2663 6\u2663 3\u2663\n9\u2665 10\u2665 q\u2665 k\u2665 j\u2663\n2\u2665 3\u2665 4\u2665 5\u2665 a\u2665\n2\u2665 2\u2665 2\u2666 3\u2663 3\u2666\nEOS\n\nhands = test_hands.each_line.map{|line| Hand.new(line) }\nputs \"High to low\"\nhands.sort.reverse.each{|hand| puts \"\nputs\n\nstr = <<EOS\njoker  2\u2666  2\u2660  k\u2660  q\u2666\njoker  5\u2665  7\u2666  8\u2660  9\u2666\njoker  2\u2666  3\u2660  4\u2660  5\u2660\njoker  3\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  2\u2666  3\u2660  3\u2666\njoker  7\u2665  7\u2666  7\u2660  7\u2663\njoker  j\u2665  q\u2665  k\u2665  A\u2665\njoker  4\u2663  k\u2663  5\u2666 10\u2660\njoker  k\u2663  7\u2663  6\u2663  4\u2663\njoker  2\u2666  joker  4\u2660  5\u2660\njoker  Q\u2666  joker  A\u2660 10\u2660\njoker  Q\u2666  joker  A\u2666 10\u2666\njoker  2\u2666  2\u2660  joker  q\u2666\nEOS\n\n\n\n\n\nDECK = Card::FACES.product(Card::SUITS).map(&:join)\nstr.each_line do |line|\n  cards_in_arrays = line.split.map{|c| c == \"joker\" ? DECK.dup : [c]} \n  all_tries  = cards_in_arrays.shift.product(*cards_in_arrays).map{|ar| Hand.new(ar.join\" \")} \n  best = all_tries.max\n  puts \"\nend\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 425092, "name": "Fibonacci word_fractal", "source": "Translate Ruby to Java: def fibonacci_word(n)\n  words = [\"1\", \"0\"]\n  (n-1).times{ words << words[-1] + words[-2] }\n  words[n]\nend\n\ndef print_fractal(word)\n  area = Hash.new(\" \")\n  x = y = 0\n  dx, dy = 0, -1\n  area[[x,y]] = \"S\"\n  word.each_char.with_index(1) do |c,n|\n    area[[x+dx, y+dy]] = dx.zero? ? \"|\" : \"-\"\n    x, y = x+2*dx, y+2*dy\n    area[[x, y]] = \"+\"\n    dx,dy = n.even? ? [dy,-dx] : [-dy,dx]  if c==\"0\"\n  end\n  \n  (xmin, xmax), (ymin, ymax) = area.keys.transpose.map(&:minmax)\n  for y in ymin..ymax\n    puts (xmin..xmax).map{|x| area[[x,y]]}.join\n  end\nend\n\nword = fibonacci_word(16)\nprint_fractal(word)\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425093, "name": "Penney's game", "source": "Translate Ruby to Java: Toss = [:Heads, :Tails]\n\ndef yourChoice\n  puts \"Enter your choice (H/T)\"\n  choice = []\n  3.times do\n    until (c = $stdin.getc.upcase) == \"H\" or c == \"T\"\n    end\n    choice << (c==\"H\" ? Toss[0] : Toss[1])\n  end\n  puts \"You chose \n  choice\nend\n\nloop do\n  puts \"\\n%s I start, %s you start ..... %s\" % [*Toss, coin = Toss.sample]\n  if coin == Toss[0]\n    myC = Toss.shuffle << Toss.sample\n    puts \"I chose \n    yC = yourChoice\n  else\n    yC = yourChoice\n    myC = Toss - [yC[1]] + yC.first(2)\n    puts \"I chose \n  end\n  \n  seq = Array.new(3){Toss.sample}\n  print seq.join(' ')\n  loop do\n    puts \"\\n I win!\" or break   if seq == myC\n    puts \"\\n You win!\" or break if seq == yC\n    seq.push(Toss.sample).shift\n    print \" \n  end\nend\n", "target": "import java.util.*;\n\npublic class PenneysGame {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        String compChoice = \"\", playerChoice;\n        if (rand.nextBoolean()) {\n\n            for (int i = 0; i < 3; i++)\n                compChoice += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n\n            playerChoice = prompt(compChoice);\n\n        } else {\n\n            playerChoice = prompt(compChoice);\n\n            compChoice = \"T\";\n            if (playerChoice.charAt(1) == 'T')\n                compChoice = \"H\";\n            compChoice += playerChoice.substring(0, 2);\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n        }\n\n        String tossed = \"\";\n        while (true) {\n            tossed += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Tossed %s%n\" , tossed);\n            if (tossed.endsWith(playerChoice)) {\n                System.out.println(\"You win!\");\n                break;\n            }\n            if (tossed.endsWith(compChoice)) {\n                System.out.println(\"Computer wins!\");\n                break;\n            }\n        }\n    }\n\n    private static String prompt(String otherChoice) {\n        Scanner sc = new Scanner(System.in);\n        String s;\n        do {\n            System.out.print(\"Choose a sequence: \");\n            s = sc.nextLine().trim().toUpperCase();\n        } while (!s.matches(\"[HT]{3}\") || s.equals(otherChoice));\n        return s;\n    }\n}\n"}
{"id": 425094, "name": "Sierpinski triangle_Graphical", "source": "Translate Ruby to Java: Shoes.app(:height=>540,:width=>540, :title=>\"Sierpinski Triangle\") do\n  def triangle(slot, tri, color)\n    x, y, len = tri\n    slot.append do\n      fill color\n      shape do\n        move_to(x,y)\n        dx = len * Math::cos(Math::PI/3)\n        dy = len * Math::sin(Math::PI/3)\n        line_to(x-dx, y+dy)\n        line_to(x+dx, y+dy)\n        line_to(x,y)\n      end\n    end\n  end\n  @s = stack(:width => 520, :height => 520) {}\n  @s.move(10,10)\n\n  length = 512\n  @triangles = [[length/2,0,length]]\n  triangle(@s, @triangles[0], rgb(0,0,0))\n\n  @n = 1\n  animate(1) do\n    if @n <= 7\n      @triangles = @triangles.inject([]) do |sum, (x, y, len)|\n        dx = len/2 * Math::cos(Math::PI/3)\n        dy = len/2 * Math::sin(Math::PI/3)\n        triangle(@s, [x, y+2*dy, -len/2], rgb(255,255,255))\n        sum += [[x, y, len/2], [x-dx, y+dy, len/2], [x+dx, y+dy, len/2]]\n      end\n    end\n    @n += 1\n  end\n\n  keypress do |key|\n    case key\n    when :control_q, \"\\x11\" then exit\n    end\n  end\nend\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 425095, "name": "Sierpinski triangle_Graphical", "source": "Translate Ruby to Java: Shoes.app(:height=>540,:width=>540, :title=>\"Sierpinski Triangle\") do\n  def triangle(slot, tri, color)\n    x, y, len = tri\n    slot.append do\n      fill color\n      shape do\n        move_to(x,y)\n        dx = len * Math::cos(Math::PI/3)\n        dy = len * Math::sin(Math::PI/3)\n        line_to(x-dx, y+dy)\n        line_to(x+dx, y+dy)\n        line_to(x,y)\n      end\n    end\n  end\n  @s = stack(:width => 520, :height => 520) {}\n  @s.move(10,10)\n\n  length = 512\n  @triangles = [[length/2,0,length]]\n  triangle(@s, @triangles[0], rgb(0,0,0))\n\n  @n = 1\n  animate(1) do\n    if @n <= 7\n      @triangles = @triangles.inject([]) do |sum, (x, y, len)|\n        dx = len/2 * Math::cos(Math::PI/3)\n        dy = len/2 * Math::sin(Math::PI/3)\n        triangle(@s, [x, y+2*dy, -len/2], rgb(255,255,255))\n        sum += [[x, y, len/2], [x-dx, y+dy, len/2], [x+dx, y+dy, len/2]]\n      end\n    end\n    @n += 1\n  end\n\n  keypress do |key|\n    case key\n    when :control_q, \"\\x11\" then exit\n    end\n  end\nend\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 425096, "name": "Nonoblock", "source": "Translate Ruby to Java: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 425097, "name": "Nonoblock", "source": "Translate Ruby to Java: def nonoblocks(cell, blocks)\n  raise 'Those blocks will not fit in those cells' if cell < blocks.inject(0,:+) + blocks.size - 1\n  nblock(cell, blocks, '', [])\nend\n\ndef nblock(cell, blocks, position, result)\n  if cell <= 0\n    result << position[0..cell-1]\n  elsif blocks.empty? or blocks[0].zero?\n    result << position + '.' * cell\n  else\n    rest = cell - blocks.inject(:+) - blocks.size + 2\n    bl, *brest = blocks\n    rest.times.inject(result) do |res, i|\n      nblock(cell-i-bl-1, brest, position + '.'*i + '\n    end\n  end\nend\n\nconf = [[ 5, [2, 1]],\n        [ 5, []],\n        [10, [8]],\n        [15, [2, 3, 2, 3]],\n        [ 5, [2, 3]],      ]\nconf.each do |cell, blocks|\n  begin\n    puts \"\n    result = nonoblocks(cell, blocks)\n    puts result, result.size, \"\"\n  rescue => e\n    p e\n  end\nend\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 425098, "name": "Eban numbers", "source": "Translate Ruby to Java: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 425099, "name": "Eban numbers", "source": "Translate Ruby to Java: def main\n    intervals = [\n        [2, 1000, true],\n        [1000, 4000, true],\n        [2, 10000, false],\n        [2, 100000, false],\n        [2, 1000000, false],\n        [2, 10000000, false],\n        [2, 100000000, false],\n        [2, 1000000000, false]\n    ]\n    for intv in intervals\n        (start, ending, display) = intv\n        if start == 2 then\n            print \"eban numbers up to and including %d:\\n\" % [ending]\n        else\n            print \"eban numbers between %d and %d (inclusive):\\n\" % [start, ending]\n        end\n\n        count = 0\n        for i in (start .. ending).step(2)\n            b = (i / 1000000000).floor\n            r = (i % 1000000000)\n            m = (r / 1000000).floor\n            r = (r % 1000000)\n            t = (r / 1000).floor\n            r = (r % 1000)\n            if m >= 30 and m <= 66 then\n                m = m % 10\n            end\n            if t >= 30 and t <= 66 then\n                t = t % 10\n            end\n            if r >= 30 and r <= 66 then\n                r = r % 10\n            end\n            if b == 0 or b == 2 or b == 4 or b == 6 then\n                if m == 0 or m == 2 or m == 4 or m == 6 then\n                    if t == 0 or t == 2 or t == 4 or t == 6 then\n                        if r == 0 or r == 2 or r == 4 or r == 6 then\n                            if display then\n                                print ' ', i\n                            end\n                            count = count + 1\n                        end\n                    end\n                end\n            end\n        end\n        if display then\n            print \"\\n\"\n        end\n        print \"count = %d\\n\\n\" % [count]\n    end\nend\n\nmain()\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 425100, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to Java: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 425101, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Ruby to Java: def valid?(sailor, nuts)\n  sailor.times do\n    return false if (nuts % sailor) != 1\n    nuts -= 1 + nuts / sailor\n  end\n  nuts > 0 and nuts % sailor == 0\nend\n\n[5,6].each do |sailor|\n  n = sailor\n  n += 1 until valid?(sailor, n)\n  puts \"\\n\n  (sailor+1).times do\n    div, mod = n.divmod(sailor)\n    puts \"  \n    n -= 1 + div\n  end\nend\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 425102, "name": "Nautical bell", "source": "Translate Ruby to Java: watches = [ \"First\", \"Middle\", \"Morning\", \"Forenoon\", \"Afternoon\", \"First dog\", \"Last dog\", \"First\" ]\nwatch_ends = [ \"00:00\", \"04:00\", \"08:00\", \"12:00\", \"16:00\", \"18:00\", \"20:00\", \"23:59\" ]\nwords = [\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"]\nsound = \"ding!\"\n\nloop do\n  time = Time.now\n  if time.sec == 0 and time.min % 30 == 0\n    num = (time.hour * 60 + time.min) / 30 % 8\n    num = 8 if num == 0\n    hr_min = time.strftime \"%H:%M\"\n    idx = watch_ends.find_index {|t| hr_min <= t}\n    text = \"%s - %s watch, %s bell%s gone\" % [\n        hr_min, \n        watches[idx], \n        words[num-1], \n        num==1 ? \"\" : \"s\"\n    ]\n    bells = (sound * num).gsub(sound + sound) {|dd| dd + ' '}\n    puts \"%-45s %s\" % [text, bells]\n  end\n  sleep 1\nend\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 425103, "name": "Nautical bell", "source": "Translate Ruby to Java: watches = [ \"First\", \"Middle\", \"Morning\", \"Forenoon\", \"Afternoon\", \"First dog\", \"Last dog\", \"First\" ]\nwatch_ends = [ \"00:00\", \"04:00\", \"08:00\", \"12:00\", \"16:00\", \"18:00\", \"20:00\", \"23:59\" ]\nwords = [\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\"]\nsound = \"ding!\"\n\nloop do\n  time = Time.now\n  if time.sec == 0 and time.min % 30 == 0\n    num = (time.hour * 60 + time.min) / 30 % 8\n    num = 8 if num == 0\n    hr_min = time.strftime \"%H:%M\"\n    idx = watch_ends.find_index {|t| hr_min <= t}\n    text = \"%s - %s watch, %s bell%s gone\" % [\n        hr_min, \n        watches[idx], \n        words[num-1], \n        num==1 ? \"\" : \"s\"\n    ]\n    bells = (sound * num).gsub(sound + sound) {|dd| dd + ' '}\n    puts \"%-45s %s\" % [text, bells]\n  end\n  sleep 1\nend\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 425104, "name": "Voronoi diagram", "source": "Translate Ruby to Java: \n\nrequire_relative 'raster_graphics'\n\nclass ColourPixel < Pixel\n  def initialize(x, y, colour)\n    @colour = colour\n    super x, y\n  end\n  attr_accessor :colour\n\n  def distance_to(px, py)\n    Math.hypot(px - x, py - y)\n  end\nend\n\nwidth = 300\nheight = 200\nnpoints = 20\npixmap = Pixmap.new(width, height)\n\n@bases = npoints.times.collect do |_i|\n  ColourPixel.new(\n    3 + rand(width - 6), 3 + rand(height - 6),  \n    RGBColour.new(rand(256), rand(256), rand(256))\n  )\nend\n\npixmap.each_pixel do |x, y|\n  nearest = @bases.min_by { |base| base.distance_to(x, y) }\n  pixmap[x, y] = nearest.colour\nend\n\n@bases.each do |base|\n  pixmap[base.x, base.y] = RGBColour::BLACK\n  pixmap.draw_circle(base, 2, RGBColour::BLACK)\nend\n\npixmap.save_as_png('voronoi_rb.png')\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 425105, "name": "Voronoi diagram", "source": "Translate Ruby to Java: \n\nrequire_relative 'raster_graphics'\n\nclass ColourPixel < Pixel\n  def initialize(x, y, colour)\n    @colour = colour\n    super x, y\n  end\n  attr_accessor :colour\n\n  def distance_to(px, py)\n    Math.hypot(px - x, py - y)\n  end\nend\n\nwidth = 300\nheight = 200\nnpoints = 20\npixmap = Pixmap.new(width, height)\n\n@bases = npoints.times.collect do |_i|\n  ColourPixel.new(\n    3 + rand(width - 6), 3 + rand(height - 6),  \n    RGBColour.new(rand(256), rand(256), rand(256))\n  )\nend\n\npixmap.each_pixel do |x, y|\n  nearest = @bases.min_by { |base| base.distance_to(x, y) }\n  pixmap[x, y] = nearest.colour\nend\n\n@bases.each do |base|\n  pixmap[base.x, base.y] = RGBColour::BLACK\n  pixmap.draw_circle(base, 2, RGBColour::BLACK)\nend\n\npixmap.save_as_png('voronoi_rb.png')\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 425106, "name": "Active Directory_Connect", "source": "Translate Ruby to Java: require 'rubygems'\nrequire 'net/ldap'\nldap = Net::LDAP.new(:host => 'ldap.example.com', :base => 'o=companyname')\nldap.authenticate('bind_dn', 'bind_pass')\n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapConnectionDemo {\n\n    public static void main(String[] args) throws LdapException, IOException {\n        try (LdapConnection connection = new LdapNetworkConnection(\"localhost\", 10389)) {\n            connection.bind();\n            connection.unBind();\n        }\n    }\n}\n"}
{"id": 425107, "name": "Knapsack problem_Bounded", "source": "Translate Ruby to Java: record Item, name : String, weight : Int32, value : Int32, count : Int32\n\nrecord Selection, mask : Array(Int32), cur_index : Int32, total_value : Int32\n\nclass Knapsack\n  @threshold_value = 0\n  @threshold_choice : Selection?\n  getter checked_nodes = 0\n\n  def knapsack_step(taken, items, remaining_weight)\n    if taken.total_value > @threshold_value\n      @threshold_value = taken.total_value\n      @threshold_choice = taken\n    end\n    candidate_index = items.index(taken.cur_index) { |item| item.weight <= remaining_weight }\n    return nil unless candidate_index\n    @checked_nodes += 1\n    candidate = items[candidate_index]\n    \n    \n    return nil if taken.total_value + 1.0 * candidate.value / candidate.weight * remaining_weight < @threshold_value\n    \n    max_count = {candidate.count, remaining_weight // candidate.weight}.min\n    (0..max_count).reverse_each do |n|\n      mask = taken.mask.clone\n      mask[candidate_index] = n\n      knapsack_step Selection.new(mask, candidate_index + 1, taken.total_value + n*candidate.value), items, remaining_weight - n*candidate.weight\n    end\n  end\n\n  def select(items, max_weight)\n    @checked_variants = 0\n    \n    list = items.sort_by { |item| -1.0 * item.value / item.weight }\n    nothing = Selection.new(Array(Int32).new(items.size, 0), 0, 0)\n    @threshold_value = 0\n    @threshold_choice = nothing\n    knapsack_step(nothing, list, max_weight)\n    selected = @threshold_choice.not_nil!\n    result = Hash(Item, Int32).new(0)\n    selected.mask.each_with_index { |v, i| result[list[i]] = v if v > 0 }\n    result\n  end\nend\n\npossible = [\n  Item.new(\"map\", 9, 150, 1),\n  Item.new(\"compass\", 13, 35, 1),\n  Item.new(\"water\", 153, 200, 2),\n  Item.new(\"sandwich\", 50, 60, 2),\n  Item.new(\"glucose\", 15, 60, 2),\n  Item.new(\"tin\", 68, 45, 3),\n  Item.new(\"banana\", 27, 60, 3),\n  Item.new(\"apple\", 39, 40, 3),\n  Item.new(\"cheese\", 23, 30, 1),\n  Item.new(\"beer\", 52, 10, 3),\n  Item.new(\"suntan cream\", 11, 70, 1),\n  Item.new(\"camera\", 32, 30, 1),\n  Item.new(\"T-shirt\", 24, 15, 2),\n  Item.new(\"trousers\", 48, 10, 2),\n  Item.new(\"umbrella\", 73, 40, 1),\n  Item.new(\"waterproof trousers\", 42, 70, 1),\n  Item.new(\"waterproof overclothes\", 43, 75, 1),\n  Item.new(\"note-case\", 22, 80, 1),\n  Item.new(\"sunglasses\", 7, 20, 1),\n  Item.new(\"towel\", 18, 12, 2),\n  Item.new(\"socks\", 4, 50, 1),\n  Item.new(\"book\", 30, 10, 2),\n]\n\nsolver = Knapsack.new\nused = solver.select(possible, 400)\nputs \"optimal choice: \nputs \"total weight \nputs \"total value \nputs \"checked nodes: \n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); \n\n        \n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        \n        List<Item> itemList = bok.calcSolution();\n\n        \n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} \n"}
{"id": 425108, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to Java: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425109, "name": "Solve a Hidato puzzle", "source": "Translate Ruby to Java: \n\nclass Hidato\n  Cell = Struct.new(:value, :used, :adj)\n  ADJUST = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n  \n  def initialize(board, pout=true)\n    @board = []\n    board.each_line do |line|\n      @board << line.split.map{|n| Cell[Integer(n), false] rescue nil} + [nil]\n    end\n    @board << []                                \n    @board.each_with_index do |row, x|\n      row.each_with_index do |cell, y|\n        if cell\n          @sx, @sy = x, y  if cell.value==1     \n          cell.adj = ADJUST.map{|dx,dy| [x+dx,y+dy]}.select{|xx,yy| @board[xx][yy]}\n        end\n      end\n    end\n    @xmax = @board.size - 1\n    @ymax = @board.map(&:size).max - 1\n    @end  = @board.flatten.compact.size\n    puts to_s('Problem:')  if pout\n  end\n  \n  def solve\n    @zbl = Array.new(@end+1, false)\n    @board.flatten.compact.each{|cell| @zbl[cell.value] = true}\n    puts (try(@board[@sx][@sy], 1) ? to_s('Solution:') : \"No solution\")\n  end\n  \n  def try(cell, seq_num)\n    return true  if seq_num > @end\n    return false if cell.used\n    value = cell.value\n    return false if value > 0 and value != seq_num\n    return false if value == 0 and @zbl[seq_num]\n    cell.used = true\n    cell.adj.each do |x, y|\n      if try(@board[x][y], seq_num+1)\n        cell.value = seq_num\n        return true\n      end\n    end\n    cell.used = false\n  end\n  \n  def to_s(msg=nil)\n    str = (0...@xmax).map do |x|\n      (0...@ymax).map{|y| \"%3s\" % ((c=@board[x][y]) ? c.value : c)}.join\n    end\n    (msg ? [msg] : []) + str + [\"\"]\n  end\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425110, "name": "Sorting algorithms_Strand sort", "source": "Translate Ruby to Java: class Array\n  def strandsort\n    a = dup\n    result = []\n    until a.empty?\n      v = a.first\n      sublist, a = a.partition{|val| v=val if v<=val}   \n      \n      result.each_index do |idx|\n        break if sublist.empty?\n        result.insert(idx, sublist.shift) if sublist.first < result[idx]\n      end\n      result += sublist\n    end\n    result\n  end\n  \n  def strandsort!\n    replace(strandsort)\n  end\nend\n\np [1, 6, 3, 2, 1, 7, 5, 3].strandsort\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class Strand{\n\t\n\tpublic static <E extends Comparable<? super E>> \n\tLinkedList<E> strandSort(LinkedList<E> list){\n\t\tif(list.size() <= 1) return list;\n\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(list.size() > 0){\n\t\t\tLinkedList<E> sorted = new LinkedList<E>();\n\t\t\tsorted.add(list.removeFirst()); \n\t\t\tfor(Iterator<E> it = list.iterator(); it.hasNext(); ){\n\t\t\t\tE elem = it.next();\n\t\t\t\tif(sorted.peekLast().compareTo(elem) <= 0){\n\t\t\t\t\tsorted.addLast(elem); \n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = merge(sorted, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static <E extends Comparable<? super E>>\n\tLinkedList<E> merge(LinkedList<E> left, LinkedList<E> right){\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(!left.isEmpty() && !right.isEmpty()){\n\t\t\t\n\t\t\tif(left.peek().compareTo(right.peek()) <= 0)\n\t\t\t\tresult.add(left.remove());\n\t\t\telse\n\t\t\t\tresult.add(right.remove());\n\t\t}\n\t\tresult.addAll(left);\n\t\tresult.addAll(right);\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,3,5,6))));\n\t}\n}\n"}
{"id": 425111, "name": "Angles (geometric), normalization and conversion", "source": "Translate Ruby to Java: module Angles\n  BASES = {\"d\" => 360, \"g\" => 400, \"m\" => 6400, \"r\" => Math::PI*2 ,\"h\" => 24 }\n \n  def self.method_missing(meth, angle)\n    from, to = BASES.values_at(*meth.to_s.split(\"2\"))\n    raise NoMethodError, meth if (from.nil? or to.nil?)\n    mod = (angle.to_f * to / from) % to\n    angle < 0 ? mod - to : mod\n  end\n\nend\n\n\nnames = Angles::BASES.keys\nputs \" \" + \"%12s \"*names.size % names\ntest = [-2, -1, 0, 1, 2*Math::PI, 16, 360/(2*Math::PI), 360-1, 400-1, 6400-1, 1_000_000]\n\ntest.each do |n|\n  names.each do |first|\n    res = names.map{|last| Angles.send((first + \"2\" + last).to_sym, n)}\n    puts first + \"%12g \"*names.size % res\n  end\n  puts\nend\n", "target": "import java.text.DecimalFormat;\n\n\n\npublic class AnglesNormalizationAndConversion {\n\n    public static void main(String[] args) {\n        DecimalFormat formatAngle = new DecimalFormat(\"######0.000000\");\n        DecimalFormat formatConv = new DecimalFormat(\"###0.0000\");\n        System.out.printf(\"                               degrees    gradiens        mils     radians%n\");\n        for ( double angle : new double[] {-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000} ) {\n            for ( String units : new String[] {\"degrees\", \"gradiens\", \"mils\", \"radians\"}) {\n                double d = 0, g = 0, m = 0, r = 0;\n                switch (units) {\n                case \"degrees\":\n                    d = d2d(angle);\n                    g = d2g(d);\n                    m = d2m(d);\n                    r = d2r(d);\n                    break;\n                case \"gradiens\":\n                    g = g2g(angle);\n                    d = g2d(g);\n                    m = g2m(g);\n                    r = g2r(g);\n                    break;\n                case \"mils\":\n                    m = m2m(angle);\n                    d = m2d(m);\n                    g = m2g(m);\n                    r = m2r(m);\n                    break;\n                case \"radians\":\n                    r = r2r(angle);\n                    d = r2d(r);\n                    g = r2g(r);\n                    m = r2m(r);\n                    break;\n                }\n                System.out.printf(\"%15s  %8s = %10s  %10s  %10s  %10s%n\", formatAngle.format(angle), units, formatConv.format(d), formatConv.format(g), formatConv.format(m), formatConv.format(r));\n            }\n        }\n    }\n\n    private static final double DEGREE = 360D;\n    private static final double GRADIAN = 400D;\n    private static final double MIL = 6400D;\n    private static final double RADIAN = (2 * Math.PI);\n    \n    private static double d2d(double a) {\n        return a % DEGREE;\n    }\n    private static double d2g(double a) {\n        return a * (GRADIAN / DEGREE);\n    }\n    private static double d2m(double a) {\n        return a * (MIL / DEGREE);\n    }\n    private static double d2r(double a) {\n        return a * (RADIAN / 360);\n    }\n\n    private static double g2d(double a) {\n        return a * (DEGREE / GRADIAN);\n    }\n    private static double g2g(double a) {\n        return a % GRADIAN;\n    }\n    private static double g2m(double a) {\n        return a * (MIL / GRADIAN);\n    }\n    private static double g2r(double a) {\n        return a * (RADIAN / GRADIAN);\n    }\n    \n    private static double m2d(double a) {\n        return a * (DEGREE / MIL);\n    }\n    private static double m2g(double a) {\n        return a * (GRADIAN / MIL);\n    }\n    private static double m2m(double a) {\n        return a % MIL;\n    }\n    private static double m2r(double a) {\n        return a * (RADIAN / MIL);\n    }\n    \n    private static double r2d(double a) {\n        return a * (DEGREE / RADIAN);\n    }\n    private static double r2g(double a) {\n        return a * (GRADIAN / RADIAN);\n    }\n    private static double r2m(double a) {\n        return a * (MIL / RADIAN);\n    }\n    private static double r2r(double a) {\n        return a % RADIAN;\n    }\n    \n}\n"}
{"id": 425112, "name": "XML_XPath", "source": "Translate Ruby to Java: \nrequire \"rexml/document\"\ninclude REXML\n\ndoc = Document.new(\n        %q@<inventory title=\"OmniCorp Store \n             ...\n           </inventory>\n          @\n                          )\n\ninvisibility = XPath.first( doc, \"//item\" ) \n\nXPath.each( doc, \"//price\") { |element| puts element.text }\n\nnames = XPath.match( doc, \"//name\" )\n", "target": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n\tfinal static String xmlStr = \n\t\t\t  \"<inventory title=\\\"OmniCorp Store #45x10^3\\\">\"\n\t\t\t+ \"  <section name=\\\"health\\\">\"\n\t\t\t+ \"    <item upc=\\\"123456789\\\" stock=\\\"12\\\">\"\n\t\t\t+ \"      <name>Invisibility Cream</name>\"\n\t\t\t+ \"      <price>14.50</price>\"\n\t\t\t+ \"      <description>Makes you invisible</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"445322344\\\" stock=\\\"18\\\">\"\n\t\t\t+ \"      <name>Levitation Salve</name>\"\n\t\t\t+ \"      <price>23.99</price>\"\n\t\t\t+ \"      <description>Levitate yourself for up to 3 hours per application</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\"\n\t\t\t+ \"  <section name=\\\"food\\\">\"\n\t\t\t+ \"    <item upc=\\\"485672034\\\" stock=\\\"653\\\">\"\n\t\t\t+ \"      <name>Blork and Freen Instameal</name>\"\n\t\t\t+ \"      <price>4.95</price>\"\n\t\t\t+ \"      <description>A tasty meal in a tablet; just add water</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"132957764\\\" stock=\\\"44\\\">\"\n\t\t\t+ \"      <name>Grob winglets</name>\"\n\t\t\t+ \"      <price>3.56</price>\"\n\t\t\t+ \"      <description>Tender winglets of Grob. Just add priwater</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\" \n\t\t\t+ \"</inventory>\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance()\n\t\t\t\t\t.newDocumentBuilder()\n\t\t\t\t\t.parse(new InputSource(new StringReader(xmlStr)));\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\t\n\t\t\tSystem.out.println(((Node) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item[1]\", doc, XPathConstants.NODE))\n\t\t\t\t\t.getAttributes().getNamedItem(\"upc\"));\n\t\t\t\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item/price\", doc,\n\t\t\t\t\tXPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++)\n\t\t\t\tSystem.out.println(nodes.item(i).getTextContent());\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Error ocurred while parsing XML.\");\n\t\t}\n\t}\n}\n"}
{"id": 425113, "name": "Ranking methods", "source": "Translate Ruby to Java: ar = \"44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\".lines.map{|line| line.split}\ngrouped = ar.group_by{|pair| pair.shift.to_i}\ns_rnk = 1\nm_rnk = o_rnk = 0\nputs \"stand.\\tmod.\\tdense\\tord.\\tfract.\"\n\ngrouped.each.with_index(1) do |(score, names), d_rnk|\n  m_rnk += names.flatten!.size\n  f_rnk = (s_rnk + m_rnk)/2.0\n  names.each do |name|\n    o_rnk += 1\n    puts \"\n  end\n  s_rnk += names.size\nend\n", "target": "import java.util.*;\n\npublic class RankingMethods {\n\n    final static String[] input = {\"44 Solomon\", \"42 Jason\", \"42 Errol\",\n        \"41 Garry\", \"41 Bernard\", \"41 Barry\", \"39 Stephen\"};\n\n    public static void main(String[] args) {\n        int len = input.length;\n\n        Map<String, int[]> map = new TreeMap<>((a, b) -> b.compareTo(a));\n        for (int i = 0; i < len; i++) {\n            String key = input[i].split(\"\\\\s+\")[0];\n            int[] arr;\n            if ((arr = map.get(key)) == null)\n                arr = new int[]{i, 0};\n            arr[1]++;\n            map.put(key, arr);\n        }\n        int[][] groups = map.values().toArray(new int[map.size()][]);\n\n        standardRanking(len, groups);\n        modifiedRanking(len, groups);\n        denseRanking(len, groups);\n        ordinalRanking(len);\n        fractionalRanking(len, groups);\n    }\n\n    private static void standardRanking(int len, int[][] groups) {\n        System.out.println(\"\\nStandard ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                rank = i + 1;\n                group++;\n            }\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void modifiedRanking(int len, int[][] groups) {\n        System.out.println(\"\\nModified ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0])\n                rank += groups[group++][1];\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void denseRanking(int len, int[][] groups) {\n        System.out.println(\"\\nDense ranking\");\n        for (int i = 0, rank = 0; i < len; i++) {\n            if (rank < groups.length && i == groups[rank][0])\n                rank++;\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void ordinalRanking(int len) {\n        System.out.println(\"\\nOrdinal ranking\");\n        for (int i = 0; i < len; i++)\n            System.out.printf(\"%d %s%n\", i + 1, input[i]);\n    }\n\n    private static void fractionalRanking(int len, int[][] groups) {\n        System.out.println(\"\\nFractional ranking\");\n        float rank = 0;\n        for (int i = 0, tmp = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                tmp += groups[group++][1];\n                rank = (i + 1 + tmp) / 2.0F;\n            }\n            System.out.printf(\"%2.1f %s%n\", rank, input[i]);\n        }\n    }\n}\n"}
{"id": 425114, "name": "Update a configuration file", "source": "Translate Ruby to Java: require 'stringio'\n\nclass ConfigFile\n\n  \n  def self.file(filename)\n    fh = File.open(filename)\n    obj = self.new(fh)\n    obj.filename = filename\n    fh.close\n    obj\n  end\n\n  \n  def self.data(string)\n    fh = StringIO.new(string)\n    obj = self.new(fh)\n    fh.close\n    obj\n  end\n\n  def initialize(filehandle)\n    @lines = filehandle.readlines\n    @filename = nil\n    tidy_file\n  end\n  attr :filename\n\n  def save()\n    if @filename\n      File.open(@filename, \"w\") {|f| f.write(self)}\n    end\n  end\n\n  def tidy_file()\n    @lines.map! do |line|\n      \n      line.lstrip!\n\n      if line.match(/^\n        \n        \n        line\n      else\n        \n        line.sub!(/^;+\\s+/, \"; \")\n      \n        if line.match(/^; \\s*$/) \n          \n          \n          line = \"\"\n        else\n          \n          line = line.rstrip + \"\\n\"\n\n          \n          \n          if m = line.match(/^(; )?([[:upper:]]+)\\s+(.*)/)\n            line = (m[1].nil? ? \"\" : m[1]) + format_line(m[2], m[3])\n          end\n        end\n\n        line\n      end\n    end\n  end\n\n  def format_line(option, value)\n    \"%s%s\\n\" % [option.upcase.strip, value.nil? ? \"\" : \" \" + value.to_s.strip]\n  end\n\n  \n  def find_option(option)\n    @lines.find_index {|line| line.match(/^\n  end\n\n  \n  def enable_option(option)\n    if idx = find_option(\"; \" + option)\n      @lines[idx][/^; /] = \"\"\n    end\n  end\n\n  \n  def disable_option(option)\n    if idx = find_option(option)\n      @lines[idx][/^/] = \"; \"\n    end\n  end\n\n  \n  \n  def set_value(option, value)\n    if idx = find_option(option)\n      @lines[idx] = format_line(option, value)\n    else\n      @lines << format_line(option, value) \n    end\n  end\n\n  def to_s\n    @lines.join('')\n  end\nend\n\n\nconfig = ConfigFile.data(DATA.read)\nconfig.disable_option('needspeeling')\nconfig.enable_option('seedsremoved')\nconfig.set_value('numberofbananas', 1024)\nconfig.set_value('numberofstrawberries', 62000)\nputs config\n\n\n__END__\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFAVOURITEFRUIT \t\tbanana\n\n\n  NEEDSPEELING\n\n\n;;; SEEDSREMOVED\n;;; \n\n\nNUMBEROFBANANAS 48\n", "target": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UpdateConfig {\n\n    public static void main(String[] args) {\n        if (args[0] == null) {\n            System.out.println(\"filename required\");\n\n        } else if (readConfig(args[0])) {\n            enableOption(\"seedsremoved\");\n            disableOption(\"needspeeling\");\n            setOption(\"numberofbananas\", \"1024\");\n            addOption(\"numberofstrawberries\", \"62000\");\n            store();\n        }\n    }\n\n    private enum EntryType {\n        EMPTY, ENABLED, DISABLED, COMMENT\n    }\n\n    private static class Entry {\n        EntryType type;\n        String name, value;\n\n        Entry(EntryType t, String n, String v) {\n            type = t;\n            name = n;\n            value = v;\n        }\n    }\n\n    private static Map<String, Entry> entries = new LinkedHashMap<>();\n    private static String path;\n\n    private static boolean readConfig(String p) {\n        path = p;\n\n        File f = new File(path);\n        if (!f.exists() || f.isDirectory())\n            return false;\n\n        String regexString = \"^(;*)\\\\s*([A-Za-z0-9]+)\\\\s*([A-Za-z0-9]*)\";\n        Pattern regex = Pattern.compile(regexString);\n\n        try (Scanner sc = new Scanner(new FileReader(f))){\n            int emptyLines = 0;\n            String line;\n            while (sc.hasNext()) {\n                line = sc.nextLine().trim();\n\n                if (line.isEmpty()) {\n                    addOption(\"\" + emptyLines++, null, EntryType.EMPTY);\n\n                } else if (line.charAt(0) == '#') {\n                    entries.put(line, new Entry(EntryType.COMMENT, line, null));\n\n                } else {\n                    line = line.replaceAll(\"[^a-zA-Z0-9\\\\x20;]\", \"\");\n                    Matcher m = regex.matcher(line);\n\n                    if (m.find() && !m.group(2).isEmpty()) {\n\n                        EntryType t = EntryType.ENABLED;\n                        if (!m.group(1).isEmpty())\n                            t = EntryType.DISABLED;\n\n                        addOption(m.group(2), m.group(3), t);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return true;\n    }\n\n    private static void addOption(String name, String value) {\n        addOption(name, value, EntryType.ENABLED);\n    }\n\n    private static void addOption(String name, String value, EntryType t) {\n        name = name.toUpperCase();\n        entries.put(name, new Entry(t, name, value));\n    }\n\n    private static void enableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.ENABLED;\n    }\n\n    private static void disableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.DISABLED;\n    }\n\n    private static void setOption(String name, String value) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.value = value;\n    }\n\n    private static void store() {\n        try (PrintWriter pw = new PrintWriter(path)) {\n            for (Entry e : entries.values()) {\n                switch (e.type) {\n                    case EMPTY:\n                        pw.println();\n                        break;\n                    case ENABLED:\n                        pw.format(\"%s %s%n\", e.name, e.value);\n                        break;\n                    case DISABLED:\n                        pw.format(\"; %s %s%n\", e.name, e.value);\n                        break;\n                    case COMMENT:\n                        pw.println(e.name);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (pw.checkError()) {\n                throw new IOException(\"writing to file failed\");\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n"}
{"id": 425115, "name": "Straddling checkerboard", "source": "Translate Ruby to Java: class StraddlingCheckerboard\n  EncodableChars = \"A-Z0-9.\"\n  SortedChars = \"  ./\" + [*\"A\"..\"Z\"].join\n  \n  def initialize(board = nil)\n    if board.nil?\n      \n      rest = \"BCDFGHJKLMPQUVWXYZ/.\".chars.shuffle\n      @board = [\"  ESTONIAR\".chars.shuffle, rest[0..9], rest[10..19]]\n    elsif board.chars.sort.join == SortedChars\n      @board = board.chars.each_slice(10).to_a\n    else\n      raise ArgumentError, \"invalid \n    end\n    \n    @row_labels = @board[0].each_with_index.select {|v, i| v == \" \"}.map {|v,i| i}\n    \n    @mapping = {}\n    @board[0].each_with_index {|char, idx| @mapping[char] = idx.to_s unless char == \" \"}\n    @board[1..2].each_with_index do |row, row_idx|\n      row.each_with_index do |char, idx|\n        @mapping[char] = \"%d%d\" % [@row_labels[row_idx], idx]\n      end\n    end\n  end\n  \n  def encode(message)\n    msg = message.upcase.delete(\"^\n    msg.chars.inject(\"\") do |crypt, char|\n      crypt << (char =~ /[0-9]/ ? @mapping[\"/\"] + char : @mapping[char])\n    end\n  end\n  \n  def decode(code)\n    msg = \"\"\n    tokens = code.chars\n    until tokens.empty?\n      token = tokens.shift\n      itoken = token.to_i\n      unless @row_labels.include?(itoken)\n        msg << @board[0][itoken]\n      else\n        token2 = tokens.shift\n        if @mapping[\"/\"] == token + token2\n          msg << tokens.shift\n        else\n          msg << @board[1+@row_labels.index(itoken)][token2.to_i]\n        end\n      end\n    end\n    msg\n  end\n  \n  def to_s\n    @board.inject(\"\") {|res, row| res << row.join}\n  end\n  \n  def inspect\n    \"\n  end\nend\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.*;\n\npublic class StraddlingCheckerboard {\n\n    final static String[] keyvals = {\"H:0\", \"O:1\", \"L:2\", \"M:4\", \"E:5\", \"S:6\",\n        \"R:8\", \"T:9\", \"A:30\", \"B:31\", \"C:32\", \"D:33\", \"F:34\", \"G:35\", \"I:36\",\n        \"J:37\", \"K:38\", \"N:39\", \"P:70\", \"Q:71\", \"U:72\", \"V:73\", \"W:74\", \"X:75\",\n        \"Y:76\", \"Z:77\", \".:78\", \"/:79\", \"0:790\", \"1:791\", \"2:792\", \"3:793\",\n        \"4:794\", \"5:795\", \"6:796\", \"7:797\", \"8:798\", \"9:799\"};\n\n    final static Map<String, String> val2key = new HashMap<>();\n    final static Map<String, String> key2val = new HashMap<>();\n\n    public static void main(String[] args) {\n        for (String keyval : keyvals) {\n            String[] kv = keyval.split(\":\");\n            val2key.put(kv[0], kv[1]);\n            key2val.put(kv[1], kv[0]);\n        }\n        String enc = encode(\"One night-it was on the twentieth of March, \"\n                + \"1888-I was returning\");\n        System.out.println(enc);\n        System.out.println(decode(enc));\n    }\n\n    static String encode(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String c : s.toUpperCase().split(\"\")) {\n            c = val2key.get(c);\n            if (c != null)\n                sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    static String decode(String s) {\n        Matcher m = Pattern.compile(\"(79.|3.|7.|.)\").matcher(s);\n        StringBuilder sb = new StringBuilder();\n        while (m.find()) {\n            String v = key2val.get(m.group(1));\n            if (v != null)\n                sb.append(v);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 425116, "name": "I before E except after C", "source": "Translate Ruby to Java: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 425117, "name": "I before E except after C", "source": "Translate Ruby to Java: require 'open-uri'\n\nplausibility_ratio = 2\ncounter = Hash.new(0)\npath = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\nrules = [['I before E when not preceded by C:', 'ie', 'ei'],\n         ['E before I when preceded by C:', 'cei', 'cie']]\n\nopen(path){|f| f.each{|line| line.scan(/ie|ei|cie|cei/){|match| counter[match] += 1 }}}\n\noverall_plausible = rules.all? do |(str, x, y)|\n  num_x, num_y, ratio = counter[x], counter[y], counter[x] / counter[y].to_f\n  plausibility = ratio > plausibility_ratio\n  puts str\n  puts \"\n  plausibility\nend\n\nputs \"Overall: \n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 425118, "name": "Xiaolin Wu's line algorithm", "source": "Translate Ruby to Java: def ipart(n); n.truncate; end\ndef fpart(n); n - ipart(n); end\ndef rfpart(n); 1.0 - fpart(n); end\n\nclass Pixmap\n  def draw_line_antialised(p1, p2, colour)\n    x1, y1 = p1.x, p1.y\n    x2, y2 = p2.x, p2.y\n \n    steep = (y2 - y1).abs > (x2 - x1).abs\n    if steep\n      x1, y1 = y1, x1\n      x2, y2 = y2, x2\n    end\n    if x1 > x2\n      x1, x2 = x2, x1\n      y1, y2 = y2, y1\n    end\n    deltax = x2 - x1\n    deltay = (y2 - y1).abs\n    gradient = 1.0 * deltay / deltax\n \n    \n    xend = x1.round\n    yend = y1 + gradient * (xend - x1)\n    xgap = rfpart(x1 + 0.5)\n    xpxl1 = xend\n    ypxl1 = ipart(yend)\n    put_colour(xpxl1, ypxl1, colour, steep, rfpart(yend)*xgap)\n    put_colour(xpxl1, ypxl1 + 1, colour, steep, fpart(yend)*xgap)\n    itery = yend + gradient\n \n    \n    xend = x2.round\n    yend = y2 + gradient * (xend - x2)\n    xgap = rfpart(x2 + 0.5)\n    xpxl2 = xend\n    ypxl2 = ipart(yend)\n    put_colour(xpxl2, ypxl2, colour, steep, rfpart(yend)*xgap)\n    put_colour(xpxl2, ypxl2 + 1, colour, steep, fpart(yend)*xgap)\n \n    \n    (xpxl1 + 1).upto(xpxl2 - 1).each do |x|\n      put_colour(x, ipart(itery), colour, steep, rfpart(itery))\n      put_colour(x, ipart(itery) + 1, colour, steep, fpart(itery))\n      itery = itery + gradient\n    end\n  end\n\n  def put_colour(x, y, colour, steep, c)\n    x, y = y, x if steep\n    self[x, y] = anti_alias(colour, self[x, y], c)\n  end\n\n  def anti_alias(new, old, ratio)\n    blended = new.values.zip(old.values).map {|n, o| (n*ratio + o*(1.0 - ratio)).round}\n    RGBColour.new(*blended)\n  end\nend\n\nbitmap = Pixmap.new(500, 500)\nbitmap.fill(RGBColour::BLUE)\n10.step(430, 60) do |a|\n  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,a], RGBColour::YELLOW)\n  bitmap.draw_line_antialised(Pixel[10, 10], Pixel[a,490], RGBColour::YELLOW)\nend\nbitmap.draw_line_antialised(Pixel[10, 10], Pixel[490,490], RGBColour::YELLOW)\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class XiaolinWu extends JPanel {\n\n    public XiaolinWu() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n    }\n\n    void plot(Graphics2D g, double x, double y, double c) {\n        g.setColor(new Color(0f, 0f, 0f, (float)c));\n        g.fillOval((int) x, (int) y, 2, 2);\n    }\n\n    int ipart(double x) {\n        return (int) x;\n    }\n\n    double fpart(double x) {\n        return x - floor(x);\n    }\n\n    double rfpart(double x) {\n        return 1.0 - fpart(x);\n    }\n\n    void drawLine(Graphics2D g, double x0, double y0, double x1, double y1) {\n\n        boolean steep = abs(y1 - y0) > abs(x1 - x0);\n        if (steep)\n            drawLine(g, y0, x0, y1, x1);\n\n        if (x0 > x1)\n            drawLine(g, x1, y1, x0, y0);\n\n        double dx = x1 - x0;\n        double dy = y1 - y0;\n        double gradient = dy / dx;\n\n        \n        double xend = round(x0);\n        double yend = y0 + gradient * (xend - x0);\n        double xgap = rfpart(x0 + 0.5);\n        double xpxl1 = xend; \n        double ypxl1 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);\n            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);\n            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);\n        }\n\n        \n        double intery = yend + gradient;\n\n        \n        xend = round(x1);\n        yend = y1 + gradient * (xend - x1);\n        xgap = fpart(x1 + 0.5);\n        double xpxl2 = xend; \n        double ypxl2 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);\n            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);\n            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);\n        }\n\n        \n        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {\n            if (steep) {\n                plot(g, ipart(intery), x, rfpart(intery));\n                plot(g, ipart(intery) + 1, x, fpart(intery));\n            } else {\n                plot(g, x, ipart(intery), rfpart(intery));\n                plot(g, x, ipart(intery) + 1, fpart(intery));\n            }\n            intery = intery + gradient;\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        drawLine(g, 550, 170, 50, 435);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Xiaolin Wu's line algorithm\");\n            f.setResizable(false);\n            f.add(new XiaolinWu(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425119, "name": "Next highest int from digits", "source": "Translate Ruby to Java: func next_from_digits(n, b = 10) {\n\n    var a = n.digits(b).flip\n\n    while (a.next_permutation) {\n        with (a.flip.digits2num(b)) { |t|\n            return t if (t > n)\n        }\n    }\n\n    return 0\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:'\n\nfor n in (\n    0, 9, 12, 21, 12453, 738440, 3345333, 45072010,\n    95322020, 982765431, 9589776899767587796600,\n) {\n    printf(\"%30s  ->  %s\\n\", n, next_from_digits(n))\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 425120, "name": "Next highest int from digits", "source": "Translate Ruby to Java: func next_from_digits(n, b = 10) {\n\n    var a = n.digits(b).flip\n\n    while (a.next_permutation) {\n        with (a.flip.digits2num(b)) { |t|\n            return t if (t > n)\n        }\n    }\n\n    return 0\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:'\n\nfor n in (\n    0, 9, 12, 21, 12453, 738440, 3345333, 45072010,\n    95322020, 982765431, 9589776899767587796600,\n) {\n    printf(\"%30s  ->  %s\\n\", n, next_from_digits(n))\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 425121, "name": "Four is magic", "source": "Translate Ruby to Java: module NumberToWord\n  \n  NUMBERS = {  \n    1 => 'one',\n    2 => 'two',\n    3 => 'three',\n    4 => 'four',\n    5 => 'five',\n    6 => 'six',\n    7 => 'seven',\n    8 => 'eight',\n    9 => 'nine',\n    10 => 'ten',\n    11 => 'eleven',\n    12 => 'twelve',\n    13 => 'thirteen',\n    14 => 'fourteen',\n    15 => 'fifteen',\n    16 => 'sixteen',\n    17 => 'seventeen',\n    18 => 'eighteen',\n    19 => 'nineteen',\n    20 => 'twenty',\n    30 => 'thirty',\n    40 => 'forty',\n    50 => 'fifty',\n    60 => 'sixty',\n    70 => 'seventy',\n    80 => 'eighty',\n    90 => 'ninety',\n    100 => 'hundred',\n    1000 => 'thousand',\n    10 ** 6 => 'million',\n    10 ** 9 => 'billion',\n    10 ** 12 => 'trillion',\n    10 ** 15 => 'quadrillion',\n    10 ** 18 => 'quintillion',\n    10 ** 21 => 'sextillion',\n    10 ** 24 => 'septillion',\n    10 ** 27 => 'octillion',\n    10 ** 30 => 'nonillion',\n    10 ** 33 => 'decillion'}.reverse_each.to_h\n  \n  refine Integer do\n    def to_english\n      return 'zero' if i.zero?\n      words =  self < 0 ? ['negative'] : []\n      i = self.abs\n      NUMBERS.each do |k, v|\n        if k <= i then\n          times = i/k\n          words << times.to_english if k >= 100\n          words << v\n          i -= times * k\n        end\n        return words.join(\" \") if i.zero?\n      end\n    end\n  end\n    \nend\n  \nusing  NumberToWord\n  \ndef magic4(n)\n  words = []\n  until n == 4\n    s = n.to_english\n    n = s.size\n    words << \"\n  end\n  words << \"four is magic.\"\n  words.join(\", \").capitalize\nend\n  \n[0, 4, 6, 11, 13, 75, 337, -164, 9_876_543_209].each{|n| puts magic4(n) }\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 425122, "name": "Sierpinski pentagon", "source": "Translate Ruby to Java: THETA = Math::PI * 2 / 5\nSCALE_FACTOR = (3 - Math.sqrt(5)) / 2\nMARGIN = 20\n\nattr_reader :pentagons, :renderer\ndef settings\n  size(400, 400)\nend\n\ndef setup\n  sketch_title 'Pentaflake'\n  radius = width / 2 - 2 * MARGIN\n  center = Vec2D.new(radius - 2 * MARGIN, 3 * MARGIN)\n  pentaflake = Pentaflake.new(center, radius, 5)\n  @pentagons = pentaflake.pentagons\nend\n\ndef draw\n  background(255)\n  stroke(0)\n  pentagons.each do |penta|\n    draw_pentagon(penta)\n  end\n  no_loop\nend\n\ndef draw_pentagon(pent)\n  points = pent.vertices\n  begin_shape\n  points.each do |pnt|\n    pnt.to_vertex(renderer)\n  end\n  end_shape(CLOSE)\nend\n\ndef renderer\n  @renderer ||= GfxRender.new(self.g)\nend\n\n\nclass Pentaflake\n  attr_reader :pentagons\n\n  def initialize(center, radius, depth)\n    @pentagons = []\n    create_pentagons(center, radius, depth)\n  end\n\n  def create_pentagons(center, radius, depth)\n    if depth.zero?\n      pentagons << Pentagon.new(center, radius)\n    else\n      radius *= SCALE_FACTOR\n      distance = radius * Math.sin(THETA) * 2\n      (0..4).each do |idx|\n        x = center.x + Math.cos(idx * THETA) * distance\n        y = center.y + Math.sin(idx * THETA) * distance\n        center = Vec2D.new(x, y)\n        create_pentagons(center, radius, depth - 1)\n      end\n    end\n  end\nend\n\nclass Pentagon\n  attr_reader :center, :radius\n\n  def initialize(center, radius)\n    @center = center\n    @radius = radius\n  end\n\n  def vertices\n    (0..4).map do |idx|\n      center + Vec2D.new(radius * Math.sin(THETA * idx), radius * Math.cos(THETA * idx))\n    end\n  end\nend\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class SierpinskiPentagon extends JPanel {\n    \n    final double degrees072 = toRadians(72);\n\n    \n    final double scaleFactor = 1 / (2 + cos(degrees072) * 2);\n\n    final int margin = 20;\n    int limit = 0;\n    Random r = new Random();\n\n    public SierpinskiPentagon() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(3000, (ActionEvent e) -> {\n            limit++;\n            if (limit >= 5)\n                limit = 0;\n            repaint();\n        }).start();\n    }\n\n    void drawPentagon(Graphics2D g, double x, double y, double side, int depth) {\n        double angle = 3 * degrees072; \n\n        if (depth == 0) {\n\n            Path2D p = new Path2D.Double();\n            p.moveTo(x, y);\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * side;\n                y = y - sin(angle) * side;\n                p.lineTo(x, y);\n                angle += degrees072;\n            }\n\n            g.setColor(RandomHue.next());\n            g.fill(p);\n\n        } else {\n\n            side *= scaleFactor;\n\n            \n            double distance = side + side * cos(degrees072) * 2;\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * distance;\n                y = y - sin(angle) * distance;\n                drawPentagon(g, x, y, side, depth - 1);\n                angle += degrees072;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        int w = getWidth();\n        double radius = w / 2 - 2 * margin;\n        double side = radius * sin(PI / 5) * 2;\n\n        drawPentagon(g, w / 2, 3 * margin, side, limit);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Sierpinski Pentagon\");\n            f.setResizable(true);\n            f.add(new SierpinskiPentagon(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass RandomHue {\n    \n    final static double goldenRatioConjugate = (sqrt(5) - 1) / 2;\n    private static double hue = Math.random();\n\n    static Color next() {\n        hue = (hue + goldenRatioConjugate) % 1;\n        return Color.getHSBColor((float) hue, 1, 1);\n    }\n}\n"}
{"id": 425123, "name": "Zhang-Suen thinning algorithm", "source": "Translate Ruby to Java: class ZhangSuen\n  NEIGHBOUR8 = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]  \n  CIRCULARS = NEIGHBOUR8 + [NEIGHBOUR8.first]                       \n  def initialize(str, black=\"\n    s1 = str.each_line.map{|line| line.chomp.each_char.map{|c| c==black ? 1 : 0}}\n    s2 = s1.map{|line| line.map{0}}\n    xrange = 1 ... s1.size-1\n    yrange = 1 ... s1[0].size-1\n    printout(s1)\n    begin\n      @r = 0\n      xrange.each{|x| yrange.each{|y| s2[x][y] = s1[x][y] - zs(s1,x,y,1)}}  \n      xrange.each{|x| yrange.each{|y| s1[x][y] = s2[x][y] - zs(s2,x,y,0)}}  \n    end until @r == 0\n    printout(s1)\n  end\n  def zs(ng,x,y,g)\n    return 0 if ng[x][y] == 0 or                                    \n               (ng[x-1][y] + ng[x][y+1] + ng[x+g][y-1+g]) == 3 or   \n               (ng[x-1+g][y+g] + ng[x+1][y] + ng[x][y-1]) == 3      \n    bp1 = NEIGHBOUR8.inject(0){|res,(i,j)| res += ng[x+i][y+j]}     \n    return 0 if bp1 < 2 or 6 < bp1\n    ap1 = CIRCULARS.map{|i,j| ng[x+i][y+j]}.each_cons(2).count{|a,b| a<b}   \n    return 0 if ap1 != 1\n    @r = 1\n  end\n  def printout(image)\n    puts image.map{|row| row.map{|col| \" \n  end\nend\n\nstr = <<EOS\n...........................................................\n.\n.\n.\n.\n...\n...\n...\n...\n...\n...\n...\n...\n.\n.\n.\n.\n...........................................................\nEOS\n\nZhangSuen.new(str)\n\ntask_example = <<EOS\n00000000000000000000000000000000\n01111111110000000111111110000000\n01110001111000001111001111000000\n01110000111000001110000111000000\n01110001111000001110000000000000\n01111111110000001110000000000000\n01110111100000001110000111000000\n01110011110011101111001111011100\n01110001111011100111111110011100\n00000000000000000000000000000000\nEOS\n\nZhangSuen.new(task_example, \"1\")\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 425124, "name": "Generate Chess960 starting position", "source": "Translate Ruby to Java: pieces = %i(\u2654 \u2655 \u2658 \u2658 \u2657 \u2657 \u2656 \u2656)\nregexes = [/\u2657(..)*\u2657/, /\u2656.*\u2654.*\u2656/]\nrow = pieces.shuffle.join until regexes.all?{|re| re.match(row)} \nputs row\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 425125, "name": "UPC", "source": "Translate Ruby to Java: DIGIT_F = {\n    \"   \n    \"  \n    \"  \n    \" \n    \" \n    \" \n    \" \n    \" \n    \" \n    \"   \n}\n\nDIGIT_R = {\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n    \"\n}\n\nEND_SENTINEL = \"\nMID_SENTINEL = \" \n\ndef decode_upc(s)\n    def decode_upc_impl(input)\n        upc = input.strip\n        if upc.length != 95 then\n            return false\n        end\n\n        pos = 0\n        digits = []\n        sum = 0\n\n        \n        if upc[pos .. pos + 2] == END_SENTINEL then\n            pos += 3\n        else\n            return false\n        end\n\n        \n        for i in 0 .. 5\n            digit = DIGIT_F[upc[pos .. pos + 6]]\n            if digit == nil then\n                return false\n            else\n                digits.push(digit)\n                sum += digit * [1, 3][digits.length % 2]\n                pos += 7\n            end\n        end\n\n        \n        if upc[pos .. pos + 4] == MID_SENTINEL then\n            pos += 5\n        else\n            return false\n        end\n\n        \n        for i in 0 .. 5\n            digit = DIGIT_R[upc[pos .. pos + 6]]\n            if digit == nil then\n                return false\n            else\n                digits.push(digit)\n                sum += digit * [1, 3][digits.length % 2]\n                pos += 7\n            end\n        end\n\n        \n        if upc[pos .. pos + 2] == END_SENTINEL then\n            pos += 3\n        else\n            return false\n        end\n\n        if sum % 10  == 0 then\n            print digits, \" \"\n            return true\n        else\n            print \"Failed Checksum \"\n            return false\n        end\n    end\n\n    if decode_upc_impl(s) then\n        puts \"Rightside Up\"\n    elsif decode_upc_impl(s.reverse) then\n        puts \"Upside Down\"\n    else\n        puts \"Invalid digit(s)\"\n    end\nend\n\ndef main\n    num = 0\n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"       \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"          \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"         \n\n    print \"%2d: \" % [num += 1]\n    decode_upc(\"        \nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class UPC {\n    private static final int SEVEN = 7;\n\n    private static final Map<String, Integer> LEFT_DIGITS = Map.of(\n        \"   ## #\", 0,\n        \"  ##  #\", 1,\n        \"  #  ##\", 2,\n        \" #### #\", 3,\n        \" #   ##\", 4,\n        \" ##   #\", 5,\n        \" # ####\", 6,\n        \" ### ##\", 7,\n        \" ## ###\", 8,\n        \"   # ##\", 9\n    );\n\n    private static final Map<String, Integer> RIGHT_DIGITS = LEFT_DIGITS.entrySet()\n        .stream()\n        .collect(Collectors.toMap(\n            entry -> entry.getKey()\n                .replace(' ', 's')\n                .replace('#', ' ')\n                .replace('s', '#'),\n            Map.Entry::getValue\n        ));\n\n    private static final String END_SENTINEL = \"# #\";\n    private static final String MID_SENTINEL = \" # # \";\n\n    private static void decodeUPC(String input) {\n        Function<String, Map.Entry<Boolean, List<Integer>>> decode = (String candidate) -> {\n            int pos = 0;\n            var part = candidate.substring(pos, pos + END_SENTINEL.length());\n\n            List<Integer> output = new ArrayList<>();\n            if (END_SENTINEL.equals(part)) {\n                pos += END_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (LEFT_DIGITS.containsKey(part)) {\n                    output.add(LEFT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + MID_SENTINEL.length());\n            if (MID_SENTINEL.equals(part)) {\n                pos += MID_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (RIGHT_DIGITS.containsKey(part)) {\n                    output.add(RIGHT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + END_SENTINEL.length());\n            if (!END_SENTINEL.equals(part)) {\n                return Map.entry(false, output);\n            }\n\n            int sum = 0;\n            for (int i = 0; i < output.size(); i++) {\n                if (i % 2 == 0) {\n                    sum += 3 * output.get(i);\n                } else {\n                    sum += output.get(i);\n                }\n            }\n            return Map.entry(sum % 10 == 0, output);\n        };\n\n        Consumer<List<Integer>> printList = list -> {\n            var it = list.iterator();\n            System.out.print('[');\n            if (it.hasNext()) {\n                System.out.print(it.next());\n            }\n            while (it.hasNext()) {\n                System.out.print(\", \");\n                System.out.print(it.next());\n            }\n            System.out.print(']');\n        };\n\n        var candidate = input.trim();\n        var out = decode.apply(candidate);\n        if (out.getKey()) {\n            printList.accept(out.getValue());\n            System.out.println();\n        } else {\n            StringBuilder builder = new StringBuilder(candidate);\n            builder.reverse();\n            out = decode.apply(builder.toString());\n            if (out.getKey()) {\n                printList.accept(out.getValue());\n                System.out.println(\" Upside down\");\n            } else if (out.getValue().size() == 12) {\n                System.out.println(\"Invalid checksum\");\n            } else {\n                System.out.println(\"Invalid digit(s)\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        var barcodes = List.of(\n            \"         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       \",\n            \"        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         \",\n            \"         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         \",\n            \"       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        \",\n            \"         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          \",\n            \"          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         \",\n            \"         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        \",\n            \"        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         \",\n            \"         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       \",\n            \"        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         \"\n        );\n        barcodes.forEach(UPC::decodeUPC);\n    }\n}\n"}
{"id": 425126, "name": "Write to Windows event log", "source": "Translate Ruby to Java: require 'win32/eventlog'\nlogger = Win32::EventLog.new\nlogger.report_event(:event_type => Win32::EventLog::INFO, :data => \"a test event log entry\")\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class WriteToWindowsEventLog {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String osName = System.getProperty(\"os.name\").toUpperCase(Locale.ENGLISH);\n        if (!osName.startsWith(\"WINDOWS\")) {\n            System.err.println(\"Not windows\");\n            return;\n        }\n\n        Process process = Runtime.getRuntime().exec(\"EventCreate /t INFORMATION /id 123 /l APPLICATION /so Java /d \\\"Rosetta Code Example\\\"\");\n        process.waitFor(10, TimeUnit.SECONDS);\n        int exitValue = process.exitValue();\n        System.out.printf(\"Process exited with value %d\\n\", exitValue);\n        if (exitValue != 0) {\n            InputStream errorStream = process.getErrorStream();\n            String result = new BufferedReader(new InputStreamReader(errorStream))\n                .lines()\n                .collect(Collectors.joining(\"\\n\"));\n            System.err.println(result);\n        }\n    }\n}\n"}
{"id": 425127, "name": "Spelling of ordinal numbers", "source": "Translate Ruby to Java: var lingua_en = frequire('Lingua::EN::Numbers')\nvar tests = [1,2,3,4,5,11,65,100,101,272,23456,8007006005004003]\n\ntests.each {|n|\n    printf(\"%16s\u00a0: %s\\n\", n, lingua_en.num2en_ordinal(n))\n}\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SpellingOfOrdinalNumbers {\n\n    public static void main(String[] args) {\n        for ( long test : new long[] {1,  2,  3,  4,  5,  11,  65,  100,  101,  272,  23456,  8007006005004003L} ) {\n            System.out.printf(\"%d = %s%n\", test, toOrdinal(test));\n        }\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n\n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 425128, "name": "Parse an IP Address", "source": "Translate Ruby to Java: require 'ipaddr'\n\n \nTESTCASES = [\"127.0.0.1\",                \"127.0.0.1:80\",\n                \"::1\",                      \"[::1]:80\",\n                \"2605:2700:0:3::4713:93e3\", \"[2605:2700:0:3::4713:93e3]:80\"]                            \n\noutput = [%w(String Address Port Family Hex),\n          %w(------ ------- ---- ------ ---)]\n\ndef output_table(rows)\n  widths = []\n  rows.each {|row| row.each_with_index {|col, i| widths[i] = [widths[i].to_i, col.to_s.length].max }}\n  format = widths.map {|size| \"%\n  rows.each {|row| puts format % row}\nend\n\nTESTCASES.each do |str|\n  case str  \n  when /\\A\\[(?<address> .* )\\]:(?<port> \\d+ )\\z/x      \n    address, port = $~[:address], $~[:port]\n  when /\\A(?<address> [^:]+ ):(?<port> \\d+ )\\z/x       \n    address, port = $~[:address], $~[:port]\n  else                                                 \n    address, port = str, nil\n  end\n  \n  ip_addr = IPAddr.new(address) \n  family = \"IPv4\" if ip_addr.ipv4?\n  family = \"IPv6\" if ip_addr.ipv6?\n\n  output << [str, ip_addr.to_s, port.to_s, family, ip_addr.to_i.to_s(16)]\nend\n\noutput_table(output)\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ParseIPAddress {\n\n    public static void main(String[] args) {\n        String [] tests = new String[] {\"192.168.0.1\", \"127.0.0.1\", \"256.0.0.1\", \"127.0.0.1:80\", \"::1\", \"[::1]:80\", \"[32e::12f]:80\", \"2605:2700:0:3::4713:93e3\", \"[2605:2700:0:3::4713:93e3]:80\", \"2001:db8:85a3:0:0:8a2e:370:7334\"};\n        System.out.printf(\"%-40s\u00a0%-32s   %s%n\", \"Test Case\", \"Hex Address\", \"Port\");\n        for ( String ip : tests ) {\n            try {\n                String [] parsed = parseIP(ip);\n                System.out.printf(\"%-40s\u00a0%-32s   %s%n\", ip, parsed[0], parsed[1]);\n            }\n            catch (IllegalArgumentException e) {\n                System.out.printf(\"%-40s Invalid address:  %s%n\", ip, e.getMessage());\n            }\n        }\n    }\n    \n    private static final Pattern IPV4_PAT = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)(?::(\\\\d+)){0,1}$\");\n    private static final Pattern IPV6_DOUBL_COL_PAT = Pattern.compile(\"^\\\\[{0,1}([0-9a-f:]*)::([0-9a-f:]*)(?:\\\\]:(\\\\d+)){0,1}$\");\n    private static String ipv6Pattern;\n    static {\n        ipv6Pattern = \"^\\\\[{0,1}\";\n        for ( int i = 1 ; i <= 7 ; i ++ ) {\n            ipv6Pattern += \"([0-9a-f]+):\";\n        }\n        ipv6Pattern += \"([0-9a-f]+)(?:\\\\]:(\\\\d+)){0,1}$\";\n    }\n    private static final Pattern IPV6_PAT = Pattern.compile(ipv6Pattern);\n    \n    private static String[] parseIP(String ip) {\n        String hex = \"\";\n        String port = \"\";\n        \n        \n        Matcher ipv4Matcher = IPV4_PAT.matcher(ip);\n        if ( ipv4Matcher.matches() ) {\n            for ( int i = 1 ; i <= 4 ; i++ ) {\n                hex += toHex4(ipv4Matcher.group(i));\n            }\n            if ( ipv4Matcher.group(5) != null ) {\n                port = ipv4Matcher.group(5);\n            }\n            return new String[] {hex, port};\n        }\n        \n        \n        Matcher ipv6DoubleColonMatcher = IPV6_DOUBL_COL_PAT.matcher(ip);\n        if ( ipv6DoubleColonMatcher.matches() ) {\n            String p1 = ipv6DoubleColonMatcher.group(1);\n            if ( p1.isEmpty() ) {\n                p1 = \"0\";\n            }\n            String p2 = ipv6DoubleColonMatcher.group(2);\n            if ( p2.isEmpty() ) {\n                p2 = \"0\";\n            }\n            ip =  p1 + getZero(8 - numCount(p1) - numCount(p2)) + p2;\n            if ( ipv6DoubleColonMatcher.group(3) != null ) {\n                ip = \"[\" + ip + \"]:\" + ipv6DoubleColonMatcher.group(3);\n            }\n        }\n        \n        \n        Matcher ipv6Matcher = IPV6_PAT.matcher(ip);\n        if ( ipv6Matcher.matches() ) {\n            for ( int i = 1 ; i <= 8 ; i++ ) {\n                hex += String.format(\"%4s\", toHex6(ipv6Matcher.group(i))).replace(\" \", \"0\");\n            }\n            if ( ipv6Matcher.group(9) != null ) {\n                port = ipv6Matcher.group(9);\n            }\n            return new String[] {hex, port};\n        }\n        \n        throw new IllegalArgumentException(\"ERROR 103: Unknown address: \" + ip);\n    }\n    \n    private static int numCount(String s) {\n        return s.split(\":\").length;\n    }\n    \n    private static String getZero(int count) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\":\");\n        while ( count > 0 ) {\n            sb.append(\"0:\");\n            count--;\n        }\n        return sb.toString();\n    }\n\n    private static String toHex4(String s) {\n        int val = Integer.parseInt(s);\n        if ( val < 0 || val > 255 ) {\n            throw new IllegalArgumentException(\"ERROR 101:  Invalid value\u00a0: \" + s);\n        }\n        return String.format(\"%2s\", Integer.toHexString(val)).replace(\" \", \"0\");\n    }\n\n    private static String toHex6(String s) {\n        int val = Integer.parseInt(s, 16);\n        if ( val < 0 || val > 65536 ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid hex value\u00a0: \" + s);\n        }\n        return s;\n    }\n\n}\n"}
{"id": 425129, "name": "Line circle intersection", "source": "Translate Ruby to Java: EPS = 1e-14\n\ndef sq(x)\n    return x * x\nend\n\ndef intersects(p1, p2, cp, r, segment)\n    res = []\n    (x0, y0) = cp\n    (x1, y1) = p1\n    (x2, y2) = p2\n    aa = y2 - y1\n    bb = x1 - x2\n    cc = x2 * y1 - x1 * y2\n    a = sq(aa) + sq(bb)\n    if bb.abs >= EPS then\n        b = 2 * (aa * cc + aa * bb * y0 - sq(bb) * x0)\n        c = sq(cc) + 2 * bb * cc * y0 - sq(bb) * (sq(r) - sq(x0) - sq(y0))\n        bnz = true\n    else\n        b = 2 * (bb * cc + aa * bb * x0 - sq(aa) * y0)\n        c = sq(cc) + 2 * aa * cc * x0 - sq(aa) * (sq(r) - sq(x0) - sq(y0))\n        bnz = false\n    end\n    d = sq(b) - 4 * a * c \n    if d < 0 then\n        return res\n    end\n\n    \n    within = ->(x, y) {\n        d1 = Math.sqrt(sq(x2 - x1) + sq(y2 - y1))   \n        d2 = Math.sqrt(sq(x - x1) + sq(y - y1))     \n        d3 = Math.sqrt(sq(x2 - x) + sq(y2 - y))     \n        delta = d1 - d2 - d3\n        return delta.abs < EPS                      \n    }\n\n    fx = ->(x) {\n        return -(aa * x + cc) / bb\n    }\n\n    fy = ->(y) {\n        return -(bb * y + cc) / aa\n    }\n\n    rxy = ->(x, y) {\n        if not segment or within.call(x, y) then\n            if x == 0.0 then\n                x = 0.0\n            end\n            if y == 0.0 then\n                y = 0.0\n            end\n            res << [x, y]\n        end\n    }\n\n    if d == 0.0 then\n        \n        if bnz then\n            x = -b / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n        else\n            y = -b / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n        end\n    else\n        \n        d = Math.sqrt(d)\n        if bnz then\n            x = (-b + d) / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n            x = (-b - d) / (2 * a)\n            y = fx.call(x)\n            rxy.call(x, y)\n        else\n            y = (-b + d) / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n            y = (-b - d) / (2 * a)\n            x = fy.call(y)\n            rxy.call(x, y)\n        end\n    end\n\n    return res\nend\n\ndef main\n    print \"The intersection points (if any) between:\\n\"\n\n    cp = [3.0, -5.0]\n    r = 3.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [-10.0, 11.0]\n    p2 = [10.0, -9.0]\n    print \"    a line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    p2 = [-10.0, 12.0]\n    print \"    a segment starting at %s and ending at %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\n\n    p1 = [3.0, -2.0]\n    p2 = [7.0, -2.0]\n    print \"    a horizontal line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    cp = [0.0, 0.0]\n    r = 4.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [0.0, -3.0]\n    p2 = [0.0, 6.0]\n    print \"    a vertical line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n    print \"    a vertical line segment containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\n\n    cp = [4.0, 2.0]\n    r = 5.0\n    print \"  A circle, center %s with radius %f, and:\\n\" % [cp, r]\n\n    p1 = [6.0, 3.0]\n    p2 = [10.0, 7.0]\n    print \"    a line containing the points %s and %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, false)]\n\n    p1 = [7.0, 4.0]\n    p2 = [11.0, 8.0]\n    print \"    a segment starting at %s and ending at %s is/are:\\n\" % [p1, p2]\n    print \"      %s\\n\" % [intersects(p1, p2, cp, r, true)]\nend\n\nmain()\n", "target": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class LineCircleIntersection {\n    public static void main(String[] args) {\n        try {\n            demo();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void demo() throws NoninvertibleTransformException {\n        Point2D center = makePoint(3, -5);\n        double radius = 3.0;\n        System.out.println(\"The intersection points (if any) between:\");\n        System.out.println(\"\\n  A circle, center (3, -5) with radius 3, and:\");\n        System.out.println(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(10, -9),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(-11, 12),\n                            center, radius, true)));\n        System.out.println(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(3, -2), makePoint(7, -2), center, radius, false)));\n        center.setLocation(0, 0);\n        radius = 4.0;\n        System.out.println(\"\\n  A circle, center (0, 0) with radius 4, and:\");\n        System.out.println(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, false)));\n        System.out.println(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, true)));\n        center.setLocation(4, 2);\n        radius = 5.0;\n        System.out.println(\"\\n  A circle, center (4, 2) with radius 5, and:\");\n        System.out.println(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(6, 3), makePoint(10, 7),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(7, 4), makePoint(11, 8),\n                            center, radius, true)));\n    }\n\n    private static Point2D makePoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static List<Point2D> intersection(Point2D p1, Point2D p2, Point2D center,\n            double radius, boolean isSegment) throws NoninvertibleTransformException {\n        List<Point2D> result = new ArrayList<>();\n        double dx = p2.getX() - p1.getX();\n        double dy = p2.getY() - p1.getY();\n        AffineTransform trans = AffineTransform.getRotateInstance(dx, dy);\n        trans.invert();\n        trans.translate(-center.getX(), -center.getY());\n        Point2D p1a = trans.transform(p1, null);\n        Point2D p2a = trans.transform(p2, null);\n        double y = p1a.getY();\n        double minX = Math.min(p1a.getX(), p2a.getX());\n        double maxX = Math.max(p1a.getX(), p2a.getX());\n        if (y == radius || y == -radius) {\n            if (!isSegment || (0 <= maxX && 0 >= minX)) {\n                p1a.setLocation(0, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n        } else if (y < radius && y > -radius) {\n            double x = Math.sqrt(radius * radius - y * y);\n            if (!isSegment || (-x <= maxX && -x >= minX)) {\n                p1a.setLocation(-x, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n            if (!isSegment || (x <= maxX && x >= minX)) {\n                p2a.setLocation(x, y);\n                trans.inverseTransform(p2a, p2a);\n                result.add(p2a);\n            }\n        }\n        return result;\n    }\n\n    public static String toString(Point2D point) {\n        return String.format(\"(%g, %g)\", point.getX(), point.getY());\n    }\n\n    public static String toString(List<Point2D> points) {\n        StringBuilder str = new StringBuilder(\"[\");\n        for (int i = 0, n = points.size(); i < n; ++i) {\n            if (i > 0)\n                str.append(\", \");\n            str.append(toString(points.get(i)));\n        }\n        str.append(\"]\");\n        return str.toString();\n    }\n}\n"}
{"id": 425130, "name": "Getting the number of decimal places", "source": "Translate Ruby to Java: func number_of_decimals(n, limit = 1e5) {\n    var prec = Num(Num!PREC)>>2\n    var prev = ''\n\n    n = Number(n) if !n.kind_of(Number)\n\n    loop {\n        var str = n.as_dec(prec)\n\n        if (prev == str) {\n            return (str.contains('.') ? str.substr(str.index('.')+1).len : 0)\n        }\n\n        prev = str\n        prec *= 2\n        return Inf if (prec > limit)\n    }\n}\n\nvar list = [\n    9, 12.345, \"12.3450\", \"12.345e53\",\n    12.34555555555555555555, 0.1234567890987654321,\n    Num.pi, 1/3, 1.5**63\n]\n\nlist.each {|n|\n    var c = number_of_decimals(n)\n    say \"Number of decimals: \n}\n", "target": "public static int findNumOfDec(double x){\n    String str = String.valueOf(x);\n    if(str.endsWith(\".0\")) return 0;\n    else return (str.substring(str.indexOf('.')).length() - 1);\n}\n"}
{"id": 425131, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425132, "name": "Solve a Hopido puzzle", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-3, 0], [0, -3], [0, 3], [3, 0], [-2, -2], [-2, 2], [2, -2], [2, 2]]\n\nboard1 = <<EOS\n. 0 0 . 0 0 .\n0 0 0 0 0 0 0\n0 0 0 0 0 0 0\n. 0 0 0 0 0 .\n. . 0 0 0 . .\n. . . 1 . . .\nEOS\nt0 = Time.now\nHLPsolver.new(board1).solve\nputs \" \n", "target": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425133, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "import java.util.*;\n\npublic class Numbrix {\n\n    final static String[] board = {\n        \"00,00,00,00,00,00,00,00,00\",\n        \"00,00,46,45,00,55,74,00,00\",\n        \"00,38,00,00,43,00,00,78,00\",\n        \"00,35,00,00,00,00,00,71,00\",\n        \"00,00,33,00,00,00,59,00,00\",\n        \"00,17,00,00,00,00,00,67,00\",\n        \"00,18,00,00,11,00,00,64,00\",\n        \"00,00,24,21,00,01,02,00,00\",\n        \"00,00,00,00,00,00,00,00,00\"};\n\n    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    static int[][] grid;\n    static int[] clues;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 2;\n        int nCols = board[0].split(\",\").length + 2;\n        int startRow = 0, startCol = 0;\n\n        grid = new int[nRows][nCols];\n        totalToFill = (nRows - 2) * (nCols - 2);\n        List<Integer> lst = new ArrayList<>();\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n\n            if (r >= 1 && r < nRows - 1) {\n\n                String[] row = board[r - 1].split(\",\");\n\n                for (int c = 1; c < nCols - 1; c++) {\n                    int val = Integer.parseInt(row[c - 1]);\n                    if (val > 0)\n                        lst.add(val);\n                    if (val == 1) {\n                        startRow = r;\n                        startCol = c;\n                    }\n                    grid[r][c] = val;\n                }\n            }\n        }\n\n        clues = lst.stream().sorted().mapToInt(i -> i).toArray();\n\n        if (solve(startRow, startCol, 1, 0))\n            printResult();\n    }\n\n    static boolean solve(int r, int c, int count, int nextClue) {\n        if (count > totalToFill)\n            return true;\n\n        if (grid[r][c] != 0 && grid[r][c] != count)\n            return false;\n\n        if (grid[r][c] == 0 && nextClue < clues.length)\n            if (clues[nextClue] == count)\n                return false;\n\n        int back = grid[r][c];\n        if (back == count)\n            nextClue++;\n\n        grid[r][c] = count;\n        for (int[] move : moves)\n            if (solve(r + move[1], c + move[0], count + 1, nextClue))\n                return true;\n\n        grid[r][c] = back;\n        return false;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425134, "name": "Solve a Numbrix puzzle", "source": "Translate Ruby to Java: require 'HLPsolver'\n\nADJACENT = [[-1, 0], [0, -1], [0, 1], [1, 0]]\n\nboard1 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board1).solve\n\nboard2 = <<EOS\n 0  0  0  0  0  0  0  0  0\n 0 11 12 15 18 21 62 61  0\n 0  6  0  0  0  0  0 60  0\n 0 33  0  0  0  0  0 57  0\n 0 32  0  0  0  0  0 56  0\n 0 37  0  1  0  0  0 73  0\n 0 38  0  0  0  0  0 72  0\n 0 43 44 47 48 51 76 77  0\n 0  0  0  0  0  0  0  0  0\nEOS\nHLPsolver.new(board2).solve\n", "target": "import java.util.*;\n\npublic class Numbrix {\n\n    final static String[] board = {\n        \"00,00,00,00,00,00,00,00,00\",\n        \"00,00,46,45,00,55,74,00,00\",\n        \"00,38,00,00,43,00,00,78,00\",\n        \"00,35,00,00,00,00,00,71,00\",\n        \"00,00,33,00,00,00,59,00,00\",\n        \"00,17,00,00,00,00,00,67,00\",\n        \"00,18,00,00,11,00,00,64,00\",\n        \"00,00,24,21,00,01,02,00,00\",\n        \"00,00,00,00,00,00,00,00,00\"};\n\n    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    static int[][] grid;\n    static int[] clues;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 2;\n        int nCols = board[0].split(\",\").length + 2;\n        int startRow = 0, startCol = 0;\n\n        grid = new int[nRows][nCols];\n        totalToFill = (nRows - 2) * (nCols - 2);\n        List<Integer> lst = new ArrayList<>();\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n\n            if (r >= 1 && r < nRows - 1) {\n\n                String[] row = board[r - 1].split(\",\");\n\n                for (int c = 1; c < nCols - 1; c++) {\n                    int val = Integer.parseInt(row[c - 1]);\n                    if (val > 0)\n                        lst.add(val);\n                    if (val == 1) {\n                        startRow = r;\n                        startCol = c;\n                    }\n                    grid[r][c] = val;\n                }\n            }\n        }\n\n        clues = lst.stream().sorted().mapToInt(i -> i).toArray();\n\n        if (solve(startRow, startCol, 1, 0))\n            printResult();\n    }\n\n    static boolean solve(int r, int c, int count, int nextClue) {\n        if (count > totalToFill)\n            return true;\n\n        if (grid[r][c] != 0 && grid[r][c] != count)\n            return false;\n\n        if (grid[r][c] == 0 && nextClue < clues.length)\n            if (clues[nextClue] == count)\n                return false;\n\n        int back = grid[r][c];\n        if (back == count)\n            nextClue++;\n\n        grid[r][c] = count;\n        for (int[] move : moves)\n            if (solve(r + move[1], c + move[0], count + 1, nextClue))\n                return true;\n\n        grid[r][c] = back;\n        return false;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425135, "name": "Arithmetic evaluation", "source": "Translate Ruby to Java: $op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n  \n  def initialize(info)\n    @info = info\n  end\n  \n  def leaf?\n    @left.nil? and @right.nil?\n  end\n  \n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n      \n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n      \n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n  \n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n  \n  tokens.each do |token|\n    if operator?(token)\n      \n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      \n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n  \n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n  \n  node_stack.last\nend\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 425136, "name": "Arithmetic evaluation", "source": "Translate Ruby to Java: $op_priority = {\"+\" => 0, \"-\" => 0, \"*\" => 1, \"/\" => 1}\n\nclass TreeNode\n  OP_FUNCTION = {\n    \"+\" => lambda {|x, y| x + y},\n    \"-\" => lambda {|x, y| x - y},\n    \"*\" => lambda {|x, y| x * y},\n    \"/\" => lambda {|x, y| x / y}}\n  attr_accessor :info, :left, :right\n  \n  def initialize(info)\n    @info = info\n  end\n  \n  def leaf?\n    @left.nil? and @right.nil?\n  end\n  \n  def to_s(order)\n    if leaf?\n      @info\n    else\n      left_s, right_s = @left.to_s(order), @right.to_s(order)\n      \n      strs = case order\n             when :prefix  then [@info, left_s, right_s]\n             when :infix   then [left_s, @info, right_s]\n             when :postfix then [left_s, right_s, @info]\n             else               []\n             end\n      \n      \"(\" + strs.join(\" \") + \")\"\n    end\n  end\n  \n  def eval\n    if !leaf? and operator?(@info)\n      OP_FUNCTION[@info].call(@left.eval, @right.eval)\n    else\n      @info.to_f\n    end\n  end\nend\n\ndef tokenize(exp)\n  exp\n    .gsub('(', ' ( ')\n    .gsub(')', ' ) ')\n    .gsub('+', ' + ')\n    .gsub('-', ' - ')\n    .gsub('*', ' * ')\n    .gsub('/', ' / ')\n    .split(' ')\nend\n\ndef operator?(token)\n  $op_priority.has_key?(token)\nend\n\ndef pop_connect_push(op_stack, node_stack)\n  temp = op_stack.pop\n  temp.right = node_stack.pop\n  temp.left = node_stack.pop\n  node_stack.push(temp)\nend\n\ndef infix_exp_to_tree(exp)\n  tokens = tokenize(exp)\n  op_stack, node_stack = [], []\n  \n  tokens.each do |token|\n    if operator?(token)\n      \n      until (op_stack.empty? or\n             op_stack.last.info == \"(\" or\n             $op_priority[op_stack.last.info] < $op_priority[token])\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      op_stack.push(TreeNode.new(token))\n    elsif token == \"(\"\n      op_stack.push(TreeNode.new(token))\n    elsif token == \")\"\n      while op_stack.last.info != \"(\"\n        pop_connect_push(op_stack, node_stack)\n      end\n      \n      \n      op_stack.pop\n    else\n      node_stack.push(TreeNode.new(token))\n    end\n  end\n  \n  until op_stack.empty?\n    pop_connect_push(op_stack, node_stack)\n  end\n  \n  node_stack.last\nend\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 425137, "name": "Sierpinski curve", "source": "Translate Ruby to Java: var rules = Hash(\n    x => 'xF+G+xF--F--xF+G+x',\n)\n\nvar lsys = LSystem(\n    width:  550,\n    height: 550,\n\n    xoff: -9,\n    yoff: -271,\n\n    len:   5,\n    angle: 45,\n    color: 'dark green',\n)\n\nlsys.execute('F--xF--F--xF', 5, \"sierpi\u0144ski_curve.png\", rules)\n", "target": "import java.io.*;\n\npublic class SierpinskiCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_curve.svg\"))) {\n            SierpinskiCurve s = new SierpinskiCurve(writer);\n            s.currentAngle = 45;\n            s.currentX = 5;\n            s.currentY = 10;\n            s.lineLength = 7;\n            s.begin(545);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                case 'G':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY -= length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F--XF--F--XF\";\n    private static final String PRODUCTION = \"XF+G+XF--F--XF+G+X\";\n    private static final int ANGLE = 45;\n}\n"}
{"id": 425138, "name": "Sierpinski curve", "source": "Translate Ruby to Java: var rules = Hash(\n    x => 'xF+G+xF--F--xF+G+x',\n)\n\nvar lsys = LSystem(\n    width:  550,\n    height: 550,\n\n    xoff: -9,\n    yoff: -271,\n\n    len:   5,\n    angle: 45,\n    color: 'dark green',\n)\n\nlsys.execute('F--xF--F--xF', 5, \"sierpi\u0144ski_curve.png\", rules)\n", "target": "import java.io.*;\n\npublic class SierpinskiCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_curve.svg\"))) {\n            SierpinskiCurve s = new SierpinskiCurve(writer);\n            s.currentAngle = 45;\n            s.currentX = 5;\n            s.currentY = 10;\n            s.lineLength = 7;\n            s.begin(545);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                case 'G':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY -= length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F--XF--F--XF\";\n    private static final String PRODUCTION = \"XF+G+XF--F--XF+G+X\";\n    private static final int ANGLE = 45;\n}\n"}
{"id": 425139, "name": "Make a backup file", "source": "Translate Ruby to Java: def backup_and_open(filename)\n  filename = File.realpath(filename)\n  bkup = filename + \".backup\"\n  backup_files = Dir.glob(bkup + \"*\").sort_by do |f|\n    f.match(/\\d+$/)\n    $&.nil? ? 0 : $&.to_i\n  end\n  backup_files.reverse.each do |fname|\n    if m = fname.match(/\\.backup\\.(\\d+)$/)\n      File.rename(fname, \"%s.%d\" % [bkup, m[1].to_i + 1])\n    elsif fname == bkup\n      File.rename(bkup, bkup + \".1\")\n    end\n  end\n  File.rename(filename, bkup)\n  File.open(filename, \"w\") {|handle| yield handle}\nend\n\n1.upto(12) {|i| backup_and_open(ARGV[0]) {|fh| fh.puts \"backup \n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.*;\n \npublic class Backup {\n\tpublic static void saveWithBackup(String filename, String... data) \n        throws IOException {\n\t\t\n\t\tPath file = Paths.get(filename).toRealPath();\n\t\tFile backFile = new File(filename + \".backup\");\n\t\tif(!backFile.exists()) {\n\t\t\t\n\t\t\tbackFile.createNewFile();\n\t\t}\n\t\tPath back = Paths.get(filename + \".backup\").toRealPath();\n\t\tFiles.move(file, back, StandardCopyOption.REPLACE_EXISTING);\n\t\ttry(PrintWriter out = new PrintWriter(file.toFile())){\n\t\t\tfor(int i = 0; i < data.length; i++) {\n\t\t\t\tout.print(data[i]);\n\t\t\t\tif(i < data.length - 1) {\n\t\t\t\t\tout.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n        public static void main(String[] args) {\n\t\ttry {\n\t\t\tsaveWithBackup(\"original.txt\", \"fourth\", \"fifth\", \"sixth\");\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t} \n}\n"}
{"id": 425140, "name": "Make a backup file", "source": "Translate Ruby to Java: def backup_and_open(filename)\n  filename = File.realpath(filename)\n  bkup = filename + \".backup\"\n  backup_files = Dir.glob(bkup + \"*\").sort_by do |f|\n    f.match(/\\d+$/)\n    $&.nil? ? 0 : $&.to_i\n  end\n  backup_files.reverse.each do |fname|\n    if m = fname.match(/\\.backup\\.(\\d+)$/)\n      File.rename(fname, \"%s.%d\" % [bkup, m[1].to_i + 1])\n    elsif fname == bkup\n      File.rename(bkup, bkup + \".1\")\n    end\n  end\n  File.rename(filename, bkup)\n  File.open(filename, \"w\") {|handle| yield handle}\nend\n\n1.upto(12) {|i| backup_and_open(ARGV[0]) {|fh| fh.puts \"backup \n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.*;\n \npublic class Backup {\n\tpublic static void saveWithBackup(String filename, String... data) \n        throws IOException {\n\t\t\n\t\tPath file = Paths.get(filename).toRealPath();\n\t\tFile backFile = new File(filename + \".backup\");\n\t\tif(!backFile.exists()) {\n\t\t\t\n\t\t\tbackFile.createNewFile();\n\t\t}\n\t\tPath back = Paths.get(filename + \".backup\").toRealPath();\n\t\tFiles.move(file, back, StandardCopyOption.REPLACE_EXISTING);\n\t\ttry(PrintWriter out = new PrintWriter(file.toFile())){\n\t\t\tfor(int i = 0; i < data.length; i++) {\n\t\t\t\tout.print(data[i]);\n\t\t\t\tif(i < data.length - 1) {\n\t\t\t\t\tout.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n        public static void main(String[] args) {\n\t\ttry {\n\t\t\tsaveWithBackup(\"original.txt\", \"fourth\", \"fifth\", \"sixth\");\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t} \n}\n"}
{"id": 425141, "name": "Snake and ladder", "source": "Translate Ruby to Java: NONE = 0; LADDER = 1; SNAKE = 2; STAY = 1; MOVE = 2; WIN = 3\nclass Cell\n    @type; @to; attr_reader :type, :to\n    def initialize; @type = NONE; @to = 0; end \n    def set( t, o ); @type = t; @to = o; end\nend\nclass Player\n    @pos; @name; attr_accessor :pos; attr_reader :name\n    def initialize( n ); @pos = 0; @name = n; end\n    def play( dice )\n        s = dice.roll; return s, STAY if @pos + s > 99\n        @pos += s; return s, WIN if @pos == 99\n        return s, MOVE\n    end\nend\nclass Die\n    @sides; def initialize( s = 6 ); @sides = s; end\n    def roll; return 1 + rand( @sides ); end\nend\ndef initBoard\n    @board = Array.new( 100 ); for i in 0 .. 99; @board[i] = Cell.new(); end\n    @board[3].set( LADDER, 13 ); @board[8].set( LADDER, 30 ); @board[19].set( LADDER, 37 );\n    @board[27].set( LADDER, 83 );@board[39].set( LADDER, 58 ); @board[50].set( LADDER, 66 );\n    @board[62].set( LADDER, 80 ); @board[70].set( LADDER, 90 ); @board[16].set( SNAKE, 6 );\n    @board[61].set( SNAKE, 18 ); @board[86].set( SNAKE, 23 ); @board[53].set( SNAKE, 33 );\n    @board[63].set( SNAKE, 59 ); @board[92].set( SNAKE, 72 ); @board[94].set( SNAKE, 74 ); \n    @board[98].set( SNAKE, 77 );\nend\ndef initPlayers\n    @players = Array.new( 4 );\n    for i in 0 .. @playersCount - 1; @players[i] = Player.new( \"player \" << i + 49 ); end\nend\ndef play\n    initBoard; initPlayers; @die = Die.new\n    while true\n        for p in 0 .. @playersCount - 1\n            puts; puts\n            if( 0 == p ) \n                print \"\n                \"Press [RETURN] to roll the die.\"\n                gets; np = @players[p].play( @die ); print \"You rolled a \n                if np[1] == WIN\n                    print \"You reached position \n                elsif np[1] == STAY; print \"Sorry, you cannot move!\\n\"\n                else print \"Your new position is cell \n                end\n            else\n                np = @players[p].play( @die ); print \"\n                if np[1] == WIN \n                     print \"He reached position \n                elsif np[1] == STAY; print \"But he cannot move....\\n\"\n                else print \"His new position is cell \n                end\n            end\n            s = @board[@players[p].pos].type\n            next if s == NONE\n            @players[p].pos = @board[@players[p].pos].to\n            case s\n                when SNAKE; print \"What a pitty, landed on a snake. \"\n                when LADDER; print \"Lucky move! Landed on a ladder. \"\n            end\n            print \"New position is cell \n        end\n    end\nend\n@playersCount = 4; @board; @players; @die\nplay\n", "target": "import java.util.Map;\nimport java.util.Random;\n\npublic class Game {\n    private static final Map<Integer, Integer> snl = Map.ofEntries(\n        Map.entry(4, 14),\n        Map.entry(9, 31),\n        Map.entry(17, 7),\n        Map.entry(20, 38),\n        Map.entry(28, 84),\n        Map.entry(40, 59),\n        Map.entry(51, 67),\n        Map.entry(54, 34),\n        Map.entry(62, 19),\n        Map.entry(63, 81),\n        Map.entry(64, 60),\n        Map.entry(71, 91),\n        Map.entry(87, 24),\n        Map.entry(93, 73),\n        Map.entry(95, 75),\n        Map.entry(99, 78)\n    );\n    private static final boolean sixesThrowAgain = true;\n    private static Random rand = new Random();\n\n    private static int turn(int player, int square) {\n        int square2 = square;\n        while (true) {\n            int roll = rand.nextInt(6) + 1;\n            System.out.printf(\"Player %d, on square %d, rolls a %d\", player, square2, roll);\n            if (square2 + roll > 100) {\n                System.out.println(\" but cannot move.\");\n            } else {\n                square2 += roll;\n                System.out.printf(\" and moves to square %d\\n\", square2);\n                if (square2 == 100) return 100;\n                Integer next = snl.getOrDefault(square2, square2);\n                if (square2 < next) {\n                    System.out.printf(\"Yay! Landed on a ladder. Climb up to %d.\\n\", next);\n                    if (next == 100) return 100;\n                    square2 = next;\n                } else if (square2 > next) {\n                    System.out.printf(\"Oops! Landed on a snake. Slither down to %d.\\n\", next);\n                    square2 = next;\n                }\n            }\n            if (roll < 6 || !sixesThrowAgain) return square2;\n            System.out.println(\"Rolled a 6 so roll again.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        \n        int[] players = {1, 1, 1};\n        while (true) {\n            for (int i = 0; i < players.length; ++i) {\n                int ns = turn(i + 1, players[i]);\n                if (ns == 100) {\n                    System.out.printf(\"Player %d wins!\\n\", i + 1);\n                    return;\n                }\n                players[i] = ns;\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425142, "name": "Snake and ladder", "source": "Translate Ruby to Java: NONE = 0; LADDER = 1; SNAKE = 2; STAY = 1; MOVE = 2; WIN = 3\nclass Cell\n    @type; @to; attr_reader :type, :to\n    def initialize; @type = NONE; @to = 0; end \n    def set( t, o ); @type = t; @to = o; end\nend\nclass Player\n    @pos; @name; attr_accessor :pos; attr_reader :name\n    def initialize( n ); @pos = 0; @name = n; end\n    def play( dice )\n        s = dice.roll; return s, STAY if @pos + s > 99\n        @pos += s; return s, WIN if @pos == 99\n        return s, MOVE\n    end\nend\nclass Die\n    @sides; def initialize( s = 6 ); @sides = s; end\n    def roll; return 1 + rand( @sides ); end\nend\ndef initBoard\n    @board = Array.new( 100 ); for i in 0 .. 99; @board[i] = Cell.new(); end\n    @board[3].set( LADDER, 13 ); @board[8].set( LADDER, 30 ); @board[19].set( LADDER, 37 );\n    @board[27].set( LADDER, 83 );@board[39].set( LADDER, 58 ); @board[50].set( LADDER, 66 );\n    @board[62].set( LADDER, 80 ); @board[70].set( LADDER, 90 ); @board[16].set( SNAKE, 6 );\n    @board[61].set( SNAKE, 18 ); @board[86].set( SNAKE, 23 ); @board[53].set( SNAKE, 33 );\n    @board[63].set( SNAKE, 59 ); @board[92].set( SNAKE, 72 ); @board[94].set( SNAKE, 74 ); \n    @board[98].set( SNAKE, 77 );\nend\ndef initPlayers\n    @players = Array.new( 4 );\n    for i in 0 .. @playersCount - 1; @players[i] = Player.new( \"player \" << i + 49 ); end\nend\ndef play\n    initBoard; initPlayers; @die = Die.new\n    while true\n        for p in 0 .. @playersCount - 1\n            puts; puts\n            if( 0 == p ) \n                print \"\n                \"Press [RETURN] to roll the die.\"\n                gets; np = @players[p].play( @die ); print \"You rolled a \n                if np[1] == WIN\n                    print \"You reached position \n                elsif np[1] == STAY; print \"Sorry, you cannot move!\\n\"\n                else print \"Your new position is cell \n                end\n            else\n                np = @players[p].play( @die ); print \"\n                if np[1] == WIN \n                     print \"He reached position \n                elsif np[1] == STAY; print \"But he cannot move....\\n\"\n                else print \"His new position is cell \n                end\n            end\n            s = @board[@players[p].pos].type\n            next if s == NONE\n            @players[p].pos = @board[@players[p].pos].to\n            case s\n                when SNAKE; print \"What a pitty, landed on a snake. \"\n                when LADDER; print \"Lucky move! Landed on a ladder. \"\n            end\n            print \"New position is cell \n        end\n    end\nend\n@playersCount = 4; @board; @players; @die\nplay\n", "target": "import java.util.Map;\nimport java.util.Random;\n\npublic class Game {\n    private static final Map<Integer, Integer> snl = Map.ofEntries(\n        Map.entry(4, 14),\n        Map.entry(9, 31),\n        Map.entry(17, 7),\n        Map.entry(20, 38),\n        Map.entry(28, 84),\n        Map.entry(40, 59),\n        Map.entry(51, 67),\n        Map.entry(54, 34),\n        Map.entry(62, 19),\n        Map.entry(63, 81),\n        Map.entry(64, 60),\n        Map.entry(71, 91),\n        Map.entry(87, 24),\n        Map.entry(93, 73),\n        Map.entry(95, 75),\n        Map.entry(99, 78)\n    );\n    private static final boolean sixesThrowAgain = true;\n    private static Random rand = new Random();\n\n    private static int turn(int player, int square) {\n        int square2 = square;\n        while (true) {\n            int roll = rand.nextInt(6) + 1;\n            System.out.printf(\"Player %d, on square %d, rolls a %d\", player, square2, roll);\n            if (square2 + roll > 100) {\n                System.out.println(\" but cannot move.\");\n            } else {\n                square2 += roll;\n                System.out.printf(\" and moves to square %d\\n\", square2);\n                if (square2 == 100) return 100;\n                Integer next = snl.getOrDefault(square2, square2);\n                if (square2 < next) {\n                    System.out.printf(\"Yay! Landed on a ladder. Climb up to %d.\\n\", next);\n                    if (next == 100) return 100;\n                    square2 = next;\n                } else if (square2 > next) {\n                    System.out.printf(\"Oops! Landed on a snake. Slither down to %d.\\n\", next);\n                    square2 = next;\n                }\n            }\n            if (roll < 6 || !sixesThrowAgain) return square2;\n            System.out.println(\"Rolled a 6 so roll again.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        \n        int[] players = {1, 1, 1};\n        while (true) {\n            for (int i = 0; i < players.length; ++i) {\n                int ns = turn(i + 1, players[i]);\n                if (ns == 100) {\n                    System.out.printf(\"Player %d wins!\\n\", i + 1);\n                    return;\n                }\n                players[i] = ns;\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425143, "name": "Naming conventions", "source": "Translate Ruby to Java: test_variable = [1, 9, 8, 3]\ntest_variable.sort    \ntest_variable         \ntest_variable.sort!   \ntest_variable         \n", "target": "\n\nmodule shop.acme.com\n    {\n    \n    const Point(Int x, Int y);\n    enum Color {Red, Green, Blue}\n    interface Callback\n        {\n        \n        Boolean active;\n        void onEvent(String event);\n        void onError(Exception e);\n        }\n\n    \n    String DefaultLogin = \"guest\";\n    Int    MAX_QUANTITY = 100;\n\n    \n    interface Bag<Element>\n            extends Iterable<Element>\n        {\n        void add(Element e);\n        }\n    }\n"}
{"id": 425144, "name": "Farey sequence", "source": "Translate Ruby to Java: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 425145, "name": "Farey sequence", "source": "Translate Ruby to Java: require \"big\"\n\ndef farey(n)\n    a, b, c, d = 0, 1, 1, n\n    fracs = [] of BigRational\n    fracs << BigRational.new(0,1)\n    while c <= n\n        k = (n + b) // d\n        a, b, c, d = c, d, k * c - a, k * d - b\n        fracs << BigRational.new(a,b)\n    end\n    fracs.uniq.sort\nend\n\nputs \"Farey sequence for order 1 through 11 (inclusive):\"\n(1..11).each do |n|\n  puts \"F(\nend\n\nputs \"Number of fractions in the Farey sequence:\"\n(100..1000).step(100) do |i|\n  puts \"F(%4d) =%7d\" % [i, farey(i).size]\nend\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 425146, "name": "Aliquot sequence classifications", "source": "Translate Ruby to Java: def aliquot(n, maxlen=16, maxterm=2**47)\n  return \"terminating\", [0] if n == 0\n  s = []\n  while (s << n).size <= maxlen and n < maxterm\n    n = n.proper_divisors.inject(0, :+)\n    if s.include?(n)\n      case n\n      when s[0]\n        case s.size\n        when 1   then   return \"perfect\", s\n        when 2   then   return \"amicable\", s\n        else            return \"sociable of length \n        end\n      when s[-1] then   return \"aspiring\", s\n      else              return \"cyclic back to \n      end\n    elsif n == 0 then   return \"terminating\", s << 0\n    end\n  end\n  return \"non-terminating\", s\nend\n\nfor n in 1..10\n  puts \"%20s: %p\" % aliquot(n)\nend\nputs\nfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n  puts \"%20s: %p\" % aliquot(n)\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 425147, "name": "Aliquot sequence classifications", "source": "Translate Ruby to Java: def aliquot(n, maxlen=16, maxterm=2**47)\n  return \"terminating\", [0] if n == 0\n  s = []\n  while (s << n).size <= maxlen and n < maxterm\n    n = n.proper_divisors.inject(0, :+)\n    if s.include?(n)\n      case n\n      when s[0]\n        case s.size\n        when 1   then   return \"perfect\", s\n        when 2   then   return \"amicable\", s\n        else            return \"sociable of length \n        end\n      when s[-1] then   return \"aspiring\", s\n      else              return \"cyclic back to \n      end\n    elsif n == 0 then   return \"terminating\", s << 0\n    end\n  end\n  return \"non-terminating\", s\nend\n\nfor n in 1..10\n  puts \"%20s: %p\" % aliquot(n)\nend\nputs\nfor n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]\n  puts \"%20s: %p\" % aliquot(n)\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 425148, "name": "Implicit type conversion", "source": "Translate Ruby to Java: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "public class ImplicitTypeConversion{\n   public static void main(String...args){\n      System.out.println( \"Primitive conversions\" );\n      byte  by = -1;\n      short sh = by;\n      int   in = sh;\n      long  lo = in;\n      System.out.println( \"byte value    -1         to 3 integral types:  \" + lo );\n\n      float  fl = 0.1f;\n      double db = fl;\n      System.out.println( \"float value   0.1        to double:            \" + db );\n\n      int    in2 = -1;\n      float  fl2 = in2;\n      double db2 = fl2;\n      System.out.println( \"int value     -1         to float and double:  \" + db2 );\n\n      int    in3 = Integer.MAX_VALUE;\n      float  fl3 = in3;\n      double db3 = fl3;\n      System.out.println( \"int value     \" + Integer.MAX_VALUE + \" to float and double:  \" + db3 );\n\n      char   ch  = 'a';\n      int    in4 = ch;\n      double db4 = in4;\n      System.out.println( \"char value    '\" + ch + \"'        to int and double:    \" + db4 );\n\n      System.out.println();\n      System.out.println( \"Boxing and unboxing\" );\n      Integer in5 = -1;\n      int     in6 = in5;\n      System.out.println( \"int  value    -1         to Integer and int:   \" + in6 );\n\n      Double db5 = 0.1;\n      double db6 = db5;\n      System.out.println( \"double value  0.1        to Double and double: \" + db6 );\n   }\n}\n"}
{"id": 425149, "name": "Implicit type conversion", "source": "Translate Ruby to Java: > 1+\"2\"            \n> \"1\"+2            \n> sqrt(-4)         \n> (\"a\" + [1,2])    \n> ('ha' * '3')     \n> ('ha' * true)    \n", "target": "public class ImplicitTypeConversion{\n   public static void main(String...args){\n      System.out.println( \"Primitive conversions\" );\n      byte  by = -1;\n      short sh = by;\n      int   in = sh;\n      long  lo = in;\n      System.out.println( \"byte value    -1         to 3 integral types:  \" + lo );\n\n      float  fl = 0.1f;\n      double db = fl;\n      System.out.println( \"float value   0.1        to double:            \" + db );\n\n      int    in2 = -1;\n      float  fl2 = in2;\n      double db2 = fl2;\n      System.out.println( \"int value     -1         to float and double:  \" + db2 );\n\n      int    in3 = Integer.MAX_VALUE;\n      float  fl3 = in3;\n      double db3 = fl3;\n      System.out.println( \"int value     \" + Integer.MAX_VALUE + \" to float and double:  \" + db3 );\n\n      char   ch  = 'a';\n      int    in4 = ch;\n      double db4 = in4;\n      System.out.println( \"char value    '\" + ch + \"'        to int and double:    \" + db4 );\n\n      System.out.println();\n      System.out.println( \"Boxing and unboxing\" );\n      Integer in5 = -1;\n      int     in6 = in5;\n      System.out.println( \"int  value    -1         to Integer and int:   \" + in6 );\n\n      Double db5 = 0.1;\n      double db6 = db5;\n      System.out.println( \"double value  0.1        to Double and double: \" + db6 );\n   }\n}\n"}
{"id": 425150, "name": "Magnanimous numbers", "source": "Translate Ruby to Java: require \"prime\"\n\nmagnanimouses = Enumerator.new do |y|\n  (0..).each {|n| y << n if (1..n.digits.size-1).all? {|k| n.divmod(10**k).sum.prime?} }\nend\n\nputs \"First 45 magnanimous numbers:\"\nputs magnanimouses.first(45).join(' ')\n \nputs \"\\n241st through 250th magnanimous numbers:\"\nputs magnanimouses.first(250).last(10).join(' ')\n \nputs \"\\n391st through 400th magnanimous numbers:\"\nputs magnanimouses.first(400).last(10).join(' ')\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MagnanimousNumbers {\n\n    public static void main(String[] args) {\n        runTask(\"Find and display the first 45 magnanimous numbers.\", 1, 45);\n        runTask(\"241st through 250th magnanimous numbers.\", 241, 250);\n        runTask(\"391st through 400th magnanimous numbers.\", 391, 400);\n    }\n    \n    private static void runTask(String message, int startN, int endN) {\n        int count = 0;\n        List<Integer> nums = new ArrayList<>();\n        for ( int n = 0 ; count < endN ; n++ ) {\n            if ( isMagnanimous(n) ) {\n                nums.add(n);\n                count++;\n            }\n        }\n        System.out.printf(\"%s%n\", message);\n        System.out.printf(\"%s%n%n\", nums.subList(startN-1, endN));\n    }\n    \n    private static boolean isMagnanimous(long n) {\n        if ( n >= 0 && n <= 9 ) {\n            return true;\n        }\n        long q = 11;\n        for ( long div = 10 ; q >= 10 ; div *= 10 ) {\n            q = n / div;\n            long r = n % div;\n            if ( ! isPrime(q+r) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 425151, "name": "Mersenne primes", "source": "Translate Ruby to Java: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 425152, "name": "Mersenne primes", "source": "Translate Ruby to Java: require 'openssl'\n(0..).each{|n| puts \"2**\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 425153, "name": "Sexy primes", "source": "Translate Ruby to Java: require 'prime'\n\nprime_array, sppair2, sppair3, sppair4, sppair5 = Array.new(5) {Array.new()} \nunsexy, i, start = [2], 0, Time.now\nPrime.each(1_000_100) {|prime| prime_array.push prime}\n\nwhile prime_array[i] < 1_000_035\n  i+=1\n  unsexy.push(i) if prime_array[(i+1)..(i+2)].include?(prime_array[i]+6) == false && prime_array[(i-2)..(i-1)].include?(prime_array[i]-6) == false && prime_array[i]+6 < 1_000_035\n  prime_array[(i+1)..(i+4)].include?(prime_array[i]+6) && prime_array[i]+6 < 1_000_035 ? sppair2.push(i) : next\n  prime_array[(i+2)..(i+5)].include?(prime_array[i]+12) && prime_array[i]+12 < 1_000_035 ? sppair3.push(i) : next\n  prime_array[(i+3)..(i+6)].include?(prime_array[i]+18) && prime_array[i]+18 < 1_000_035 ? sppair4.push(i) : next\n  prime_array[(i+4)..(i+7)].include?(prime_array[i]+24) && prime_array[i]+24 < 1_000_035 ? sppair5.push(i) : next\nend\n\nputs \"\\nSexy prime pairs: \nsppair2.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime triplets: \nsppair3.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime quadruplets: \nsppair4.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12, prime_array[prime]+18].join(\" - \"), \"\\n\"}\nputs \"\\nSexy prime quintuplets: \nsppair5.last(5).each {|prime| print [prime_array[prime], prime_array[prime]+6, prime_array[prime]+12, prime_array[prime]+18, prime_array[prime]+24].join(\" - \"), \"\\n\"}\n\nputs \"\\nUnSexy prime: \nunsexy.last(10).each {|item| print prime_array[item], \" \"}\nprint \"\\n\\n\", Time.now - start, \" seconds\"\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SexyPrimes {\n\n    public static void main(String[] args) {\n        sieve();\n        int pairs = 0;\n        List<String> pairList = new ArrayList<>();\n        int triples = 0;\n        List<String> tripleList = new ArrayList<>();\n        int quadruplets = 0;\n        List<String> quadrupletList = new ArrayList<>();\n        int unsexyCount = 1;  \n        List<String> unsexyList = new ArrayList<>();\n        for ( int i = 3 ; i < MAX ; i++ ) {\n            if ( i-6 >= 3 && primes[i-6] && primes[i] ) {\n                pairs++;\n                pairList.add((i-6) + \" \" + i);\n                if ( pairList.size() > 5 ) {\n                    pairList.remove(0);\n                }\n            }\n            else if ( i < MAX-2 && primes[i] && ! (i+6<MAX && primes[i] && primes[i+6])) {\n                unsexyCount++;\n                unsexyList.add(\"\" + i);\n                if ( unsexyList.size() > 10 ) {\n                    unsexyList.remove(0);\n                }\n            }\n            if ( i-12 >= 3 && primes[i-12] && primes[i-6] && primes[i] ) {\n                triples++;\n                tripleList.add((i-12) + \" \" + (i-6) + \" \" + i);\n                if ( tripleList.size() > 5 ) {\n                    tripleList.remove(0);\n                }\n            }\n            if ( i-16 >= 3 && primes[i-18] && primes[i-12] && primes[i-6] && primes[i] ) {\n                quadruplets++;\n                quadrupletList.add((i-18) + \" \" + (i-12) + \" \" + (i-6) + \" \" + i);\n                if ( quadrupletList.size() > 5 ) {\n                    quadrupletList.remove(0);\n                }\n            }\n        }\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, pairs);\n        System.out.printf(\"The last 5 sexy pairs:%n  %s%n%n\", pairList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, triples);\n        System.out.printf(\"The last 5 sexy triples:%n  %s%n%n\", tripleList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy quadruplets less than\u00a0%,d =\u00a0%,d%n\", MAX, quadruplets);\n        System.out.printf(\"The last 5 sexy quadruplets:%n  %s%n%n\", quadrupletList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of unsexy primes less than\u00a0%,d =\u00a0%,d%n\", MAX, unsexyCount);\n        System.out.printf(\"The last 10 unsexy primes:%n  %s%n%n\", unsexyList.toString().replaceAll(\", \", \"], [\"));\n    }\n\n    private static int MAX = 1_000_035;\n    private static boolean[] primes = new boolean[MAX];\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 425154, "name": "Taxicab numbers", "source": "Translate Ruby to Java: def taxicab_number(nmax=1200)\n  [*1..nmax].repeated_combination(2).group_by{|x,y| x**3 + y**3}.select{|k,v| v.size>1}.sort\nend\n\nt = [0] + taxicab_number\n\n[*1..25, *2000...2007].each do |i|\n  puts \"%4d: %10d\" % [i, t[i][0]] + t[i][1].map{|a| \" = %4d**3 + %4d**3\" % a}.join\nend\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 425155, "name": "Strong and weak primes", "source": "Translate Ruby to Java: require 'prime'\n\nstrong_gen = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b<b} }\nweak_gen   = Enumerator.new{|y| Prime.each_cons(3){|a,b,c|y << b if a+c-b>b} }\n\nputs \"First 36 strong primes:\"\nputs strong_gen.take(36).join(\" \"), \"\\n\"\nputs \"First 37 weak primes:\"\nputs weak_gen.take(37).join(\" \"), \"\\n\"\n\n[1_000_000, 10_000_000].each do |limit|\n  strongs, weaks = 0, 0\n  Prime.each_cons(3) do |a,b,c|\n    strongs += 1 if b > a+c-b\n    weaks += 1 if b < a+c-b\n    break if c > limit\n  end\n  puts \"\nend\n", "target": "public class StrongAndWeakPrimes {\n\n    private static int MAX = 10_000_000 + 1000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 36 strong primes:\");        \n        displayStrongPrimes(36);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of strong primes below\u00a0%,d =\u00a0%,d%n\", n, strongPrimesBelow(n));\n        }\n        System.out.println(\"First 37 weak primes:\");        \n        displayWeakPrimes(37);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of weak primes below\u00a0%,d =\u00a0%,d%n\", n, weakPrimesBelow(n));\n        }\n    }\n\n    private static int weakPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n\n    private static void displayWeakPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static int getNextPrime(int currentPrime) {\n        int nextPrime = currentPrime + 2;\n        while ( ! primes[nextPrime] ) {\n            nextPrime += 2;\n        }\n        return nextPrime;\n    }\n    \n    private static int strongPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n    \n    private static void displayStrongPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 425156, "name": "Left factorials", "source": "Translate Ruby to Java: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 425157, "name": "Left factorials", "source": "Translate Ruby to Java: left_fact = Enumerator.new do |y|\n  f, lf = 1, 0\n  1.step do |n|\n    y  << lf \n    lf += f\n    f  *= n\n  end\nend\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 425158, "name": "Strange unique prime triplets", "source": "Translate Ruby to Java: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 425159, "name": "Strange unique prime triplets", "source": "Translate Ruby to Java: require 'prime'\n\nPrime.each(30).to_a.combination(3).select{|trio| trio.sum.prime? }.each do |a,b,c|\n  puts \"\nend\n\nm = 1000\ncount = Prime.each(m).to_a.combination(3).count{|trio| trio.sum.prime? }\nputs \"Count of strange unique prime triplets < \n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 425160, "name": "Strange plus numbers", "source": "Translate Ruby to Java: $p = [\n    false, false, true, true, false,\n    true, false, true, false, false,\n    false, true, false, true, false,\n    false, false, true, false\n]\n\ndef isStrange(n)\n    if n < 10 then\n        return false\n    end\n\n    while n >= 10 do\n        if not $p[n % 10 + (n / 10).floor % 10] then\n            return false\n        end\n        n = (n / 10).floor\n    end\n\n    return true\nend\n\ndef test(nMin, nMax)\n    k = 0\n    for n in nMin .. nMax\n        if isStrange(n) then\n            print n\n            k = k + 1\n            if k % 10 != 0 then\n                print ' '\n            else\n                print \"\\n\"\n            end\n        end\n    end\nend\n\ntest(101, 499)\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 425161, "name": "Strange plus numbers", "source": "Translate Ruby to Java: $p = [\n    false, false, true, true, false,\n    true, false, true, false, false,\n    false, true, false, true, false,\n    false, false, true, false\n]\n\ndef isStrange(n)\n    if n < 10 then\n        return false\n    end\n\n    while n >= 10 do\n        if not $p[n % 10 + (n / 10).floor % 10] then\n            return false\n        end\n        n = (n / 10).floor\n    end\n\n    return true\nend\n\ndef test(nMin, nMax)\n    k = 0\n    for n in nMin .. nMax\n        if isStrange(n) then\n            print n\n            k = k + 1\n            if k % 10 != 0 then\n                print ' '\n            else\n                print \"\\n\"\n            end\n        end\n    end\nend\n\ntest(101, 499)\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 425162, "name": "Smarandache prime-digital sequence", "source": "Translate Ruby to Java: require \"prime\"\n \nsmarandache = Enumerator.new do|y|\n  prime_digits = [2,3,5,7]\n  prime_digits.each{|pr| y << pr} \n  (1..).each do |n|\n    prime_digits.repeated_permutation(n).each do |perm|\n      c = perm.join.to_i * 10 \n      y << c + 3 if (c+3).prime?\n      y << c + 7 if (c+7).prime?\n    end\n  end\nend\n\nseq = smarandache.take(100)\np seq.first(25)\np seq.last\n", "target": "public class SmarandachePrimeDigitalSequence {\n\n    public static void main(String[] args) {\n        long s = getNextSmarandache(7);\n        System.out.printf(\"First 25 Smarandache prime-digital sequence numbers:%n2 3 5 7 \");\n        for ( int count = 1 ; count <= 21 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                System.out.printf(\"%d \", s);\n                count++;\n            }\n        }\n        System.out.printf(\"%n%n\");\n        for (int i = 2 ; i <=5 ; i++ ) {\n            long n = (long) Math.pow(10, i);\n            System.out.printf(\"%,dth Smarandache prime-digital sequence number = %d%n\", n, getSmarandachePrime(n));\n        }\n    }\n    \n    private static final long getSmarandachePrime(long n) {\n        if ( n < 10 ) {\n            switch ((int) n) {\n            case 1:  return 2;\n            case 2:  return 3;\n            case 3:  return 5;\n            case 4:  return 7;\n            }\n        }\n        long s = getNextSmarandache(7);\n        long result = 0;\n        for ( int count = 1 ; count <= n-4 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                count++;\n                result = s;\n            }\n        }\n        return result;\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long getNextSmarandache(long n) {\n        \n        if ( n % 10 == 3 ) {\n            return n+4;\n        }\n        long retVal = n-4;\n        \n        \n        int k = 0;\n        while ( n % 10 == 7 ) {\n            k++;\n            n /= 10;\n        }\n        \n        \n        long digit = n % 10;\n\n        \n        long coeff = (digit == 2 ? 1 : 2);\n        \n        \n        retVal += coeff * Math.pow(10, k);\n        \n        \n        while ( k > 1 ) {\n            retVal -= 5 * Math.pow(10, k-1);\n            k--;\n        }\n        \n        \n        return retVal;\n    }\n\n}\n"}
{"id": 425163, "name": "Magic squares of doubly even order", "source": "Translate Ruby to Java: def double_even_magic_square(n)\n  raise ArgumentError, \"Need multiple of four\" if n%4 > 0\n  block_size, max = n/4, n*n\n  pre_pat = [true, false, false, true,\n             false, true, true, false]\n  pre_pat += pre_pat.reverse\n  pattern = pre_pat.flat_map{|b| [b] * block_size} * block_size\n  flat_ar = pattern.each_with_index.map{|yes, num| yes ? num+1 : max-num}\n  flat_ar.each_slice(n).to_a\nend\n\ndef to_string(square)\n  n = square.size\n  fmt = \"%\n  square.inject(\"\"){|str,row| str << fmt % row << \"\\n\"}\nend\n\nputs to_string(double_even_magic_square(8))\n", "target": "public class MagicSquareDoublyEven {\n\n    public static void main(String[] args) {\n        int n = 8;\n        for (int[] row : magicSquareDoublyEven(n)) {\n            for (int x : row)\n                System.out.printf(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    static int[][] magicSquareDoublyEven(final int n) {\n        if (n < 4 || n % 4 != 0)\n            throw new IllegalArgumentException(\"base must be a positive \"\n                    + \"multiple of 4\");\n\n        \n        int bits = 0b1001_0110_0110_1001;\n        int size = n * n;\n        int mult = n / 4;  \n\n        int[][] result = new int[n][n];\n\n        for (int r = 0, i = 0; r < n; r++) {\n            for (int c = 0; c < n; c++, i++) {\n                int bitPos = c / mult + (r / mult) * 4;\n                result[r][c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;\n            }\n        }\n        return result;\n    }\n}\n"}
{"id": 425164, "name": "Plasma effect", "source": "Translate Ruby to Java: attr_reader :buffer, :palette, :r, :g, :b, :rd, :gd, :bd, :dim\n\ndef settings\n  size(600, 600)\nend\n\ndef setup\n  sketch_title 'Plasma Effect'\n  frame_rate 25\n  @r = 42\n  @g = 84\n  @b = 126\n  @rd = true\n  @gd = true\n  @bd = true\n  @dim = width * height\n  @buffer = Array.new(dim)\n  grid(width, height) do |x, y|\n    buffer[x + y * width] = (\n      (\n        (128 + (128 * sin(x / 32.0))) +\n        (128 + (128 * cos(y / 32.0))) +\n        (128 + (128 * sin(Math.hypot(x, y) / 32.0)))\n      ) / 4\n    ).to_i\n  end\n  load_pixels\nend\n\ndef draw\n  if rd\n    @r -= 1\n    @rd = false if r.negative?\n  else\n    @r += 1\n    @rd = true if r > 128\n  end\n  if gd\n    @g -= 1\n    @gd = false if g.negative?\n  else\n    @g += 1\n    @gd = true if g > 128\n  end\n  if bd\n    @b -= 1\n    @bd = false if b.negative?\n  else\n    @b += 1\n    @bd = true if b > 128\n  end\n  @palette = (0..127).map do |col|\n    s1 = sin(col * Math::PI / 25)\n    s2 = sin(col * Math::PI / 50 + Math::PI / 4)\n    color(r + s1 * 128, g + s2 * 128, b + s1 * 128)\n  end\n  dim.times do |idx|\n    pixels[idx] = palette[(buffer[idx] + frame_count) & 127]\n  end\n  update_pixels\nend\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport static java.awt.image.BufferedImage.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class PlasmaEffect extends JPanel {\n    float[][] plasma;\n    float hueShift = 0;\n    BufferedImage img;\n\n    public PlasmaEffect() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        img = new BufferedImage(dim.width, dim.height, TYPE_INT_RGB);\n        plasma = createPlasma(dim.height, dim.width);\n\n        \n        new Timer(42, (ActionEvent e) -> {\n            hueShift = (hueShift + 0.02f) % 1;\n            repaint();\n        }).start();\n    }\n\n    float[][] createPlasma(int w, int h) {\n        float[][] buffer = new float[h][w];\n\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n\n                double value = sin(x / 16.0);\n                value += sin(y / 8.0);\n                value += sin((x + y) / 16.0);\n                value += sin(sqrt(x * x + y * y) / 8.0);\n                value += 4; \n                value /= 8; \n\n                \n                assert (value >= 0.0 && value <= 1.0) : \"Hue value out of bounds\";\n\n                buffer[y][x] = (float) value;\n            }\n        return buffer;\n    }\n\n    void drawPlasma(Graphics2D g) {\n        int h = plasma.length;\n        int w = plasma[0].length;\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n                float hue = hueShift + plasma[y][x] % 1;\n                img.setRGB(x, y, Color.HSBtoRGB(hue, 1, 1));\n            }\n        g.drawImage(img, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPlasma(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Plasma Effect\");\n            f.setResizable(false);\n            f.add(new PlasmaEffect(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425165, "name": "Square-free integers", "source": "Translate Ruby to Java: require \"prime\"\n\nclass Integer\n  def square_free?\n    prime_division.none?{|pr, exp| exp > 1}\n  end\nend\n\nputs (1..145).select(&:square_free?).each_slice(20).map{|a| a.join(\" \")}\nputs\n\nm = 10**12\nputs (m..m+145).select(&:square_free?).each_slice(6).map{|a| a.join(\" \")}\nputs\n\nmarkers = [100, 1000, 10_000, 100_000, 1_000_000]\ncount = 0\n(1..1_000_000).each do |n|\n  count += 1 if n.square_free?\n  puts \"\nend\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SquareFree\n{\n    private static List<Long> sieve(long limit) {\n        List<Long> primes = new ArrayList<Long>();\n        primes.add(2L);\n        boolean[] c = new boolean[(int)limit + 1]; \n        \n        long p = 3;\n        for (;;) {\n            long p2 = p * p;\n            if (p2 > limit) break;\n            for (long i = p2; i <= limit; i += 2 * p) c[(int)i] = true;\n            for (;;) {\n                p += 2;\n                if (!c[(int)p]) break;\n            }\n        }\n        for (long i = 3; i <= limit; i += 2) {\n            if (!c[(int)i]) primes.add(i);\n        }\n        return primes;\n    }\n\n    private static List<Long> squareFree(long from, long to) {\n        long limit = (long)Math.sqrt((double)to);\n        List<Long> primes = sieve(limit);\n        List<Long> results = new ArrayList<Long>();\n\n        outer: for (long i = from; i <= to; i++) {\n            for (long p : primes) {\n                long p2 = p * p;\n                if (p2 > i) break;\n                if (i % p2 == 0) continue outer;\n            }\n            results.add(i);\n        }\n        return results;\n    }\n\n    private final static long TRILLION = 1000000000000L;\n\n    public static void main(String[] args) {\n        System.out.println(\"Square-free integers from 1 to 145:\");\n        List<Long> sf = squareFree(1, 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 20 == 0) {\n                System.out.println();\n            }\n            System.out.printf(\"%4d\", sf.get(i));\n        }\n\n        System.out.print(\"\\n\\nSquare-free integers\");\n        System.out.printf(\" from %d to %d:\\n\", TRILLION, TRILLION + 145);\n        sf = squareFree(TRILLION, TRILLION + 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 5 == 0) System.out.println();\n            System.out.printf(\"%14d\", sf.get(i));\n        }\n\n        System.out.println(\"\\n\\nNumber of square-free integers:\\n\");\n        long[] tos = {100, 1000, 10000, 100000, 1000000};\n        for (long to : tos) {\n            System.out.printf(\"  from %d to %d = %d\\n\", 1, to, squareFree(1, to).size());\n        }\n    }\n}\n"}
{"id": 425166, "name": "Self numbers", "source": "Translate Ruby to Java: func is_self_number(n) {\n\n    if (n < 30) {\n        return (((n < 10) && (n.is_odd)) || (n == 20))\n    }\n\n    var qd = (1 + n.ilog10)\n    var r  = (1 + (n-1)%9)\n    var h  = (r + 9*(r%2))/2\n    var ld = 10\n\n    while (h + 9*qd >= n%ld) {\n        ld *= 10\n    }\n\n    var vs = idiv(n, ld).sumdigits\n    n %= ld\n\n    0..qd -> none { |i|\n        vs + sumdigits(n - h - 9*i) == (h + 9*i)\n    }\n}\n\nsay is_self_number.first(50).join(' ')\n", "target": "public class SelfNumbers {\n    private static final int MC = 103 * 1000 * 10000 + 11 * 9 + 1;\n    private static final boolean[] SV = new boolean[MC + 1];\n\n    private static void sieve() {\n        int[] dS = new int[10_000];\n        for (int a = 9, i = 9999; a >= 0; a--) {\n            for (int b = 9; b >= 0; b--) {\n                for (int c = 9, s = a + b; c >= 0; c--) {\n                    for (int d = 9, t = s + c; d >= 0; d--) {\n                        dS[i--] = t + d;\n                    }\n                }\n            }\n        }\n        for (int a = 0, n = 0; a < 103; a++) {\n            for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000) {\n                for (int c = 0, s = d + dS[b] + n; c < 10000; c++) {\n                    SV[dS[c] + s++] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"The first 50 self numbers are:\");\n        for (int i = 0, count = 0; count <= 50; i++) {\n            if (!SV[i]) {\n                count++;\n                if (count <= 50) {\n                    System.out.printf(\"%d \", i);\n                } else {\n                    System.out.printf(\"%n%n       Index     Self number%n\");\n                }\n            }\n        }\n        for (int i = 0, limit = 1, count = 0; i < MC; i++) {\n            if (!SV[i]) {\n                if (++count == limit) {\n                    System.out.printf(\"%,12d  \u00a0%,13d%n\", count, i);\n                    limit *= 10;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425167, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Ruby to Java: nivens = Enumerator.new {|y| (1..).each {|n| y << n if n.remainder(n.digits.sum).zero?} }\n\ncur_gap = 0\nputs 'Gap    Index of gap  Starting Niven'\n\nnivens.each_cons(2).with_index(1) do |(n1, n2), i|\n  break if i > 10_000_000\n  if n2-n1 > cur_gap then\n    printf \"%3d %15s %15s\\n\", n2-n1, i, n1\n    cur_gap = n2-n1\n  end\nend\n", "target": "public class NivenNumberGaps {\n\n    \n    \n    public static void main(String[] args) {\n        long prevGap = 0;\n        long prevN = 1;\n        long index = 0;\n        System.out.println(\"Gap      Gap Index   Starting Niven\");\n        for ( long n = 2 ; n < 20_000_000_000l ; n++ ) {\n            if ( isNiven(n) ) {\n                index++;\n                long curGap = n - prevN;\n                if ( curGap > prevGap ) {\n                    System.out.printf(\"%3d \u00a0%,13d \u00a0%,15d%n\", curGap, index, prevN);\n                    prevGap = curGap;\n                }\n                prevN = n;\n            }\n        }\n    }\n    \n    public static boolean isNiven(long n) {\n        long sum = 0;\n        long nSave = n;\n        while ( n > 0 ) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return nSave % sum == 0;\n    }\n\n}\n"}
{"id": 425168, "name": "Old Russian measure of length", "source": "Translate Ruby to Java: module Distances\n\n  RATIOS = \n  {arshin: 0.7112, centimeter: 0.01,     diuym:   0.0254,\n   fut:    0.3048, kilometer:  1000.0,   liniya:  0.00254,\n   meter:  1.0,    milia:      7467.6,   piad:    0.1778,\n   sazhen: 2.1336, tochka:     0.000254, vershok: 0.04445,\n   versta: 1066.8}\n\n  def self.method_missing(meth, arg)\n    from, to = meth.to_s.split(\"2\").map(&:to_sym)\n    raise NoMethodError, meth if ([from,to]-RATIOS.keys).size > 0\n    RATIOS[from] * arg / RATIOS[to]\n  end\n\n  def self.print_others(name, num)\n    puts \"\n    RATIOS.except(name.to_sym).each {|k,v| puts \"\n  end\nend\n\nDistances.print_others(\"meter\", 2)\nputs\np Distances.meter2centimeter(3)\np Distances.arshin2meter(1)\np Distances.versta2kilometer(20) \n\np Distances.mile2piad(1)\n", "target": "public class OldRussianMeasures {\n\n    final static String[] keys = {\"tochka\", \"liniya\", \"centimeter\", \"diuym\",\n        \"vershok\", \"piad\", \"fut\", \"arshin\", \"meter\", \"sazhen\", \"kilometer\",\n        \"versta\", \"milia\"};\n\n    final static double[] values = {0.000254, 0.00254, 0.01,0.0254,\n        0.04445, 0.1778, 0.3048, 0.7112, 1.0, 2.1336, 1000.0,\n        1066.8, 7467.6};\n\n    public static void main(String[] a) {\n        if (a.length == 2 && a[0].matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?\")) {\n            double inputVal = lookup(a[1]);\n            if (!Double.isNaN(inputVal)) {\n                double magnitude = Double.parseDouble(a[0]);\n                double meters = magnitude * inputVal;\n                System.out.printf(\"%s %s to: %n%n\", a[0], a[1]);\n                for (String k: keys)\n                    System.out.printf(\"%10s: %g%n\", k, meters / lookup(k));\n                return;\n            }\n        }\n        System.out.println(\"Please provide a number and unit\");\n\n    }\n\n    public static double lookup(String key) {\n        for (int i = 0; i < keys.length; i++)\n            if (keys[i].equals(key))\n                return values[i];\n        return Double.NaN;\n    }\n}\n"}
{"id": 425169, "name": "Pancake numbers", "source": "Translate Ruby to Java: def pancake(n)\n    gap = 2\n    sum = 2\n    adj = -1\n    while sum < n\n        adj = adj + 1\n        gap = gap * 2 - 1\n        sum = sum + gap\n    end\n    return n + adj\nend\n\nfor i in 0 .. 3\n    for j in 1 .. 5\n        n = i * 5 + j\n        print \"p(%2d) = %2d  \" % [n, pancake(n)]\n    end\n    print \"\\n\"\nend\n", "target": "public class Pancake {\n    private static int pancake(int n) {\n        int gap = 2;\n        int sum = 2;\n        int adj = -1;\n        while (sum < n) {\n            adj++;\n            gap = 2 * gap - 1;\n            sum += gap;\n        }\n        return n + adj;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 4; i++) {\n            for (int j = 1; j < 6; j++) {\n                int n = 5 * i + j;\n                System.out.printf(\"p(%2d) = %2d  \", n, pancake(n));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425170, "name": "Pythagorean quadruples", "source": "Translate Ruby to Java: n = 2200\nl_add, l = Hash(Int32, Bool).new(false), Hash(Int32, Bool).new(false)\n(1..n).each do |x|\n  x2 = x * x \n  (x..n).each { |y| l_add[x2 + y * y] = true } \nend\n\ns = 3\n(1..n).each do |x|\n  s1 = s\n  s += 2\n  s2 = s\n  ((x+1)..n).each do |y|\n    l[y] = true if l_add[s1]\n    s1 += s2\n    s2 += 2\n  end\nend\n\nputs (1..n).reject{ |x| l[x] }.join(\" \")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PythagoreanQuadruples {\n\n    public static void main(String[] args) {\n        long d = 2200;\n        System.out.printf(\"Values of d < %d where a, b, and c are non-zero and a^2 + b^2 + c^2 = d^2 has no solutions:%n%s%n\", d, getPythagoreanQuadruples(d));\n    }\n\n    \n    private static List<Long> getPythagoreanQuadruples(long max) {\n        List<Long> list = new ArrayList<>();\n        long n = -1;\n        long m = -1;\n        while ( true ) {\n            long nTest = (long) Math.pow(2, n+1);\n            long mTest = (long) (5L * Math.pow(2, m+1));\n            long test = 0;\n            if ( nTest > mTest ) {\n                test = mTest;\n                m++;\n            }\n            else {\n                test = nTest;\n                n++;\n            }\n            if ( test < max ) {\n                list.add(test);\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n\n}\n"}
{"id": 425171, "name": "Sum and product puzzle", "source": "Translate Ruby to Java: def add(x,y) x + y end\ndef mul(x,y) x * y end\n\ndef sumEq(s,p) s.select{|q| add(*p) == add(*q)} end\ndef mulEq(s,p) s.select{|q| mul(*p) == mul(*q)} end\n\ns1 = (a = *2...100).product(a).select{|x,y| x<y && x+y<100}\ns2 = s1.select{|p| sumEq(s1,p).all?{|q| mulEq(s1,q).size != 1} }\ns3 = s2.select{|p| (mulEq(s1,p) & s2).size == 1}\np    s3.select{|p| (sumEq(s1,p) & s3).size == 1}\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SumAndProductPuzzle {\n    private final long beginning;\n    private final int maxSum;\n    private static final int MIN_VALUE = 2;\n    private List<int[]> firstConditionExcludes = new ArrayList<>();\n    private List<int[]> secondConditionExcludes = new ArrayList<>();\n    \n    public static void main(String... args){\n        \n        if (args.length == 0){\n            new SumAndProductPuzzle(100).run();\n            new SumAndProductPuzzle(1684).run();\n            new SumAndProductPuzzle(1685).run();\n        } else {\n            for (String arg : args){\n                try{\n                    new SumAndProductPuzzle(Integer.valueOf(arg)).run();\n                } catch (NumberFormatException e){\n                    System.out.println(\"Please provide only integer arguments. \" +\n                            \"Provided argument \" + arg + \" was not an integer. \" +\n                            \"Alternatively, calling the program with no arguments \" +\n                            \"will run the puzzle where maximum sum equals 100, 1684, and 1865.\");\n                }\n            }\n        }\n    }\n    \n    public SumAndProductPuzzle(int maxSum){\n        this.beginning = System.currentTimeMillis();\n        this.maxSum = maxSum;\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" started at \" + String.valueOf(beginning) + \".\");\n    }\n    \n    public void run(){\n        for (int x = MIN_VALUE; x < maxSum - MIN_VALUE; x++){\n            for (int y = x + 1; y < maxSum - MIN_VALUE; y++){\n                \n                if (isSumNoGreaterThanMax(x,y) &&\n                    isSKnowsPCannotKnow(x,y) &&\n                    isPKnowsNow(x,y) &&\n                    isSKnowsNow(x,y)\n                    ){\n                    System.out.println(\"Found solution x is \" + String.valueOf(x) + \" y is \" + String.valueOf(y) + \n                            \" in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n                }\n            }\n        }\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" ended in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n    }\n    \n    public boolean isSumNoGreaterThanMax(int x, int y){\n        return x + y <= maxSum;\n    }\n    \n    public boolean isSKnowsPCannotKnow(int x, int y){\n        \n        if (firstConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        for (int[] addends : sumAddends(x, y)){\n            if ( !(productFactors(addends[0], addends[1]).size() > 1) ) {\n                firstConditionExcludes.add(new int[] {x, y});\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public boolean isPKnowsNow(int x, int y){\n        \n        if (secondConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        int countSolutions = 0;\n        for (int[] factors : productFactors(x, y)){\n            if (isSKnowsPCannotKnow(factors[0], factors[1])){\n                countSolutions++;\n            }\n        }\n        \n        if (countSolutions == 1){\n            return true;\n        } else {\n            secondConditionExcludes.add(new int[] {x, y});\n            return false;\n        }\n    }\n    \n    public boolean isSKnowsNow(int x, int y){\n        \n        int countSolutions = 0;\n        for (int[] addends : sumAddends(x, y)){\n            if (isPKnowsNow(addends[0], addends[1])){\n                countSolutions++;\n            }\n        }\n        return countSolutions == 1;\n    }\n    \n    public List<int[]> sumAddends(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int sum = x + y;\n        \n        for (int addend = MIN_VALUE; addend < sum - addend; addend++){\n            if (isSumNoGreaterThanMax(addend, sum - addend)){\n                list.add(new int[]{addend, sum - addend});\n            }\n        }\n        return list;\n    }\n    \n    public List<int[]> productFactors(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int product = x * y;\n        \n        for (int factor = MIN_VALUE; factor < product / factor; factor++){\n            if (product % factor == 0){\n                if (isSumNoGreaterThanMax(factor, product / factor)){\n                    list.add(new int[]{factor, product / factor});\n                }\n            }\n        }\n        return list;\n    }\n}\n"}
{"id": 425172, "name": "Superpermutation minimisation", "source": "Translate Ruby to Java: \n\n\n\n\n\n\n\nl = []\n(1..6).each{|e|\n  a, i = [], e-2\n  (0..l.length-e+1).each{|g|\n     if not (n = l[g..g+e-2]).uniq!\n       a.concat(n[(a[0]? i : 0)..-1]).push(e).concat(n)\n       i = e-2\n     else\n       i -= 1\n     end\n   }\n   a.each{|n| print n}; puts \"\\n\\n\"\n   l = a\n}\n", "target": "import static java.util.stream.IntStream.rangeClosed;\n\npublic class Test {\n    final static int nMax = 12;\n\n    static char[] superperm;\n    static int pos;\n    static int[] count = new int[nMax];\n\n    static int factSum(int n) {\n        return rangeClosed(1, n)\n                .map(m -> rangeClosed(1, m).reduce(1, (a, b) -> a * b)).sum();\n    }\n\n    static boolean r(int n) {\n        if (n == 0)\n            return false;\n\n        char c = superperm[pos - n];\n        if (--count[n] == 0) {\n            count[n] = n;\n            if (!r(n - 1))\n                return false;\n        }\n        superperm[pos++] = c;\n        return true;\n    }\n\n    static void superPerm(int n) {\n        String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        pos = n;\n        superperm = new char[factSum(n)];\n\n        for (int i = 0; i < n + 1; i++)\n            count[i] = i;\n        for (int i = 1; i < n + 1; i++)\n            superperm[i - 1] = chars.charAt(i);\n\n        while (r(n)) {\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int n = 0; n < nMax; n++) {\n            superPerm(n);\n            System.out.printf(\"superPerm(%2d) len = %d\", n, superperm.length);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425173, "name": "Test integerness", "source": "Translate Ruby to Java: class Numeric\n  def to_i?\n    self == self.to_i rescue false\n   end\nend\n \n\nar = [25.000000, 24.999999, 25.000100, -2.1e120, -5e-2,  \n      Float::NAN, Float::INFINITY,                       \n      2r, 2.5r,                                          \n      2+0i, 2+0.0i, 5-5i]                                \n \nar.each{|num| puts \"\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 425174, "name": "Ulam numbers", "source": "Translate Ruby to Java: func ulam(n) {\n\n    static u     = Set(1,2)\n    static ulams = [0, 1, 2]\n\n    return ulams[n] if (ulams.end >= n)\n\n    ++n\n\n    for(var i = 3; true; ++i) {\n        var count = 0\n\n        ulams.each {|v|\n            if (u.has(i - v) && (v != i-v)) {\n                break if (count++ > 2)\n            }\n        }\n\n        if (count == 2) {\n            ulams << i\n            u << i\n            break if (ulams.len == n)\n        }\n    }\n\n    ulams.tail\n}\n\nfor k in (1..3) {\n    say \"The 10^\n}\n", "target": "public class UlamNumbers {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int n = 1; n <= 100000; n *= 10) {\n            System.out.printf(\"Ulam(%d) = %d\\n\", n, ulam(n));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"Elapsed time:\u00a0%.3f seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private static int ulam(int n) {\n        int[] ulams = new int[Math.max(n, 2)];\n        ulams[0] = 1;\n        ulams[1] = 2;\n        int sieveLength = 2;\n        int[] sieve = new int[sieveLength];\n        sieve[0] = sieve[1] = 1;\n        for (int u = 2, ulen = 2; ulen < n; ) {\n            sieveLength = u + ulams[ulen - 2];\n            sieve = extend(sieve, sieveLength);\n            for (int i = 0; i < ulen - 1; ++i)\n                ++sieve[u + ulams[i] - 1];\n            for (int i = u; i < sieveLength; ++i) {\n                if (sieve[i] == 1) {\n                    u = i + 1;\n                    ulams[ulen++] = u;\n                    break;\n                }\n            }\n        }\n        return ulams[n - 1];\n    }\n\n    private static int[] extend(int[] array, int minLength) {\n        if (minLength <= array.length)\n            return array;\n        int newLength = 2 * array.length;\n        while (newLength < minLength)\n            newLength *= 2;\n        int[] newArray = new int[newLength];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n}\n"}
{"id": 425175, "name": "Type detection", "source": "Translate Ruby to Java: def print_type(x)\n  puts \"Compile-time type of \n  puts \"    Actual runtime type is \nend\n\nprint_type 123\nprint_type 123.45\nprint_type  rand < 0.5 ? \"1\" : 0 \nprint_type rand < 1.5\nprint_type nil\nprint_type 'c'\nprint_type \"str\"\nprint_type [1,2]\nprint_type({ 2, \"two\" })\nprint_type({a: 1, b: 2})\nprint_type ->(x : Int32){ x+2 > 0 }\n", "target": "public class TypeDetection {\n    private static void showType(Object a) {\n        if (a instanceof Integer) {\n            System.out.printf(\"'%s' is an integer\\n\", a);\n        } else if (a instanceof Double) {\n            System.out.printf(\"'%s' is a double\\n\", a);\n        } else if (a instanceof Character) {\n            System.out.printf(\"'%s' is a character\\n\", a);\n        } else {\n            System.out.printf(\"'%s' is some other type\\n\", a);\n        }\n    }\n\n    public static void main(String[] args) {\n        showType(5);\n        showType(7.5);\n        showType('d');\n        showType(true);\n    }\n}\n"}
{"id": 425176, "name": "Safe primes and unsafe primes", "source": "Translate Ruby to Java: require \"prime\"\nclass Integer\n  def safe_prime? \n    ((self-1)/2).prime?\n  end\nend\n\ndef format_parts(n)\n  partitions = Prime.each(n).partition(&:safe_prime?).map(&:count)\n  \"There are %d safes and %d unsafes below \nend\n\nputs \"First 35 safe-primes:\"\np Prime.each.lazy.select(&:safe_prime?).take(35).to_a\nputs format_parts(1_000_000), \"\\n\" \n\nputs \"First 40 unsafe-primes:\"\np Prime.each.lazy.reject(&:safe_prime?).take(40).to_a\nputs format_parts(10_000_000)\n", "target": "public class SafePrimes {\n    public static void main(String... args) {\n        \n        int SIEVE_SIZE = 10_000_000;\n        boolean[] isComposite = new boolean[SIEVE_SIZE];\n        \n        isComposite[0] = true;\n        isComposite[1] = true;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (isComposite[n]) {\n                continue;\n            }\n            for (int i = n * 2; i < SIEVE_SIZE; i += n) {\n                isComposite[i] = true;\n            }\n        }\n        \n        int oldSafePrimeCount = 0;\n        int oldUnsafePrimeCount = 0;\n        int safePrimeCount = 0;\n        int unsafePrimeCount = 0;\n        StringBuilder safePrimes = new StringBuilder();\n        StringBuilder unsafePrimes = new StringBuilder();\n        int safePrimesStrCount = 0;\n        int unsafePrimesStrCount = 0;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (n == 1_000_000) {\n                oldSafePrimeCount = safePrimeCount;\n                oldUnsafePrimeCount = unsafePrimeCount;\n            }\n            if (isComposite[n]) {\n                continue;\n            }\n            boolean isUnsafe = isComposite[(n - 1) >>> 1];\n            if (isUnsafe) {\n                if (unsafePrimeCount < 40) {\n                    if (unsafePrimeCount > 0) {\n                        unsafePrimes.append(\", \");\n                    }\n                    unsafePrimes.append(n);\n                    unsafePrimesStrCount++;\n                }\n                unsafePrimeCount++;\n            }\n            else {\n                if (safePrimeCount < 35) {\n                    if (safePrimeCount > 0) {\n                        safePrimes.append(\", \");\n                    }\n                    safePrimes.append(n);\n                    safePrimesStrCount++;\n                }\n                safePrimeCount++;\n            }\n        }\n        \n        System.out.println(\"First \" + safePrimesStrCount + \" safe primes: \" + safePrimes.toString());\n        System.out.println(\"Number of safe primes below 1,000,000: \" + oldSafePrimeCount);\n        System.out.println(\"Number of safe primes below 10,000,000: \" + safePrimeCount);\n        System.out.println(\"First \" + unsafePrimesStrCount + \" unsafe primes: \" + unsafePrimes.toString());\n        System.out.println(\"Number of unsafe primes below 1,000,000: \" + oldUnsafePrimeCount);\n        System.out.println(\"Number of unsafe primes below 10,000,000: \" + unsafePrimeCount);\n        \n        return;\n    }\n}\n"}
{"id": 425177, "name": "Hash join", "source": "Translate Ruby to Java: def hashJoin(table1, index1, table2, index2)\n  \n  h = table1.group_by {|s| s[index1]}\n  h.default = []\n  \n  table2.collect {|r|\n    h[r[index2]].collect {|s| [s, r]}\n  }.flatten(1)\nend\n\ntable1 = [[27, \"Jonah\"],\n          [18, \"Alan\"],\n          [28, \"Glory\"],\n          [18, \"Popeye\"],\n          [28, \"Alan\"]]\ntable2 = [[\"Jonah\", \"Whales\"],\n          [\"Jonah\", \"Spiders\"],\n          [\"Alan\", \"Ghosts\"],\n          [\"Alan\", \"Zombies\"],\n          [\"Glory\", \"Buffy\"]]\n\nhashJoin(table1, 1, table2, 0).each { |row| p row }\n", "target": "import java.util.*;\n\npublic class HashJoin {\n\n    public static void main(String[] args) {\n        String[][] table1 = {{\"27\", \"Jonah\"}, {\"18\", \"Alan\"}, {\"28\", \"Glory\"},\n        {\"18\", \"Popeye\"}, {\"28\", \"Alan\"}};\n\n        String[][] table2 = {{\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n        {\"Bob\", \"foo\"}};\n\n        hashJoin(table1, 1, table2, 0).stream()\n                .forEach(r -> System.out.println(Arrays.deepToString(r)));\n    }\n\n    static List<String[][]> hashJoin(String[][] records1, int idx1,\n            String[][] records2, int idx2) {\n\n        List<String[][]> result = new ArrayList<>();\n        Map<String, List<String[]>> map = new HashMap<>();\n\n        for (String[] record : records1) {\n            List<String[]> v = map.getOrDefault(record[idx1], new ArrayList<>());\n            v.add(record);\n            map.put(record[idx1], v);\n        }\n\n        for (String[] record : records2) {\n            List<String[]> lst = map.get(record[idx2]);\n            if (lst != null) {\n                lst.stream().forEach(r -> {\n                    result.add(new String[][]{r, record});\n                });\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"id": 425178, "name": "Permutations with repetitions", "source": "Translate Ruby to Java: rp = [1,2,3].repeated_permutation(2) \np rp.to_a \n\n\np rp.take_while{|(a, b)| a + b < 5}  \n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425179, "name": "Permutations with repetitions", "source": "Translate Ruby to Java: rp = [1,2,3].repeated_permutation(2) \np rp.to_a \n\n\np rp.take_while{|(a, b)| a + b < 5}  \n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425180, "name": "Audio alarm", "source": "Translate Ruby to Java: puts \"Enter a number of seconds:\"\nseconds = gets.chomp.to_i\nputs \"Enter a MP3 file to be played\"\nmp3filepath = File.dirname(__FILE__) + \"/\" + gets.chomp + \".mp3\"\nsleep(seconds)\npid = fork{ exec 'mpg123','-q', mp3filepath }\n", "target": "import com.sun.javafx.application.PlatformImpl;\nimport java.io.File;\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javafx.scene.media.Media;\nimport javafx.scene.media.MediaPlayer;\n\npublic class AudioAlarm {\n\n    public static void main(String[] args) throws InterruptedException {\n        Scanner input = new Scanner(System.in);\n\n        System.out.print(\"Enter a number of seconds: \");\n        int seconds = Integer.parseInt(input.nextLine());\n\n        System.out.print(\"Enter a filename (must end with .mp3 or .wav): \");\n        String audio = input.nextLine();\n\n        TimeUnit.SECONDS.sleep(seconds);\n\n        Media media = new Media(new File(audio).toURI().toString());\n        AtomicBoolean stop = new AtomicBoolean();\n        Runnable onEnd = () -> stop.set(true);\n\n        PlatformImpl.startup(() -> {}); \n\n        MediaPlayer player = new MediaPlayer(media);\n        player.setOnEndOfMedia(onEnd);\n        player.setOnError(onEnd);\n        player.setOnHalted(onEnd);\n        player.play();\n\n        while (!stop.get()) {\n            Thread.sleep(100);\n        }\n        System.exit(0); \n    }\n}\n"}
{"id": 425181, "name": "Find largest left truncatable prime in a given base", "source": "Translate Ruby to Java: \n\n\n\n\nrequire 'prime'\nBASE = 3\nMAX = 500\nstems = Prime.each(BASE-1).to_a\n(1..MAX-1).each {|i|\n  print \"\n  t = []\n  b = BASE ** i\n  stems.each {|z|\n    (1..BASE-1).each {|n|\n      c = n*b+z\n      t.push(c) if c.prime?\n  }}\n  break if t.empty?\n  stems = t\n}\nputs \"The largest left truncatable prime \n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass LeftTruncatablePrime\n{\n  private static List<BigInteger> getNextLeftTruncatablePrimes(BigInteger n, int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> probablePrimes = new ArrayList<BigInteger>();\n    String baseString = n.equals(BigInteger.ZERO) ? \"\" : n.toString(radix);\n    for (int i = 1; i < radix; i++)\n    {\n      BigInteger p = new BigInteger(Integer.toString(i, radix) + baseString, radix);\n      if (p.isProbablePrime(millerRabinCertainty))\n        probablePrimes.add(p);\n    }\n    return probablePrimes;\n  }\n  \n  public static BigInteger getLargestLeftTruncatablePrime(int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> lastList = null;\n    List<BigInteger> list = getNextLeftTruncatablePrimes(BigInteger.ZERO, radix, millerRabinCertainty);\n    while (!list.isEmpty())\n    {\n      lastList = list;\n      list = new ArrayList<BigInteger>();\n      for (BigInteger n : lastList)\n        list.addAll(getNextLeftTruncatablePrimes(n, radix, millerRabinCertainty));\n    }\n    if (lastList == null)\n      return null;\n    Collections.sort(lastList);\n    return lastList.get(lastList.size() - 1);\n  }\n  \n  public static void main(String[] args)\n  {\n    if (args.length != 2) {\n      System.err.println(\"There must be exactly two command line arguments.\");\n      return;\n    }\n    int maxRadix;\n    try {\n      maxRadix = Integer.parseInt(args[0]);\n      if (maxRadix < 3) throw new NumberFormatException(); \n    } catch (NumberFormatException e) {\n      System.err.println(\"Radix must be an integer greater than 2.\");\n      return;\n    }\n    int millerRabinCertainty;\n    try {\n      millerRabinCertainty = Integer.parseInt(args[1]);\n    } catch (NumberFormatException e) {\n      System.err.println(\"Miiller-Rabin Certainty must be an integer.\");\n      return;\n    }  \n    for (int radix = 3; radix <= maxRadix; radix++)\n    {\n      BigInteger largest = getLargestLeftTruncatablePrime(radix, millerRabinCertainty);\n      System.out.print(\"n=\" + radix + \": \");\n      if (largest == null)\n        System.out.println(\"No left-truncatable prime\");\n      else\n        System.out.println(largest + \" (in base \" + radix + \"): \" + largest.toString(radix));\n    }\n  }\n  \n}\n"}
{"id": 425182, "name": "24 game_Solve", "source": "Translate Ruby to Java: class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n  \n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n  \n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      \n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 \n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n\ndigits = ARGV.map do |arg| \n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have \n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found \n  puts solutions.sort\nend\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 425183, "name": "24 game_Solve", "source": "Translate Ruby to Java: class TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n  \n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n  \n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      \n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 \n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n\ndigits = ARGV.map do |arg| \n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have \n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found \n  puts solutions.sort\nend\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 425184, "name": "Hough transform", "source": "Translate Ruby to Java: require 'mathn'\nrequire 'rubygems'\nrequire 'gd2'\ninclude GD2\n\ndef hough_transform(img)\n  mx, my = img.w*0.5, img.h*0.5\n  max_d = Math.sqrt(mx**2 + my**2)\n  min_d = max_d * -1\n  hough = Hash.new(0)\n  (0..img.w).each do |x|\n    puts \"\n    (0..img.h).each do |y|\n      if img.pixel2color(img.get_pixel(x,y)).g > 32\n        (0...180).each do |a|\n          rad = a * (Math::PI / 180.0)\n          d = (x-mx) * Math.cos(rad) + (y-my) * Math.sin(rad)\n          hough[\"\n        end\n      end\n    end\n  end\n  heat = GD2::Image.import 'heatmap.png'\n  out = GD2::Image::TrueColor.new(180,max_d*2)\n  max = hough.values.max\n  p max\n  hough.each_pair do |k,v|\n    a,d = k.split('_').map(&:to_i)\n    c = (v / max) * 255\n    c = heat.get_pixel(c,0)\n    out.set_pixel(a, max_d + d, c)\n  end\n  out\nend\n", "target": "import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class HoughTransform\n{\n  public static ArrayData houghTransform(ArrayData inputData, int thetaAxisSize, int rAxisSize, int minContrast)\n  {\n    int width = inputData.width;\n    int height = inputData.height;\n    int maxRadius = (int)Math.ceil(Math.hypot(width, height));\n    int halfRAxisSize = rAxisSize >>> 1;\n    ArrayData outputData = new ArrayData(thetaAxisSize, rAxisSize);\n    \n    \n    double[] sinTable = new double[thetaAxisSize];\n    double[] cosTable = new double[thetaAxisSize];\n    for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n    {\n      double thetaRadians = theta * Math.PI / thetaAxisSize;\n      sinTable[theta] = Math.sin(thetaRadians);\n      cosTable[theta] = Math.cos(thetaRadians);\n    }\n    \n    for (int y = height - 1; y >= 0; y--)\n    {\n      for (int x = width - 1; x >= 0; x--)\n      {\n        if (inputData.contrast(x, y, minContrast))\n        {\n          for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n          {\n            double r = cosTable[theta] * x + sinTable[theta] * y;\n            int rScaled = (int)Math.round(r * halfRAxisSize / maxRadius) + halfRAxisSize;\n            outputData.accumulate(theta, rScaled, 1);\n          }\n        }\n      }\n    }\n    return outputData;\n  }\n  \n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n    \n    public void accumulate(int x, int y, int delta)\n    {  set(x, y, get(x, y) + delta);  }\n    \n    public boolean contrast(int x, int y, int minContrast)\n    {\n      int centerValue = get(x, y);\n      for (int i = 8; i >= 0; i--)\n      {\n        if (i == 4)\n          continue;\n        int newx = x + (i % 3) - 1;\n        int newy = y + (i / 3) - 1;\n        if ((newx < 0) || (newx >= width) || (newy < 0) || (newy >= height))\n          continue;\n        if (Math.abs(get(newx, newy) - centerValue) >= minContrast)\n          return true;\n      }\n      return false;\n    }\n    \n    public int getMax()\n    {\n      int max = dataArray[0];\n      for (int i = width * height - 1; i > 0; i--)\n        if (dataArray[i] > max)\n          max = dataArray[i];\n      return max;\n    }\n  }\n  \n  public static ArrayData getArrayDataFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData arrayData = new ArrayData(width, height);\n    \n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        rgbValue = (int)(((rgbValue & 0xFF0000) >>> 16) * 0.30 + ((rgbValue & 0xFF00) >>> 8) * 0.59 + (rgbValue & 0xFF) * 0.11);\n        arrayData.set(x, height - 1 - y, rgbValue);\n      }\n    }\n    return arrayData;\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData arrayData) throws IOException\n  {\n    int max = arrayData.getMax();\n    BufferedImage outputImage = new BufferedImage(arrayData.width, arrayData.height, BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < arrayData.height; y++)\n    {\n      for (int x = 0; x < arrayData.width; x++)\n      {\n        int n = Math.min((int)Math.round(arrayData.get(x, y) * 255.0 / max), 255);\n        outputImage.setRGB(x, arrayData.height - 1 - y, (n << 16) | (n << 8) | 0x90 | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    ArrayData inputData = getArrayDataFromImage(args[0]);\n    int minContrast = (args.length >= 4) ? 64 : Integer.parseInt(args[4]);\n    ArrayData outputData = houghTransform(inputData, Integer.parseInt(args[2]), Integer.parseInt(args[3]), minContrast);\n    writeOutputImage(args[1], outputData);\n    return;\n  }\n}\n"}
{"id": 425185, "name": "Tonelli-Shanks algorithm", "source": "Translate Ruby to Java: func tonelli(n, p) {\n    legendre(n, p) == 1 || die \"not a square (mod p)\"\n    var q = p-1\n    var s = valuation(q, 2)\n    s == 1 ? return(powmod(n, (p + 1) >> 2, p)) : (q >>= s)\n    var c = powmod(2 ..^ p -> first {|z| legendre(z, p) == -1}, q, p)\n    var r = powmod(n, (q + 1) >> 1, p)\n    var t = powmod(n, q, p)\n    var m = s\n    var t2 = 0\n    while (!p.divides(t - 1)) {\n        t2 = ((t * t) % p)\n        var b\n        for i in (1 ..^ m) {\n            if (p.divides(t2 - 1)) {\n                b = powmod(c, 1 << (m - i - 1), p)\n                m = i\n                break\n            }\n            t2 = ((t2 * t2) % p)\n        }\n\n        r = ((r * b) % p)\n        c = ((b * b) % p)\n        t = ((t * c) % p)\n    }\n    return r\n}\n\nvar tests = [\n    [10, 13], [56, 101], [1030, 10009], [44402, 100049],\n    [665820697, 1000000009], [881398088036, 1000000000039],\n    [41660815127637347468140745042827704103445750172002, 10**50 + 577],\n]\n\nfor n,p in tests {\n    var r = tonelli(n, p)\n    assert((r*r - n) % p == 0)\n    say \"Roots of \n}\n", "target": "import java.math.BigInteger;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class TonelliShanks {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TEN = BigInteger.TEN;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static class Solution {\n        private BigInteger root1;\n        private BigInteger root2;\n        private boolean exists;\n\n        Solution(BigInteger root1, BigInteger root2, boolean exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n    }\n\n    private static Solution ts(Long n, Long p) {\n        return ts(BigInteger.valueOf(n), BigInteger.valueOf(p));\n    }\n\n    private static Solution ts(BigInteger n, BigInteger p) {\n        BiFunction<BigInteger, BigInteger, BigInteger> powModP = (BigInteger a, BigInteger e) -> a.modPow(e, p);\n        Function<BigInteger, BigInteger> ls = (BigInteger a) -> powModP.apply(a, p.subtract(ONE).divide(TWO));\n\n        if (!ls.apply(n).equals(ONE)) return new Solution(ZERO, ZERO, false);\n\n        BigInteger q = p.subtract(ONE);\n        BigInteger ss = ZERO;\n        while (q.and(ONE).equals(ZERO)) {\n            ss = ss.add(ONE);\n            q = q.shiftRight(1);\n        }\n\n        if (ss.equals(ONE)) {\n            BigInteger r1 = powModP.apply(n, p.add(ONE).divide(FOUR));\n            return new Solution(r1, p.subtract(r1), true);\n        }\n\n        BigInteger z = TWO;\n        while (!ls.apply(z).equals(p.subtract(ONE))) z = z.add(ONE);\n        BigInteger c = powModP.apply(z, q);\n        BigInteger r = powModP.apply(n, q.add(ONE).divide(TWO));\n        BigInteger t = powModP.apply(n, q);\n        BigInteger m = ss;\n\n        while (true) {\n            if (t.equals(ONE)) return new Solution(r, p.subtract(r), true);\n            BigInteger i = ZERO;\n            BigInteger zz = t;\n            while (!zz.equals(BigInteger.ONE) && i.compareTo(m.subtract(ONE)) < 0) {\n                zz = zz.multiply(zz).mod(p);\n                i = i.add(ONE);\n            }\n            BigInteger b = c;\n            BigInteger e = m.subtract(i).subtract(ONE);\n            while (e.compareTo(ZERO) > 0) {\n                b = b.multiply(b).mod(p);\n                e = e.subtract(ONE);\n            }\n            r = r.multiply(b).mod(p);\n            c = b.multiply(b).mod(p);\n            t = t.multiply(c).mod(p);\n            m = i;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Long>> pairs = List.of(\n            Map.entry(10L, 13L),\n            Map.entry(56L, 101L),\n            Map.entry(1030L, 10009L),\n            Map.entry(1032L, 10009L),\n            Map.entry(44402L, 100049L),\n            Map.entry(665820697L, 1000000009L),\n            Map.entry(881398088036L, 1000000000039L)\n        );\n\n        for (Map.Entry<Long, Long> pair : pairs) {\n            Solution sol = ts(pair.getKey(), pair.getValue());\n            System.out.printf(\"n = %s\\n\", pair.getKey());\n            System.out.printf(\"p = %s\\n\", pair.getValue());\n            if (sol.exists) {\n                System.out.printf(\"root1 = %s\\n\", sol.root1);\n                System.out.printf(\"root2 = %s\\n\", sol.root2);\n            } else {\n                System.out.println(\"No solution exists\");\n            }\n            System.out.println();\n        }\n\n        BigInteger bn = new BigInteger(\"41660815127637347468140745042827704103445750172002\");\n        BigInteger bp = TEN.pow(50).add(BigInteger.valueOf(577));\n        Solution sol = ts(bn, bp);\n        System.out.printf(\"n = %s\\n\", bn);\n        System.out.printf(\"p = %s\\n\", bp);\n        if (sol.exists) {\n            System.out.printf(\"root1 = %s\\n\", sol.root1);\n            System.out.printf(\"root2 = %s\\n\", sol.root2);\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n"}
{"id": 425186, "name": "Truth table", "source": "Translate Ruby to Java: loop do\n  print \"\\ninput a boolean expression (e.g. 'a & b'): \"\n  expr = gets.strip.downcase \n  break if expr.empty?\n\n  vars = expr.scan(/\\p{Alpha}+/)\n  if vars.empty?\n    puts \"no variables detected in your boolean expression\"\n    next\n  end\n\n  vars.each {|v| print \"\n  puts \"| \n\n  prefix = []\n  suffix = []\n  vars.each do |v|\n    prefix << \"[false, true].each do |\n    suffix << \"end\"\n  end\n\n  body = vars.inject(\"puts \") {|str, v| str + \"\n  body += '\"| \" + eval(expr).to_s'\n\n  eval (prefix + [body] + suffix).join(\"\\n\")\nend\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class TruthTable {\n    public static void main( final String... args ) {\n        System.out.println( new TruthTable( args ) );\n    }\n\n    private interface Operator {\n        boolean evaluate( Stack<Boolean> s );\n    }\n\n    \n    private static final Map<String,Operator> operators = new HashMap<String,Operator>() {{\n        \n        put( \"&\", stack -> Boolean.logicalAnd( stack.pop(), stack.pop() ) );\n        put( \"|\", stack -> Boolean.logicalOr( stack.pop(), stack.pop() ) );\n        put( \"!\", stack -> ! stack.pop() );\n        put( \"^\", stack -> ! stack.pop().equals ( stack.pop() ) );\n    }};\n\n    private final List<String> variables;\n    private final String[]     symbols;\n\n    \n    public TruthTable( final String... symbols ) {\n        final Set<String> variables = new LinkedHashSet<>();\n\n        for ( final String symbol : symbols ) {\n            if ( ! operators.containsKey( symbol ) ) {\n                variables.add( symbol );\n            }\n        }\n        this.variables = new ArrayList<>( variables );\n        this.symbols = symbols;\n    }\n\n    @Override\n    public String toString () {\n        final StringBuilder result = new StringBuilder();\n\n        for ( final String variable : variables ) {\n            result.append( variable ).append( ' ' );\n        }\n        result.append( ' ' );\n        for ( final String symbol : symbols ) {\n            result.append( symbol ).append ( ' ' );\n        }\n        result.append( '\\n' );\n        for ( final List<Boolean> values : enumerate( variables.size () ) ) {\n            final Iterator<String> i = variables.iterator();\n\n            for ( final Boolean value : values ) {\n                result.append(\n                    String.format(\n                        \"%-\" + i.next().length() + \"c \",\n                        value ? 'T' : 'F'\n                    )\n                );\n            }\n            result.append( ' ' )\n                .append( evaluate( values ) ? 'T' : 'F' )\n                .append( '\\n' );\n        }\n\n        return result.toString ();\n    }\n\n    \n    private static List<List<Boolean>> enumerate( final int size ) {\n        if ( 1 == size )\n            return new ArrayList<List<Boolean>>() {{\n                add( new ArrayList<Boolean>() {{ add(false); }} );\n                add( new ArrayList<Boolean>() {{ add(true);  }} );\n            }};\n\n        return new ArrayList<List<Boolean>>() {{\n            for ( final List<Boolean> head : enumerate( size - 1 ) ) {\n                add( new ArrayList<Boolean>( head ) {{ add(false); }} );\n                add( new ArrayList<Boolean>( head ) {{ add(true);  }} );\n            }\n        }};\n    }\n\n    \n    private boolean evaluate( final List<Boolean> enumeration ) {\n        final Iterator<Boolean>   i      = enumeration.iterator();\n        final Map<String,Boolean> values = new HashMap<>();\n        final Stack<Boolean>      stack  = new Stack<>();\n\n        variables.forEach ( v -> values.put( v, i.next() ) );\n        for ( final String symbol : symbols ) {\n            final Operator op = operators.get ( symbol );\n\n            \n            stack.push(\n                null == op\n                    ? values.get ( symbol )\n                    : op.evaluate ( stack )\n            );\n        }\n        return stack.pop();\n    }\n}\n"}
{"id": 425187, "name": "Set of real numbers", "source": "Translate Ruby to Java: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 425188, "name": "Set of real numbers", "source": "Translate Ruby to Java: class Rset\n  Set = Struct.new(:lo, :hi, :inc_lo, :inc_hi) do\n    def include?(x)\n      (inc_lo ? lo<=x : lo<x) and (inc_hi ? x<=hi : x<hi)\n    end\n    def length\n      hi - lo\n    end\n    def to_s\n      \"\n    end\n  end\n  \n  def initialize(lo=nil, hi=nil, inc_lo=false, inc_hi=false)\n    if lo.nil? and hi.nil?\n      @sets = []            \n    else\n      raise TypeError      unless lo.is_a?(Numeric) and hi.is_a?(Numeric)\n      raise ArgumentError  unless valid?(lo, hi, inc_lo, inc_hi)\n      @sets = [Set[lo, hi, !!inc_lo, !!inc_hi]]         \n    end\n  end\n  \n  def self.[](lo, hi, inc_hi=true)\n    self.new(lo, hi, true, inc_hi)\n  end\n  \n  def self.parse(str)\n    raise ArgumentError  unless str =~ /(\\[|\\()(.+),(.+)(\\]|\\))/\n    b0, lo, hi, b1 = $~.captures        \n    lo = Rational(lo)\n    lo = lo.numerator  if lo.denominator == 1\n    hi = Rational(hi)\n    hi = hi.numerator  if hi.denominator == 1\n    self.new(lo, hi, b0=='[', b1==']')\n  end\n  \n  def initialize_copy(obj)\n    super\n    @sets = @sets.map(&:dup)\n  end\n  \n  def include?(x)\n    @sets.any?{|set| set.include?(x)}\n  end\n  \n  def empty?\n    @sets.empty?\n  end\n  \n  def union(other)\n    sets = (@sets+other.sets).map(&:dup).sort_by{|set| [set.lo, set.hi]}\n    work = []\n    pre = sets.shift\n    sets.each do |post|\n      if valid?(pre.hi, post.lo, !pre.inc_hi, !post.inc_lo)\n        work << pre\n        pre = post\n      else\n        pre.inc_lo |= post.inc_lo  if pre.lo == post.lo\n        if pre.hi < post.hi\n          pre.hi = post.hi\n          pre.inc_hi = post.inc_hi\n        elsif pre.hi == post.hi\n          pre.inc_hi |= post.inc_hi\n        end\n      end\n    end\n    work << pre  if pre\n    new_Rset(work)\n  end\n  alias | union\n  \n  def intersection(other)\n    sets = @sets.map(&:dup)\n    work = []\n    other.sets.each do |oset|\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          \n        elsif oset.lo < set.lo and set.hi < oset.hi\n          work << set\n        else\n          lo = [set.lo, oset.lo].max\n          if set.lo == oset.lo\n            inc_lo = set.inc_lo && oset.inc_lo\n          else\n            inc_lo = (set.lo < oset.lo) ? oset.inc_lo : set.inc_lo\n          end\n          hi = [set.hi, oset.hi].min\n          if set.hi == oset.hi\n            inc_hi = set.inc_hi && oset.inc_hi\n          else\n            inc_hi = (set.hi < oset.hi) ? set.inc_hi : oset.inc_hi\n          end\n          work << Set[lo, hi, inc_lo, inc_hi]  if valid?(lo, hi, inc_lo, inc_hi)\n        end\n      end\n    end\n    new_Rset(work)\n  end\n  alias & intersection\n  \n  def difference(other)\n    sets = @sets.map(&:dup)\n    other.sets.each do |oset|\n      work = []\n      sets.each do |set|\n        if set.hi < oset.lo or oset.hi < set.lo\n          work << set\n        elsif oset.lo < set.lo and set.hi < oset.hi\n          \n        else\n          if set.lo < oset.lo\n            inc_hi = (set.hi==oset.lo and !set.inc_hi) ? false : !oset.inc_lo\n            work << Set[set.lo, oset.lo, set.inc_lo, inc_hi]\n          elsif valid?(set.lo, oset.lo, set.inc_lo, !oset.inc_lo)\n            work << Set[set.lo, set.lo, true, true]\n          end\n          if oset.hi < set.hi\n            inc_lo = (oset.hi==set.lo and !set.inc_lo) ? false : !oset.inc_hi\n            work << Set[oset.hi, set.hi, inc_lo, set.inc_hi]\n          elsif valid?(oset.hi, set.hi, !oset.inc_hi, set.inc_hi)\n            work << Set[set.hi, set.hi, true, true]\n          end\n        end\n      end\n      sets = work\n    end\n    new_Rset(sets)\n  end\n  alias - difference\n  \n  \n  def ^(other)\n    (self - other) | (other - self)\n  end\n  \n  def ==(other)\n    self.class == other.class and @sets == other.sets\n  end\n  \n  def length\n    @sets.inject(0){|len, set| len + set.length}\n  end\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n  \n  protected\n  \n  attr_accessor :sets\n  \n  private\n  \n  def new_Rset(sets)\n    rset = self.class.new          \n    rset.sets = sets\n    rset\n  end\n  \n  def valid?(lo, hi, inc_lo, inc_hi)\n    lo < hi or (lo==hi and inc_lo and inc_hi)\n  end\nend\n\ndef Rset(lo, hi, inc_hi=false)\n  Rset.new(lo, hi, false, inc_hi)\nend\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 425189, "name": "State name puzzle", "source": "Translate Ruby to Java: require 'set'\n\n\nPrimes = [ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29, 31, 37, 41, \n          43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101]\nStates = [\n    \"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\", \"California\", \"Colorado\",\n    \"Connecticut\", \"Delaware\", \"Florida\", \"Georgia\", \"Hawaii\", \"Idaho\",\n    \"Illinois\", \"Indiana\", \"Iowa\", \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\",\n    \"Maryland\", \"Massachusetts\", \"Michigan\", \"Minnesota\", \"Mississippi\",\n    \"Missouri\", \"Montana\", \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\",\n    \"New Mexico\", \"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\",\n    \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n    \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n    \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\"\n]\n\ndef print_answer(states)\n  \n  goedel = lambda {|str| str.chars.map {|c| Primes[c.ord - 65]}.reduce(:*)}\n  pairs = Hash.new {|h,k| h[k] = Array.new}\n  map = states.uniq.map {|state| [state, goedel[state.upcase.delete(\"^A-Z\")]]}\n  map.combination(2) {|(s1,g1), (s2,g2)| pairs[g1 * g2] << [s1, s2]}\n\n  \n  result = []\n  pairs.values.select {|val| val.length > 1}.each do |list_of_pairs|\n    list_of_pairs.combination(2) do |pair1, pair2|\n      if Set[*pair1, *pair2].length == 4\n        result << [pair1, pair2]\n      end\n    end\n  end\n\n  \n  result.each_with_index do |(pair1, pair2), i| \n    puts \"%d\\t%s\\t%s\" % [i+1, pair1.join(', '), pair2.join(', ')]\n  end\nend\n\nputs \"real states only\"\nprint_answer(States)\nputs \"\"\nputs \"with fictional states\"\nprint_answer(States + [\"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\"])\n", "target": "import java.util.*;\nimport java.util.stream.*;\n\npublic class StateNamePuzzle {\n\n    static String[] states = {\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n        \"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n        \"Georgia\", \"hawaii\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\",\n        \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n        \"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n        \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n        \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n        \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n        \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n        \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n        \"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\",};\n\n    public static void main(String[] args) {\n        solve(Arrays.asList(states));\n    }\n\n    static void solve(List<String> input) {\n        Map<String, String> orig = input.stream().collect(Collectors.toMap(\n                s -> s.replaceAll(\"\\\\s\", \"\").toLowerCase(), s -> s, (s, a) -> s));\n\n        input = new ArrayList<>(orig.keySet());\n\n        Map<String, List<String[]>> map = new HashMap<>();\n        for (int i = 0; i < input.size() - 1; i++) {\n            String pair0 = input.get(i);\n            for (int j = i + 1; j < input.size(); j++) {\n\n                String[] pair = {pair0, input.get(j)};\n                String s = pair0 + pair[1];\n                String key = Arrays.toString(s.chars().sorted().toArray());\n\n                List<String[]> val = map.getOrDefault(key, new ArrayList<>());\n                val.add(pair);\n                map.put(key, val);\n            }\n        }\n\n        map.forEach((key, list) -> {\n            for (int i = 0; i < list.size() - 1; i++) {\n                String[] a = list.get(i);\n                for (int j = i + 1; j < list.size(); j++) {\n                    String[] b = list.get(j);\n\n                    if (Stream.of(a[0], a[1], b[0], b[1]).distinct().count() < 4)\n                        continue;\n\n                    System.out.printf(\"%s + %s = %s + %s %n\", orig.get(a[0]),\n                            orig.get(a[1]), orig.get(b[0]), orig.get(b[1]));\n                }\n            }\n        });\n    }\n}\n"}
{"id": 425190, "name": "Super-d numbers", "source": "Translate Ruby to Java: (2..8).each do |d|\n  rep = d.to_s * d\n  print \"\n  puts (2..).lazy.select{|n| (d * n**d).to_s.include?(rep) }.first(10).join(\", \")\nend\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 425191, "name": "Textonyms", "source": "Translate Ruby to Java: CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nNUMS  = \"22233344455566677778889999\" * 2\ndict  = \"unixdict.txt\"\n\ntextonyms = File.open(dict){|f| f.map(&:chomp).group_by {|word| word.tr(CHARS, NUMS) } }\n\nputs \"There are \nThey require \n\n\nputs \"\\n25287876746242: \n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read\u00a0%,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are\u00a0%,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require\u00a0%,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to\u00a0%,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n"}
{"id": 425192, "name": "Church numerals", "source": "Translate Ruby to Java: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 425193, "name": "Church numerals", "source": "Translate Ruby to Java: def zero(f)\n  return lambda {|x| x}\nend\nZero = lambda { |f| zero(f) }\n \ndef succ(n)\n  return lambda { |f| lambda { |x| f.(n.(f).(x)) } }\nend\n \nThree = succ(succ(succ(Zero)))\n \ndef add(n, m)\n  return lambda { |f| lambda { |x| m.(f).(n.(f).(x)) } }\nend\n \ndef mult(n, m)\n  return lambda { |f| lambda { |x| m.(n.(f)).(x) } }\nend\n \ndef power(b, e)\n  return e.(b)\nend\n \ndef int_from_couch(f)\n  countup = lambda { |i| i+1 }\n  f.(countup).(0)\nend\n \ndef couch_from_int(x)\n  countdown = lambda { |i|\n    case i \n      when 0 then Zero \n      else succ(countdown.(i-1))\n    end\n  }\n  countdown.(x)\nend\n \nFour  = couch_from_int(4)\n \nputs [ add(Three, Four),\n       mult(Three, Four),\n       power(Three, Four),\n       power(Four, Three) ].map {|f| int_from_couch(f) }\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 425194, "name": "Reflection_List methods", "source": "Translate Ruby to Java: \nclass Super\n  CLASSNAME = 'super'\n  \n  def initialize(name)\n    @name = name\n    def self.superOwn\n      'super owned'\n    end\n  end\n  \n  def to_s\n    \"Super(\n  end\n  \n  def doSup\n    'did super stuff'\n  end\n  \n  def self.superClassStuff\n    'did super class stuff'\n  end\n  \n  protected\n  def protSup\n    \"Super's protected\"\n  end\n  \n  private\n  def privSup\n    \"Super's private\"\n  end\nend\n\nmodule Other\n  def otherStuff\n    'did other stuff'\n  end\nend\n\nclass Sub < Super\n  CLASSNAME = 'sub'\n  attr_reader :dynamic\n  \n  include Other\n  \n  def initialize(name, *args)\n    super(name)\n    @rest = args;\n    @dynamic = {}\n    def self.subOwn\n      'sub owned'\n    end\n  end\n  \n  def methods(regular=true)\n    super + @dynamic.keys\n  end\n  \n  def method_missing(name, *args, &block)\n    return super unless @dynamic.member?(name)\n    method = @dynamic[name]\n    if method.arity > 0\n      if method.parameters[0][1] == :self\n        args.unshift(self)\n      end\n      if method.lambda?\n        \n        args += args + [nil] * [method.arity - args.length, 0].max\n        \n        if method.parameters[-1][0] != :rest\n          args = args[0,method.arity]\n        end\n      end\n      method.call(*args)\n    else\n      method.call\n    end\n  end\n  \n  def public_methods(all=true)\n    super + @dynamic.keys\n  end\n  \n  def respond_to?(symbol, include_all=false)\n    @dynamic.member?(symbol) || super\n  end\n  \n  def to_s\n    \"Sub(\n  end\n  \n  def doSub\n    'did sub stuff'\n  end\n  \n  def self.subClassStuff\n    'did sub class stuff'\n  end\n  \n  protected\n  def protSub\n    \"Sub's protected\"\n  end\n  \n  private\n  def privSub\n    \"Sub's private\"\n  end\nend\n\nsup = Super.new('sup')\nsub = Sub.new('sub', 0, 'I', 'two')\nsub.dynamic[:incr] = proc {|i| i+1}\n\np sub.public_methods(false)\n\n\np sub.methods - Object.methods\n\n\np sub.public_methods - Object.public_methods\n\n\np sub.methods - sup.methods\n\n\n\np sub.methods(false)\n\np sub.singleton_methods\n\n", "target": "import java.lang.reflect.Method;\n\npublic class ListMethods {\n    public int examplePublicInstanceMethod(char c, double d) {\n        return 42;\n    }\n\n    private boolean examplePrivateInstanceMethod(String s) {\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Class clazz = ListMethods.class;\n\n        System.out.println(\"All public methods (including inherited):\");\n        for (Method m : clazz.getMethods()) {\n            System.out.println(m);\n        }\n        System.out.println();\n        System.out.println(\"All declared methods (excluding inherited):\");\n        for (Method m : clazz.getDeclaredMethods()) {\n            System.out.println(m);\n        }\n    }\n}\n"}
{"id": 425195, "name": "Send an unknown method call", "source": "Translate Ruby to Java: class Example\n  def foo\n    42\n  end\n  def bar(arg1, arg2, &block)\n    block.call arg1, arg2\n  end\nend\n\nsymbol = :foo\nExample.new.send symbol                         \nExample.new.send( :bar, 1, 2 ) { |x,y| x+y }    \nargs = [1, 2]\nExample.new.send( \"bar\", *args ) { |x,y| x+y }  \n", "target": "import java.lang.reflect.Method;\n\nclass Example {\n  public int foo(int x) {\n    return 42 + x;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Object example = new Example();\n    String name = \"foo\";\n    Class<?> clazz = example.getClass();\n    Method meth = clazz.getMethod(name, int.class);\n    Object result = meth.invoke(example, 5); \n    System.out.println(result);        \n  }\n}\n"}
{"id": 425196, "name": "Canonicalize CIDR", "source": "Translate Ruby to Java: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 425197, "name": "Canonicalize CIDR", "source": "Translate Ruby to Java: \n\n\nif ARGV.length == 0 then\n    ARGV = $stdin.readlines.map(&:chomp)\nend\n\nARGV.each do |cidr|\n\n  \n  dotted, size_str = cidr.split('/')\n  size = size_str.to_i\n\n  \n  binary = dotted.split('.').map { |o| \"%08b\" % o }.join\n\n  \n  binary[size .. -1] = '0' * (32 - size)\n\n  \n  canon = binary.chars.each_slice(8).map { |a| a.join.to_i(2) }.join('.')\n\n  \n  puts \"\nend\n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 425198, "name": "Sequence of primorial primes", "source": "Translate Ruby to Java: \n\nrequire 'prime' \nrequire 'openssl' \n \ni, urutan, primorial_number = 1, 1, OpenSSL::BN.new(1)\nstart = Time.now\nprime_array = Prime.first (500)\n\nuntil urutan > 20\n  primorial_number *= prime_array[i-1] \n  if (primorial_number - 1).prime_fasttest? || (primorial_number + 1).prime_fasttest?\n    puts \"\n    urutan += 1\n  end \n  i += 1\nend\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 425199, "name": "Combinations and permutations", "source": "Translate Ruby to Java: require \"big\"\ninclude Math\n \nstruct Int\n \n  def permutation(k)\n    (self-k+1..self).product(1.to_big_i)\n  end\n \n  def combination(k)\n    self.permutation(k) // (1..k).product(1.to_big_i)\n  end\n \n  def big_permutation(k)\n    exp(lgamma_plus(self) - lgamma_plus(self-k)) \n  end\n \n  def big_combination(k)\n    exp( lgamma_plus(self) - lgamma_plus(self - k) - lgamma_plus(k))\n  end\n \n  private def lgamma_plus(n)\n    lgamma(n+1)  \n  end\n \nend\n\np 12.permutation(9)               \np 12.big_permutation(9)           \np 60.combination(53)              \np 145.big_permutation(133)        \np 900.big_combination(450)        \np 1000.big_combination(969)       \np 15000.big_permutation(73)       \n\np 15000.big_permutation(74)       \n\np 15000.permutation(74)           \n", "target": "import java.math.BigInteger;\n\npublic class CombinationsAndPermutations {\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n        System.out.println(\"A sample of permutations from 1 to 12 with exact Integer arithmetic:\");\n        for ( int n = 1 ; n <= 12 ; n++ ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, permutation(n, k));\n        }\n\n        System.out.println();\n        System.out.println(\"A sample of combinations from 10 to 60 with exact Integer arithmetic:\");\n        for ( int n = 10 ; n <= 60 ; n += 5 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, combination(n, k));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of permutations from 5 to 15000 displayed in floating point arithmetic:\");\n        System.out.printf(\"%d P %d = %s%n\", 5, 2, display(permutation(5, 2), 50));\n        for ( int n = 1000 ; n <= 15000 ; n += 1000 ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, display(permutation(n, k), 50));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of combinations from 100 to 1000 displayed in floating point arithmetic:\");\n        for ( int n = 100 ; n <= 1000 ; n += 100 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, display(combination(n, k), 50));\n        }\n\n    }\n    \n    private static String display(BigInteger val, int precision) {\n        String s = val.toString();\n        precision = Math.min(precision, s.length());\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.substring(0, 1));\n        sb.append(\".\");\n        sb.append(s.substring(1, precision));\n        sb.append(\" * 10^\");\n        sb.append(s.length()-1);\n        return sb.toString();\n    }\n    \n    public static BigInteger combination(int n, int k) {\n        \n        \n        if ( n-k < k ) {\n            k = n-k;\n        }\n        BigInteger result = permutation(n, k);\n        while ( k > 0 ) {\n            result = result.divide(BigInteger.valueOf(k));\n            k--;\n        }\n        return result;\n    }\n    \n    public static BigInteger permutation(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for ( int i = n ; i >= n-k+1 ; i-- ) {\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 425200, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to Java: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 425201, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Ruby to Java: \n\n\n\n\n\nrequire 'flt'\nFlt::BinNum.Context.precision = 8192\na = n = 1\ng = 1 / Flt::BinNum(2).sqrt\nz = 0.25\n(0..17).each{\n  x = [(a + g) * 0.5, (a * g).sqrt]\n  var = x[0] - a\n  z -= var * var * n\n  n += n\n  a = x[0]\n  g = x[1]\n}\nputs a * a / z\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 425202, "name": "Long primes", "source": "Translate Ruby to Java: require \"big\"\n\ndef prime?(n)                     \n  return n | 1 == 3 if n < 5      \n  return false if n.gcd(6) != 1   \n  pc = typeof(n).new(5)           \n  until pc*pc > n\n    return false if n % pc == 0 || n % (pc + 2) == 0  \n    pc += 6                       \n  end\n  true\nend\n\n\n\ndef long_prime?(p)\n  return false unless prime? p\n  (2...p).each do |d|\n    return d == (p - 1) if (p - 1) % d == 0 && (10.to_big_i ** d) % p == 1\n  end \n  false\nend\n\nstart = Time.monotonic  \nputs \"Long primes \u2264 500:\"\n(2..500).each { |pc| print \"\nputs \n[500, 1000, 2000, 4000, 8000, 16000, 32000, 64000].each do |n|\n  puts \"Number of long primes \u2264 \nend\nputs \"\\nTime: \n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class LongPrimes\n{\n    private static void sieve(int limit, List<Integer> primes)\n    {\n        boolean[] c = new boolean[limit];\n        for (int i = 0; i < limit; i++)\n            c[i] = false;\n        \n        int p = 3, n = 0;\n        int p2 = p * p;\n        while (p2 <= limit)\n        {\n            for (int i = p2; i <= limit; i += 2 * p)\n                c[i] = true;\n            do\n                p += 2;\n            while (c[p]);\n            p2 = p * p;\n        }\n        for (int i = 3; i <= limit; i += 2)\n            if (!c[i])\n                primes.add(i);\n    }\n\n    \n    private static int findPeriod(int n)\n    {\n        int r = 1, period = 0;\n        for (int i = 1; i < n; i++)\n            r = (10 * r) % n;\n        int rr = r;\n        do\n        {\n            r = (10 * r) % n;\n            ++period;\n        }\n        while (r != rr);\n        return period;\n    }\n    \n    public static void main(String[] args)\n    {\n        int[] numbers = new int[]{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};\n        int[] totals = new int[numbers.length]; \n        List<Integer> primes = new LinkedList<Integer>();\n        List<Integer> longPrimes = new LinkedList<Integer>();\n        sieve(64000, primes);\n        for (int prime : primes)\n            if (findPeriod(prime) == prime - 1)\n                longPrimes.add(prime);\n        int count = 0, index = 0;\n        for (int longPrime : longPrimes)\n        {\n            if (longPrime > numbers[index])\n                totals[index++] = count;\n            ++count;\n        }\n        totals[numbers.length - 1] = count;\n        System.out.println(\"The long primes up to \" + numbers[0] + \" are:\");\n        System.out.println(longPrimes.subList(0, totals[0]));\n        System.out.println();\n        System.out.println(\"The number of long primes up to:\");\n        for (int i = 0; i <= 7; i++)\n            System.out.printf(\"  %5d is %d\\n\", numbers[i], totals[i]);\n    }\n}\n"}
{"id": 425203, "name": "Primorial numbers", "source": "Translate Ruby to Java: require 'prime'\n \ndef primorial_number(n)\n  pgen = Prime.each\n  (1..n).inject(1){|p,_| p*pgen.next}\nend\n \nputs \"First ten primorials: \n \n(1..5).each do |n|\n  puts \"primorial(10**\nend\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialNumbers {\n    final static int sieveLimit = 1300_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++)\n            System.out.printf(\"primorial(%d): %d%n\", i, primorial(i));\n\n        for (int i = 1; i < 6; i++) {\n            int len = primorial((int) Math.pow(10, i)).toString().length();\n            System.out.printf(\"primorial(10^%d) has length %d%n\", i, len);\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 425204, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to Java: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 425205, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Ruby to Java: def ef(fr)\n  ans = []\n  if fr >= 1\n    return [[fr.to_i], Rational(0, 1)]  if fr.denominator == 1\n    intfr = fr.to_i\n    ans, fr = [intfr], fr - intfr\n  end\n  x, y = fr.numerator, fr.denominator\n  while x != 1\n    ans << Rational(1, (1/fr).ceil)\n    fr = Rational(-y % x, y * (1/fr).ceil)\n    x, y = fr.numerator, fr.denominator\n  end\n  ans << fr\nend\n\nfor fr in [Rational(43, 48), Rational(5, 121), Rational(2014, 59)]\n  puts '%s => %s' % [fr, ef(fr).join(' + ')]\nend\n\nlenmax = denommax = [0]\nfor b in 2..99\n  for a in 1...b\n    fr = Rational(a,b)\n    e = ef(fr)\n    elen, edenom = e.length, e[-1].denominator\n    lenmax = [elen, fr] if elen > lenmax[0]\n    denommax = [edenom, fr] if edenom > denommax[0]\n  end\nend\nputs 'Term max is %s with %i terms' % [lenmax[1], lenmax[0]]\ndstr = denommax[0].to_s\nputs 'Denominator max is %s with %i digits' % [denommax[1], dstr.size], dstr\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 425206, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Ruby to Java: func legendre_pair((1), x) { (x, 1) }\nfunc legendre_pair( n,  x) {\n    var (m1, m2) = legendre_pair(n - 1, x)\n    var u = (1 - 1/n)\n    ((1 + u)*x*m1 - u*m2, m1)\n}\n\nfunc legendre((0), _) { 1 }\nfunc legendre( n,  x) { [legendre_pair(n, x)][0] }\n\nfunc legendre_prime({ .is_zero }, _) { 0 }\nfunc legendre_prime({ .is_one  }, _) { 1 }\n\nfunc legendre_prime(n, x) {\n    var (m0, m1) = legendre_pair(n, x)\n    (m1 - x*m0) * n / (1 - x**2)\n}\n\nfunc approximate_legendre_root(n, k) {\n    \n    var t = ((4*k - 1) / (4*n + 2))\n    (1 - ((n - 1)/(8 * n**3))) * cos(Num.pi * t)\n}\n\nfunc newton_raphson(f, f_prime, r, eps = 2e-16) {\n    loop {\n        var dr = (-f(r) / f_prime(r))\n        dr.abs >= eps || break\n        r += dr\n    }\n    return r\n}\n\nfunc legendre_root(n, k) {\n    newton_raphson(legendre.method(:call, n), legendre_prime.method(:call, n),\n                   approximate_legendre_root(n, k))\n}\n\nfunc weight(n, r) { 2 / ((1 - r**2) * legendre_prime(n, r)**2) }\n\nfunc nodes(n) {\n    gather {\n        take(Pair(0, weight(n, 0))) if n.is_odd\n        { |i|\n            var r = legendre_root(n, i)\n            var w = weight(n, r)\n            take(Pair(r, w), Pair(-r, w))\n        }.each(1 .. (n >> 1))\n    }\n}\n\nfunc quadrature(n, f, a, b, nds = nodes(n)) {\n    func scale(x) { (x*(b - a) + a + b) / 2 }\n    (b - a) / 2 * nds.sum { .second * f(scale(.first)) }\n}\n\n[(5..10)..., 20].each { |i|\n    printf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.15f\\n\",\n        i, quadrature(i, {.exp}, -3, +3))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class Test {\n    final static int N = 5;\n\n    static double[] lroots = new double[N];\n    static double[] weight = new double[N];\n    static double[][] lcoef = new double[N + 1][N + 1];\n\n    static void legeCoef() {\n        lcoef[0][0] = lcoef[1][1] = 1;\n\n        for (int n = 2; n <= N; n++) {\n\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n\n            for (int i = 1; i <= n; i++) {\n                lcoef[n][i] = ((2 * n - 1) * lcoef[n - 1][i - 1]\n                        - (n - 1) * lcoef[n - 2][i]) / n;\n            }\n        }\n    }\n\n    static double legeEval(int n, double x) {\n        double s = lcoef[n][n];\n        for (int i = n; i > 0; i--)\n            s = s * x + lcoef[n][i - 1];\n        return s;\n    }\n\n    static double legeDiff(int n, double x) {\n        return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);\n    }\n\n    static void legeRoots() {\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = cos(PI * (i - 0.25) / (N + 0.5));\n            do {\n                x1 = x;\n                x -= legeEval(N, x) / legeDiff(N, x);\n            } while (x != x1);\n\n            lroots[i - 1] = x;\n\n            x1 = legeDiff(N, x);\n            weight[i - 1] = 2 / ((1 - x * x) * x1 * x1);\n        }\n    }\n\n    static double legeInte(Function<Double, Double> f, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weight[i] * f.apply(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n\n    public static void main(String[] args) {\n        legeCoef();\n        legeRoots();\n\n        System.out.print(\"Roots: \");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", lroots[i]);\n\n        System.out.print(\"\\nWeight:\");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", weight[i]);\n\n        System.out.printf(\"%nintegrating Exp(x) over [-3, 3]:%n\\t%10.8f,%n\"\n                + \"compared to actual%n\\t%10.8f%n\",\n                legeInte(x -> exp(x), -3, 3), exp(3) - exp(-3));\n    }\n}\n"}
{"id": 425207, "name": "K-d tree", "source": "Translate Ruby to Java: struct Kd_node {\n    d,\n    split,\n    left,\n    right,\n}\n\nstruct Orthotope {\n    min,\n    max,\n}\n\nclass Kd_tree(n, bounds) {\n\n    method init {\n        n = self.nk2(0, n);\n    }\n\n    method nk2(split, e) {\n        return(nil) if (e.len <= 0);\n        var exset = e.sort_by { _[split] }\n        var m = (exset.len // 2);\n        var d = exset[m];\n        while ((m+1 < exset.len) && (exset[m+1][split] == d[split])) {\n            ++m;\n        }\n\n        var s2 = ((split + 1) % d.len);     \n        Kd_node(d: d, split: split,\n                left:  self.nk2(s2, exset.first(m)),\n                right: self.nk2(s2, exset.last(m-1)));\n    }\n}\n\nstruct T3 {\n    nearest,\n    dist_sqd = Inf,\n    nodes_visited = 0,\n}\n\nfunc find_nearest(k, t, p) {\n    func nn(kd, target, hr, max_dist_sqd) {\n        kd || return T3(nearest: [0]*k);\n\n        var nodes_visited = 1;\n        var s = kd.split;\n        var pivot = kd.d;\n        var left_hr = Orthotope(hr.min, hr.max);\n        var right_hr = Orthotope(hr.min, hr.max);\n        left_hr.max[s] = pivot[s];\n        right_hr.min[s] = pivot[s];\n\n        var nearer_kd;\n        var further_kd;\n        var nearer_hr;\n        var further_hr;\n        if (target[s] <= pivot[s]) {\n            (nearer_kd, nearer_hr) = (kd.left, left_hr);\n            (further_kd, further_hr) = (kd.right, right_hr);\n        }\n        else {\n            (nearer_kd, nearer_hr) = (kd.right, right_hr);\n            (further_kd, further_hr) = (kd.left, left_hr);\n        }\n\n        var n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd);\n        var nearest = n1.nearest;\n        var dist_sqd = n1.dist_sqd;\n        nodes_visited += n1.nodes_visited;\n\n        if (dist_sqd < max_dist_sqd) {\n            max_dist_sqd = dist_sqd;\n        }\n        var d = (pivot[s] - target[s] -> sqr);\n        if (d > max_dist_sqd) {\n            return T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n        }\n        d = (pivot ~Z- target \u00bbsqr\u00bb() \u00ab+\u00bb);\n        if (d < dist_sqd) {\n            nearest = pivot;\n            dist_sqd = d;\n            max_dist_sqd = dist_sqd;\n        }\n\n        var n2 = nn(further_kd, target, further_hr, max_dist_sqd);\n        nodes_visited += n2.nodes_visited;\n        if (n2.dist_sqd < dist_sqd) {\n            nearest = n2.nearest;\n            dist_sqd = n2.dist_sqd;\n        }\n\n        T3(nearest: nearest, dist_sqd: dist_sqd, nodes_visited: nodes_visited);\n    }\n\n    return nn(t.n, p, t.bounds, Inf);\n}\n\nfunc show_nearest(k, heading, kd, p) {\n    print <<-\"END\"\n        \n        Point:            [\n        END\n    var n = find_nearest(k, kd, p);\n    print <<-\"END\"\n        Nearest neighbor: [\n        Distance:         \n        Nodes visited:    \n\n        END\n}\n\nfunc random_point(k) { k.of { 1.rand } }\nfunc random_points(k, n) { n.of { random_point(k) } }\n\nvar kd1 = Kd_tree([[2, 3],[5, 4],[9, 6],[4, 7],[8, 1],[7, 2]],\n              Orthotope(min: [0, 0], max: [10, 10]));\nshow_nearest(2, \"Wikipedia example data\", kd1, [9, 2]);\n\nvar N = 1000\nvar t0 = Time.micro\nvar kd2 = Kd_tree(random_points(3, N), Orthotope(min: [0,0,0], max: [1,1,1]))\n\nvar t1 = Time.micro\nshow_nearest(2,\n    \"k-d tree with \n     kd2, random_point(3))\n", "target": "import java.util.*;\n\npublic class KdTree {\n    private int dimensions_;\n    private Node root_ = null;\n    private Node best_ = null;\n    private double bestDistance_ = 0;\n    private int visited_ = 0;\n    \n    public KdTree(int dimensions, List<Node> nodes) {\n        dimensions_ = dimensions;\n        root_ = makeTree(nodes, 0, nodes.size(), 0);\n    }\n    \n    public Node findNearest(Node target) {\n        if (root_ == null)\n            throw new IllegalStateException(\"Tree is empty!\");\n        best_ = null;\n        visited_ = 0;\n        bestDistance_ = 0;\n        nearest(root_, target, 0);\n        return best_;\n    }\n    \n    public int visited() {\n        return visited_;\n    }\n    \n    public double distance() {\n        return Math.sqrt(bestDistance_);\n    }\n    \n    private void nearest(Node root, Node target, int index) {\n        if (root == null)\n            return;\n        ++visited_;\n        double d = root.distance(target);\n        if (best_ == null || d < bestDistance_) {\n            bestDistance_ = d;\n            best_ = root;\n        }\n        if (bestDistance_ == 0)\n            return;\n        double dx = root.get(index) - target.get(index);\n        index = (index + 1) % dimensions_;\n        nearest(dx > 0 ? root.left_ : root.right_, target, index);\n        if (dx * dx >= bestDistance_)\n            return;\n        nearest(dx > 0 ? root.right_ : root.left_, target, index);\n    }\n    \n    private Node makeTree(List<Node> nodes, int begin, int end, int index) {\n        if (end <= begin)\n            return null;\n        int n = begin + (end - begin)/2;\n        Node node = QuickSelect.select(nodes, begin, end - 1, n, new NodeComparator(index));\n        index = (index + 1) % dimensions_;\n        node.left_ = makeTree(nodes, begin, n, index);\n        node.right_ = makeTree(nodes, n + 1, end, index);\n        return node;\n    }\n    \n    private static class NodeComparator implements Comparator<Node> {\n        private int index_;\n\n        private NodeComparator(int index) {\n            index_ = index;\n        }\n        public int compare(Node n1, Node n2) {\n            return Double.compare(n1.get(index_), n2.get(index_));\n        }\n    }\n    \n    public static class Node {\n        private double[] coords_;\n        private Node left_ = null;\n        private Node right_ = null;\n\n        public Node(double[] coords) {\n            coords_ = coords;\n        }\n        public Node(double x, double y) {\n            this(new double[]{x, y});\n        }\n        public Node(double x, double y, double z) {\n            this(new double[]{x, y, z});\n        }\n        double get(int index) {\n            return coords_[index];\n        }\n        double distance(Node node) {\n            double dist = 0;\n            for (int i = 0; i < coords_.length; ++i) {\n                double d = coords_[i] - node.coords_[i];\n                dist += d * d;\n            }\n            return dist;\n        }\n        public String toString() {\n            StringBuilder s = new StringBuilder(\"(\");\n            for (int i = 0; i < coords_.length; ++i) {\n                if (i > 0)\n                    s.append(\", \");\n                s.append(coords_[i]);\n            }\n            s.append(')');\n            return s.toString();\n        }\n    }\n}\n"}
{"id": 425208, "name": "Cut a rectangle", "source": "Translate Ruby to Java: def cut_it(h, w)\n  if h.odd?\n    return 0  if w.odd?\n    h, w = w, h\n  end\n  return 1  if w == 1\n  \n  nxt = [[w+1, 1, 0], [-w-1, -1, 0], [-1, 0, -1], [1, 0, 1]]  \n  blen = (h + 1) * (w + 1) - 1\n  grid = [false] * (blen + 1)\n  \n  walk = lambda do |y, x, count=0|\n    return count+1  if y==0 or y==h or x==0 or x==w\n    t = y * (w + 1) + x\n    grid[t] = grid[blen - t] = true\n    nxt.each do |nt, dy, dx|\n      count += walk[y + dy, x + dx]  unless grid[t + nt]\n    end\n    grid[t] = grid[blen - t] = false\n    count\n  end\n  \n  t = h / 2 * (w + 1) + w / 2\n  if w.odd?\n    grid[t] = grid[t + 1] = true\n    count = walk[h / 2, w / 2 - 1]\n    count + walk[h / 2 - 1, w / 2] * 2\n  else\n    grid[t] = true\n    count = walk[h / 2, w / 2 - 1]\n    return count * 2  if h == w\n    count + walk[h / 2 - 1, w / 2]\n  end\nend\n\nfor w in 1..9\n  for h in 1..w\n    puts \"%d x %d: %d\" % [w, h, cut_it(w, h)]  if (w * h).even?\n  end\nend\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 425209, "name": "Cut a rectangle", "source": "Translate Ruby to Java: def cut_it(h, w)\n  if h.odd?\n    return 0  if w.odd?\n    h, w = w, h\n  end\n  return 1  if w == 1\n  \n  nxt = [[w+1, 1, 0], [-w-1, -1, 0], [-1, 0, -1], [1, 0, 1]]  \n  blen = (h + 1) * (w + 1) - 1\n  grid = [false] * (blen + 1)\n  \n  walk = lambda do |y, x, count=0|\n    return count+1  if y==0 or y==h or x==0 or x==w\n    t = y * (w + 1) + x\n    grid[t] = grid[blen - t] = true\n    nxt.each do |nt, dy, dx|\n      count += walk[y + dy, x + dx]  unless grid[t + nt]\n    end\n    grid[t] = grid[blen - t] = false\n    count\n  end\n  \n  t = h / 2 * (w + 1) + w / 2\n  if w.odd?\n    grid[t] = grid[t + 1] = true\n    count = walk[h / 2, w / 2 - 1]\n    count + walk[h / 2 - 1, w / 2] * 2\n  else\n    grid[t] = true\n    count = walk[h / 2, w / 2 - 1]\n    return count * 2  if h == w\n    count + walk[h / 2 - 1, w / 2]\n  end\nend\n\nfor w in 1..9\n  for h in 1..w\n    puts \"%d x %d: %d\" % [w, h, cut_it(w, h)]  if (w * h).even?\n  end\nend\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 425210, "name": "Chaos game", "source": "Translate Ruby to Java: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425211, "name": "Chaos game", "source": "Translate Ruby to Java: require('Imager')\n\nvar width  = 600\nvar height = 600\n\nvar points = [\n    [width//2,        0],\n    [       0, height-1],\n    [height-1, height-1],\n]\n\nvar img = %O|Imager|.new(\n                      xsize => width,\n                      ysize => height,\n                     )\n\nvar color = %O|Imager::Color|.new('\nvar r = [(width-1).irand, (height-1).irand]\n\n30000.times {\n    var p = points.rand\n\n    r[] = (\n        (p[0] + r[0]) // 2,\n        (p[1] + r[1]) // 2,\n    )\n\n    img.setpixel(\n        x     => r[0],\n        y     => r[1],\n        color => color,\n    )\n}\n\nimg.write(file => 'chaos_game.png')\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425212, "name": "World Cup group stage", "source": "Translate Ruby to Java: teams = [:a, :b, :c, :d]\nmatches = teams.combination(2).to_a\noutcomes = [:win, :draw, :loss]\ngains = {win:[3,0], draw:[1,1], loss:[0,3]}\nplaces_histogram = Array.new(4) {Array.new(10,0)}\n\n\n\noutcomes.repeated_permutation(6).each do |outcome|\n  results = Hash.new(0)\n  \n  \n  outcome.zip(matches).each do |decision, (team1, team2)|\n    results[team1] += gains[decision][0]\n    results[team2] += gains[decision][1]\n  end \n  \n  \n  results.values.sort.reverse.each_with_index do |points, place|\n    places_histogram[place][points] += 1\n  end\nend\n\nfmt = \"%s\u00a0:\" + \"%4s\"*10\nputs fmt % [\" \", *0..9]\nputs fmt % [\"-\", *[\"---\"]*10]\nplaces_histogram.each.with_index(1) {|hist,place| puts fmt % [place, *hist]}\n", "target": "import java.util.Arrays;\n \npublic class GroupStage{\n    \n    static String[] games = {\"12\", \"13\", \"14\", \"23\", \"24\", \"34\"};\n    static String results = \"000000\";\n\n    private static boolean nextResult(){\n        if(results.equals(\"222222\")) return false;\n        int res = Integer.parseInt(results, 3) + 1;\n        results = Integer.toString(res, 3);\n        while(results.length() < 6) results = \"0\" + results;\t\n        return true;\n    }\n\n    public static void main(String[] args){\n        int[][] points = new int[4][10]; \t\t\n        do{\n            int[] records = {0,0,0,0};\n            for(int i = 0; i < 6; i++){\n                switch(results.charAt(i)){\n                    case '2': records[games[i].charAt(0) - '1'] += 3; break;    \n                    case '1':                                                   \n                        records[games[i].charAt(0) - '1']++;\n                        records[games[i].charAt(1) - '1']++;\n                        break;\n                    case '0': records[games[i].charAt(1) - '1'] += 3; break;    \n                }\n            }\n            Arrays.sort(records);\t\n            points[0][records[0]]++;\n            points[1][records[1]]++;\n            points[2][records[2]]++;\n            points[3][records[3]]++;\n        }while(nextResult());\n        System.out.println(\"First place: \" + Arrays.toString(points[3]));\n        System.out.println(\"Second place: \" + Arrays.toString(points[2]));\n        System.out.println(\"Third place: \" + Arrays.toString(points[1]));\n        System.out.println(\"Fourth place: \" + Arrays.toString(points[0]));\n    }\n}\n"}
{"id": 425213, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Ruby to Java: rpn = RPNExpression.from_infix(\"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\")\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 425214, "name": "Perlin noise", "source": "Translate Ruby to Java: const p = (%w'47 4G 3T 2J 2I F 3N D 5L 2N 2O 1H 5E 6H 7 69 3W 10 2V U 1X 3Y 8\n2R 11 6O L A N 5A 6 44 6V 3C 6I 23 0 Q 5H 1Q 2M 70 63 5N 39 Z B W 1L 4X X 2G\n6L 45 1K 2F 4U K 3H 3S 4R 4O 1W 4V 22 4L 1Z 3Q 3V 1C R 4M 25 42 4E 6F 2B 33 6D\n3E 1O 5V 3P 6E 64 2X 2K 15 1J 1A 6T 14 6S 2U 3Z 1I 1T P 1R 4H 1 60 28 21 5T 24\n3O 57 5S 2H I 4P 5K 5G 3R 3M 38 58 4F 2E 4K 2S 31 5I 4T 56 3 1S 1G 61 6A 6Y 3G\n3F 5 5M 12 43 3A 3I 73 2A 2D 5W 5R 5Q 1N 6B 1B G 1M H 52 59 S 16 67 53 4Q 5X\n3B 6W 48 2 18 4A 4J 1Y 65 49 2T 4B 4N 17 4S 9 3L M 13 71 J 2Q 30 32 27 35 68\n6G 4Y 55 34 2W 62 6U 2P 6C 6Z Y 6Q 5D 6M 5U 40 C 5B 4Z 4I 6P 29 1F 41 6J 6X E\n6N 2Z 1D 5C 5Y V 51 5J 2Y 4D 54 2C 5O 4W 37 3D 1E 19 3J 4 46 72 3U 6K 5P 2L 66\n36 1V T O 20 6R 3X 3K 5F 26 1U 5Z 1P 4C 50' * 2 -> map {|n| Num(n, 36) })\n\nfunc fade(n) { n * n * n * (n * (n * 6 - 15) + 10) }\nfunc lerp(t, a, b) { a + t*(b-a) }\n\nfunc grad(h, x, y, z) {\n    h &= 15\n    var u = (h < 8 ? x : y)\n    var v = (h < 4 ? y : (h ~~ [12,14] ? x : z))\n    (h&1 ? -u : u) + (h&2 ? -v : v)\n}\n\nfunc noise(x, y, z) {\n    var(X, Y, Z) = [x, y, z].map { .floor & 255 }...\n    var (u, v, w) = [x-=X, y-=Y, z-=Z].map { fade(_) }...\n    var (AA, AB) = with(p[X]   + Y) {|i| (p[i] + Z, p[i+1] + Z) }\n    var (BA, BB) = with(p[X+1] + Y) {|i| (p[i] + Z, p[i+1] + Z) }\n    lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z  ),\n                            grad(p[BA  ], x-1, y  , z  )),\n                    lerp(u, grad(p[AB  ], x  , y-1, z  ),\n                            grad(p[BB  ], x-1, y-1, z  ))),\n            lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1),\n                            grad(p[BA+1], x-1, y  , z-1)),\n                    lerp(u, grad(p[AB+1], x  , y-1, z-1),\n                            grad(p[BB+1], x-1, y-1, z-1))))\n}\n\nsay noise(3.14, 42, 7)\n", "target": "\n\npublic final class ImprovedNoise {\n   static public double noise(double x, double y, double z) {\n      int X = (int)Math.floor(x) & 255,                  \n          Y = (int)Math.floor(y) & 255,                  \n          Z = (int)Math.floor(z) & 255;\n      x -= Math.floor(x);                                \n      y -= Math.floor(y);                                \n      z -= Math.floor(z);\n      double u = fade(x),                                \n             v = fade(y),                                \n             w = fade(z);\n      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      \n          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      \n\n      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                     grad(p[BA  ], x-1, y  , z   )), \n                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                     grad(p[BB  ], x-1, y-1, z   ))),\n                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                     grad(p[BA+1], x-1, y  , z-1 )), \n                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                     grad(p[BB+1], x-1, y-1, z-1 ))));\n   }\n   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n   static double lerp(double t, double a, double b) { return a + t * (b - a); }\n   static double grad(int hash, double x, double y, double z) {\n      int h = hash & 15;                      \n      double u = h<8 ? x : y,                 \n             v = h<4 ? y : h==12||h==14 ? x : z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n   }\n   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   };\n   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }\n}\n"}
{"id": 425215, "name": "A_ search algorithm", "source": "Translate Ruby to Java: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425216, "name": "A_ search algorithm", "source": "Translate Ruby to Java: class AStarGraph {\n\n    has barriers = [\n        [2,4],[2,5],[2,6],[3,6],[4,6],[5,6],[5,5],[5,4],[5,3],[5,2],[4,2],[3,2]\n    ]\n\n    method heuristic(start, goal) {\n        var (D1 = 1, D2 = 1)\n        var dx = abs(start[0] - goal[0])\n        var dy = abs(start[1] - goal[1])\n        (D1 * (dx + dy)) + ((D2 - 2*D1) * Math.min(dx, dy))\n    }\n\n    method get_vertex_neighbours(pos) {\n        gather {\n            for dx, dy in [[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]] {\n                var x2 = (pos[0] + dx)\n                var y2 = (pos[1] + dy)\n                (x2<0 || x2>7 || y2<0 || y2>7) && next\n                take([x2, y2])\n            }\n        }\n    }\n\n    method move_cost(_a, b) {\n        barriers.contains(b) ? 100 : 1\n    }\n}\n\nfunc AStarSearch(start, end, graph) {\n\n    var G = Hash()\n    var F = Hash()\n\n    G{start} = 0\n    F{start} = graph.heuristic(start, end)\n\n    var closedVertices = []\n    var openVertices = [start]\n    var cameFrom = Hash()\n\n    while (openVertices) {\n\n        var current = nil\n        var currentFscore = Inf\n\n        for pos in openVertices {\n            if (F{pos} < currentFscore) {\n                currentFscore = F{pos}\n                current = pos\n            }\n        }\n\n        if (current == end) {\n            var path = [current]\n            while (cameFrom.contains(current)) {\n                current = cameFrom{current}\n                path << current\n            }\n            path.flip!\n            return (path, F{end})\n        }\n\n        openVertices.remove(current)\n        closedVertices.append(current)\n\n        for neighbour in (graph.get_vertex_neighbours(current)) {\n            if (closedVertices.contains(neighbour)) {\n                next\n            }\n            var candidateG = (G{current} + graph.move_cost(current, neighbour))\n\n            if (!openVertices.contains(neighbour)) {\n                openVertices.append(neighbour)\n            }\n            elsif (candidateG >= G{neighbour}) {\n                next\n            }\n\n            cameFrom{neighbour} = current\n            G{neighbour} = candidateG\n            var H = graph.heuristic(neighbour, end)\n            F{neighbour} = (G{neighbour} + H)\n        }\n    }\n\n    die \"A* failed to find a solution\"\n}\n\nvar graph = AStarGraph()\nvar (route, cost) = AStarSearch([0,0], [7,7], graph)\n\nvar w = 10\nvar h = 10\n\nvar grid = h.of { w.of { \".\" } }\nfor y in (^h) { grid[y][0] = \"\u2588\"; grid[y][-1] = \"\u2588\" }\nfor x in (^w) { grid[0][x] = \"\u2588\"; grid[-1][x] = \"\u2588\" }\n\nfor x,y in (graph.barriers) { grid[x+1][y+1] = \"\u2588\" }\nfor x,y in (route)          { grid[x+1][y+1] = \"x\" }\n\ngrid.each { .join.say }\n\nsay \"Path cost \n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 425217, "name": "Lychrel numbers", "source": "Translate Ruby to Java: require \"set\"\nrequire \"big\"\n \ndef add_reverse(num, max_iter=1000)\n  num = num.to_big_i\n  nums = [] of BigInt\n  (1..max_iter).each_with_object(Set.new([num])) do |_, nums|\n    num += reverse_int(num)\n    nums << num\n    return nums if palindrome?(num)\n  end\nend\n \ndef palindrome?(num)\n  num == reverse_int(num)\nend\n \ndef reverse_int(num)\n  num.to_s.reverse.to_big_i\nend\n \ndef split_roots_from_relateds(roots_and_relateds)\n  roots = roots_and_relateds.dup\n  i = 1\n  while i < roots.size\n    this = roots[i]\n    if roots[0...i].any?{ |prev| this.intersects?(prev) }\n      roots.delete_at(i)\n    else\n      i += 1\n    end\n  end\n  root = roots.map{ |each_set| each_set.min }\n  related = roots_and_relateds.map{ |each_set| each_set.min }\n  related = related.reject{ |n| root.includes?(n) }\n  return root, related\nend\n \ndef find_lychrel(maxn, max_reversions)\n  series = (1..maxn).map{ |n| add_reverse(n, max_reversions*2) }\n  roots_and_relateds = series.select{ |s| s.size > max_reversions }\n  split_roots_from_relateds(roots_and_relateds)\nend\n \nmaxn, reversion_limit = 10000, 500\nputs \"Calculations using n = 1..\nlychrel, l_related = find_lychrel(maxn, reversion_limit)\nputs \"  Number of Lychrel numbers: \nputs \"    Lychrel numbers: \nputs \"  Number of Lychrel related: \npals = (lychrel + l_related).select{|x| palindrome?(x)}.sort\nputs \"  Number of Lychrel palindromes: \nputs \"    Lychrel palindromes: \n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 425218, "name": "Lychrel numbers", "source": "Translate Ruby to Java: require \"set\"\nrequire \"big\"\n \ndef add_reverse(num, max_iter=1000)\n  num = num.to_big_i\n  nums = [] of BigInt\n  (1..max_iter).each_with_object(Set.new([num])) do |_, nums|\n    num += reverse_int(num)\n    nums << num\n    return nums if palindrome?(num)\n  end\nend\n \ndef palindrome?(num)\n  num == reverse_int(num)\nend\n \ndef reverse_int(num)\n  num.to_s.reverse.to_big_i\nend\n \ndef split_roots_from_relateds(roots_and_relateds)\n  roots = roots_and_relateds.dup\n  i = 1\n  while i < roots.size\n    this = roots[i]\n    if roots[0...i].any?{ |prev| this.intersects?(prev) }\n      roots.delete_at(i)\n    else\n      i += 1\n    end\n  end\n  root = roots.map{ |each_set| each_set.min }\n  related = roots_and_relateds.map{ |each_set| each_set.min }\n  related = related.reject{ |n| root.includes?(n) }\n  return root, related\nend\n \ndef find_lychrel(maxn, max_reversions)\n  series = (1..maxn).map{ |n| add_reverse(n, max_reversions*2) }\n  roots_and_relateds = series.select{ |s| s.size > max_reversions }\n  split_roots_from_relateds(roots_and_relateds)\nend\n \nmaxn, reversion_limit = 10000, 500\nputs \"Calculations using n = 1..\nlychrel, l_related = find_lychrel(maxn, reversion_limit)\nputs \"  Number of Lychrel numbers: \nputs \"    Lychrel numbers: \nputs \"  Number of Lychrel related: \npals = (lychrel + l_related).select{|x| palindrome?(x)}.sort\nputs \"  Number of Lychrel palindromes: \nputs \"    Lychrel palindromes: \n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 425219, "name": "Check Machin-like formulas", "source": "Translate Ruby to Java: var equationtext = <<'EOT'\n  pi/4 = arctan(1/2) + arctan(1/3)\n  pi/4 = 2*arctan(1/3) + arctan(1/7)\n  pi/4 = 4*arctan(1/5) - arctan(1/239)\n  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)\n  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)\n  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8)\n  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99)\n  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)\n  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)\n  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)\n  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)\n  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)\n  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)\n  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)\n  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)\nEOT\n\nfunc parse_eqn(equation) {\n    static eqn_re = %r{\n    (^ \\s* pi/4 \\s* = \\s* )?                 \n    (?:                                      \n        \\s* ( [-+] )? \\s*\n        (?: ( \\d+ ) \\s* \\*)?\n        \\s* arctan\\((.*?)\\)\n    )}x\n\n    gather {\n        for lhs,sign,mult,rat in (equation.findall(eqn_re)) {\n            take([\n                [+1, -1][sign == '-'] * (mult ? Num(mult) : 1),\n                Num(rat)\n            ])\n        }\n    }\n}\n\nfunc tanEval(coef, f) {\n    return f if (coef == 1)\n    return -tanEval(-coef, f) if (coef < 0)\n    var ca = coef>>1\n    var cb = (coef - ca)\n    var (a, b) = (tanEval(ca, f), tanEval(cb, f))\n    (a + b) / (1 - a*b)\n}\n\nfunc tans(xs) {\n    var xslen = xs.len\n    return tanEval(xs[0]...) if (xslen == 1)\n    var (aa, bb) = xs.part(xslen>>1)\n    var (a, b) = (tans(aa), tans(bb))\n    (a + b) / (1 - a*b)\n}\n\nvar machins = equationtext.lines.map(parse_eqn)\n\nfor machin,eqn in (machins ~Z equationtext.lines) {\n    var ans = tans(machin)\n    printf(\"%5s: %s\\n\", (ans == 1 ? 'OK' : 'ERROR'), eqn)\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 425220, "name": "Check Machin-like formulas", "source": "Translate Ruby to Java: var equationtext = <<'EOT'\n  pi/4 = arctan(1/2) + arctan(1/3)\n  pi/4 = 2*arctan(1/3) + arctan(1/7)\n  pi/4 = 4*arctan(1/5) - arctan(1/239)\n  pi/4 = 5*arctan(1/7) + 2*arctan(3/79)\n  pi/4 = 5*arctan(29/278) + 7*arctan(3/79)\n  pi/4 = arctan(1/2) + arctan(1/5) + arctan(1/8)\n  pi/4 = 4*arctan(1/5) - arctan(1/70) + arctan(1/99)\n  pi/4 = 5*arctan(1/7) + 4*arctan(1/53) + 2*arctan(1/4443)\n  pi/4 = 6*arctan(1/8) + 2*arctan(1/57) + arctan(1/239)\n  pi/4 = 8*arctan(1/10) - arctan(1/239) - 4*arctan(1/515)\n  pi/4 = 12*arctan(1/18) + 8*arctan(1/57) - 5*arctan(1/239)\n  pi/4 = 16*arctan(1/21) + 3*arctan(1/239) + 4*arctan(3/1042)\n  pi/4 = 22*arctan(1/28) + 2*arctan(1/443) - 5*arctan(1/1393) - 10*arctan(1/11018)\n  pi/4 = 22*arctan(1/38) + 17*arctan(7/601) + 10*arctan(7/8149)\n  pi/4 = 44*arctan(1/57) + 7*arctan(1/239) - 12*arctan(1/682) + 24*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12943)\n  pi/4 = 88*arctan(1/172) + 51*arctan(1/239) + 32*arctan(1/682) + 44*arctan(1/5357) + 68*arctan(1/12944)\nEOT\n\nfunc parse_eqn(equation) {\n    static eqn_re = %r{\n    (^ \\s* pi/4 \\s* = \\s* )?                 \n    (?:                                      \n        \\s* ( [-+] )? \\s*\n        (?: ( \\d+ ) \\s* \\*)?\n        \\s* arctan\\((.*?)\\)\n    )}x\n\n    gather {\n        for lhs,sign,mult,rat in (equation.findall(eqn_re)) {\n            take([\n                [+1, -1][sign == '-'] * (mult ? Num(mult) : 1),\n                Num(rat)\n            ])\n        }\n    }\n}\n\nfunc tanEval(coef, f) {\n    return f if (coef == 1)\n    return -tanEval(-coef, f) if (coef < 0)\n    var ca = coef>>1\n    var cb = (coef - ca)\n    var (a, b) = (tanEval(ca, f), tanEval(cb, f))\n    (a + b) / (1 - a*b)\n}\n\nfunc tans(xs) {\n    var xslen = xs.len\n    return tanEval(xs[0]...) if (xslen == 1)\n    var (aa, bb) = xs.part(xslen>>1)\n    var (a, b) = (tans(aa), tans(bb))\n    (a + b) / (1 - a*b)\n}\n\nvar machins = equationtext.lines.map(parse_eqn)\n\nfor machin,eqn in (machins ~Z equationtext.lines) {\n    var ans = tans(machin)\n    printf(\"%5s: %s\\n\", (ans == 1 ? 'OK' : 'ERROR'), eqn)\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 425221, "name": "The ISAAC cipher", "source": "Translate Ruby to Java: require('Math::Random::ISAAC')\n\nfunc xor_isaac(key, msg) {\n  var rng = %O<Math::Random::ISAAC>.new(unpack('C*', key))\n\n  msg.chars\u00bbord()\u00bb                                          \\\n    -> \u00bb^\u00ab 256.of{ rng.irand % 95 + 32 }.last(msg.len).flip \\\n    -> \u00ab%\u00ab '%02X' -> join\n}\n\nvar msg = 'a Top Secret secret'\nvar key = 'this is my secret key'\n\nvar enc = xor_isaac(key, msg)\nvar dec = xor_isaac(key, pack('H*', enc))\n\nsay \"Message: \nsay \"Key   \u00a0: \nsay \"XOR   \u00a0: \nsay \"XOR dcr: \n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 425222, "name": "The ISAAC cipher", "source": "Translate Ruby to Java: require('Math::Random::ISAAC')\n\nfunc xor_isaac(key, msg) {\n  var rng = %O<Math::Random::ISAAC>.new(unpack('C*', key))\n\n  msg.chars\u00bbord()\u00bb                                          \\\n    -> \u00bb^\u00ab 256.of{ rng.irand % 95 + 32 }.last(msg.len).flip \\\n    -> \u00ab%\u00ab '%02X' -> join\n}\n\nvar msg = 'a Top Secret secret'\nvar key = 'this is my secret key'\n\nvar enc = xor_isaac(key, msg)\nvar dec = xor_isaac(key, pack('H*', enc))\n\nsay \"Message: \nsay \"Key   \u00a0: \nsay \"XOR   \u00a0: \nsay \"XOR dcr: \n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 425223, "name": "Permutations_Rank of a permutation", "source": "Translate Ruby to Java: class Permutation\n  include Enumerable\n  attr_reader :num_elements, :size\n  \n  def initialize(num_elements)\n    @num_elements = num_elements\n    @size = fact(num_elements)\n  end\n  \n  def each\n    return self.to_enum unless block_given?\n    (0...@size).each{|i| yield unrank(i)}\n  end\n  \n  def unrank(r)  \n    pi = (0...num_elements).to_a\n    (@num_elements-1).downto(1) do |n|\n      s, r = r.divmod(fact(n))\n      pi[n], pi[s] = pi[s], pi[n]\n    end\n    pi\n  end\n  \n  def rank(pi)  \n    pi = pi.dup\n    pi1 = pi.zip(0...pi.size).sort.map(&:last)\n    (pi.size-1).downto(0).inject(0) do |memo,i|\n      pi[i], pi[pi1[i]] = pi[pi1[i]], (s = pi[i])\n      pi1[s], pi1[i] = pi1[i], pi1[s]\n      memo += s * fact(i)\n    end\n  end\n  \n  private\n  def fact(n)\n    n.zero? ? 1 : n.downto(1).inject(:*)\n  end\nend\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 425224, "name": "Permutations_Rank of a permutation", "source": "Translate Ruby to Java: class Permutation\n  include Enumerable\n  attr_reader :num_elements, :size\n  \n  def initialize(num_elements)\n    @num_elements = num_elements\n    @size = fact(num_elements)\n  end\n  \n  def each\n    return self.to_enum unless block_given?\n    (0...@size).each{|i| yield unrank(i)}\n  end\n  \n  def unrank(r)  \n    pi = (0...num_elements).to_a\n    (@num_elements-1).downto(1) do |n|\n      s, r = r.divmod(fact(n))\n      pi[n], pi[s] = pi[s], pi[n]\n    end\n    pi\n  end\n  \n  def rank(pi)  \n    pi = pi.dup\n    pi1 = pi.zip(0...pi.size).sort.map(&:last)\n    (pi.size-1).downto(0).inject(0) do |memo,i|\n      pi[i], pi[pi1[i]] = pi[pi1[i]], (s = pi[i])\n      pi1[s], pi1[i] = pi1[i], pi1[s]\n      memo += s * fact(i)\n    end\n  end\n  \n  private\n  def fact(n)\n    n.zero? ? 1 : n.downto(1).inject(:*)\n  end\nend\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 425225, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to Java: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 425226, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Ruby to Java: def p(l, n)\n    test = 0\n    logv = Math.log(2.0) / Math.log(10.0)\n    factor = 1\n    loopv = l\n    while loopv > 10 do\n        factor = factor * 10\n        loopv = loopv / 10\n    end\n    while n > 0 do\n        test = test + 1\n        val = (factor * (10.0 ** ((test * logv).modulo(1.0)))).floor\n        if val == l then\n            n = n - 1\n        end\n    end\n    return test\nend\n\ndef runTest(l, n)\n    print \"P(%d, %d) = %d\\n\" % [l, n, p(l, n)]\nend\n\nrunTest(12, 1)\nrunTest(12, 2)\nrunTest(123, 45)\nrunTest(123, 12345)\nrunTest(123, 678910)\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 425227, "name": "Stirling numbers of the second kind", "source": "Translate Ruby to Java: @memo = {}\n\ndef sterling2(n, k)\n  key = [n,k]\n  return @memo[key] if @memo.key?(key)\n  return 1 if n.zero? and k.zero?\n  return 0 if n.zero? or  k.zero?\n  return 1 if n == k\n  return 0 if k > n\n  res = k * sterling2(n-1, k) + sterling2(n - 1, k-1)\n  @memo[key] = res\nend\n\nr = (0..12)\nputs \"Sterling2 numbers:\"\nputs \"n/k \n \nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n \nputs \"\\nMaximum value from the sterling2(100, k)\";\nputs (1..100).map{|a| sterling2(100,a)}.max\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 425228, "name": "Stirling numbers of the second kind", "source": "Translate Ruby to Java: @memo = {}\n\ndef sterling2(n, k)\n  key = [n,k]\n  return @memo[key] if @memo.key?(key)\n  return 1 if n.zero? and k.zero?\n  return 0 if n.zero? or  k.zero?\n  return 1 if n == k\n  return 0 if k > n\n  res = k * sterling2(n-1, k) + sterling2(n - 1, k-1)\n  @memo[key] = res\nend\n\nr = (0..12)\nputs \"Sterling2 numbers:\"\nputs \"n/k \n \nr.each do |row|\n  print \"%-4s\" % row\n  puts \"\nend\n \nputs \"\\nMaximum value from the sterling2(100, k)\";\nputs (1..100).map{|a| sterling2(100,a)}.max\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 425229, "name": "Cipolla's algorithm", "source": "Translate Ruby to Java: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class CipollasAlgorithm {\n    private static final BigInteger BIG = BigInteger.TEN.pow(50).add(BigInteger.valueOf(151));\n    private static final BigInteger BIG_TWO = BigInteger.valueOf(2);\n\n    private static class Point {\n        BigInteger x;\n        BigInteger y;\n\n        Point(BigInteger x, BigInteger y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", this.x, this.y);\n        }\n    }\n\n    private static class Triple {\n        BigInteger x;\n        BigInteger y;\n        boolean b;\n\n        Triple(BigInteger x, BigInteger y, boolean b) {\n            this.x = x;\n            this.y = y;\n            this.b = b;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s, %s)\", this.x, this.y, this.b);\n        }\n    }\n\n    private static Triple c(String ns, String ps) {\n        BigInteger n = new BigInteger(ns);\n        BigInteger p = !ps.isEmpty() ? new BigInteger(ps) : BIG;\n\n        \n        Function<BigInteger, BigInteger> ls = (BigInteger a)\n            -> a.modPow(p.subtract(BigInteger.ONE).divide(BIG_TWO), p);\n\n        \n        if (!ls.apply(n).equals(BigInteger.ONE)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        BigInteger a = BigInteger.ZERO;\n        BigInteger omega2;\n        while (true) {\n            omega2 = a.multiply(a).add(p).subtract(n).mod(p);\n            if (ls.apply(omega2).equals(p.subtract(BigInteger.ONE))) {\n                break;\n            }\n            a = a.add(BigInteger.ONE);\n        }\n\n        \n        BigInteger finalOmega = omega2;\n        BiFunction<Point, Point, Point> mul = (Point aa, Point bb) -> new Point(\n            aa.x.multiply(bb.x).add(aa.y.multiply(bb.y).multiply(finalOmega)).mod(p),\n            aa.x.multiply(bb.y).add(bb.x.multiply(aa.y)).mod(p)\n        );\n\n        \n        Point r = new Point(BigInteger.ONE, BigInteger.ZERO);\n        Point s = new Point(a, BigInteger.ONE);\n        BigInteger nn = p.add(BigInteger.ONE).shiftRight(1).mod(p);\n        while (nn.compareTo(BigInteger.ZERO) > 0) {\n            if (nn.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                r = mul.apply(r, s);\n            }\n            s = mul.apply(s, s);\n            nn = nn.shiftRight(1);\n        }\n\n        \n        if (!r.y.equals(BigInteger.ZERO)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        if (!r.x.multiply(r.x).mod(p).equals(n)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        return new Triple(r.x, p.subtract(r.x), true);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(c(\"10\", \"13\"));\n        System.out.println(c(\"56\", \"101\"));\n        System.out.println(c(\"8218\", \"10007\"));\n        System.out.println(c(\"8219\", \"10007\"));\n        System.out.println(c(\"331575\", \"1000003\"));\n        System.out.println(c(\"665165880\", \"1000000007\"));\n        System.out.println(c(\"881398088036\", \"1000000000039\"));\n        System.out.println(c(\"34035243914635549601583369544560650254325084643201\", \"\"));\n    }\n}\n"}
{"id": 425230, "name": "Cipolla's algorithm", "source": "Translate Ruby to Java: func cipolla(n, p) {\n\n    legendre(n, p) == 1 || return nil\n\n    var (a = 0, \u03c92 = 0)\n    loop {\n        \u03c92 = ((a*a - n) % p)\n        if (legendre(\u03c92, p) == -1) {\n            break\n        }\n        ++a\n    }\n\n    struct point { x, y }\n\n    func mul(a, b) {\n        point((a.x*b.x + a.y*b.y*\u03c92) % p, (a.x*b.y + b.x*a.y) % p)\n    }\n\n    var r = point(1, 0)\n    var s = point(a, 1)\n\n    for (var n = ((p+1) >> 1); n > 0; n >>= 1) {\n        r = mul(r, s) if n.is_odd\n        s = mul(s, s)\n    }\n\n    r.y == 0 ? r.x : nil\n}\n\nvar tests = [\n    [10, 13],\n    [56, 101],\n    [8218, 10007],\n    [8219, 10007],\n    [331575, 1000003],\n    [665165880, 1000000007],\n    [881398088036 1000000000039],\n    [34035243914635549601583369544560650254325084643201, 10**50 + 151],\n]\n\nfor n,p in tests {\n    var r = cipolla(n, p)\n    if (defined(r)) {\n        say \"Roots of \n    } else {\n        say \"No solution for (\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class CipollasAlgorithm {\n    private static final BigInteger BIG = BigInteger.TEN.pow(50).add(BigInteger.valueOf(151));\n    private static final BigInteger BIG_TWO = BigInteger.valueOf(2);\n\n    private static class Point {\n        BigInteger x;\n        BigInteger y;\n\n        Point(BigInteger x, BigInteger y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", this.x, this.y);\n        }\n    }\n\n    private static class Triple {\n        BigInteger x;\n        BigInteger y;\n        boolean b;\n\n        Triple(BigInteger x, BigInteger y, boolean b) {\n            this.x = x;\n            this.y = y;\n            this.b = b;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s, %s)\", this.x, this.y, this.b);\n        }\n    }\n\n    private static Triple c(String ns, String ps) {\n        BigInteger n = new BigInteger(ns);\n        BigInteger p = !ps.isEmpty() ? new BigInteger(ps) : BIG;\n\n        \n        Function<BigInteger, BigInteger> ls = (BigInteger a)\n            -> a.modPow(p.subtract(BigInteger.ONE).divide(BIG_TWO), p);\n\n        \n        if (!ls.apply(n).equals(BigInteger.ONE)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        BigInteger a = BigInteger.ZERO;\n        BigInteger omega2;\n        while (true) {\n            omega2 = a.multiply(a).add(p).subtract(n).mod(p);\n            if (ls.apply(omega2).equals(p.subtract(BigInteger.ONE))) {\n                break;\n            }\n            a = a.add(BigInteger.ONE);\n        }\n\n        \n        BigInteger finalOmega = omega2;\n        BiFunction<Point, Point, Point> mul = (Point aa, Point bb) -> new Point(\n            aa.x.multiply(bb.x).add(aa.y.multiply(bb.y).multiply(finalOmega)).mod(p),\n            aa.x.multiply(bb.y).add(bb.x.multiply(aa.y)).mod(p)\n        );\n\n        \n        Point r = new Point(BigInteger.ONE, BigInteger.ZERO);\n        Point s = new Point(a, BigInteger.ONE);\n        BigInteger nn = p.add(BigInteger.ONE).shiftRight(1).mod(p);\n        while (nn.compareTo(BigInteger.ZERO) > 0) {\n            if (nn.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                r = mul.apply(r, s);\n            }\n            s = mul.apply(s, s);\n            nn = nn.shiftRight(1);\n        }\n\n        \n        if (!r.y.equals(BigInteger.ZERO)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        if (!r.x.multiply(r.x).mod(p).equals(n)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        return new Triple(r.x, p.subtract(r.x), true);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(c(\"10\", \"13\"));\n        System.out.println(c(\"56\", \"101\"));\n        System.out.println(c(\"8218\", \"10007\"));\n        System.out.println(c(\"8219\", \"10007\"));\n        System.out.println(c(\"331575\", \"1000003\"));\n        System.out.println(c(\"665165880\", \"1000000007\"));\n        System.out.println(c(\"881398088036\", \"1000000000039\"));\n        System.out.println(c(\"34035243914635549601583369544560650254325084643201\", \"\"));\n    }\n}\n"}
{"id": 425231, "name": "Pierpont primes", "source": "Translate Ruby to Java: require 'gmp'\n\ndef  smooth_generator(ar)\n  return to_enum(__method__, ar) unless block_given?\n  next_smooth = 1\n  queues = ar.map{|num| [num, []] }\n  loop do\n    yield next_smooth\n    queues.each {|m, queue| queue << next_smooth * m}\n    next_smooth = queues.collect{|m, queue| queue.first}.min\n    queues.each{|m, queue| queue.shift if queue.first == next_smooth }\n  end\nend\n  \ndef pierpont(num = 1)\n    return to_enum(__method__, num) unless block_given?\n    smooth_generator([2,3]).each{|smooth| yield smooth+num if GMP::Z(smooth + num).probab_prime? > 0}\nend\n\ndef puts_cols(ar, n=10)\n  ar.each_slice(n).map{|slice|puts  slice.map{|n| n.to_s.rjust(10)}.join }\nend\n\nn, m = 50, 250\nputs \"First \nputs_cols(pierpont.take(n))\nputs \"\nputs \"First \nputs_cols(pierpont(-1).take(n))\nputs \"\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PierpontPrimes {\n\n    public static void main(String[] args) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        display(\"First 50 Pierpont primes of the first kind:\", pierpontPrimes(50, true));\n        display(\"First 50 Pierpont primes of the second kind:\", pierpontPrimes(50, false));\n        System.out.printf(\"250th Pierpont prime of the first kind:     %s%n%n\", nf.format(pierpontPrimes(250, true).get(249)));\n        System.out.printf(\"250th Pierpont prime of the second kind: %s%n%n\", nf.format(pierpontPrimes(250, false).get(249)));\n    }\n    \n    private static void display(String message, List<BigInteger> primes) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        System.out.printf(\"%s%n\", message);\n        for ( int i = 1 ; i <= primes.size() ; i++ ) {\n            System.out.printf(\"%10s  \", nf.format(primes.get(i-1)));\n            if ( i % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        System.out.printf(\"%n\");\n    }\n\n    public static List<BigInteger> pierpontPrimes(int n, boolean first) {\n        List<BigInteger> primes = new ArrayList<BigInteger>();\n        if ( first ) {\n            primes.add(BigInteger.valueOf(2));\n            n -= 1;\n        }\n\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        int twoIndex = 0, threeIndex = 0;\n        List<BigInteger> twoSmooth = new ArrayList<BigInteger>();\n\n        BigInteger one = BigInteger.ONE;\n        BigInteger mOne = BigInteger.valueOf(-1);\n        int count = 0;\n        while ( count < n ) {\n            BigInteger min = twoTest.min(threeTest);\n            twoSmooth.add(min);\n            if ( min.compareTo(twoTest) == 0 ) {\n                twoTest = two.multiply(twoSmooth.get(twoIndex));\n                twoIndex++;\n            }\n            if ( min.compareTo(threeTest) == 0 ) {\n                threeTest = three.multiply(twoSmooth.get(threeIndex));\n                threeIndex++;\n            }\n            BigInteger test = min.add(first ? one : mOne);\n            if ( test.isProbablePrime(10) ) {\n                primes.add(test);\n                count++;\n            }\n        }\n        return primes;\n    }\n    \n}\n"}
{"id": 425232, "name": "N-smooth numbers", "source": "Translate Ruby to Java: require \"big\"\n\ndef prime?(n) \n  return false unless (n | 1 == 3 if n < 5) || (n % 6) | 4 == 5\n  sqrt_n = Math.isqrt(n)  \n  pc = typeof(n).new(5)\n  while pc <= sqrt_n\n    return false if n % pc == 0 || n % (pc + 2) == 0\n    pc += 6\n  end\n  true\nend\n\ndef gen_primes(a, b)\n    (a..b).select { |pc| pc if prime? pc }\nend\n\ndef nsmooth(n, limit)\n    raise \"Exception(n or limit)\" if n < 2 || n > 521 || limit < 1\n    raise \"Exception(must be a prime number: n)\" unless prime? n\n    \n    primes = gen_primes(2, n)\n    ns = [0.to_big_i] * limit\n    ns[0] = 1.to_big_i\n    nextp = primes[0..primes.index(n)].map { |prm| prm.to_big_i }\n\n    indices = [0] * nextp.size\n    (1...limit).each do |m|\n        ns[m] = nextp.min\n        (0...indices.size).each do |i|\n            if ns[m] == nextp[i]\n                indices[i] += 1\n                nextp[i] = primes[i] * ns[indices[i]]\n            end\n        end\n    end\n    ns\nend\n\ngen_primes(2, 29).each do |prime|\n    print \"The first 25 \n    print nsmooth(prime, 25)\n    puts\nend\nputs\ngen_primes(3, 29).each do |prime|\n    print \"The 3000 to 3202 \n    print nsmooth(prime, 3002)[2999..]\n    puts\nend\nputs\ngen_primes(503, 521).each do |prime|\n    print \"The 30,000 to 30,019 \n    print nsmooth(prime, 30019)[29999..]\n    puts\nend\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NSmoothNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"show the first 25 n-smooth numbers for n = 2 through n = 29%n\");\n        int max = 25;\n        List<BigInteger> primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The first %d %d-smooth numbers:%n\", max, n);\n                BigInteger[] humble = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = 0 ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", humble[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"show three numbers starting with 3,000 for n-smooth numbers for n = 3 through n = 29%n\");\n        int count = 3;\n        max = 3000 + count - 1;\n        primes = new ArrayList<>();\n        primes.add(BigInteger.valueOf(2));\n        for ( int n = 3 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = max-count ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", nSmooth[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"Show twenty numbers starting with 30,000 n-smooth numbers for n=503 through n=521%n\");\n        count = 20;\n        max = 30000 + count - 1;\n        primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 521 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                if ( n >= 503 && n <= 521 ) {\n                    System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                    BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                    for ( int i = max-count ; i < max ; i++ ) {\n                        System.out.printf(\"%s \", nSmooth[i]);\n                    }\n                    System.out.printf(\"%n%n\");\n                }\n            }\n        }\n\n    }\n\n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BigInteger[] nSmooth(int n, BigInteger[] primes) {\n        int size = primes.length;\n        BigInteger[] test = new BigInteger[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            test[i] = primes[i];\n        }\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        \n        int[] indexes = new int[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            indexes[i] = 0;\n        }\n        \n        for ( int index = 1 ; index < n ; index++ ) {\n            BigInteger min = test[0];\n            for ( int i = 1 ; i < size ; i++ ) {\n                min = min.min(test[i]);\n            }\n            results[index] = min;\n            \n            for ( int i = 0 ; i < size ; i++ ) {\n                if ( results[index].compareTo(test[i]) == 0 ) {\n                    indexes[i] = indexes[i] + 1;\n                    test[i] = primes[i].multiply(results[indexes[i]]);\n                }\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 425233, "name": "Partition an integer x into n primes", "source": "Translate Ruby to Java: require \"prime\"\n\ndef prime_partition(x, n)\n  Prime.each(x).to_a.combination(n).detect{|primes| primes.sum == x}\nend\n\nTESTCASES = [[99809, 1], [18, 2], [19, 3], [20, 4], [2017, 24], \n             [22699, 1], [22699, 2], [22699, 3], [22699, 4], [40355, 3]]\n\nTESTCASES.each do |prime, num|\n  res = prime_partition(prime, num) \n  str = res.nil? ? \"no solution\" : res.join(\" + \")\n  puts  \"Partitioned \nend\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PartitionInteger {\n    private static final int[] primes = IntStream.concat(IntStream.of(2), IntStream.iterate(3, n -> n + 2))\n        .filter(PartitionInteger::isPrime)\n        .limit(50_000)\n        .toArray();\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    private static boolean findCombo(int k, int x, int m, int n, int[] combo) {\n        boolean foundCombo = false;\n        if (k >= m) {\n            if (Arrays.stream(combo).map(i -> primes[i]).sum() == x) {\n                String s = m > 1 ? \"s\" : \"\";\n                System.out.printf(\"Partitioned %5d with %2d prime%s: \", x, m, s);\n                for (int i = 0; i < m; ++i) {\n                    System.out.print(primes[combo[i]]);\n                    if (i < m - 1) System.out.print('+');\n                    else System.out.println();\n                }\n                foundCombo = true;\n            }\n        } else {\n            for (int j = 0; j < n; ++j) {\n                if (k == 0 || j > combo[k - 1]) {\n                    combo[k] = j;\n                    if (!foundCombo) {\n                        foundCombo = findCombo(k + 1, x, m, n, combo);\n                    }\n                }\n            }\n        }\n        return foundCombo;\n    }\n\n    private static void partition(int x, int m) {\n        if (x < 2 || m < 1 || m >= x) {\n            throw new IllegalArgumentException();\n        }\n        int[] filteredPrimes = Arrays.stream(primes).filter(it -> it <= x).toArray();\n        int n = filteredPrimes.length;\n        if (n < m) throw new IllegalArgumentException(\"Not enough primes\");\n        int[] combo = new int[m];\n        boolean foundCombo = findCombo(0, x, m, n, combo);\n        if (!foundCombo) {\n            String s = m > 1 ? \"s\" : \" \";\n            System.out.printf(\"Partitioned %5d with %2d prime%s: (not possible)\\n\", x, m, s);\n        }\n    }\n\n    public static void main(String[] args) {\n        partition(99809, 1);\n        partition(18, 2);\n        partition(19, 3);\n        partition(20, 4);\n        partition(2017, 24);\n        partition(22699, 1);\n        partition(22699, 2);\n        partition(22699, 3);\n        partition(22699, 4);\n        partition(40355, 3);\n    }\n}\n"}
{"id": 425234, "name": "Stirling numbers of the first kind", "source": "Translate Ruby to Java: $cache = {}\ndef sterling1(n, k)\n    if n == 0 and k == 0 then\n        return 1\n    end\n    if n > 0 and k == 0 then\n        return 0\n    end\n    if k > n then\n        return 0\n    end\n    key = [n, k]\n    if $cache[key] then\n        return $cache[key]\n    end\n    value = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n    $cache[key] = value\n    return value\nend\n\nMAX = 12\ndef main\n    print \"Unsigned Stirling numbers of the first kind:\\n\"\n    print \"n/k\"\n    for n in 0 .. MAX\n        print \"%10d\" % [n]\n    end\n    print \"\\n\"\n\n    for n in 0 .. MAX\n        print \"%-3d\" % [n]\n        for k in 0 .. n\n            print \"%10d\" % [sterling1(n, k)]\n        end\n        print \"\\n\"\n    end\n\n    print \"The maximum value of S1(100, k) =\\n\"\n    previous = 0\n    for k in 1 .. 100\n        current = sterling1(100, k)\n        if previous < current then\n            previous = current\n        else\n            print previous, \"\\n\"\n            print \"(%d digits, k = %d)\\n\" % [previous.to_s.length, k - 1]\n            break\n        end\n    end\nend\n\nmain()\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 425235, "name": "Stirling numbers of the first kind", "source": "Translate Ruby to Java: $cache = {}\ndef sterling1(n, k)\n    if n == 0 and k == 0 then\n        return 1\n    end\n    if n > 0 and k == 0 then\n        return 0\n    end\n    if k > n then\n        return 0\n    end\n    key = [n, k]\n    if $cache[key] then\n        return $cache[key]\n    end\n    value = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n    $cache[key] = value\n    return value\nend\n\nMAX = 12\ndef main\n    print \"Unsigned Stirling numbers of the first kind:\\n\"\n    print \"n/k\"\n    for n in 0 .. MAX\n        print \"%10d\" % [n]\n    end\n    print \"\\n\"\n\n    for n in 0 .. MAX\n        print \"%-3d\" % [n]\n        for k in 0 .. n\n            print \"%10d\" % [sterling1(n, k)]\n        end\n        print \"\\n\"\n    end\n\n    print \"The maximum value of S1(100, k) =\\n\"\n    previous = 0\n    for k in 1 .. 100\n        current = sterling1(100, k)\n        if previous < current then\n            previous = current\n        else\n            print previous, \"\\n\"\n            print \"(%d digits, k = %d)\\n\" % [previous.to_s.length, k - 1]\n            break\n        end\n    end\nend\n\nmain()\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 425236, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to Java: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 425237, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Ruby to Java: func perpendicular_distance(Arr start, Arr end, Arr point) {\n    ((point == start) || (point == end)) && return 0\n    var (\u0394x,  \u0394y ) = (  end \u00bb-\u00ab start)...\n    var (\u0394px, \u0394py) = (point \u00bb-\u00ab start)...\n    var h = hypot(\u0394x, \u0394y)\n    [\\\u0394x, \\\u0394y].map { *_ /= h }\n    (([\u0394px, \u0394py] \u00bb-\u00ab ([\u0394x, \u0394y] \u00bb*\u00bb (\u0394x*\u0394px + \u0394y*\u0394py))) \u00bb**\u00bb 2).sum.sqrt\n}\n\nfunc Ramer_Douglas_Peucker(Arr points { .all { .len > 1 } }, \u03b5 = 1) {\n    points.len == 2 && return points\n\n    var d = (^points -> map {\n        perpendicular_distance(points[0], points[-1], points[_])\n    })\n\n    if (d.max > \u03b5) {\n        var i = d.index(d.max)\n        return [Ramer_Douglas_Peucker(points.ft(0, i), \u03b5).ft(0, -2)...,\n                Ramer_Douglas_Peucker(points.ft(i),    \u03b5)...]\n    }\n\n    return [points[0,-1]]\n}\n\nsay Ramer_Douglas_Peucker(\n    [[0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9]]\n)\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 425238, "name": "Bilinear interpolation", "source": "Translate Ruby to Java: require('Imager')\n\nfunc scale(img, scaleX, scaleY) {\n    var (width, height) = (img.getwidth, img.getheight)\n    var (newWidth, newHeight) = (int(width*scaleX), int(height*scaleY))\n\n    var out = %O<Imager>.new(xsize => newWidth, ysize => newHeight)\n\n    var lerp = { |s, e, t|\n        s + t*(e-s)\n    }\n\n    var blerp = { |c00, c10, c01, c11, tx, ty|\n        lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty)\n    }\n\n    for x,y in (^newWidth ~X ^newHeight) {\n        var gxf = (x/newWidth  * (width  - 1))\n        var gyf = (y/newHeight * (height - 1))\n\n        var gx = gxf.int\n        var gy = gyf.int\n\n        var *c00 = img.getpixel(x => gx,   y => gy  ).rgba\n        var *c10 = img.getpixel(x => gx+1, y => gy  ).rgba\n        var *c01 = img.getpixel(x => gx,   y => gy+1).rgba\n        var *c11 = img.getpixel(x => gx+1, y => gy+1).rgba\n\n        var rgb = 3.of { |i|\n            blerp(c00[i], c10[i], c01[i], c11[i], gxf - gx, gyf - gy).int\n        }\n\n        out.setpixel(x => x, y => y, color => rgb)\n    }\n\n    return out\n}\n\nvar img = %O<Imager>.new(file => \"input.png\")\nvar out = scale(img, 1.6, 1.6)\nout.write(file => \"output.png\")\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class BilinearInterpolation {\n    \n    private static int get(int self, int n) {\n        return (self >> (n * 8)) & 0xFF;\n    }\n\n    private static float lerp(float s, float e, float t) {\n        return s + (e - s) * t;\n    }\n\n    private static float blerp(final Float c00, float c10, float c01, float c11, float tx, float ty) {\n        return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);\n    }\n\n    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {\n        int newWidth = (int) (self.getWidth() * scaleX);\n        int newHeight = (int) (self.getHeight() * scaleY);\n        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());\n        for (int x = 0; x < newWidth; ++x) {\n            for (int y = 0; y < newHeight; ++y) {\n                float gx = ((float) x) / newWidth * (self.getWidth() - 1);\n                float gy = ((float) y) / newHeight * (self.getHeight() - 1);\n                int gxi = (int) gx;\n                int gyi = (int) gy;\n                int rgb = 0;\n                int c00 = self.getRGB(gxi, gyi);\n                int c10 = self.getRGB(gxi + 1, gyi);\n                int c01 = self.getRGB(gxi, gyi + 1);\n                int c11 = self.getRGB(gxi + 1, gyi + 1);\n                for (int i = 0; i <= 2; ++i) {\n                    float b00 = get(c00, i);\n                    float b10 = get(c10, i);\n                    float b01 = get(c01, i);\n                    float b11 = get(c11, i);\n                    int ble = ((int) blerp(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);\n                    rgb = rgb | ble;\n                }\n                newImage.setRGB(x, y, rgb);\n            }\n        }\n        return newImage;\n    }\n\n    public static void main(String[] args) throws IOException {\n        File lenna = new File(\"Lenna100.jpg\");\n        BufferedImage image = ImageIO.read(lenna);\n        BufferedImage image2 = scale(image, 1.6f, 1.6f);\n        File lenna2 = new File(\"Lenna100_larger.jpg\");\n        ImageIO.write(image2, \"jpg\", lenna2);\n    }\n}\n"}
{"id": 425239, "name": "Bilinear interpolation", "source": "Translate Ruby to Java: require('Imager')\n\nfunc scale(img, scaleX, scaleY) {\n    var (width, height) = (img.getwidth, img.getheight)\n    var (newWidth, newHeight) = (int(width*scaleX), int(height*scaleY))\n\n    var out = %O<Imager>.new(xsize => newWidth, ysize => newHeight)\n\n    var lerp = { |s, e, t|\n        s + t*(e-s)\n    }\n\n    var blerp = { |c00, c10, c01, c11, tx, ty|\n        lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty)\n    }\n\n    for x,y in (^newWidth ~X ^newHeight) {\n        var gxf = (x/newWidth  * (width  - 1))\n        var gyf = (y/newHeight * (height - 1))\n\n        var gx = gxf.int\n        var gy = gyf.int\n\n        var *c00 = img.getpixel(x => gx,   y => gy  ).rgba\n        var *c10 = img.getpixel(x => gx+1, y => gy  ).rgba\n        var *c01 = img.getpixel(x => gx,   y => gy+1).rgba\n        var *c11 = img.getpixel(x => gx+1, y => gy+1).rgba\n\n        var rgb = 3.of { |i|\n            blerp(c00[i], c10[i], c01[i], c11[i], gxf - gx, gyf - gy).int\n        }\n\n        out.setpixel(x => x, y => y, color => rgb)\n    }\n\n    return out\n}\n\nvar img = %O<Imager>.new(file => \"input.png\")\nvar out = scale(img, 1.6, 1.6)\nout.write(file => \"output.png\")\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class BilinearInterpolation {\n    \n    private static int get(int self, int n) {\n        return (self >> (n * 8)) & 0xFF;\n    }\n\n    private static float lerp(float s, float e, float t) {\n        return s + (e - s) * t;\n    }\n\n    private static float blerp(final Float c00, float c10, float c01, float c11, float tx, float ty) {\n        return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);\n    }\n\n    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {\n        int newWidth = (int) (self.getWidth() * scaleX);\n        int newHeight = (int) (self.getHeight() * scaleY);\n        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());\n        for (int x = 0; x < newWidth; ++x) {\n            for (int y = 0; y < newHeight; ++y) {\n                float gx = ((float) x) / newWidth * (self.getWidth() - 1);\n                float gy = ((float) y) / newHeight * (self.getHeight() - 1);\n                int gxi = (int) gx;\n                int gyi = (int) gy;\n                int rgb = 0;\n                int c00 = self.getRGB(gxi, gyi);\n                int c10 = self.getRGB(gxi + 1, gyi);\n                int c01 = self.getRGB(gxi, gyi + 1);\n                int c11 = self.getRGB(gxi + 1, gyi + 1);\n                for (int i = 0; i <= 2; ++i) {\n                    float b00 = get(c00, i);\n                    float b10 = get(c10, i);\n                    float b01 = get(c01, i);\n                    float b11 = get(c11, i);\n                    int ble = ((int) blerp(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);\n                    rgb = rgb | ble;\n                }\n                newImage.setRGB(x, y, rgb);\n            }\n        }\n        return newImage;\n    }\n\n    public static void main(String[] args) throws IOException {\n        File lenna = new File(\"Lenna100.jpg\");\n        BufferedImage image = ImageIO.read(lenna);\n        BufferedImage image2 = scale(image, 1.6f, 1.6f);\n        File lenna2 = new File(\"Lenna100_larger.jpg\");\n        ImageIO.write(image2, \"jpg\", lenna2);\n    }\n}\n"}
{"id": 425240, "name": "Vector", "source": "Translate Ruby to Java: class Vector\n  def self.polar(r, angle=0)\n    new(r*Math.cos(angle), r*Math.sin(angle))\n  end\n  \n  attr_reader :x, :y\n  \n  def initialize(x, y)\n    raise TypeError unless x.is_a?(Numeric) and y.is_a?(Numeric)\n    @x, @y = x, y\n  end\n  \n  def +(other)\n    raise TypeError if self.class != other.class\n    self.class.new(@x + other.x, @y + other.y)\n  end\n  \n  def -@;       self.class.new(-@x, -@y)        end\n  def -(other)  self + (-other)                 end\n  \n  def *(scalar)\n    raise TypeError unless scalar.is_a?(Numeric)\n    self.class.new(@x * scalar, @y * scalar)\n  end\n  \n  def /(scalar)\n    raise TypeError unless scalar.is_a?(Numeric) and scalar.nonzero?\n    self.class.new(@x / scalar, @y / scalar)\n  end\n  \n  def r;        @r     ||= Math.hypot(@x, @y)   end\n  def angle;    @angle ||= Math.atan2(@y, @x)   end\n  def polar;    [r, angle]                      end\n  def rect;     [@x, @y]                        end\n  def to_s;     \"\n  alias inspect to_s\nend\n\np v = Vector.new(1,1)                   \np w = Vector.new(3,4)                   \np v + w                                 \np v - w                                 \np -v                                    \np w * 5                                 \np w / 2.0                               \np w.x                                   \np w.y                                   \np v.polar                               \np w.polar                               \np z = Vector.polar(1, Math::PI/2)       \np z.rect                                \np z.polar                               \np z = Vector.polar(-2, Math::PI/4)      \np z.polar                               \n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(new Vec2(5, 7).add(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).sub(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).mult(11));\n        System.out.println(new Vec2(5, 7).div(2));\n    }\n}\n\nclass Vec2 {\n    final double x, y;\n\n    Vec2(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 add(Vec2 v) {\n        return new Vec2(x + v.x, y + v.y);\n    }\n\n    Vec2 sub(Vec2 v) {\n        return new Vec2(x - v.x, y - v.y);\n    }\n\n    Vec2 div(double val) {\n        return new Vec2(x / val, y / val);\n    }\n\n    Vec2 mult(double val) {\n        return new Vec2(x * val, y * val);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(Locale.US, \"[%s, %s]\", x, y);\n    }\n}\n"}
{"id": 425241, "name": "Elliptic curve arithmetic", "source": "Translate Ruby to Java: module EC {\n\n    var A = 0\n    var B = 7\n\n    class Horizon {\n        method to_s {\n            \"EC Point at horizon\"\n        }\n\n        method *(_) {\n            self\n        }\n\n        method -(_) {\n            self\n        }\n    }\n\n    class Point(Number x, Number y) {\n        method to_s {\n            \"EC Point at x=\n        }\n\n        method neg {\n            Point(x, -y)\n        }\n\n        method -(Point p) {\n            self + -p\n        }\n\n        method +(Point p) {\n\n            if (x == p.x) {\n                return (y == p.y ? self*2 : Horizon())\n            }\n            else {\n                var slope = (p.y - y)/(p.x - x)\n                var x2 = (slope**2 - x - p.x)\n                var y2 = (slope * (x - x2) - y)\n                Point(x2, y2)\n            }\n        }\n\n        method +(Horizon _) {\n            self\n        }\n\n        method *((0)) {\n            Horizon()\n        }\n\n        method *((1)) {\n            self\n        }\n\n        method *((2)) {\n            var l = (3 * x**2 + A)/(2 * y)\n            var x2 = (l**2 - 2*x)\n            var y2 = (l * (x - x2) - y)\n            Point(x2, y2)\n        }\n\n        method *(Number n) {\n            2*(self * (n>>1)) + self*(n % 2)\n        }\n    }\n\n    class Horizon {\n        method +(Point p) {\n            p\n        }\n    }\n\n    class Number {\n        method +(Point p) {\n            p + self\n        }\n        method *(Point p) {\n            p * self\n        }\n        method *(Horizon h) {\n            h\n        }\n        method -(Point p) {\n            -p + self\n        }\n    }\n}\n\nsay var p = with(1) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var q = with(2) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var s = (p + q)\n\nsay (\"checking alignment:  \", abs((p.x - q.x)*(-s.y - q.y) - (p.y - q.y)*(s.x - q.x)) < 1e-20)\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 425242, "name": "Elliptic curve arithmetic", "source": "Translate Ruby to Java: module EC {\n\n    var A = 0\n    var B = 7\n\n    class Horizon {\n        method to_s {\n            \"EC Point at horizon\"\n        }\n\n        method *(_) {\n            self\n        }\n\n        method -(_) {\n            self\n        }\n    }\n\n    class Point(Number x, Number y) {\n        method to_s {\n            \"EC Point at x=\n        }\n\n        method neg {\n            Point(x, -y)\n        }\n\n        method -(Point p) {\n            self + -p\n        }\n\n        method +(Point p) {\n\n            if (x == p.x) {\n                return (y == p.y ? self*2 : Horizon())\n            }\n            else {\n                var slope = (p.y - y)/(p.x - x)\n                var x2 = (slope**2 - x - p.x)\n                var y2 = (slope * (x - x2) - y)\n                Point(x2, y2)\n            }\n        }\n\n        method +(Horizon _) {\n            self\n        }\n\n        method *((0)) {\n            Horizon()\n        }\n\n        method *((1)) {\n            self\n        }\n\n        method *((2)) {\n            var l = (3 * x**2 + A)/(2 * y)\n            var x2 = (l**2 - 2*x)\n            var y2 = (l * (x - x2) - y)\n            Point(x2, y2)\n        }\n\n        method *(Number n) {\n            2*(self * (n>>1)) + self*(n % 2)\n        }\n    }\n\n    class Horizon {\n        method +(Point p) {\n            p\n        }\n    }\n\n    class Number {\n        method +(Point p) {\n            p + self\n        }\n        method *(Point p) {\n            p * self\n        }\n        method *(Horizon h) {\n            h\n        }\n        method -(Point p) {\n            -p + self\n        }\n    }\n}\n\nsay var p = with(1) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var q = with(2) {|v| EC::Point(v, sqrt(abs(1 - v**3 - EC::A*v - EC::B))) }\nsay var s = (p + q)\n\nsay (\"checking alignment:  \", abs((p.x - q.x)*(-s.y - q.y) - (p.y - q.y)*(s.x - q.x)) < 1e-20)\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 425243, "name": "Chebyshev coefficients", "source": "Translate Ruby to Java: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 425244, "name": "Chebyshev coefficients", "source": "Translate Ruby to Java: def mapp(x, min_x, max_x, min_to, max_to)\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\nend\n\ndef chebyshevCoef(func, min, max, coef)\n    n = coef.length\n\n    for i in 0 .. n-1 do\n        m = mapp(Math.cos(Math::PI * (i + 0.5) / n), -1, 1, min, max)\n        f = func.call(m) * 2 / n\n\n        for j in 0 .. n-1 do\n            coef[j] = coef[j] + f * Math.cos(Math::PI * j * (i + 0.5) / n)\n        end\n    end\nend\n\nN = 10\ndef main\n    c = Array.new(N, 0)\n    min = 0\n    max = 1\n    chebyshevCoef(lambda { |x| Math.cos(x) }, min, max, c)\n\n    puts \"Coefficients:\"\n    puts c\nend\n\nmain()\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 425245, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to Java: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 425246, "name": "Burrows\u2013Wheeler transform", "source": "Translate Ruby to Java: STX = \"\\u0002\"\nETX = \"\\u0003\"\n\ndef bwt(s)\n    for c in s.split('')\n        if c == STX or c == ETX then\n            raise ArgumentError.new(\"Input can't contain STX or ETX\")\n        end\n    end\n\n    ss = (\"%s%s%s\" % [STX, s, ETX]).split('')\n    table = []\n    for i in 0 .. ss.length - 1\n        table.append(ss.join)\n        ss = ss.rotate(-1)\n    end\n\n    table = table.sort\n    return table.map{ |e| e[-1] }.join\nend\n\ndef ibwt(r)\n    len = r.length\n    table = [\"\"] * len\n    for i in 0 .. len - 1\n        for j in 0 .. len - 1\n            table[j] = r[j] + table[j]\n        end\n        table = table.sort\n    end\n    for row in table\n        if row[-1] == ETX then\n            return row[1 .. -2]\n        end\n    end\n    return \"\"\nend\n\ndef makePrintable(s)\n    s = s.gsub(STX, \"^\")\n    return s.gsub(ETX, \"|\")\nend\n\ndef main\n    tests = [\n        \"banana\",\n        \"appellee\",\n        \"dogwood\",\n        \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n        \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n        \"\\u0002ABC\\u0003\"\n    ]\n    for test in tests\n        print makePrintable(test), \"\\n\"\n        print \" --> \"\n\n        begin\n            t = bwt(test)\n            print makePrintable(t), \"\\n\"\n\n            r = ibwt(t)\n            print \" --> \", r, \"\\n\\n\"\n        rescue ArgumentError => e\n            print e.message, \"\\n\"\n            print \" -->\\n\\n\"\n        end\n    end\nend\n\nmain()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 425247, "name": "Card shuffles", "source": "Translate Ruby to Java: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class CardShuffles{\n\n\tprivate static final Random rand = new Random();\n\n\tpublic static <T> LinkedList<T> riffleShuffle(List<T> list, int flips){\n\t\tLinkedList<T> newList = new LinkedList<T>();\n\n\t\tnewList.addAll(list);\n\n\t\tfor(int n = 0; n < flips; n++){\n\t\t\t\n\t\t\tint cutPoint = newList.size() / 2 \n\t\t\t\t+ (rand.nextBoolean() ? -1 : 1 ) * rand.nextInt((int)(newList.size() * 0.1));\n\n\t\t\t\n\t\t\tList<T> left = new LinkedList<T>();\n\t\t\tleft.addAll(newList.subList(0, cutPoint));\n\t\t\tList<T> right = new LinkedList<T>();\n\t\t\tright.addAll(newList.subList(cutPoint, newList.size()));\n\n\t\t\tnewList.clear();\n\n\t\t\twhile(left.size() > 0 && right.size() > 0){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble() >= ((double)left.size() / right.size()) / 2){\n\t\t\t\t\tnewList.add(right.remove(0));\n\t\t\t\t}else{\n\t\t\t\t\tnewList.add(left.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(left.size() > 0) newList.addAll(left);\n\t\t\tif(right.size() > 0) newList.addAll(right);\n\t\t}\n\t\treturn newList;\n\t}\n\n\tpublic static <T> LinkedList<T> overhandShuffle(List<T> list, int passes){\n\t\tLinkedList<T> mainHand = new LinkedList<T>();\n\n\t\tmainHand.addAll(list);\n\t\tfor(int n = 0; n < passes; n++){\n\t\t\tLinkedList<T> otherHand = new LinkedList<T>();\n\n\t\t\twhile(mainHand.size() > 0){\n\t\t\t\t\n\t\t\t\tint cutSize = rand.nextInt((int)(list.size() * 0.2)) + 1;\n\n\t\t\t\tLinkedList<T> temp = new LinkedList<T>();\n\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < cutSize && mainHand.size() > 0; i++){\n\t\t\t\t\ttemp.add(mainHand.remove());\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble()  >= 0.1){\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(0, temp);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tmainHand = otherHand;\n\t\t}\t\t\n\t\treturn mainHand;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tList<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tCollections.shuffle(list);\n\t\tSystem.out.println(list + \"\\n\");\n\t}\n}\n"}
{"id": 425248, "name": "Card shuffles", "source": "Translate Ruby to Java: def riffle deck\n  left, right = deck.partition{rand(10).odd?}\n  new_deck    = []\n\n  \n  until ((left_card=left.pop).to_i + (right_card=right.shift).to_i).zero? do\n    new_deck << left_card  if left_card\n    new_deck << right_card if right_card\n  end\n\n  new_deck\nend\n\ndef overhand deck\n  deck, new_deck = deck.dup, []\n  s = deck.size\n  new_deck += deck.pop(rand(s * 0.2)) until deck.empty?\n  new_deck\nend\n\ndef bonus deck\n  deck.sort { |a, b| Time.now.to_i % a <=> Time.now.to_i % b }\nend\n\ndeck = [*1..20]\n\np riffle(deck)\np overhand(deck)\np bonus(deck)\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class CardShuffles{\n\n\tprivate static final Random rand = new Random();\n\n\tpublic static <T> LinkedList<T> riffleShuffle(List<T> list, int flips){\n\t\tLinkedList<T> newList = new LinkedList<T>();\n\n\t\tnewList.addAll(list);\n\n\t\tfor(int n = 0; n < flips; n++){\n\t\t\t\n\t\t\tint cutPoint = newList.size() / 2 \n\t\t\t\t+ (rand.nextBoolean() ? -1 : 1 ) * rand.nextInt((int)(newList.size() * 0.1));\n\n\t\t\t\n\t\t\tList<T> left = new LinkedList<T>();\n\t\t\tleft.addAll(newList.subList(0, cutPoint));\n\t\t\tList<T> right = new LinkedList<T>();\n\t\t\tright.addAll(newList.subList(cutPoint, newList.size()));\n\n\t\t\tnewList.clear();\n\n\t\t\twhile(left.size() > 0 && right.size() > 0){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble() >= ((double)left.size() / right.size()) / 2){\n\t\t\t\t\tnewList.add(right.remove(0));\n\t\t\t\t}else{\n\t\t\t\t\tnewList.add(left.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(left.size() > 0) newList.addAll(left);\n\t\t\tif(right.size() > 0) newList.addAll(right);\n\t\t}\n\t\treturn newList;\n\t}\n\n\tpublic static <T> LinkedList<T> overhandShuffle(List<T> list, int passes){\n\t\tLinkedList<T> mainHand = new LinkedList<T>();\n\n\t\tmainHand.addAll(list);\n\t\tfor(int n = 0; n < passes; n++){\n\t\t\tLinkedList<T> otherHand = new LinkedList<T>();\n\n\t\t\twhile(mainHand.size() > 0){\n\t\t\t\t\n\t\t\t\tint cutSize = rand.nextInt((int)(list.size() * 0.2)) + 1;\n\n\t\t\t\tLinkedList<T> temp = new LinkedList<T>();\n\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < cutSize && mainHand.size() > 0; i++){\n\t\t\t\t\ttemp.add(mainHand.remove());\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble()  >= 0.1){\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(0, temp);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tmainHand = otherHand;\n\t\t}\t\t\n\t\treturn mainHand;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tList<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tCollections.shuffle(list);\n\t\tSystem.out.println(list + \"\\n\");\n\t}\n}\n"}
{"id": 425249, "name": "Faulhaber's triangle", "source": "Translate Ruby to Java: class Frac\n    attr_accessor:num\n    attr_accessor:denom\n\n    def initialize(n,d)\n        if d == 0 then\n            raise ArgumentError.new('d cannot be zero')\n        end\n\n        nn = n\n        dd = d\n        if nn == 0 then\n            dd = 1\n        elsif dd < 0 then\n            nn = -nn\n            dd = -dd\n        end\n\n        g = nn.abs.gcd(dd.abs)\n        if g > 1 then\n            nn = nn / g\n            dd = dd / g\n        end\n\n        @num = nn\n        @denom = dd\n    end\n\n    def to_s\n        if self.denom == 1 then\n            return self.num.to_s\n        else\n            return \"%d/%d\" % [self.num, self.denom]\n        end\n    end\n\n    def -@\n        return Frac.new(-self.num, self.denom)\n    end\n\n    def +(rhs)\n        return Frac.new(self.num * rhs.denom + self.denom * rhs.num, rhs.denom * self.denom)\n    end\n    def -(rhs)\n        return Frac.new(self.num * rhs.denom - self.denom * rhs.num, rhs.denom * self.denom)\n    end\n\n    def *(rhs)\n        return Frac.new(self.num * rhs.num, rhs.denom * self.denom)\n    end\nend\n\nFRAC_ZERO = Frac.new(0, 1)\nFRAC_ONE  = Frac.new(1, 1)\n\ndef bernoulli(n)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n\n    a = Array.new(n + 1)\n    a[0] = FRAC_ZERO\n\n    for m in 0 .. n do\n        a[m] = Frac.new(1, m + 1)\n        m.downto(1) do |j|\n            a[j - 1] = (a[j - 1] - a[j]) * Frac.new(j, 1)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef binomial(n, k)\n    if n < 0 then\n        raise ArgumentError.new('n cannot be negative')\n    end\n    if k < 0 then\n        raise ArgumentError.new('k cannot be negative')\n    end\n    if n < k then\n        raise ArgumentError.new('n cannot be less than k')\n    end\n\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k + 1 .. n do\n        num = num * i\n    end\n\n    den = 1\n    for i in 2 .. n - k do\n        den = den * i\n    end\n\n    return num / den\nend\n\ndef faulhaberTriangle(p)\n    coeffs = Array.new(p + 1)\n    coeffs[0] = FRAC_ZERO\n    q = Frac.new(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -sign\n        coeffs[p - j] = q * Frac.new(sign, 1) * Frac.new(binomial(p + 1, j), 1) * bernoulli(j)\n    end\n    return coeffs\nend\n\ndef main\n    for i in 0 .. 9 do\n        coeffs = faulhaberTriangle(i)\n        coeffs.each do |coeff|\n            print \"%5s  \" % [coeff]\n        end\n        puts\n    end\nend\n\nmain()\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\n\npublic class FaulhabersTriangle {\n    private static final MathContext MC = new MathContext(256);\n\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        public double toDouble() {\n            return (double) num / denom;\n        }\n\n        public BigDecimal toBigDecimal() {\n            return BigDecimal.valueOf(num).divide(BigDecimal.valueOf(denom), MC);\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static long binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        long num = LongStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        long den = LongStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static Frac[] faulhaberTriangle(int p) {\n        Frac[] coeffs = new Frac[p + 1];\n        Arrays.fill(coeffs, Frac.ZERO);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            coeffs[p - j] = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n        }\n        return coeffs;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            Frac[] coeffs = faulhaberTriangle(i);\n            for (Frac coeff : coeffs) {\n                System.out.printf(\"%5s  \", coeff);\n            }\n            System.out.println();\n        }\n        System.out.println();\n        \n        int k = 17;\n        Frac[] cc = faulhaberTriangle(k);\n        int n = 1000;\n        BigDecimal nn = BigDecimal.valueOf(n);\n        BigDecimal np = BigDecimal.ONE;\n        BigDecimal sum = BigDecimal.ZERO;\n        for (Frac c : cc) {\n            np = np.multiply(nn);\n            sum = sum.add(np.multiply(c.toBigDecimal()));\n        }\n        System.out.println(sum.toBigInteger());\n    }\n}\n"}
{"id": 425250, "name": "Paraffins", "source": "Translate Ruby to Java: MAX_N = 500\nBRANCH = 4\n\ndef tree(br, n, l=n, sum=1, cnt=1)\n  for b in br+1 .. BRANCH\n    sum += n\n    return if sum >= MAX_N\n    \n    return if l * 2 >= sum and b >= BRANCH\n    if b == br + 1\n      c = $ra[n] * cnt\n    else\n      c = c * ($ra[n] + (b - br - 1)) / (b - br)\n    end\n    $unrooted[sum] += c if l * 2 < sum\n    next if b >= BRANCH\n    $ra[sum] += c\n    (1...n).each {|m| tree(b, m, l, sum, c)}\n  end\nend\n\ndef bicenter(s)\n  return if s.odd?\n  aux = $ra[s / 2]\n  $unrooted[s] += aux * (aux + 1) / 2\nend\n\n$ra       = [0] * MAX_N\n$unrooted = [0] * MAX_N\n\n$ra[0] = $ra[1] = $unrooted[0] = $unrooted[1] = 1\nfor n in 1...MAX_N\n  tree(0, n)\n  bicenter(n)\n  puts \"%d: %d\" % [n, $unrooted[n]]\nend\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 425251, "name": "Paraffins", "source": "Translate Ruby to Java: MAX_N = 500\nBRANCH = 4\n\ndef tree(br, n, l=n, sum=1, cnt=1)\n  for b in br+1 .. BRANCH\n    sum += n\n    return if sum >= MAX_N\n    \n    return if l * 2 >= sum and b >= BRANCH\n    if b == br + 1\n      c = $ra[n] * cnt\n    else\n      c = c * ($ra[n] + (b - br - 1)) / (b - br)\n    end\n    $unrooted[sum] += c if l * 2 < sum\n    next if b >= BRANCH\n    $ra[sum] += c\n    (1...n).each {|m| tree(b, m, l, sum, c)}\n  end\nend\n\ndef bicenter(s)\n  return if s.odd?\n  aux = $ra[s / 2]\n  $unrooted[s] += aux * (aux + 1) / 2\nend\n\n$ra       = [0] * MAX_N\n$unrooted = [0] * MAX_N\n\n$ra[0] = $ra[1] = $unrooted[0] = $unrooted[1] = 1\nfor n in 1...MAX_N\n  tree(0, n)\n  bicenter(n)\n  puts \"%d: %d\" % [n, $unrooted[n]]\nend\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 425252, "name": "Faulhaber's formula", "source": "Translate Ruby to Java: def binomial(n,k)\n    if n < 0 or k < 0 or n < k then\n        return -1\n    end\n    if n == 0 or k == 0 then\n        return 1\n    end\n\n    num = 1\n    for i in k+1 .. n do\n        num = num * i\n    end\n\n    denom = 1\n    for i in 2 .. n-k do\n        denom = denom * i\n    end\n\n    return num / denom\nend\n\ndef bernoulli(n)\n    if n < 0 then\n        raise \"n cannot be less than zero\"\n    end\n\n    a = Array.new(16)\n    for m in 0 .. n do\n        a[m] = Rational(1, m + 1)\n        for j in m.downto(1) do\n            a[j-1] = (a[j-1] - a[j]) * Rational(j)\n        end\n    end\n\n    if n != 1 then\n        return a[0]\n    end\n    return -a[0]\nend\n\ndef faulhaber(p)\n    print(\"%d\u00a0: \" % [p])\n    q = Rational(1, p + 1)\n    sign = -1\n    for j in 0 .. p do\n        sign = -1 * sign\n        coeff = q * Rational(sign) * Rational(binomial(p+1, j)) * bernoulli(j)\n        if coeff == 0 then\n            next\n        end\n        if j == 0 then\n            if coeff != 1 then\n                if coeff == -1 then\n                    print \"-\"\n                else\n                    print coeff\n                end\n            end\n        else\n            if coeff == 1 then\n                print \" + \"\n            elsif coeff == -1 then\n                print \" - \"\n            elsif 0 < coeff then\n                print \" + \"\n                print coeff\n            else\n                print \" - \"\n                print -coeff\n            end\n        end\n        pwr = p + 1 - j\n        if pwr > 1 then\n            print \"n^%d\" % [pwr]\n        else\n            print \"n\"\n        end\n    end\n    print \"\\n\"\nend\n\ndef main\n    for i in 0 .. 9 do\n        faulhaber(i)\n    end\nend\n\nmain()\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class FaulhabersFormula {\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n        public static final Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        private double toDouble() {\n            return (double) num / denom;\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static int binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        int num = IntStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        int den = IntStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static void faulhaber(int p) {\n        System.out.printf(\"%d\u00a0: \", p);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            Frac coeff = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n            if (Frac.ZERO.equals(coeff)) continue;\n            if (j == 0) {\n                if (!Frac.ONE.equals(coeff)) {\n                    if (Frac.ONE.unaryMinus().equals(coeff)) {\n                        System.out.print(\"-\");\n                    } else {\n                        System.out.print(coeff);\n                    }\n                }\n            } else {\n                if (Frac.ONE.equals(coeff)) {\n                    System.out.print(\" + \");\n                } else if (Frac.ONE.unaryMinus().equals(coeff)) {\n                    System.out.print(\" - \");\n                } else if (coeff.compareTo(Frac.ZERO) > 0) {\n                    System.out.printf(\" + %s\", coeff);\n                } else {\n                    System.out.printf(\" - %s\", coeff.unaryMinus());\n                }\n            }\n            int pwr = p + 1 - j;\n            if (pwr > 1)\n                System.out.printf(\"n^%d\", pwr);\n            else\n                System.out.print(\"n\");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            faulhaber(i);\n        }\n    }\n}\n"}
{"id": 425253, "name": "Active Directory_Search for a user", "source": "Translate Ruby to Java: require 'rubygems'\nrequire 'net/ldap'\n\nldap = Net::LDAP.new(:host => 'hostname', :base => 'base')\nldap.authenticate('bind_dn', 'bind_pass')\n\nfilter = Net::LDAP::Filter.pres('objectclass')\nfilter &= Net::LDAP::Filter.eq('sn','Jackman')\n\nfilter = Net::LDAP::Filter.construct('(&(objectclass=*)(sn=Jackman))')\n\nresults = ldap.search(:filter => filter)  \n\nputs results[0][:sn]  \n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\nimport org.apache.directory.api.ldap.model.cursor.EntryCursor;\nimport org.apache.directory.api.ldap.model.entry.Entry;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.message.SearchScope;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapSearchDemo {\n\n    public static void main(String[] args) throws IOException, LdapException, CursorException {\n        new LdapSearchDemo().demonstrateSearch();\n    }\n\n    private void demonstrateSearch() throws IOException, LdapException, CursorException {\n        try (LdapConnection conn = new LdapNetworkConnection(\"localhost\", 11389)) {\n            conn.bind(\"uid=admin,ou=system\", \"********\");\n            search(conn, \"*mil*\");\n            conn.unBind();\n        }\n    }\n\n    private void search(LdapConnection connection, String uid) throws LdapException, CursorException {\n        String baseDn = \"ou=users,o=mojo\";\n        String filter = \"(&(objectClass=person)(&(uid=\" + uid + \")))\";\n        SearchScope scope = SearchScope.SUBTREE;\n        String[] attributes = {\"dn\", \"cn\", \"sn\", \"uid\"};\n        int ksearch = 0;\n\n        EntryCursor cursor = connection.search(baseDn, filter, scope, attributes);\n        while (cursor.next()) {\n            ksearch++;\n            Entry entry = cursor.get();\n            System.out.printf(\"Search entry %d = %s%n\", ksearch, entry);\n        }\n    }\n}\n"}
{"id": 425254, "name": "Prime conspiracy", "source": "Translate Ruby to Java: require \"prime\"\n\ndef prime_conspiracy(m)\n  conspiracy = Hash.new(0)\n  Prime.take(m).map{|n| n%10}.each_cons(2){|a,b| conspiracy[[a,b]] += 1}\n  puts \"\n  conspiracy.sort.each do |(a,b),v|\n    puts \"%d \u2192 %d count:%10d frequency:%7.4f\u00a0%\" % [a, b, v, 100.0*v/m]\n  end\nend\n\nprime_conspiracy(1_000_000)\n", "target": "public class PrimeConspiracy {\n\n    public static void main(String[] args) {\n        final int limit = 1000_000;\n        final int sieveLimit = 15_500_000;\n\n        int[][] buckets = new int[10][10];\n        int prevDigit = 2;\n        boolean[] notPrime = sieve(sieveLimit);\n\n        for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n            if (notPrime[n])\n                continue;\n\n            int digit = n % 10;\n            buckets[prevDigit][digit]++;\n            prevDigit = digit;\n            primeCount++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (buckets[i][j] != 0) {\n                    System.out.printf(\"%d -> %d\u00a0: %2f%n\", i,\n                            j, buckets[i][j] / (limit / 100.0));\n                }\n            }\n        }\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 425255, "name": "List rooted trees", "source": "Translate Ruby to Java: TREE_LIST = []\nOFFSET = []\n\nfor i in 0..31\n    if i == 1 then\n        OFFSET << 1\n    else\n        OFFSET << 0\n    end\nend\n\ndef append(t)\n    TREE_LIST << (1 | (t << 1))\nend\n\ndef show(t, l)\n    while l > 0\n        l = l - 1\n        if t % 2 == 1 then\n            print '('\n        else\n            print ')'\n        end\n        t = t >> 1\n    end\nend\n\ndef listTrees(n)\n    for i in OFFSET[n] .. OFFSET[n + 1] - 1\n        show(TREE_LIST[i], n * 2)\n        print \"\\n\"\n    end\nend\n\ndef assemble(n, t, sl, pos, rem)\n    if rem == 0 then\n        append(t)\n        return\n    end\n\n    if sl > rem then\n        sl = rem\n        pos = OFFSET[sl]\n    elsif pos >= OFFSET[sl + 1] then\n        sl = sl - 1\n        if sl == 0 then\n            return\n        end\n        pos = OFFSET[sl]\n    end\n\n    assemble(n, t << (2 * sl) | TREE_LIST[pos], sl, pos, rem - sl)\n    assemble(n, t, sl, pos + 1, rem)\nend\n\ndef makeTrees(n)\n    if OFFSET[n + 1] != 0 then\n        return\n    end\n    if n > 0 then\n        makeTrees(n - 1)\n    end\n    assemble(n, 0, n - 1, OFFSET[n - 1], n - 1)\n    OFFSET[n + 1] = TREE_LIST.length()\nend\n\ndef test(n)\n    if n < 1 || n > 12 then\n        raise ArgumentError.new(\"Argument must be between 1 and 12\")\n    end\n\n    append(0)\n\n    makeTrees(n)\n    print \"Number of %d-trees: %d\\n\" % [n, OFFSET[n + 1] - OFFSET[n]]\n    listTrees(n)\nend\n\ntest(5)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListRootedTrees {\n    private static final List<Long> TREE_LIST = new ArrayList<>();\n\n    private static final List<Integer> OFFSET = new ArrayList<>();\n\n    static {\n        for (int i = 0; i < 32; i++) {\n            if (i == 1) {\n                OFFSET.add(1);\n            } else {\n                OFFSET.add(0);\n            }\n        }\n    }\n\n    private static void append(long t) {\n        TREE_LIST.add(1 | (t << 1));\n    }\n\n    private static void show(long t, int l) {\n        while (l-- > 0) {\n            if (t % 2 == 1) {\n                System.out.print('(');\n            } else {\n                System.out.print(')');\n            }\n            t = t >> 1;\n        }\n    }\n\n    private static void listTrees(int n) {\n        for (int i = OFFSET.get(n); i < OFFSET.get(n + 1); i++) {\n            show(TREE_LIST.get(i), n * 2);\n            System.out.println();\n        }\n    }\n\n    private static void assemble(int n, long t, int sl, int pos, int rem) {\n        if (rem == 0) {\n            append(t);\n            return;\n        }\n\n        var pp = pos;\n        var ss = sl;\n\n        if (sl > rem) {\n            ss = rem;\n            pp = OFFSET.get(ss);\n        } else if (pp >= OFFSET.get(ss + 1)) {\n            ss--;\n            if (ss == 0) {\n                return;\n            }\n            pp = OFFSET.get(ss);\n        }\n\n        assemble(n, t << (2 * ss) | TREE_LIST.get(pp), ss, pp, rem - ss);\n        assemble(n, t, ss, pp + 1, rem);\n    }\n\n    private static void makeTrees(int n) {\n        if (OFFSET.get(n + 1) != 0) {\n            return;\n        }\n        if (n > 0) {\n            makeTrees(n - 1);\n        }\n        assemble(n, 0, n - 1, OFFSET.get(n - 1), n - 1);\n        OFFSET.set(n + 1, TREE_LIST.size());\n    }\n\n    private static void test(int n) {\n        if (n < 1 || n > 12) {\n            throw new IllegalArgumentException(\"Argument must be between 1 and 12\");\n        }\n\n        append(0);\n\n        makeTrees(n);\n        System.out.printf(\"Number of %d-trees: %d\\n\", n, OFFSET.get(n + 1) - OFFSET.get(n));\n        listTrees(n);\n    }\n\n    public static void main(String[] args) {\n        test(5);\n    }\n}\n"}
{"id": 425256, "name": "Lucky and even lucky numbers", "source": "Translate Ruby to Java: def generator(even=false, nmax=1000000)\n  start = even ? 2 : 1\n  Enumerator.new do |y|\n    n = 1\n    ary = [0] + (start..nmax).step(2).to_a      \n    y << ary[n]\n    while (m = ary[n+=1]) < ary.size\n      y << m\n      (m...ary.size).step(m){|i| ary[i]=nil}\n      ary.compact!                              \n    end\n    \n    ary[n..-1].each{|i| y << i}\n    raise StopIteration\n  end\nend\n\ndef lucky(argv)\n  j, k = argv[0].to_i, argv[1].to_i\n  mode = /even/i=~argv[2] ? :'even lucky' : :lucky\n  seq = generator(mode == :'even lucky')\n  ord = ->(n){\"\n  if k.zero?\n    puts \"\n  elsif 0 < k\n    puts \"\n         \"  \n  else\n    k = -k\n    ary = []\n    loop do\n      case num=seq.next\n      when 1...j\n      when j..k  then ary << num\n      else break\n      end\n    end\n    puts \"all \n         \"  \n  end\nend\n\nif __FILE__ == $0\n  lucky(ARGV)\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class LuckyNumbers {\n\n    private static int MAX = 200000;\n    private static List<Integer> luckyEven = luckyNumbers(MAX, true);\n    private static List<Integer> luckyOdd = luckyNumbers(MAX, false);\n    \n    public static void main(String[] args) {\n        \n        if ( args.length == 1 || ( args.length == 2 && args[1].compareTo(\"lucky\") == 0 ) ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"LuckyNumber(%d) = %d%n\", n, luckyOdd.get(n-1));\n        }\n        \n        else if ( args.length == 2 && args[1].compareTo(\"evenLucky\") == 0 ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"EvenLuckyNumber(%d) = %d%n\", n, luckyEven.get(n-1));            \n        }\n        \n        else if ( args.length == 2 || args.length == 3 ) {\n            int j = Integer.parseInt(args[0]);\n            int k = Integer.parseInt(args[1]);\n            \n            if ( ( args.length == 2 && k > 0 ) || (args.length == 3 && k > 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                System.out.printf(\"LuckyNumber(%d) through LuckyNumber(%d) = %s%n\", j, k, luckyOdd.subList(j-1, k));\n            }\n            \n            else if ( args.length == 3 && k > 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                System.out.printf(\"EvenLuckyNumber(%d) through EvenLuckyNumber(%d) = %s%n\", j, k, luckyEven.subList(j-1, k));\n            }\n            \n            else if ( ( args.length == 2 && k < 0 ) || (args.length == 3 && k < 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                int n = Collections.binarySearch(luckyOdd, j);\n                int m = Collections.binarySearch(luckyOdd, -k);\n                System.out.printf(\"Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyOdd.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n            \n            else if ( args.length == 3 && k < 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                int n = Collections.binarySearch(luckyEven, j);\n                int m = Collections.binarySearch(luckyEven, -k);\n                System.out.printf(\"Even Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyEven.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n        }\n    }\n    \n    private static List<Integer> luckyNumbers(int max, boolean even) {\n        List<Integer> luckyList = new ArrayList<>();\n        for ( int i = even ? 2 : 1 ; i <= max ; i += 2 ) {\n            luckyList.add(i);\n        }\n        int start = 1;\n        boolean removed = true;\n        while ( removed ) {\n            removed = false;\n            int increment = luckyList.get(start);\n            List<Integer> remove = new ArrayList<>();\n            for ( int i = increment-1 ; i < luckyList.size() ; i += increment ) {\n                remove.add(0, i);\n                removed = true;\n            }\n            for ( int i : remove ) {\n                luckyList.remove(i);\n            }\n            start++;\n        }\n        return luckyList;\n    }\n\n}\n"}
{"id": 425257, "name": "Imaginary base numbers", "source": "Translate Ruby to Java: \n\ndef base2i_decode(qi)\n  return 0 if qi == '0'\n  md = qi.match(/^(?<int>[0-3]+)(?:\\.(?<frc>[0-3]+))?$/)\n  raise 'ill-formed quarter-imaginary base value' if !md\n  ls_pow = md[:frc] ? -(md[:frc].length) : 0\n  value = 0\n  (md[:int] + (md[:frc] ? md[:frc] : '')).reverse.each_char.with_index do |dig, inx|\n    value += dig.to_i * (2i)**(inx + ls_pow)\n  end\n  return value\nend\n\n\n\ndef base2i_encode(gi)\n  odd = gi.imag.to_i.odd?\n  frac = (gi.imag.to_i != 0)\n  real = gi.real.to_i\n  imag = (gi.imag.to_i + 1) / 2\n  value = ''\n  phase_real = true\n  while (real != 0) || (imag != 0)\n    if phase_real\n      real, rem = real.divmod(4)\n      real = -real\n    else\n      imag, rem = imag.divmod(4)\n      imag = -imag\n    end\n    value.prepend(rem.to_s)\n    phase_real = !phase_real\n  end\n  value = '0' if value == ''\n  value.concat(odd ? '.2' : '.0') if frac\n  return value\nend\n", "target": "public class ImaginaryBaseNumber {\n    private static class Complex {\n        private Double real, imag;\n\n        public Complex(double r, double i) {\n            this.real = r;\n            this.imag = i;\n        }\n\n        public Complex(int r, int i) {\n            this.real = (double) r;\n            this.imag = (double) i;\n        }\n\n        public Complex add(Complex rhs) {\n            return new Complex(\n                real + rhs.real,\n                imag + rhs.imag\n            );\n        }\n\n        public Complex times(Complex rhs) {\n            return new Complex(\n                real * rhs.real - imag * rhs.imag,\n                real * rhs.imag + imag * rhs.real\n            );\n        }\n\n        public Complex times(double rhs) {\n            return new Complex(\n                real * rhs,\n                imag * rhs\n            );\n        }\n\n        public Complex inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(\n                real / denom,\n                -imag / denom\n            );\n        }\n\n        public Complex unaryMinus() {\n            return new Complex(-real, -imag);\n        }\n\n        public Complex divide(Complex rhs) {\n            return this.times(rhs.inv());\n        }\n\n        \n        public QuaterImaginary toQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = real.intValue();\n            int im = imag.intValue();\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem += 4;\n                    re++;\n                }\n                sb.append(rem);\n                sb.append(0);\n            }\n            if (im != 0) {\n                Double f = new Complex(0.0, imag).divide(new Complex(0.0, 2.0)).real;\n                im = ((Double) Math.ceil(f)).intValue();\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem += 4;\n                        im++;\n                    }\n                    if (index < sb.length()) {\n                        sb.setCharAt(index, (char) (rem + 48));\n                    } else {\n                        sb.append(0);\n                        sb.append(rem);\n                    }\n                    index += 2;\n                }\n                fi = f.intValue();\n            }\n            sb.reverse();\n            if (fi != -1) sb.append(\".\").append(fi);\n            while (sb.charAt(0) == '0') sb.deleteCharAt(0);\n            if (sb.charAt(0) == '.') sb.insert(0, '0');\n            return new QuaterImaginary(sb.toString());\n        }\n\n        @Override\n        public String toString() {\n            double real2 = real == -0.0 ? 0.0 : real;  \n            double imag2 = imag == -0.0 ? 0.0 : imag;  \n            String result = imag2 >= 0.0 ? String.format(\"%.0f +\u00a0%.0fi\", real2, imag2) : String.format(\"%.0f -\u00a0%.0fi\", real2, -imag2);\n            result = result.replace(\".0 \", \" \").replace(\".0i\", \"i\").replace(\" + 0i\", \"\");\n            if (result.startsWith(\"0 + \")) result = result.substring(4);\n            if (result.startsWith(\"0 - \")) result = result.substring(4);\n            return result;\n        }\n    }\n\n    private static class QuaterImaginary {\n        private static final Complex TWOI = new Complex(0.0, 2.0);\n        private static final Complex INVTWOI = TWOI.inv();\n\n        private String b2i;\n\n        public QuaterImaginary(String b2i) {\n            if (b2i.equals(\"\") || !b2i.chars().allMatch(c -> \"0123.\".indexOf(c) > -1) || b2i.chars().filter(c -> c == '.').count() > 1) {\n                throw new RuntimeException(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex toComplex() {\n            int pointPos = b2i.indexOf(\".\");\n            int posLen = pointPos != -1 ? pointPos : b2i.length();\n            Complex sum = new Complex(0, 0);\n            Complex prod = new Complex(1, 0);\n\n            for (int j = 0; j < posLen; ++j) {\n                double k = b2i.charAt(posLen - 1 - j) - '0';\n                if (k > 0.0) sum = sum.add(prod.times(k));\n                prod = prod.times(TWOI);\n            }\n            if (pointPos != -1) {\n                prod = INVTWOI;\n                for (int j = posLen + 1; j < b2i.length(); ++j) {\n                    double k = b2i.charAt(j) - '0';\n                    if (k > 0.0) sum = sum.add(prod.times(k));\n                    prod = prod.times(INVTWOI);\n                }\n            }\n\n            return sum;\n        }\n\n        @Override\n        public String toString() {\n            return b2i;\n        }\n    }\n\n    public static void main(String[] args) {\n        String fmt = \"%4s -> %8s -> %4s\";\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(i, 0);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n        System.out.println();\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(0, i);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425258, "name": "Statistics_Normal distribution", "source": "Translate Ruby to Java: \n\n\nclass NormalFromUniform\n  \n  def initialize()\n    @next = nil\n  end\n  \n  def rand()\n    if @next\n      retval, @next = @next, nil\n      return retval\n    else\n      u = v = s = nil\n      loop do\n        u = Random.rand(-1.0..1.0)\n        v = Random.rand(-1.0..1.0)\n        s = u**2 + v**2\n        break if (s > 0.0) && (s <= 1.0)\n      end\n      f = Math.sqrt(-2.0 * Math.log(s) / s)\n      @next = v * f\n      return u * f\n    end\n  end\nend\n", "target": "import static java.lang.Math.*;\nimport static java.util.Arrays.stream;\nimport java.util.Locale;\nimport java.util.function.DoubleSupplier;\nimport static java.util.stream.Collectors.joining;\nimport java.util.stream.DoubleStream;\nimport static java.util.stream.IntStream.range;\n\npublic class Test implements DoubleSupplier {\n\n    private double mu, sigma;\n    private double[] state = new double[2];\n    private int index = state.length;\n\n    Test(double m, double s) {\n        mu = m;\n        sigma = s;\n    }\n\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    @Override\n    public double getAsDouble() {\n        index++;\n        if (index >= state.length) {\n            double r = sqrt(-2 * log(random())) * sigma;\n            double x = 2 * PI * random();\n            state = new double[]{mu + r * sin(x), mu + r * cos(x)};\n            index = 0;\n        }\n        return state[index];\n\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.US);\n        double[] data = DoubleStream.generate(new Test(0.0, 0.5)).limit(100_000)\n                .toArray();\n\n        double[] res = meanStdDev(data);\n        System.out.printf(\"Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n\n        showHistogram01(stream(data).map(a -> max(0.0, min(0.9999, a / 3 + 0.5)))\n                .toArray());\n    }\n}\n"}
{"id": 425259, "name": "Vogel's approximation method", "source": "Translate Ruby to Java: \n\n\n\nCOSTS  = {W: {A: 16, B: 16, C: 13, D: 22, E: 17},\n          X: {A: 14, B: 14, C: 13, D: 19, E: 15},\n          Y: {A: 19, B: 19, C: 20, D: 23, E: 50},\n          Z: {A: 50, B: 12, C: 50, D: 15, E: 11}}\ndemand = {A: 30, B: 20, C: 70, D: 30, E: 60}\nsupply = {W: 50, X: 60, Y: 50, Z: 50}\nCOLS = demand.keys\nres = {}; COSTS.each_key{|k| res[k] = Hash.new(0)}\ng = {}; supply.each_key{|x| g[x] = COSTS[x].keys.sort_by{|g| COSTS[x][g]}}\n        demand.each_key{|x| g[x] = COSTS.keys.sort_by{|g| COSTS[g][x]}}\n\nuntil g.empty? \n  d = demand.collect{|x,y| [x, z = COSTS[g[x][0]][x], g[x][1] ? COSTS[g[x][1]][x] - z : z]}\n  dmax = d.max_by{|n| n[2]}\n  d = d.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}\n  s = supply.collect{|x,y| [x, z = COSTS[x][g[x][0]], g[x][1] ? COSTS[x][g[x][1]] - z : z]}\n  dmax = s.max_by{|n| n[2]}\n  s = s.select{|x| x[2] == dmax[2]}.min_by{|n| n[1]}\n  t,f = d[2]==s[2] ? [s[1], d[1]] : [d[2],s[2]] \n  d,s = t > f ? [d[0],g[d[0]][0]] : [g[s[0]][0],s[0]]\n  v = [supply[s], demand[d]].min\n  res[s][d] += v\n  demand[d] -= v\n  if demand[d] == 0 then\n    supply.reject{|k, n| n == 0}.each_key{|x| g[x].delete(d)}\n    g.delete(d)\n    demand.delete(d)\n  end\n  supply[s] -= v\n  if supply[s] == 0 then\n    demand.reject{|k, n| n == 0}.each_key{|x| g[x].delete(s)}\n    g.delete(s)\n    supply.delete(s)\n  end\nend\n\nCOLS.each{|n| print \"\\t\", n}\nputs\ncost = 0\nCOSTS.each_key do |g|\n  print g, \"\\t\"\n  COLS.each do |n|\n    y = res[g][n]\n    print y if y != 0\n    cost += y * COSTS[g][n]\n    print \"\\t\"\n  end\n  puts\nend\nprint \"\\n\\nTotal Cost = \", cost\n", "target": "import java.util.Arrays;\nimport static java.util.Arrays.stream;\nimport java.util.concurrent.*;\n\npublic class VogelsApproximationMethod {\n\n    final static int[] demand = {30, 20, 70, 30, 60};\n    final static int[] supply = {50, 60, 50, 50};\n    final static int[][] costs = {{16, 16, 13, 22, 17}, {14, 14, 13, 19, 15},\n    {19, 19, 20, 23, 50}, {50, 12, 50, 15, 11}};\n\n    final static int nRows = supply.length;\n    final static int nCols = demand.length;\n\n    static boolean[] rowDone = new boolean[nRows];\n    static boolean[] colDone = new boolean[nCols];\n    static int[][] result = new int[nRows][nCols];\n\n    static ExecutorService es = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) throws Exception {\n        int supplyLeft = stream(supply).sum();\n        int totalCost = 0;\n\n        while (supplyLeft > 0) {\n            int[] cell = nextCell();\n            int r = cell[0];\n            int c = cell[1];\n\n            int quantity = Math.min(demand[c], supply[r]);\n            demand[c] -= quantity;\n            if (demand[c] == 0)\n                colDone[c] = true;\n\n            supply[r] -= quantity;\n            if (supply[r] == 0)\n                rowDone[r] = true;\n\n            result[r][c] = quantity;\n            supplyLeft -= quantity;\n\n            totalCost += quantity * costs[r][c];\n        }\n\n        stream(result).forEach(a -> System.out.println(Arrays.toString(a)));\n        System.out.println(\"Total cost: \" + totalCost);\n\n        es.shutdown();\n    }\n\n    static int[] nextCell() throws Exception {\n        Future<int[]> f1 = es.submit(() -> maxPenalty(nRows, nCols, true));\n        Future<int[]> f2 = es.submit(() -> maxPenalty(nCols, nRows, false));\n\n        int[] res1 = f1.get();\n        int[] res2 = f2.get();\n\n        if (res1[3] == res2[3])\n            return res1[2] < res2[2] ? res1 : res2;\n\n        return (res1[3] > res2[3]) ? res2 : res1;\n    }\n\n    static int[] diff(int j, int len, boolean isRow) {\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n        int minP = -1;\n        for (int i = 0; i < len; i++) {\n            if (isRow ? colDone[i] : rowDone[i])\n                continue;\n            int c = isRow ? costs[j][i] : costs[i][j];\n            if (c < min1) {\n                min2 = min1;\n                min1 = c;\n                minP = i;\n            } else if (c < min2)\n                min2 = c;\n        }\n        return new int[]{min2 - min1, min1, minP};\n    }\n\n    static int[] maxPenalty(int len1, int len2, boolean isRow) {\n        int md = Integer.MIN_VALUE;\n        int pc = -1, pm = -1, mc = -1;\n        for (int i = 0; i < len1; i++) {\n            if (isRow ? rowDone[i] : colDone[i])\n                continue;\n            int[] res = diff(i, len2, isRow);\n            if (res[0] > md) {\n                md = res[0];  \n                pm = i;       \n                mc = res[1];  \n                pc = res[2];  \n            }\n        }\n        return isRow ? new int[]{pm, pc, mc, md} : new int[]{pc, pm, mc, md};\n    }\n}\n"}
{"id": 425260, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Ruby to Java: def mod(m, n)\n    result = m % n\n    if result < 0 then\n        result = result + n\n    end\n    return result\nend\n\ndef getA004290(n)\n    if n == 1 then\n        return 1\n    end\n    arr = Array.new(n) { Array.new(n, 0) }\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while true\n        m = m + 1\n        if arr[m - 1][mod(-10 ** m, n)] == 1 then\n            break\n        end\n        arr[m][0] = 1\n        for k in 1 .. n - 1\n            arr[m][k] = [arr[m - 1][k], arr[m - 1][mod(k - 10 ** m, n)]].max\n        end\n    end\n    r = 10 ** m\n    k = mod(-r, n)\n    (m - 1).downto(1) { |j|\n        if arr[j - 1][k] == 0 then\n            r = r + 10 ** j\n            k = mod(k - 10 ** j, n)\n        end\n    }\n    if k == 1 then\n        r = r + 1\n    end\n    return r\nend\n\ntestCases = Array(1 .. 10)\ntestCases.concat(Array(95 .. 105))\ntestCases.concat([297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878])\nfor n in testCases\n    result = getA004290(n)\n    print \"A004290(%d) = %d = %d * %d\\n\" % [n, result, n, result / n]\nend\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class MinimumNumberOnlyZeroAndOne {\n\n    public static void main(String[] args) {\n        for ( int n : getTestCases() ) {\n            BigInteger result = getA004290(n);\n            System.out.printf(\"A004290(%d) = %s = %s * %s%n\", n, result, n, result.divide(BigInteger.valueOf(n)));\n        }\n    }\n    \n    private static List<Integer> getTestCases() {\n        List<Integer> testCases = new ArrayList<>();\n        for ( int i = 1 ; i <= 10 ; i++ ) {\n            testCases.add(i);\n        }\n        for ( int i = 95 ; i <= 105 ; i++ ) {\n            testCases.add(i);\n        }\n        for (int i : new int[] {297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878} ) {\n            testCases.add(i);\n        }\n        return testCases;\n    }\n    \n    private static BigInteger getA004290(int n) {\n        if ( n == 1 ) {\n            return BigInteger.valueOf(1);\n        }\n        int[][] L = new int[n][n];\n        for ( int i = 2 ; i < n ; i++ ) {\n            L[0][i] = 0;\n        }\n        L[0][0] = 1;\n        L[0][1] = 1;\n        int m = 0;\n        BigInteger ten = BigInteger.valueOf(10);\n        BigInteger nBi = BigInteger.valueOf(n);\n        while ( true ) {\n            m++;\n            \n            if ( L[m-1][mod(ten.pow(m).negate(), nBi).intValue()] == 1 ) {\n                break;\n            }\n            L[m][0] = 1;\n            for ( int k = 1 ; k < n ; k++ ) {\n                \n                L[m][k] = Math.max(L[m-1][k], L[m-1][mod(BigInteger.valueOf(k).subtract(ten.pow(m)), nBi).intValue()]);\n            }\n            \n        }\n        \n        \n        BigInteger r = ten.pow(m);\n        BigInteger k = mod(r.negate(), nBi);\n        for ( int j = m-1 ; j >= 1 ; j-- ) {\n            if ( L[j-1][k.intValue()] == 0 ) {\n                \n                \n                r = r.add(ten.pow(j));\n                k = mod(k.subtract(ten.pow(j)), nBi);\n            }\n        }\n        if ( k.compareTo(BigInteger.ONE) == 0 ) {\n            r = r.add(BigInteger.ONE);\n        }\n        return r;\n    }\n\n    private static BigInteger mod(BigInteger m, BigInteger n) {\n        BigInteger result = m.mod(n);\n        if ( result.compareTo(BigInteger.ZERO) < 0 ) {\n            result = result.add(n);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int mod(int m, int n) {\n        int result = m % n;\n        if ( result < 0 ) {\n            result += n;\n        }\n        return result;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int pow(int base, int exp) {\n        return (int) Math.pow(base, exp);\n    }\n}\n"}
{"id": 425261, "name": "Magic squares of singly even order", "source": "Translate Ruby to Java: def odd_magic_square(n)\n  n.times.map{|i| n.times.map{|j| n*((i+j+1+n/2)%n) + ((i+2*j-5)%n) + 1} }\nend\n\ndef single_even_magic_square(n) \n  raise ArgumentError, \"must be even, but not divisible by 4.\" unless (n-2) % 4 == 0\n  raise ArgumentError, \"2x2 magic square not possible.\" if n == 2\n\n  order = (n-2)/4\n  odd_square = odd_magic_square(n/2)\n  to_add = (0..3).map{|f| f*n*n/4}\n  quarts = to_add.map{|f| odd_square.dup.map{|row|row.map{|el| el+f}} }\n\n  sq = []\n  quarts[0].zip(quarts[2]){|d1,d2| sq << [d1,d2].flatten}\n  quarts[3].zip(quarts[1]){|d1,d2| sq << [d1,d2].flatten}\n\n  sq = sq.transpose\n  order.times{|i| sq[i].rotate!(n/2)}\n  swap(sq[0][order], sq[0][-order-1])\n  swap(sq[order][order], sq[order][-order-1])\n  (order-1).times{|i| sq[-(i+1)].rotate!(n/2)}\n  randomize(sq)\nend\n\ndef swap(a,b)\n  a,b = b,a\nend\n\ndef randomize(square)\n  square.shuffle.transpose.shuffle\nend\n\ndef to_string(square)\n  n = square.size\n  fmt = \"%\n  square.inject(\"\"){|str,row| str << fmt % row << \"\\n\"}\nend\n\nputs to_string(single_even_magic_square(6))\n", "target": "public class MagicSquareSinglyEven {\n\n    public static void main(String[] args) {\n        int n = 6;\n        for (int[] row : magicSquareSinglyEven(n)) {\n            for (int x : row)\n                System.out.printf(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int n) {\n        if (n < 3 || n % 2 == 0)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int value = 0;\n        int gridSize = n * n;\n        int c = n / 2, r = 0;\n\n        int[][] result = new int[n][n];\n\n        while (++value <= gridSize) {\n            result[r][c] = value;\n            if (r == 0) {\n                if (c == n - 1) {\n                    r++;\n                } else {\n                    r = n - 1;\n                    c++;\n                }\n            } else if (c == n - 1) {\n                r--;\n                c = 0;\n            } else if (result[r - 1][c + 1] == 0) {\n                r--;\n                c++;\n            } else {\n                r++;\n            }\n        }\n        return result;\n    }\n\n    static int[][] magicSquareSinglyEven(final int n) {\n        if (n < 6 || (n - 2) % 4 != 0)\n            throw new IllegalArgumentException(\"base must be a positive \"\n                    + \"multiple of 4 plus 2\");\n\n        int size = n * n;\n        int halfN = n / 2;\n        int subSquareSize = size / 4;\n\n        int[][] subSquare = magicSquareOdd(halfN);\n        int[] quadrantFactors = {0, 2, 3, 1};\n        int[][] result = new int[n][n];\n\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                int quadrant = (r / halfN) * 2 + (c / halfN);\n                result[r][c] = subSquare[r % halfN][c % halfN];\n                result[r][c] += quadrantFactors[quadrant] * subSquareSize;\n            }\n        }\n\n        int nColsLeft = halfN / 2;\n        int nColsRight = nColsLeft - 1;\n\n        for (int r = 0; r < halfN; r++)\n            for (int c = 0; c < n; c++) {\n                if (c < nColsLeft || c >= n - nColsRight\n                        || (c == nColsLeft && r == nColsLeft)) {\n\n                    if (c == 0 && r == nColsLeft)\n                        continue;\n\n                    int tmp = result[r][c];\n                    result[r][c] = result[r + halfN][c];\n                    result[r + halfN][c] = tmp;\n                }\n            }\n\n        return result;\n    }\n}\n"}
{"id": 425262, "name": "Weird numbers", "source": "Translate Ruby to Java: def divisors(n : Int32) : Array(Int32)\n  divs = [1]\n  divs2 = [] of Int32\n\n  i = 2\n  while i * i < n\n    if n % i == 0\n      j = n // i\n      divs << i\n      divs2 << j if i != j\n    end\n\n    i += 1\n  end\n\n  i = divs.size - 1\n\n  \n  while i >= 0\n    divs2 << divs[i]\n    i -= 1\n  end\n\n  divs2\nend\n\ndef abundant(n : Int32, divs : Array(Int32)) : Bool\n  divs.sum > n\nend\n\ndef semiperfect(n : Int32, divs : Array(Int32)) : Bool\n  if divs.size > 0\n    h = divs[0]\n    t = divs[1..]\n\n    return n < h ? semiperfect(n, t) : n == h || semiperfect(n - h, t) || semiperfect(n, t)\n  end\n\n  return false\nend\n\ndef sieve(limit : Int32) : Array(Bool)\n  \n  \n\n  w = Array(Bool).new(limit, false) \n\n  i = 2\n  while i < limit\n    if !w[i]\n      divs = divisors i\n\n      if !abundant(i, divs)\n        w[i] = true\n      elsif semiperfect(i, divs)\n        j = i\n        while j < limit\n          w[j] = true\n          j += i\n        end\n      end\n    end\n\n    i += 2\n  end\n\n  w\nend\n\ndef main\n  w = sieve 17000\n  count = 0\n  max = 25\n\n  print \"The first 25 weird numbers are: \"\n\n  n = 2\n  while count < max\n    if !w[n]\n      print \"\n      count += 1\n    end\n\n    n += 2\n  end\n\n  puts \"\\n\"\nend\n\nrequire \"benchmark\"\nputs Benchmark.measure { main }\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WeirdNumbers {\n\n    public static void main(String[] args) {\n        int n = 2;\n        \n        for ( int count = 1 ; count <= 25 ; n += 2 ) {\n            if ( isWeird(n) ) {\n                System.out.printf(\"w(%d) = %d%n\", count, n);\n                count++;\n            }\n        }\n    }\n    \n    private static boolean isWeird(int n) {\n        List<Integer> properDivisors = getProperDivisors(n);\n        return isAbundant(properDivisors, n) && ! isSemiPerfect(properDivisors, n);\n    }\n    \n    private static boolean isAbundant(List<Integer> divisors, int n) {\n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        return divisorSum > n;\n    }\n    \n    \n    private static boolean isSemiPerfect(List<Integer> divisors, int sum) {\n        int size = divisors.size();\n        \n        \n        boolean subset[][] = new boolean[sum+1][size+1];\n\n        \n        for (int i = 0; i <= size; i++) {\n            subset[0][i] = true; \n        }\n        \n        \n        for (int i = 1; i <= sum; i++) {\n            subset[i][0] = false; \n        }\n        \n        \n        for ( int i = 1 ; i <= sum ; i++ ) {\n            for ( int j = 1 ; j <= size ; j++ ) {\n                subset[i][j] = subset[i][j-1];\n                int test = divisors.get(j-1);\n                if ( i >= test ) {\n                    subset[i][j] = subset[i][j] || subset[i - test][j-1]; \n                }\n            } \n        } \n\n        return subset[sum][size];\n    }\n\n    private static final List<Integer> getProperDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i && div != number ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 425263, "name": "ASCII art diagram converter", "source": "Translate Ruby to Java: header = <<HEADER\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                      ID                       |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    QDCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ANCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    NSCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|                    ARCOUNT                    |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nHEADER\n\nItem = Struct.new(:name, :bits, :range)\nRE = /\\| *\\w+ */\n\ni = 0\ntable = header.scan(RE).map{|m| Item.new( m.delete(\"^A-Za-z\"), b = m.size/3, i...(i += b)) }\n\nteststr = \"78477bbf5496e12e1bf169a4\"\npadding = table.sum(&:bits)\nbinstr  = teststr.hex.to_s(2).rjust(padding, \"0\")\n\ntable.each{|el| p el.values}; puts\ntable.each{|el| puts \"%7s, %2d bits: %s\" % [el.name, el.bits, binstr[el.range] ]}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        \n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                \n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                \n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                \n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                \n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        \n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n"}
{"id": 425264, "name": "Peaceful chess queen armies", "source": "Translate Ruby to Java: class Position\n    attr_reader :x, :y\n\n    def initialize(x, y)\n        @x = x\n        @y = y\n    end\n\n    def ==(other)\n        self.x == other.x &&\n        self.y == other.y\n    end\n\n    def to_s\n        '(%d, %d)' % [@x, @y]\n    end\n\n    def to_str\n        to_s\n    end\nend\n\ndef isAttacking(queen, pos)\n    return queen.x == pos.x ||\n           queen.y == pos.y ||\n           (queen.x - pos.x).abs() == (queen.y - pos.y).abs()\nend\n\ndef place(m, n, blackQueens, whiteQueens)\n    if m == 0 then\n        return true\n    end\n    placingBlack = true\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            catch :inner do\n                pos = Position.new(i, j)\n                for queen in blackQueens\n                    if pos == queen || !placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                for queen in whiteQueens\n                    if pos == queen || placingBlack && isAttacking(queen, pos) then\n                        throw :inner\n                    end\n                end\n                if placingBlack then\n                    blackQueens << pos\n                    placingBlack = false\n                else\n                    whiteQueens << pos\n                    if place(m - 1, n, blackQueens, whiteQueens) then\n                        return true\n                    end\n                    blackQueens.pop\n                    whiteQueens.pop\n                    placingBlack = true\n                end\n            end\n        end\n    end\n    if !placingBlack then\n        blackQueens.pop\n    end\n    return false\nend\n\ndef printBoard(n, blackQueens, whiteQueens)\n    \n    board = Array.new(n) { Array.new(n) { ' ' } }\n    for i in 0 .. n-1\n        for j in 0 .. n-1\n            if i % 2 == j % 2 then\n                board[i][j] = '\u2022'\n            else\n                board[i][j] = '\u25e6'\n            end\n        end\n    end\n\n    \n    for queen in blackQueens\n        board[queen.y][queen.x] = 'B'\n    end\n    for queen in whiteQueens\n        board[queen.y][queen.x] = 'W'\n    end\n\n    \n    for row in board\n        for cell in row\n            print cell, ' '\n        end\n        print \"\\n\"\n    end\n    print \"\\n\"\nend\n\nnms = [\n    [2, 1],\n    [3, 1], [3, 2],\n    [4, 1], [4, 2], [4, 3],\n    [5, 1], [5, 2], [5, 3], [5, 4], [5, 5],\n    [6, 1], [6, 2], [6, 3], [6, 4], [6, 5], [6, 6],\n    [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6], [7, 7]\n]\nfor nm in nms\n    m = nm[1]\n    n = nm[0]\n    print \"%d black and %d white queens on a %d x %d board:\\n\" % [m, m, n, n]\n\n    blackQueens = []\n    whiteQueens = []\n    if place(m, n, blackQueens, whiteQueens) then\n        printBoard(n, blackQueens, whiteQueens)\n    else\n        print \"No solution exists.\\n\\n\"\n    end\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Peaceful {\n    enum Piece {\n        Empty,\n        Black,\n        White,\n    }\n\n    public static class Position {\n        public int x, y;\n\n        public Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Position) {\n                Position pos = (Position) obj;\n                return pos.x == x && pos.y == y;\n            }\n            return false;\n        }\n    }\n\n    private static boolean place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n        if (m == 0) {\n            return true;\n        }\n        boolean placingBlack = true;\n        for (int i = 0; i < n; ++i) {\n            inner:\n            for (int j = 0; j < n; ++j) {\n                Position pos = new Position(i, j);\n                for (Position queen : pBlackQueens) {\n                    if (pos.equals(queen) || !placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                for (Position queen : pWhiteQueens) {\n                    if (pos.equals(queen) || placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                if (placingBlack) {\n                    pBlackQueens.add(pos);\n                    placingBlack = false;\n                } else {\n                    pWhiteQueens.add(pos);\n                    if (place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                        return true;\n                    }\n                    pBlackQueens.remove(pBlackQueens.size() - 1);\n                    pWhiteQueens.remove(pWhiteQueens.size() - 1);\n                    placingBlack = true;\n                }\n            }\n        }\n        if (!placingBlack) {\n            pBlackQueens.remove(pBlackQueens.size() - 1);\n        }\n        return false;\n    }\n\n    private static boolean isAttacking(Position queen, Position pos) {\n        return queen.x == pos.x\n            || queen.y == pos.y\n            || Math.abs(queen.x - pos.x) == Math.abs(queen.y - pos.y);\n    }\n\n    private static void printBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n        Piece[] board = new Piece[n * n];\n        Arrays.fill(board, Piece.Empty);\n\n        for (Position queen : blackQueens) {\n            board[queen.x + n * queen.y] = Piece.Black;\n        }\n        for (Position queen : whiteQueens) {\n            board[queen.x + n * queen.y] = Piece.White;\n        }\n        for (int i = 0; i < board.length; ++i) {\n            if ((i != 0) && i % n == 0) {\n                System.out.println();\n            }\n\n            Piece b = board[i];\n            if (b == Piece.Black) {\n                System.out.print(\"B \");\n            } else if (b == Piece.White) {\n                System.out.print(\"W \");\n            } else {\n                int j = i / n;\n                int k = i - j * n;\n                if (j % 2 == k % 2) {\n                    System.out.print(\"\u2022 \");\n                } else {\n                    System.out.print(\"\u25e6 \");\n                }\n            }\n        }\n        System.out.println('\\n');\n    }\n\n    public static void main(String[] args) {\n        List<Position> nms = List.of(\n            new Position(2, 1),\n            new Position(3, 1),\n            new Position(3, 2),\n            new Position(4, 1),\n            new Position(4, 2),\n            new Position(4, 3),\n            new Position(5, 1),\n            new Position(5, 2),\n            new Position(5, 3),\n            new Position(5, 4),\n            new Position(5, 5),\n            new Position(6, 1),\n            new Position(6, 2),\n            new Position(6, 3),\n            new Position(6, 4),\n            new Position(6, 5),\n            new Position(6, 6),\n            new Position(7, 1),\n            new Position(7, 2),\n            new Position(7, 3),\n            new Position(7, 4),\n            new Position(7, 5),\n            new Position(7, 6),\n            new Position(7, 7)\n        );\n        for (Position nm : nms) {\n            int m = nm.y;\n            int n = nm.x;\n            System.out.printf(\"%d black and %d white queens on a %d x %d board:\\n\", m, m, n, n);\n            List<Position> blackQueens = new ArrayList<>();\n            List<Position> whiteQueens = new ArrayList<>();\n            if (place(m, n, blackQueens, whiteQueens)) {\n                printBoard(n, blackQueens, whiteQueens);\n            } else {\n                System.out.println(\"No solution exists.\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 425265, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Ruby to Java: def isPrime(n)\n    return false if n < 2\n    return n == 2 if n % 2 == 0\n    return n == 3 if n % 3 == 0\n\n    k = 5\n    while k * k <= n\n        return false if n % k == 0\n        k = k + 2\n    end\n\n    return true\nend\n\ndef getSmallPrimes(numPrimes)\n    smallPrimes = [2]\n    count = 0\n    n = 3\n    while count < numPrimes\n        if isPrime(n) then\n            smallPrimes << n\n            count = count + 1\n        end\n        n = n + 2\n    end\n    return smallPrimes\nend\n\ndef getDivisorCount(n)\n    count = 1\n    while n % 2 == 0\n        n = (n / 2).floor\n        count = count + 1\n    end\n\n    d = 3\n    while d * d <= n\n        q = (n / d).floor\n        r = n % d\n        dc = 0\n        while r == 0\n            dc = dc + count\n            n = q\n            q = (n / d).floor\n            r = n % d\n        end\n        count = count + dc\n        d = d + 2\n    end\n    if n != 1 then\n        count = 2 * count\n    end\n    return count\nend\n\nMAX = 15\n@smallPrimes = getSmallPrimes(MAX)\n\ndef OEISA073916(n)\n    if isPrime(n) then\n        return @smallPrimes[n - 1] ** (n - 1)\n    end\n\n    count = 0\n    result = 0\n    i = 1\n    while count < n\n        if n % 2 == 1 then\n            \n            root = Math.sqrt(i)\n            if root * root != i then\n                i = i + 1\n                next\n            end\n        end\n        if getDivisorCount(i) == n then\n            count = count + 1\n            result = i\n        end\n        i = i + 1\n    end\n    return result\nend\n\nn = 1\nwhile n <= MAX\n    print \"A073916(\", n, \") = \", OEISA073916(n), \"\\n\"\n    n = n + 1\nend\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SequenceNthNumberWithExactlyNDivisors {\n\n    public static void main(String[] args) {\n        int max = 45;\n        smallPrimes(max);\n        for ( int n = 1; n <= max ; n++ ) {\n            System.out.printf(\"A073916(%d) = %s%n\", n, OEISA073916(n));\n        }\n    }\n    \n    private static List<Integer> smallPrimes = new ArrayList<>();\n    \n    private static void smallPrimes(int numPrimes) {\n        smallPrimes.add(2);\n        for ( int n = 3, count = 0 ; count < numPrimes ; n += 2 ) {\n            if ( isPrime(n) ) {\n                smallPrimes.add(n);\n                count++;\n            }\n        }\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) {\n            return false;\n        }\n        for ( long d = 3 ; d*d <= test ; d += 2 ) {\n            if ( test % d == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int getDivisorCount(long n) {\n        int count = 1;\n        while ( n % 2 == 0 ) {\n            n /= 2;\n            count += 1;\n        }\n        for ( long d = 3 ; d*d <= n ; d += 2 ) {\n            long q = n / d;\n            long r = n % d;\n            int dc = 0;\n            while ( r == 0 ) {\n                dc += count;\n                n = q;\n                q = n / d;\n                r = n % d;\n            }\n            count += dc;\n        }\n        if ( n != 1 ) {\n            count *= 2;\n        }\n        return count;\n    }\n    \n    private static BigInteger OEISA073916(int n) {\n        if ( isPrime(n) ) {\n            return BigInteger.valueOf(smallPrimes.get(n-1)).pow(n - 1);\n        }\n        int count = 0;\n        int result = 0;\n        for ( int i = 1 ; count < n ; i++ ) {\n            if ( n % 2 == 1 ) {\n                \n                int sqrt = (int) Math.sqrt(i);\n                if ( sqrt*sqrt != i ) {\n                    continue;\n                }\n            }\n            if ( getDivisorCount(i) == n ) {\n                count++;\n                result = i;\n            }\n        }\n        return BigInteger.valueOf(result);\n    }\n\n}\n"}
{"id": 425266, "name": "Readline interface", "source": "Translate Ruby to Java: require \"readline\"\nrequire \"abbrev\"\n\ncommands = %w[search download open help history quit url prev past]\nReadline.completion_proc = commands.abbrev.to_proc\n\nwhile buf = Readline.readline(\">\", true) \n  exit if buf.strip == \"quit\"\n  p buf\nend\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\npublic class ReadlineInterface {\n    private static LinkedList<String> histArr = new LinkedList<>();\n\n    private static void hist() {\n        if (histArr.isEmpty()) {\n            System.out.println(\"No history\");\n        } else {\n            histArr.forEach(cmd -> System.out.printf(\" - %s\\n\", cmd));\n        }\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    private static void hello() {\n        System.out.println(\"Hello World!\");\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    private static void help() {\n        System.out.println(\"Available commands:\");\n        System.out.println(\"  hello\");\n        System.out.println(\"  hist\");\n        System.out.println(\"  exit\");\n        System.out.println(\"  help\");\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<String, Runnable> cmdMap = new HashMap<>();\n        cmdMap.put(\"help\", ReadlineInterface::help);\n        cmdMap.put(\"hist\", ReadlineInterface::hist);\n        cmdMap.put(\"hello\", ReadlineInterface::hello);\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.println(\"Enter a command, type help for a listing.\");\n        while (true) {\n            System.out.print(\">\");\n            String line = in.readLine();\n            if (\"exit\".equals(line)) {\n                break;\n            }\n\n            cmdMap.getOrDefault(line, ReadlineInterface::help).run();\n        }\n    }\n}\n"}
{"id": 425267, "name": "Addition chains", "source": "Translate Ruby to Java: def check_seq(pos, seq, n, min_len)\n    if pos > min_len or seq[0] > n then\n        return min_len, 0\n    elsif seq[0] == n then\n        return pos, 1\n    elsif pos < min_len then\n        return try_perm(0, pos, seq, n, min_len)\n    else\n        return min_len, 0\n    end\nend\n\ndef try_perm(i, pos, seq, n, min_len)\n    if i > pos then\n        return min_len, 0\n    end\n\n    res11, res12 = check_seq(pos + 1, [seq[0] + seq[i]] + seq, n, min_len)\n    res21, res22 = try_perm(i + 1, pos, seq, n, res11)\n\n    if res21 < res11 then\n        return res21, res22\n    elsif res21 == res11 then\n        return res21, res12 + res22\n    else\n        raise \"try_perm exception\"\n    end\nend\n\ndef init_try_perm(x)\n    return try_perm(0, 0, [1], x, 12)\nend\n\ndef find_brauer(num)\n    actualMin, brauer = init_try_perm(num)\n    puts\n    print \"N = \", num, \"\\n\"\n    print \"Minimum length of chains: L(n)= \", actualMin, \"\\n\"\n    print \"Number of minimum length Brauer chains: \", brauer, \"\\n\"\nend\n\ndef main\n    nums = [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]\n    for i in nums do\n        find_brauer(i)\n    end\nend\n\nmain()\n", "target": "public class AdditionChains {\n    private static class Pair {\n        int f, s;\n\n        Pair(int f, int s) {\n            this.f = f;\n            this.s = s;\n        }\n    }\n\n    private static int[] prepend(int n, int[] seq) {\n        int[] result = new int[seq.length + 1];\n        result[0] = n;\n        System.arraycopy(seq, 0, result, 1, seq.length);\n        return result;\n    }\n\n    private static Pair check_seq(int pos, int[] seq, int n, int min_len) {\n        if (pos > min_len || seq[0] > n) return new Pair(min_len, 0);\n        else if (seq[0] == n) return new Pair(pos, 1);\n        else if (pos < min_len) return try_perm(0, pos, seq, n, min_len);\n        else return new Pair(min_len, 0);\n    }\n\n    private static Pair try_perm(int i, int pos, int[] seq, int n, int min_len) {\n        if (i > pos) return new Pair(min_len, 0);\n\n        Pair res1 = check_seq(pos + 1, prepend(seq[0] + seq[i], seq), n, min_len);\n        Pair res2 = try_perm(i + 1, pos, seq, n, res1.f);\n\n        if (res2.f < res1.f) return res2;\n        else if (res2.f == res1.f) return new Pair(res2.f, res1.s + res2.s);\n        else throw new RuntimeException(\"Try_perm exception\");\n    }\n\n    private static Pair init_try_perm(int x) {\n        return try_perm(0, 0, new int[]{1}, x, 12);\n    }\n\n    private static void find_brauer(int num) {\n        Pair res = init_try_perm(num);\n        System.out.println();\n        System.out.println(\"N = \" + num);\n        System.out.println(\"Minimum length of chains: L(n)= \" + res.f);\n        System.out.println(\"Number of minimum length Brauer chains: \" + res.s);\n    }\n\n    public static void main(String[] args) {\n        int[] nums = new int[]{7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379};\n        for (int i : nums) {\n            find_brauer(i);\n        }\n    }\n}\n"}
{"id": 425268, "name": "Montgomery reduction", "source": "Translate Ruby to Java: func montgomeryReduce(m, a) {\n    {\n        a += m if a.is_odd\n        a >>= 1\n    } * m.as_bin.len\n\n    a % m\n}\n\nvar m  = 750791094644726559640638407699\nvar t1 = 323165824550862327179367294465482435542970161392400401329100\n\nvar r1 = 440160025148131680164261562101\nvar r2 = 435362628198191204145287283255\n\nvar x1 = 540019781128412936473322405310\nvar x2 = 515692107665463680305819378593\n\nsay(\"Original x1:        \", x1)\nsay(\"Recovererd from r1: \", montgomeryReduce(m, r1))\nsay(\"Original x2:        \", x2)\nsay(\"Recovererd from r2: \", montgomeryReduce(m, r2))\n\nprint(\"\\nMontgomery computation of x1^x2 mod m:    \")\nvar prod = montgomeryReduce(m, t1/x1)\nvar base = montgomeryReduce(m, t1)\n\nfor (var exponent = x2; exponent ; exponent >>= 1) {\n    prod = montgomeryReduce(m, prod * base) if exponent.is_odd\n    base = montgomeryReduce(m, base * base)\n}\n\nsay(montgomeryReduce(m, prod))\nsay(\"Library-based computation of x1^x2 mod m: \", x1.powmod(x2, m))\n", "target": "import java.math.BigInteger;\n\npublic class MontgomeryReduction {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    public static class Montgomery {\n        public static final int BASE = 2;\n\n        BigInteger m;\n        BigInteger rrm;\n        int n;\n\n        public Montgomery(BigInteger m) {\n            if (m.compareTo(BigInteger.ZERO) <= 0 || !m.testBit(0)) {\n                throw new IllegalArgumentException();\n            }\n            this.m = m;\n            this.n = m.bitLength();\n            this.rrm = ONE.shiftLeft(n * 2).mod(m);\n        }\n\n        public BigInteger reduce(BigInteger t) {\n            BigInteger a = t;\n            for (int i = 0; i < n; i++) {\n                if (a.testBit(0)) a = a.add(this.m);\n                a = a.shiftRight(1);\n            }\n            if (a.compareTo(m) >= 0) a = a.subtract(this.m);\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        BigInteger m  = new BigInteger(\"750791094644726559640638407699\");\n        BigInteger x1 = new BigInteger(\"540019781128412936473322405310\");\n        BigInteger x2 = new BigInteger(\"515692107665463680305819378593\");\n\n        Montgomery mont = new Montgomery(m);\n        BigInteger t1 = x1.multiply(mont.rrm);\n        BigInteger t2 = x2.multiply(mont.rrm);\n\n        BigInteger r1 = mont.reduce(t1);\n        BigInteger r2 = mont.reduce(t2);\n        BigInteger r = ONE.shiftLeft(mont.n);\n\n        System.out.printf(\"b\u00a0:  %s\\n\", Montgomery.BASE);\n        System.out.printf(\"n\u00a0:  %s\\n\", mont.n);\n        System.out.printf(\"r\u00a0:  %s\\n\", r);\n        System.out.printf(\"m\u00a0:  %s\\n\", mont.m);\n        System.out.printf(\"t1:  %s\\n\", t1);\n        System.out.printf(\"t2:  %s\\n\", t2);\n        System.out.printf(\"r1:  %s\\n\", r1);\n        System.out.printf(\"r2:  %s\\n\", r2);\n        System.out.println();\n        System.out.printf(\"Original x1      \u00a0:  %s\\n\", x1);\n        System.out.printf(\"Recovered from r1\u00a0:  %s\\n\", mont.reduce(r1));\n        System.out.printf(\"Original x2      \u00a0:  %s\\n\", x2);\n        System.out.printf(\"Recovered from r2\u00a0:  %s\\n\", mont.reduce(r2));\n\n        System.out.println();\n        System.out.println(\"Montgomery computation of x1 ^ x2 mod m\u00a0:\");\n        BigInteger prod = mont.reduce(mont.rrm);\n        BigInteger base = mont.reduce(x1.multiply(mont.rrm));\n        BigInteger exp = x2;\n        while (exp.bitLength()>0) {\n            if (exp.testBit(0)) prod=mont.reduce(prod.multiply(base));\n            exp = exp.shiftRight(1);\n            base = mont.reduce(base.multiply(base));\n        }\n        System.out.println(mont.reduce(prod));\n\n        System.out.println();\n        System.out.println(\"Library-based computation of x1 ^ x2 mod m\u00a0:\");\n        System.out.println(x1.modPow(x2, m));\n    }\n}\n"}
{"id": 425269, "name": "Sokoban", "source": "Translate Ruby to Java: require 'set'\n\nclass Sokoban\n  def initialize(level)\n    board = level.each_line.map(&:rstrip)\n    @nrows = board.map(&:size).max\n    board.map!{|line| line.ljust(@nrows)}\n    board.each_with_index do |row, r|\n      row.each_char.with_index do |ch, c|\n        @px, @py = c, r  if ch == '@' or ch == '+'\n      end\n    end\n    @goal = board.join.tr(' .@\n                 .each_char.with_index.select{|ch, c| ch == '.'}\n                 .map(&:last)\n    @board = board.join.tr(' .@\n  end\n  \n  def pos(x, y)\n    y * @nrows + x\n  end\n  \n  def push(x, y, dx, dy, board)         \n    return  if board[pos(x+2*dx, y+2*dy)] != ' '\n    board[pos(x     , y     )] = ' '\n    board[pos(x + dx, y + dy)] = '@'\n    board[pos(x+2*dx, y+2*dy)] = '$'\n  end\n  \n  def solved?(board)\n    @goal.all?{|i| board[i] == '$'}\n  end\n  \n  DIRS = [[0, -1, 'u', 'U'], [ 1, 0, 'r', 'R'], [0,  1, 'd', 'D'], [-1, 0, 'l', 'L']]\n  def solve\n    queue = [[@board, \"\", @px, @py]]\n    visited = Set[@board]\n    \n    until queue.empty?\n      current, csol, x, y = queue.shift\n      \n      for dx, dy, cmove, cpush in DIRS\n        work = current.dup\n        case work[pos(x+dx, y+dy)]      \n        when '$'\n          next  unless push(x, y, dx, dy, work)\n          next  unless visited.add?(work)\n          return csol+cpush  if solved?(work)\n          queue << [work, csol+cpush, x+dx, y+dy]\n        when ' '\n          work[pos(x, y)]       = ' '\n          work[pos(x+dx, y+dy)] = '@'\n          queue << [work, csol+cmove, x+dx, y+dy]  if visited.add?(work)\n        end\n      end\n    end\n    \"No solution\"\n  end\nend\n", "target": "import java.util.*;\n\npublic class Sokoban {\n    String destBoard, currBoard;\n    int playerX, playerY, nCols;\n\n    Sokoban(String[] board) {\n        nCols = board[0].length();\n        StringBuilder destBuf = new StringBuilder();\n        StringBuilder currBuf = new StringBuilder();\n\n        for (int r = 0; r < board.length; r++) {\n            for (int c = 0; c < nCols; c++) {\n\n                char ch = board[r].charAt(c);\n\n                destBuf.append(ch != '$' && ch != '@' ? ch : ' ');\n                currBuf.append(ch != '.' ? ch : ' ');\n\n                if (ch == '@') {\n                    this.playerX = c;\n                    this.playerY = r;\n                }\n            }\n        }\n        destBoard = destBuf.toString();\n        currBoard = currBuf.toString();\n    }\n\n    String move(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newPlayerPos = (y + dy) * nCols + x + dx;\n\n        if (trialBoard.charAt(newPlayerPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[newPlayerPos] = '@';\n\n        return new String(trial);\n    }\n\n    String push(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n        if (trialBoard.charAt(newBoxPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[(y + dy) * nCols + x + dx] = '@';\n        trial[newBoxPos] = '$';\n\n        return new String(trial);\n    }\n\n    boolean isSolved(String trialBoard) {\n        for (int i = 0; i < trialBoard.length(); i++)\n            if ((destBoard.charAt(i) == '.')\n                    != (trialBoard.charAt(i) == '$'))\n                return false;\n        return true;\n    }\n\n    String solve() {\n        class Board {\n            String cur, sol;\n            int x, y;\n\n            Board(String s1, String s2, int px, int py) {\n                cur = s1;\n                sol = s2;\n                x = px;\n                y = py;\n            }\n        }\n        char[][] dirLabels = {{'u', 'U'}, {'r', 'R'}, {'d', 'D'}, {'l', 'L'}};\n        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n\n        Set<String> history = new HashSet<>();\n        LinkedList<Board> open = new LinkedList<>();\n\n        history.add(currBoard);\n        open.add(new Board(currBoard, \"\", playerX, playerY));\n\n        while (!open.isEmpty()) {\n            Board item = open.poll();\n            String cur = item.cur;\n            String sol = item.sol;\n            int x = item.x;\n            int y = item.y;\n\n            for (int i = 0; i < dirs.length; i++) {\n                String trial = cur;\n                int dx = dirs[i][0];\n                int dy = dirs[i][1];\n\n                \n                if (trial.charAt((y + dy) * nCols + x + dx) == '$') {\n\n                    \n                    if ((trial = push(x, y, dx, dy, trial)) != null) {\n\n                        \n                        if (!history.contains(trial)) {\n\n                            String newSol = sol + dirLabels[i][1];\n\n                            if (isSolved(trial))\n                                return newSol;\n\n                            open.add(new Board(trial, newSol, x + dx, y + dy));\n                            history.add(trial);\n                        }\n                    }\n\n                \n                } else if ((trial = move(x, y, dx, dy, trial)) != null) {\n\n                    if (!history.contains(trial)) {\n                        String newSol = sol + dirLabels[i][0];\n                        open.add(new Board(trial, newSol, x + dx, y + dy));\n                        history.add(trial);\n                    }\n                }\n            }\n        }\n        return \"No solution\";\n    }\n\n    public static void main(String[] a) {\n        String level = \"#######,#     #,#     #,#. #  #,#. $$ #,\"\n                + \"#.$$  #,#.#  @#,#######\";\n        System.out.println(new Sokoban(level.split(\",\")).solve());\n    }\n}\n"}
{"id": 425270, "name": "Zumkeller numbers", "source": "Translate Ruby to Java: class Integer\n  \n  def divisors\n    res = [1, self]\n    (2..Integer.sqrt(self)).each do |n|\n      div, mod = divmod(n)\n      res << n << div if mod.zero?\n    end\n    res.uniq.sort\n  end\n  \n  def zumkeller?\n    divs = divisors\n    sum  = divs.sum\n    return false unless sum.even? && sum >= self*2\n    half = sum / 2\n    max_combi_size = divs.size / 2\n    1.upto(max_combi_size).any? do |combi_size|\n      divs.combination(combi_size).any?{|combi| combi.sum == half}\n    end\n  end\n  \nend\n\ndef p_enum(enum, cols = 10, col_width = 8)\n  enum.each_slice(cols) {|slice| puts \"%\nend\n\nputs \"\np_enum 1.step.lazy.select(&:zumkeller?).take(n), 14, 6\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select(&:zumkeller?).take(n)\n\nputs \"\\n\np_enum 1.step(by: 2).lazy.select{|x| x % 5 > 0 && x.zumkeller?}.take(n)\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ZumkellerNumbers {\n\n    public static void main(String[] args) {\n        int n = 1;\n        System.out.printf(\"First 220 Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 220 ; n += 1 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%3d  \", n);\n                if ( count % 20 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%6d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers that do not end in a 5:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( n % 5 != 0 && isZumkeller(n) ) {\n                System.out.printf(\"%8d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n\n    }\n    \n    private static boolean isZumkeller(int n) {\n        \n        if ( n % 18 == 6 || n % 18 == 12 ) {\n            return true;\n        }\n        \n        List<Integer> divisors = getDivisors(n);        \n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        \n        \n        if ( divisorSum % 2 == 1 ) {\n            return false;\n        }\n        \n        \n        int abundance = divisorSum - 2 * n;\n        if ( n % 2 == 1 && abundance > 0 && abundance % 2 == 0 ) {\n            return true;\n        }\n        \n        Collections.sort(divisors);\n        int j = divisors.size() - 1;\n        int sum = divisorSum/2;\n        \n        \n        if ( divisors.get(j) > sum ) {\n            return false;\n        }\n        \n        return canPartition(j, divisors, sum, new int[2]);\n    }\n    \n    private static boolean canPartition(int j, List<Integer> divisors, int sum, int[] buckets) {\n        if ( j < 0 ) {\n            return true;\n        }\n        for ( int i = 0 ; i < 2 ; i++ ) {\n            if ( buckets[i] + divisors.get(j) <= sum ) {\n                buckets[i] += divisors.get(j);\n                if ( canPartition(j-1, divisors, sum, buckets) ) {\n                    return true;\n                }\n                buckets[i] -= divisors.get(j);\n            }\n            if( buckets[i] == 0 ) {\n                break;\n            }\n        }\n        return false;\n    }\n    \n    private static final List<Integer> getDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 425271, "name": "Suffix tree", "source": "Translate Ruby to Java: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SuffixTreeProblem {\n    private static class Node {\n        String sub = \"\";                       \n        List<Integer> ch = new ArrayList<>();  \n    }\n\n    private static class SuffixTree {\n        private List<Node> nodes = new ArrayList<>();\n\n        public SuffixTree(String str) {\n            nodes.add(new Node());\n            for (int i = 0; i < str.length(); ++i) {\n                addSuffix(str.substring(i));\n            }\n        }\n\n        private void addSuffix(String suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.length()) {\n                char b = suf.charAt(i);\n                List<Integer> children = nodes.get(n).ch;\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    if (x2 == children.size()) {\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = suf.substring(i);\n                        nodes.add(temp);\n                        children.add(n2);\n                        return;\n                    }\n                    n2 = children.get(x2);\n                    if (nodes.get(n2).sub.charAt(0) == b) break;\n                    x2++;\n                }\n                \n                String sub2 = nodes.get(n2).sub;\n                int j = 0;\n                while (j < sub2.length()) {\n                    if (suf.charAt(i + j) != sub2.charAt(j)) {\n                        \n                        int n3 = n2;\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = sub2.substring(0, j);\n                        temp.ch.add(n3);\n                        nodes.add(temp);\n                        nodes.get(n3).sub = sub2.substring(j);  \n                        nodes.get(n).ch.set(x2, n2);\n                        break;  \n                    }\n                    j++;\n                }\n                i += j;  \n                n = n2;  \n            }\n        }\n\n        public void visualize() {\n            if (nodes.isEmpty()) {\n                System.out.println(\"<empty>\");\n                return;\n            }\n            visualize_f(0, \"\");\n        }\n\n        private void visualize_f(int n, String pre) {\n            List<Integer> children = nodes.get(n).ch;\n            if (children.isEmpty()) {\n                System.out.println(\"- \" + nodes.get(n).sub);\n                return;\n            }\n            System.out.println(\"\u2510 \" + nodes.get(n).sub);\n            for (int i = 0; i < children.size() - 1; i++) {\n                Integer c = children.get(i);\n                System.out.print(pre + \"\u251c\u2500\");\n                visualize_f(c, pre + \"\u2502 \");\n            }\n            System.out.print(pre + \"\u2514\u2500\");\n            visualize_f(children.get(children.size() - 1), pre + \"  \");\n        }\n    }\n\n    public static void main(String[] args) {\n        new SuffixTree(\"banana$\").visualize();\n    }\n}\n"}
{"id": 425272, "name": "Suffix tree", "source": "Translate Ruby to Java: func suffix_tree(Str t) {\n    suffix_tree(^t.len -> map { t.substr(_) })\n}\n\nfunc suffix_tree(a {.len == 1}) {\n    Hash(a[0] => nil) \n}\n\nfunc suffix_tree(Arr a) {\n    var h = Hash()\n    for k,v in (a.group_by { .char(0) }) {\n        var subtree = suffix_tree(v.map { .substr(1) })\n        var subkeys = subtree.keys\n        if (subkeys.len == 1) {\n            var subk = subkeys[0]\n            h{k + subk} = subtree{subk}\n        }\n        else {\n            h{k} = subtree\n        }\n    }\n    return h\n}\n\nsay suffix_tree('banana$')\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SuffixTreeProblem {\n    private static class Node {\n        String sub = \"\";                       \n        List<Integer> ch = new ArrayList<>();  \n    }\n\n    private static class SuffixTree {\n        private List<Node> nodes = new ArrayList<>();\n\n        public SuffixTree(String str) {\n            nodes.add(new Node());\n            for (int i = 0; i < str.length(); ++i) {\n                addSuffix(str.substring(i));\n            }\n        }\n\n        private void addSuffix(String suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.length()) {\n                char b = suf.charAt(i);\n                List<Integer> children = nodes.get(n).ch;\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    if (x2 == children.size()) {\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = suf.substring(i);\n                        nodes.add(temp);\n                        children.add(n2);\n                        return;\n                    }\n                    n2 = children.get(x2);\n                    if (nodes.get(n2).sub.charAt(0) == b) break;\n                    x2++;\n                }\n                \n                String sub2 = nodes.get(n2).sub;\n                int j = 0;\n                while (j < sub2.length()) {\n                    if (suf.charAt(i + j) != sub2.charAt(j)) {\n                        \n                        int n3 = n2;\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = sub2.substring(0, j);\n                        temp.ch.add(n3);\n                        nodes.add(temp);\n                        nodes.get(n3).sub = sub2.substring(j);  \n                        nodes.get(n).ch.set(x2, n2);\n                        break;  \n                    }\n                    j++;\n                }\n                i += j;  \n                n = n2;  \n            }\n        }\n\n        public void visualize() {\n            if (nodes.isEmpty()) {\n                System.out.println(\"<empty>\");\n                return;\n            }\n            visualize_f(0, \"\");\n        }\n\n        private void visualize_f(int n, String pre) {\n            List<Integer> children = nodes.get(n).ch;\n            if (children.isEmpty()) {\n                System.out.println(\"- \" + nodes.get(n).sub);\n                return;\n            }\n            System.out.println(\"\u2510 \" + nodes.get(n).sub);\n            for (int i = 0; i < children.size() - 1; i++) {\n                Integer c = children.get(i);\n                System.out.print(pre + \"\u251c\u2500\");\n                visualize_f(c, pre + \"\u2502 \");\n            }\n            System.out.print(pre + \"\u2514\u2500\");\n            visualize_f(children.get(children.size() - 1), pre + \"  \");\n        }\n    }\n\n    public static void main(String[] args) {\n        new SuffixTree(\"banana$\").visualize();\n    }\n}\n"}
{"id": 425273, "name": "Reflection_List properties", "source": "Translate Ruby to Java: class Foo\n  @@xyz = nil\n  def initialize(name, age)\n    @name, @age = name, age\n  end\n  def add_sex(sex)\n    @sex = sex\n  end\nend\n\np foo = Foo.new(\"Angel\", 18)            \np foo.instance_variables                \np foo.instance_variable_defined?(:@age) \np foo.instance_variable_get(:@age)      \np foo.instance_variable_set(:@age, 19)  \np foo                                   \nfoo.add_sex(:woman)\np foo.instance_variables                \np foo                                   \nfoo.instance_variable_set(:@bar, nil)\np foo.instance_variables                \n\np Foo.class_variables                   \np Foo.class_variable_defined?(:@@xyz)   \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@xyz, :xyz)  \np Foo.class_variable_get(:@@xyz)        \np Foo.class_variable_set(:@@abc, 123)   \np Foo.class_variables                   \n", "target": "import java.lang.reflect.Field;\n\npublic class ListFields {\n    public int examplePublicField = 42;\n    private boolean examplePrivateField = true;\n    \n    public static void main(String[] args) throws IllegalAccessException {\n        ListFields obj = new ListFields();\n        Class clazz = obj.getClass();\n\n        System.out.println(\"All public fields (including inherited):\");\n        for (Field f : clazz.getFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n        System.out.println();\n        System.out.println(\"All declared fields (excluding inherited):\");\n        for (Field f : clazz.getDeclaredFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n    }\n}\n"}
{"id": 425274, "name": "Eertree", "source": "Translate Ruby to Java: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Eertree {\n    public static void main(String[] args) {\n        List<Node> tree = eertree(\"eertree\");\n        List<String> result = subPalindromes(tree);\n        System.out.println(result);\n    }\n\n    private static class Node {\n        int length;\n        Map<Character, Integer> edges = new HashMap<>();\n        int suffix;\n\n        public Node(int length) {\n            this.length = length;\n        }\n\n        public Node(int length, Map<Character, Integer> edges, int suffix) {\n            this.length = length;\n            this.edges = edges != null ? edges : new HashMap<>();\n            this.suffix = suffix;\n        }\n    }\n\n    private static final int EVEN_ROOT = 0;\n    private static final int ODD_ROOT = 1;\n\n    private static List<Node> eertree(String s) {\n        List<Node> tree = new ArrayList<>();\n        tree.add(new Node(0, null, ODD_ROOT));\n        tree.add(new Node(-1, null, ODD_ROOT));\n        int suffix = ODD_ROOT;\n        int n, k;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            for (n = suffix; ; n = tree.get(n).suffix) {\n                k = tree.get(n).length;\n                int b = i - k - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            if (tree.get(n).edges.containsKey(c)) {\n                suffix = tree.get(n).edges.get(c);\n                continue;\n            }\n            suffix = tree.size();\n            tree.add(new Node(k + 2));\n            tree.get(n).edges.put(c, suffix);\n            if (tree.get(suffix).length == 1) {\n                tree.get(suffix).suffix = 0;\n                continue;\n            }\n            while (true) {\n                n = tree.get(n).suffix;\n                int b = i - tree.get(n).length - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            tree.get(suffix).suffix = tree.get(n).edges.get(c);\n        }\n        return tree;\n    }\n\n    private static List<String> subPalindromes(List<Node> tree) {\n        List<String> s = new ArrayList<>();\n        subPalindromes_children(0, \"\", tree, s);\n        for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {\n            String ct = String.valueOf(cm.getKey());\n            s.add(ct);\n            subPalindromes_children(cm.getValue(), ct, tree, s);\n        }\n        return s;\n    }\n\n    \n    private static void subPalindromes_children(final int n, final String p, final List<Node> tree, List<String> s) {\n        for (Map.Entry<Character, Integer> cm : tree.get(n).edges.entrySet()) {\n            Character c = cm.getKey();\n            Integer m = cm.getValue();\n            String pl = c + p + c;\n            s.add(pl);\n            subPalindromes_children(m, pl, tree, s);\n        }\n    }\n}\n"}
{"id": 425275, "name": "Eertree", "source": "Translate Ruby to Java: class Node\n    def initialize(length, edges = {}, suffix = 0)\n        @length = length\n        @edges = edges\n        @suffix = suffix\n    end\n\n    attr_reader :length\n    attr_reader :edges\n    attr_accessor :suffix\nend\n\nEVEN_ROOT = 0\nODD_ROOT = 1\n\ndef eertree(s)\n    tree = [\n        Node.new(0, {}, ODD_ROOT),\n        Node.new(-1, {}, ODD_ROOT)\n    ]\n    suffix = ODD_ROOT\n    s.each_char.with_index { |c, i|\n        n = suffix\n        k = 0\n        loop do\n            k = tree[n].length\n            b = i - k - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n            n = tree[n].suffix\n        end\n        if tree[n].edges.key?(c) then\n                suffix = tree[n].edges[c]\n            next\n        end\n        suffix = tree.length\n        tree << Node.new(k + 2)\n        tree[n].edges[c] = suffix\n        if tree[suffix].length == 1 then\n            tree[suffix].suffix = 0\n            next\n        end\n        loop do\n            n = tree[n].suffix\n            b = i - tree[n].length - 1\n            if b >= 0 and s[b] == c then\n                break\n            end\n        end\n        tree[suffix].suffix = tree[n].edges[c]\n    }\n    return tree\nend\n\ndef subPalindromes(tree)\n    s = []\n\n    children = lambda { |n,p,f|\n        for c,v in tree[n].edges\n            m = tree[n].edges[c]\n            p = c + p + c\n            s << p\n            f.call(m, p, f)\n        end\n    }\n\n    children.call(0, '', children)\n\n    for c,n in tree[1].edges\n        s << c\n        children.call(n, c, children)\n    end\n\n    return s\nend\n\ntree = eertree(\"eertree\")\nprint subPalindromes(tree), \"\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Eertree {\n    public static void main(String[] args) {\n        List<Node> tree = eertree(\"eertree\");\n        List<String> result = subPalindromes(tree);\n        System.out.println(result);\n    }\n\n    private static class Node {\n        int length;\n        Map<Character, Integer> edges = new HashMap<>();\n        int suffix;\n\n        public Node(int length) {\n            this.length = length;\n        }\n\n        public Node(int length, Map<Character, Integer> edges, int suffix) {\n            this.length = length;\n            this.edges = edges != null ? edges : new HashMap<>();\n            this.suffix = suffix;\n        }\n    }\n\n    private static final int EVEN_ROOT = 0;\n    private static final int ODD_ROOT = 1;\n\n    private static List<Node> eertree(String s) {\n        List<Node> tree = new ArrayList<>();\n        tree.add(new Node(0, null, ODD_ROOT));\n        tree.add(new Node(-1, null, ODD_ROOT));\n        int suffix = ODD_ROOT;\n        int n, k;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            for (n = suffix; ; n = tree.get(n).suffix) {\n                k = tree.get(n).length;\n                int b = i - k - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            if (tree.get(n).edges.containsKey(c)) {\n                suffix = tree.get(n).edges.get(c);\n                continue;\n            }\n            suffix = tree.size();\n            tree.add(new Node(k + 2));\n            tree.get(n).edges.put(c, suffix);\n            if (tree.get(suffix).length == 1) {\n                tree.get(suffix).suffix = 0;\n                continue;\n            }\n            while (true) {\n                n = tree.get(n).suffix;\n                int b = i - tree.get(n).length - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            tree.get(suffix).suffix = tree.get(n).edges.get(c);\n        }\n        return tree;\n    }\n\n    private static List<String> subPalindromes(List<Node> tree) {\n        List<String> s = new ArrayList<>();\n        subPalindromes_children(0, \"\", tree, s);\n        for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {\n            String ct = String.valueOf(cm.getKey());\n            s.add(ct);\n            subPalindromes_children(cm.getValue(), ct, tree, s);\n        }\n        return s;\n    }\n\n    \n    private static void subPalindromes_children(final int n, final String p, final List<Node> tree, List<String> s) {\n        for (Map.Entry<Character, Integer> cm : tree.get(n).edges.entrySet()) {\n            Character c = cm.getKey();\n            Integer m = cm.getValue();\n            String pl = c + p + c;\n            s.add(pl);\n            subPalindromes_children(m, pl, tree, s);\n        }\n    }\n}\n"}
{"id": 425276, "name": "Base58Check encoding", "source": "Translate Ruby to Java: ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\nnums =  [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n\nputs nums.map{|n| n.digits(58).reverse.map{|i| ALPHABET[i]}.join}\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n"}
{"id": 425277, "name": "Latin Squares in reduced form", "source": "Translate Ruby to Java: def printSquare(a)\n    for row in a\n        print row, \"\\n\"\n    end\n    print \"\\n\"\nend\n\ndef dList(n, start)\n    start = start - 1 \n    a = Array.new(n) {|i| i}\n    a[0], a[start] = a[start], a[0]\n    a[1..] = a[1..].sort\n    first = a[1]\n\n    r = []\n    recurse = lambda {|last|\n        if last == first then\n            \n            \n            a[1..].each_with_index {|v, j|\n                if j + 1 == v then\n                    return \n                end\n            }\n            \n            b = a.map { |i| i + 1 }\n            r << b\n            return\n        end\n\n        i = last\n        while i >= 1 do\n            a[i], a[last] = a[last], a[i]\n            recurse.call(last - 1)\n            a[i], a[last] = a[last], a[i]\n            i = i - 1\n        end\n    }\n\n    recurse.call(n - 1)\n    return r\nend\n\ndef reducedLatinSquares(n, echo)\n    if n <= 0 then\n        if echo then\n            print \"[]\\n\\n\"\n        end\n        return 0\n    end\n    if n == 1 then\n        if echo then\n            print \"[1]\\n\\n\"\n        end\n        return 1\n    end\n\n    rlatin = Array.new(n) { Array.new(n, Float::NAN)}\n\n    \n    for j in 0 .. n - 1\n        rlatin[0][j] = j + 1\n    end\n\n    count = 0\n    recurse = lambda {|i|\n        rows = dList(n, i)\n\n        for r in 0 .. rows.length - 1\n            rlatin[i - 1] = rows[r].dup\n            catch (:outer) do\n                for k in 0 .. i - 2\n                    for j in 1 .. n - 1\n                        if rlatin[k][j] == rlatin[i - 1][j] then\n                            if r < rows.length - 1 then\n                                throw :outer\n                            end\n                            if i > 2 then\n                                return\n                            end\n                        end\n                    end\n                end\n                if i < n then\n                    recurse.call(i + 1)\n                else\n                    count = count + 1\n                    if echo then\n                        printSquare(rlatin)\n                    end\n                end\n            end\n        end\n    }\n\n    \n    recurse.call(2)\n    return count\nend\n\ndef factorial(n)\n    if n == 0 then\n        return 1\n    end\n    prod = 1\n    for i in 2 .. n\n        prod = prod * i\n    end\n    return prod\nend\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4, true)\n\nprint \"The size of the set of reduced latin squares for the following orders\\n\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in 1 .. 6\n    size = reducedLatinSquares(n, false)\n    f = factorial(n - 1)\n    f = f * f * n * size\n    print \"Order %d Size\u00a0%-4d x %d! x %d! => Total %d\\n\" % [n, size, n, n - 1, f]\nend\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class LatinSquaresInReducedForm {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Reduced latin squares of order 4:%n\");\n        for ( LatinSquare square : getReducedLatinSquares(4) ) {\n            System.out.printf(\"%s%n\", square);\n        }\n        \n        System.out.printf(\"Compute the number of latin squares from count of reduced latin squares:%n(Reduced Latin Square Count) * n! * (n-1)! = Latin Square Count%n\");\n        for ( int n = 1 ; n <= 6 ; n++ ) {\n            List<LatinSquare> list = getReducedLatinSquares(n);\n            System.out.printf(\"Size = %d, %d * %d * %d =\u00a0%,d%n\", n, list.size(), fact(n), fact(n-1), list.size()*fact(n)*fact(n-1));\n        }\n    }\n    \n    private static long fact(int n) {\n        if ( n == 0 ) {\n            return 1;\n        }\n        int prod = 1;\n        for ( int i = 1 ; i <= n ; i++ ) {\n            prod *= i;\n        }\n        return prod;\n    }\n    \n    private static List<LatinSquare> getReducedLatinSquares(int n) {\n        List<LatinSquare> squares = new ArrayList<>();\n        \n        squares.add(new LatinSquare(n));\n        PermutationGenerator permGen = new PermutationGenerator(n);\n        for ( int fillRow = 1 ; fillRow < n ; fillRow++ ) {\n            List<LatinSquare> squaresNext = new ArrayList<>();\n            for ( LatinSquare square : squares ) {\n                while ( permGen.hasMore() ) {\n                    int[] perm = permGen.getNext();\n                    \n                    \n                    if ( (perm[0]+1) != (fillRow+1) ) {\n                        continue;\n                    }\n                    \n                    \n                    boolean permOk = true;\n                    done:\n                    for ( int row = 0 ; row < fillRow ; row++ ) {\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            if ( square.get(row, col) == (perm[col]+1) ) {\n                                permOk = false;\n                                break done;\n                            }\n                        }\n                    }\n                    if ( permOk ) {\n                        LatinSquare newSquare = new LatinSquare(square);\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            newSquare.set(fillRow, col, perm[col]+1);\n                        }\n                        squaresNext.add(newSquare);\n                    }\n                }\n                permGen.reset();\n            }\n            squares = squaresNext;\n        }\n        \n        return squares;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int[] display(int[] in) {\n        int [] out = new int[in.length];\n        for ( int i = 0 ; i < in.length ; i++ ) {\n            out[i] = in[i] + 1;\n        }\n        return out;\n    }\n    \n    private static class LatinSquare {\n        \n        int[][] square;\n        int size;\n        \n        public LatinSquare(int n) {\n            square = new int[n][n];\n            size = n;\n            for ( int col = 0 ; col < n ; col++ ) {\n                set(0, col, col + 1);\n            }\n        }\n        \n        public LatinSquare(LatinSquare ls) {\n            int n = ls.size;\n            square = new int[n][n];\n            size = n;\n            for ( int row = 0 ; row < n ; row++ ) {\n                for ( int col = 0 ; col < n ; col++ ) {\n                    set(row, col, ls.get(row, col));\n                }\n            }\n        }\n        \n        public void set(int row, int col, int value) {\n            square[row][col] = value;\n        }\n\n        public int get(int row, int col) {\n            return square[row][col];\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            for ( int row = 0 ; row < size ; row++ ) {\n                sb.append(Arrays.toString(square[row]));\n                sb.append(\"\\n\");\n            }\n            return sb.toString();\n        }\n        \n        \n    }\n\n    private static class PermutationGenerator {\n\n        private int[] a;\n        private BigInteger numLeft;\n        private BigInteger total;\n\n        public PermutationGenerator (int n) {\n            if (n < 1) {\n                throw new IllegalArgumentException (\"Min 1\");\n            }\n            a = new int[n];\n            total = getFactorial(n);\n            reset();\n        }\n\n        private void reset () {\n            for ( int i = 0 ; i < a.length ; i++ ) {\n                a[i] = i;\n            }\n            numLeft = new BigInteger(total.toString());\n        }\n\n        public boolean hasMore() {\n            return numLeft.compareTo(BigInteger.ZERO) == 1;\n        }\n\n        private static BigInteger getFactorial (int n) {\n            BigInteger fact = BigInteger.ONE;\n            for ( int i = n ; i > 1 ; i-- ) {\n                fact = fact.multiply(new BigInteger(Integer.toString(i)));\n            }\n            return fact;\n        }\n\n        \n        public int[] getNext() {\n            if ( numLeft.equals(total) ) {\n                numLeft = numLeft.subtract (BigInteger.ONE);\n                return a;\n            }\n\n            \n            int j = a.length - 2;\n            while ( a[j] > a[j+1] ) {\n                j--;\n            }\n\n            \n            int k = a.length - 1;\n            while ( a[j] > a[k] ) {\n                k--;\n            }\n\n            \n            int temp = a[k];\n            a[k] = a[j];\n            a[j] = temp;\n\n            \n            int r = a.length - 1;\n            int s = j + 1;\n            while (r > s) {\n                int temp2 = a[s];\n                a[s] = a[r];\n                a[r] = temp2;\n                r--;\n                s++;\n            }\n\n            numLeft = numLeft.subtract(BigInteger.ONE);\n            return a;\n        }\n    }\n\n}\n"}
{"id": 425278, "name": "Kosaraju", "source": "Translate Ruby to Java: func korasaju(Array g) {\n    \n    var vis = g.len.of(false)\n    var L   = []\n    var x   = g.end\n    var t   = g.len.of { [] }\n\n    \n    func visit(u) {\n        if (!vis[u]) {\n            vis[u] = true\n            g[u].each {|v|\n                visit(v)\n                t[v] << u\n            }\n            L[x--] = u\n        }\n    }\n\n    \n    g.range.each {|u|\n        visit(u)\n    }\n\n    var c = []\n\n    \n    func assign(u, root) {\n        if (vis[u]) {\n            vis[u] = false\n            c[u] = root\n            t[u].each {|v|\n                assign(v, root)\n            }\n        }\n    }\n\n    \n    L.each {|u|\n        assign(u, u)\n    }\n\n    return c\n}\n\nvar g = [[1], [2], [0], [1, 2, 4], [3, 5], [2, 6], [5], [4, 6, 7]]\nsay korasaju(g)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.IntConsumer;\nimport java.util.stream.Collectors;\n\npublic class Kosaraju {\n    static class Recursive<I> {\n        I func;\n    }\n\n    private static List<Integer> kosaraju(List<List<Integer>> g) {\n        \n        int size = g.size();\n        boolean[] vis = new boolean[size];\n        int[] l = new int[size];\n        AtomicInteger x = new AtomicInteger(size);\n\n        List<List<Integer>> t = new ArrayList<>();\n        for (int i = 0; i < size; ++i) {\n            t.add(new ArrayList<>());\n        }\n\n        Recursive<IntConsumer> visit = new Recursive<>();\n        visit.func = (int u) -> {\n            if (!vis[u]) {\n                vis[u] = true;\n                for (Integer v : g.get(u)) {\n                    visit.func.accept(v);\n                    t.get(v).add(u);\n                }\n                int xval = x.decrementAndGet();\n                l[xval] = u;\n            }\n        };\n\n        \n        for (int i = 0; i < size; ++i) {\n            visit.func.accept(i);\n        }\n        int[] c = new int[size];\n\n        Recursive<BiConsumer<Integer, Integer>> assign = new Recursive<>();\n        assign.func = (Integer u, Integer root) -> {\n            if (vis[u]) {  \n                vis[u] = false;\n                c[u] = root;\n                for (Integer v : t.get(u)) {\n                    assign.func.accept(v, root);\n                }\n            }\n        };\n\n        \n        for (int u : l) {\n            assign.func.accept(u, u);\n        }\n\n        return Arrays.stream(c).boxed().collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < 8; ++i) {\n            g.add(new ArrayList<>());\n        }\n        g.get(0).add(1);\n        g.get(1).add(2);\n        g.get(2).add(0);\n        g.get(3).add(1);\n        g.get(3).add(2);\n        g.get(3).add(4);\n        g.get(4).add(3);\n        g.get(4).add(5);\n        g.get(5).add(2);\n        g.get(5).add(6);\n        g.get(6).add(5);\n        g.get(7).add(4);\n        g.get(7).add(6);\n        g.get(7).add(7);\n\n        List<Integer> output = kosaraju(g);\n        System.out.println(output);\n    }\n}\n"}
{"id": 425279, "name": "Markov chain text generator", "source": "Translate Ruby to Java: class Markov(N)\n  @dictionary = Hash(StaticArray(String, N), Array(String)).new { [] of String }\n\n  def parse(filename : String)\n    File.open(filename) do |file|\n      parse(file)\n    end\n  end\n\n  private def prefix_from(array)\n    StaticArray(String, N).new { |i| array[-(N - i)] }\n  end\n\n  def parse(input : IO)\n    sequence = [] of String\n    loop do\n      word = input.gets(' ', true)\n      break unless word\n      if sequence.size == N\n        prefix = prefix_from(sequence)\n        @dictionary[prefix] = (@dictionary[prefix] << word)\n      end\n      sequence << word\n      sequence.shift if sequence.size > N\n    end\n  end\n\n  def generate(count)\n    prefix = @dictionary.keys.sample\n    result = Array(String).new(prefix.size) { |i| prefix[i] }\n    (count - N).times do\n      prefix = prefix_from(result)\n      values = @dictionary[prefix]\n      break if values.size == 0\n      result << values.sample\n    end\n    result.join(' ')\n  end\nend\n\nchain = Markov(3).new\nchain.parse(\"alice_oz.txt\")\nputs chain.generate(200)\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Random;\n\npublic class MarkovChain {\n    private static Random r = new Random();\n\n    private static String markov(String filePath, int keySize, int outputSize) throws IOException {\n        if (keySize < 1) throw new IllegalArgumentException(\"Key size can't be less than 1\");\n        Path path = Paths.get(filePath);\n        byte[] bytes = Files.readAllBytes(path);\n        String[] words = new String(bytes).trim().split(\" \");\n        if (outputSize < keySize || outputSize >= words.length) {\n            throw new IllegalArgumentException(\"Output size is out of range\");\n        }\n        Map<String, List<String>> dict = new HashMap<>();\n\n        for (int i = 0; i < (words.length - keySize); ++i) {\n            StringBuilder key = new StringBuilder(words[i]);\n            for (int j = i + 1; j < i + keySize; ++j) {\n                key.append(' ').append(words[j]);\n            }\n            String value = (i + keySize < words.length) ? words[i + keySize] : \"\";\n            if (!dict.containsKey(key.toString())) {\n                ArrayList<String> list = new ArrayList<>();\n                list.add(value);\n                dict.put(key.toString(), list);\n            } else {\n                dict.get(key.toString()).add(value);\n            }\n        }\n\n        int n = 0;\n        int rn = r.nextInt(dict.size());\n        String prefix = (String) dict.keySet().toArray()[rn];\n        List<String> output = new ArrayList<>(Arrays.asList(prefix.split(\" \")));\n\n        while (true) {\n            List<String> suffix = dict.get(prefix);\n            if (suffix.size() == 1) {\n                if (Objects.equals(suffix.get(0), \"\")) return output.stream().reduce(\"\", (a, b) -> a + \" \" + b);\n                output.add(suffix.get(0));\n            } else {\n                rn = r.nextInt(suffix.size());\n                output.add(suffix.get(rn));\n            }\n            if (output.size() >= outputSize) return output.stream().limit(outputSize).reduce(\"\", (a, b) -> a + \" \" + b);\n            n++;\n            prefix = output.stream().skip(n).limit(keySize).reduce(\"\", (a, b) -> a + \" \" + b).trim();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(markov(\"alice_oz.txt\", 3, 200));\n    }\n}\n"}
{"id": 425280, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Ruby to Java: def cumulative_freq(freq)\n  cf = {}\n  total = 0\n  freq.keys.sort.each do |b|\n    cf[b] = total\n    total += freq[b]\n  end\n  return cf\nend\n\ndef arithmethic_coding(bytes, radix)\n\n  \n  freq = Hash.new(0)\n  bytes.each { |b| freq[b] += 1 }\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  base = bytes.size\n\n  \n  lower = 0\n\n  \n  pf = 1\n\n  \n  \n  bytes.each do |b|\n    lower = lower*base + cf[b]*pf\n    pf *= freq[b]\n  end\n\n  \n  upper = lower+pf\n\n  pow = 0\n  loop do\n    pf /= radix\n    break if pf==0\n    pow += 1\n  end\n\n  enc = ((upper-1) / radix**pow)\n  [enc, pow, freq]\nend\n\ndef arithmethic_decoding(enc, radix, pow, freq)\n\n  \n  enc *= radix**pow;\n\n  \n  base = freq.values.reduce(:+)\n\n  \n  cf = cumulative_freq(freq)\n\n  \n  dict = {}\n  cf.each_pair do |k,v|\n    dict[v] = k\n  end\n\n  \n  lchar = nil\n  (0...base).each do |i|\n    if dict.has_key?(i)\n      lchar = dict[i]\n    elsif lchar != nil\n      dict[i] = lchar\n    end\n  end\n\n  \n  decoded = []\n  (0...base).reverse_each do |i|\n    pow = base**i\n    div = enc/pow\n\n    c  = dict[div]\n    fv = freq[c]\n    cv = cf[c]\n\n    rem = ((enc - pow*cv) / fv)\n\n    enc = rem\n    decoded << c\n  end\n\n  \n  return decoded\nend\n\nradix = 10      \n\n%w(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT).each do |str|\n\n  enc, pow, freq = arithmethic_coding(str.bytes, radix)\n  dec = arithmethic_decoding(enc, radix, pow, freq).map{|b| b.chr }.join\n\n  printf(\"%-25s=> %19s * %d^%s\\n\", str, enc, radix, pow)\n\n  if str != dec\n    raise \"\\tHowever that is incorrect!\"\n  end\nend\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ArithmeticCoding {\n    private static class Triple<A, B, C> {\n        A a;\n        B b;\n        C c;\n\n        Triple(A a, B b, C c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n\n    private static class Freq extends HashMap<Character, Long> {\n        \n    }\n\n    private static Freq cumulativeFreq(Freq freq) {\n        long total = 0;\n        Freq cf = new Freq();\n        for (int i = 0; i < 256; ++i) {\n            char c = (char) i;\n            Long v = freq.get(c);\n            if (v != null) {\n                cf.put(c, total);\n                total += v;\n            }\n        }\n        return cf;\n    }\n\n    private static Triple<BigInteger, Integer, Freq> arithmeticCoding(String str, Long radix) {\n        \n        char[] chars = str.toCharArray();\n\n        \n        Freq freq = new Freq();\n        for (char c : chars) {\n            if (!freq.containsKey(c))\n                freq.put(c, 1L);\n            else\n                freq.put(c, freq.get(c) + 1);\n        }\n\n        \n        Freq cf = cumulativeFreq(freq);\n\n        \n        BigInteger base = BigInteger.valueOf(chars.length);\n\n        \n        BigInteger lower = BigInteger.ZERO;\n\n        \n        BigInteger pf = BigInteger.ONE;\n\n        \n        \n        for (char c : chars) {\n            BigInteger x = BigInteger.valueOf(cf.get(c));\n            lower = lower.multiply(base).add(x.multiply(pf));\n            pf = pf.multiply(BigInteger.valueOf(freq.get(c)));\n        }\n\n        \n        BigInteger upper = lower.add(pf);\n\n        int powr = 0;\n        BigInteger bigRadix = BigInteger.valueOf(radix);\n\n        while (true) {\n            pf = pf.divide(bigRadix);\n            if (pf.equals(BigInteger.ZERO)) break;\n            powr++;\n        }\n\n        BigInteger diff = upper.subtract(BigInteger.ONE).divide(bigRadix.pow(powr));\n        return new Triple<>(diff, powr, freq);\n    }\n\n    private static String arithmeticDecoding(BigInteger num, long radix, int pwr, Freq freq) {\n        BigInteger powr = BigInteger.valueOf(radix);\n        BigInteger enc = num.multiply(powr.pow(pwr));\n        long base = 0;\n        for (Long v : freq.values()) base += v;\n\n        \n        Freq cf = cumulativeFreq(freq);\n\n        \n        Map<Long, Character> dict = new HashMap<>();\n        for (Map.Entry<Character, Long> entry : cf.entrySet()) dict.put(entry.getValue(), entry.getKey());\n\n        \n        long lchar = -1;\n        for (long i = 0; i < base; ++i) {\n            Character v = dict.get(i);\n            if (v != null) {\n                lchar = v;\n            } else if (lchar != -1) {\n                dict.put(i, (char) lchar);\n            }\n        }\n\n        \n        StringBuilder decoded = new StringBuilder((int) base);\n        BigInteger bigBase = BigInteger.valueOf(base);\n        for (long i = base - 1; i >= 0; --i) {\n            BigInteger pow = bigBase.pow((int) i);\n            BigInteger div = enc.divide(pow);\n            Character c = dict.get(div.longValue());\n            BigInteger fv = BigInteger.valueOf(freq.get(c));\n            BigInteger cv = BigInteger.valueOf(cf.get(c));\n            BigInteger diff = enc.subtract(pow.multiply(cv));\n            enc = diff.divide(fv);\n            decoded.append(c);\n        }\n        \n        return decoded.toString();\n    }\n\n    public static void main(String[] args) {\n        long radix = 10;\n        String[] strings = {\"DABDDB\", \"DABDDBBDDBA\", \"ABRACADABRA\", \"TOBEORNOTTOBEORTOBEORNOT\"};\n        String fmt = \"%-25s=> %19s * %d^%s\\n\";\n        for (String str : strings) {\n            Triple<BigInteger, Integer, Freq> encoded = arithmeticCoding(str, radix);\n            String dec = arithmeticDecoding(encoded.a, radix, encoded.b, encoded.c);\n            System.out.printf(fmt, str, encoded.a, radix, encoded.b);\n            if (!Objects.equals(str, dec)) throw new RuntimeException(\"\\tHowever that is incorrect!\");\n        }\n    }\n}\n"}
{"id": 425281, "name": "Playfair cipher", "source": "Translate Ruby to Java: class Playfair\n  Size = 5\n  def initialize(key, missing)\n    @missing = missing.upcase\n    alphabet = ('A'..'Z').to_a.join.upcase.delete(@missing).split''\n    extended = key.upcase.gsub(/[^A-Z]/,'').split('') + alphabet\n    grid = extended.uniq[0...Size*Size].each_slice(Size).to_a\n    coords = {}\n    grid.each_with_index do |row, i|\n      row.each_with_index do |letter, j|\n       coords[letter] = [i,j]\n      end\n    end\n    @encode = {}\n    alphabet.product(alphabet).reject { |a,b| a==b }.each do |a, b|\n      i1, j1 = coords[a]\n      i2, j2 = coords[b]\n      if i1 == i2 then\n         j1 = (j1 + 1) % Size\n         j2 = (j2 + 1) % Size\n      elsif j1 == j2 then\n         i1 = (i1 + 1) % Size\n         i2 = (i2 + 1) % Size\n      else\n         j1, j2 = j2, j1\n      end\n      @encode[\"\n      @decode = @encode.invert\n    end\n  end\n\n  def encode(plaintext) \n    plain = plaintext.upcase.gsub(/[^A-Z]/,'')\n    if @missing == 'J' then\n      plain = plain.gsub(/J/, 'I')\n    else\n      plain = plain.gsub(@missing, 'X')\n    end\n    plain = plain.gsub(/(.)\\1/, '\\1X\\1')\n    if plain.length % 2 == 1 then\n      plain += 'X'\n    end\n    return plain.upcase.split('').each_slice(2).map do |pair|\n      @encode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\n\n  def decode(ciphertext) \n    cipher = ciphertext.upcase.gsub(/[^A-Z]/,'')\n    return cipher.upcase.split('').each_slice(2).map do |pair|\n      @decode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\nend\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 425282, "name": "Playfair cipher", "source": "Translate Ruby to Java: class Playfair\n  Size = 5\n  def initialize(key, missing)\n    @missing = missing.upcase\n    alphabet = ('A'..'Z').to_a.join.upcase.delete(@missing).split''\n    extended = key.upcase.gsub(/[^A-Z]/,'').split('') + alphabet\n    grid = extended.uniq[0...Size*Size].each_slice(Size).to_a\n    coords = {}\n    grid.each_with_index do |row, i|\n      row.each_with_index do |letter, j|\n       coords[letter] = [i,j]\n      end\n    end\n    @encode = {}\n    alphabet.product(alphabet).reject { |a,b| a==b }.each do |a, b|\n      i1, j1 = coords[a]\n      i2, j2 = coords[b]\n      if i1 == i2 then\n         j1 = (j1 + 1) % Size\n         j2 = (j2 + 1) % Size\n      elsif j1 == j2 then\n         i1 = (i1 + 1) % Size\n         i2 = (i2 + 1) % Size\n      else\n         j1, j2 = j2, j1\n      end\n      @encode[\"\n      @decode = @encode.invert\n    end\n  end\n\n  def encode(plaintext) \n    plain = plaintext.upcase.gsub(/[^A-Z]/,'')\n    if @missing == 'J' then\n      plain = plain.gsub(/J/, 'I')\n    else\n      plain = plain.gsub(@missing, 'X')\n    end\n    plain = plain.gsub(/(.)\\1/, '\\1X\\1')\n    if plain.length % 2 == 1 then\n      plain += 'X'\n    end\n    return plain.upcase.split('').each_slice(2).map do |pair|\n      @encode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\n\n  def decode(ciphertext) \n    cipher = ciphertext.upcase.gsub(/[^A-Z]/,'')\n    return cipher.upcase.split('').each_slice(2).map do |pair|\n      @decode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\nend\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 425283, "name": "Word break problem", "source": "Translate Ruby to Java: def split_text_with_dict(text, dict, splited=[])\n  solutions = []\n  dict.each do |word|\n    if text.start_with? word\n      new_text = text.delete_prefix word\n      new_splited = splited.dup<< word\n      if new_text.empty?\n        solutions << new_splited\n      else\n        sols = split_text_with_dict(new_text, dict, new_splited)\n        sols.each { |s| solutions << s } \n      end\n    end\n  end\n  return solutions\nend\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class WordBreak {\n\n    public static void main(String[] args) {\n        List<String> dict = Arrays.asList(\"a\", \"aa\", \"b\", \"ab\", \"aab\");\n        for ( String testString : Arrays.asList(\"aab\", \"aa b\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n        dict = Arrays.asList(\"abc\", \"a\", \"ac\", \"b\", \"c\", \"cb\", \"d\");\n        for ( String testString : Arrays.asList(\"abcd\", \"abbc\", \"abcbcd\", \"acdbc\", \"abcdd\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static List<List<String>> wordBreak(String s, List<String> dictionary) {\n        List<List<String>> matches = new ArrayList<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(new Node(s));\n        while ( ! queue.isEmpty() ) {\n            Node node = queue.remove();\n            \n            if ( node.val.length() == 0 ) {\n                matches.add(node.parsed);\n            }\n            else {\n                for ( String word : dictionary ) {\n                    \n                    if ( node.val.startsWith(word) ) {\n                        String valNew = node.val.substring(word.length(), node.val.length());\n                        List<String> parsedNew = new ArrayList<>();\n                        parsedNew.addAll(node.parsed);\n                        parsedNew.add(word);\n                        queue.add(new Node(valNew, parsedNew));\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    \n    private static class Node {\n        private String val;  \n        private List<String> parsed;  \n        public Node(String initial) {\n            val = initial;\n            parsed = new ArrayList<>();\n        }\n        public Node(String s, List<String> p) {\n            val = s;\n            parsed = p;\n        }\n    }\n\n}\n"}
{"id": 425284, "name": "Create an object_Native demonstration", "source": "Translate Ruby to Java: \n\n\n\n\n\n\n\nclass FencedHash\n\n  \n  \n  \n  \n  \n  \n  \n  def initialize(hash, obj=nil)\n    @default = obj\n    @hash = {}\n    hash.each_pair do |key, value|\n      \n      \n      @hash[key] = [value, value]\n    end\n  end\n\n  def initialize_clone(orig)\n    \n    \n    super\n    copy = {}\n    @hash.each_pair {|key, values| copy[key] = values.clone }\n    @hash = copy\n  end\n\n  def initialize_dup(orig)\n    \n    \n    super\n    copy = {}\n    @hash.each_pair {|key, values| copy[key] = values.dup }\n    @hash = copy\n  end\n\n  \n  \n  def [](key)\n    values = @hash[key]\n    if values\n      values[0]\n    else\n      @default\n    end\n  end\n\n  \n  \n  \n  \n  \n  \n  def []=(key, value)\n    values = @hash[key]\n    if values\n      values[0] = value\n    else\n      raise KeyError, \"fence prevents adding new key: \n    end\n  end\n  alias store []=\n\n  \n  def clear\n    @hash.each_value {|values| values[0] = values[1]}\n    self\n  end\n\n  \n  \n  def delete(key)\n    values = @hash[key]\n    if values\n      old = values[0]\n      values[0] = values[1]\n      old  \n    end    \n  end\n\n  \n  \n  \n  \n  \n  \n  def delete_if\n    if block_given?\n      @hash.each_pair do |key, values|\n        yield(key, values[0]) and values[0] = values[1]\n      end\n      self\n    else\n      enum_for(:delete_if) { @hash.size }\n    end\n  end\n\n  \n  attr_accessor :default\n\n  \n  \n  \n  \n  \n  def each_key(&block)\n    if block\n      @hash.each_key(&block)\n      self\n    else\n      enum_for(:each_key) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  \n  def each_pair\n    if block_given?\n      @hash.each_pair {|key, values| yield [key, values[0]] }\n      self\n    else\n      enum_for(:each_pair) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  def each_value\n    if block_given?\n      @hash.each_value {|values| yield values[0] }\n    else\n      enum_for(:each_value) { @hash.size }\n    end\n  end\n\n  \n  \n  \n  \n  \n  def fetch(*argv)\n    argc = argv.length\n    unless argc.between?(1, 2)\n      raise(ArgumentError,\n            \"wrong number of arguments (\n    end\n    if argc == 2 and block_given?\n      warn(\"\n           \"block supersedes default value argument\")\n    end\n\n    key, default = argv\n    values = @hash[key]\n    if values\n      values[0]\n    elsif block_given?\n      yield key\n    elsif argc == 2\n      default\n    else\n      raise KeyError, \"key not found: \n    end\n  end\n\n  \n  def freeze\n    @hash.each_value {|values| values.freeze }\n    super\n  end\n\n  \n  def has_key?(key)\n    @hash.has_key?(key)\n  end\n  alias include? has_key?\n  alias member? has_key?\n\n  \n  \n  \n  \n  \n  \n  def keep_if\n    if block_given?\n      @hash.each_pair do |key, values|\n        yield(key, values[0]) or values[0] = values[1]\n      end\n      self\n    else\n      enum_for(:keep_if) { @hash.size }\n    end\n  end\n\n  \n  def keys\n    @hash.keys\n  end\n\n  \n  def length\n    @hash.length\n  end\n  alias size length\n\n  \n  def to_h\n    result = Hash.new(@default)\n    @hash.each_pair {|key, values| result[key] = values[0]}\n    result\n  end\n\n  \n  def to_s\n    \"\n  end\n  alias inspect to_s\n\n  \n  def values\n    @hash.each_value.map {|values| values[0]}\n  end\n\n  \n  def values_at(*keys)\n    keys.map {|key| self[key]}\n  end\nend\n", "target": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class ImmutableMap {\n\n    public static void main(String[] args) {\n        Map<String,Integer> hashMap = getImmutableMap();\n        try {\n            hashMap.put(\"Test\", 23);\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to put new value.\");\n        }\n        try {\n            hashMap.clear();\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to clear map.\");\n        }\n        try {\n            hashMap.putIfAbsent(\"Test\", 23);\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to put if absent.\");\n        }\n        \n        for ( String key : hashMap.keySet() ) {\n            System.out.printf(\"key = %s, value = %s%n\", key, hashMap.get(key));\n        }\n    }\n    \n    private static Map<String,Integer> getImmutableMap() {\n        Map<String,Integer> hashMap = new HashMap<>();\n        hashMap.put(\"Key 1\", 34);\n        hashMap.put(\"Key 2\", 105);\n        hashMap.put(\"Key 3\", 144);\n\n        return Collections.unmodifiableMap(hashMap);\n    }\n    \n}\n"}
{"id": 425285, "name": "Decimal floating point number to binary", "source": "Translate Ruby to Java: def dec2bin(dec, precision=16)    \n  int, df = dec.split(\".\")\n  minus = int.delete!(\"-\")\n  bin = (minus ? \"-\" : \"\") + int.to_i.to_s(2) + \".\"\n  if df and df.to_i>0\n    fp = (\".\"+df).to_f\n    digit = 1\n    until fp.zero? or digit>precision\n      fp *= 2\n      n = fp.to_i\n      bin << n.to_s\n      fp -= n\n      digit += 1\n    end\n  else\n    bin << \"0\"\n  end\n  bin\nend\n\ndef bin2dec(bin)              \n  int, df = bin.split(\".\")\n  minus = int.delete!(\"-\")\n  dec = (minus ? \"-\" : \"\") + int.to_i(2).to_s\n  if df\n    dec << (df.to_i(2) / 2.0**(df.size)).to_s[1..-1]\n  else\n    dec << \".0\"\n  end\nend\n\ndata = %w[23.34375 11.90625 -23.34375 -11.90625]\ndata.each do |dec|\n  bin  = dec2bin(dec)\n  dec2 = bin2dec(bin)\n  puts \"%10s => %12s =>%10s\" % [dec, bin, dec2]\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 425286, "name": "Decimal floating point number to binary", "source": "Translate Ruby to Java: def dec2bin(dec, precision=16)    \n  int, df = dec.split(\".\")\n  minus = int.delete!(\"-\")\n  bin = (minus ? \"-\" : \"\") + int.to_i.to_s(2) + \".\"\n  if df and df.to_i>0\n    fp = (\".\"+df).to_f\n    digit = 1\n    until fp.zero? or digit>precision\n      fp *= 2\n      n = fp.to_i\n      bin << n.to_s\n      fp -= n\n      digit += 1\n    end\n  else\n    bin << \"0\"\n  end\n  bin\nend\n\ndef bin2dec(bin)              \n  int, df = bin.split(\".\")\n  minus = int.delete!(\"-\")\n  dec = (minus ? \"-\" : \"\") + int.to_i(2).to_s\n  if df\n    dec << (df.to_i(2) / 2.0**(df.size)).to_s[1..-1]\n  else\n    dec << \".0\"\n  end\nend\n\ndata = %w[23.34375 11.90625 -23.34375 -11.90625]\ndata.each do |dec|\n  bin  = dec2bin(dec)\n  dec2 = bin2dec(bin)\n  puts \"%10s => %12s =>%10s\" % [dec, bin, dec2]\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 425287, "name": "Free polyominoes enumeration", "source": "Translate Ruby to Java: require 'set'\n\ndef translate2origin(poly)\n  \n  minx = poly.map(&:first).min\n  miny = poly.map(&:last).min\n  poly.map{|x,y| [x - minx, y - miny]}.sort\nend\n\ndef rotate90(x,y) [y, -x] end\ndef reflect(x,y)  [-x, y] end\n\n\ndef rotations_and_reflections(poly)\n  [poly,\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| reflect(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n   poly = poly.map{|x,y| rotate90(x,y)},\n          poly.map{|x,y| rotate90(x,y)} ]\nend\n\ndef canonical(poly)\n  rotations_and_reflections(poly).map{|pl| translate2origin(pl)}\nend\n\n\ndef contiguous(x,y)\n  [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]\nend\n\n\ndef new_points(poly)\n  points = []\n  poly.each{|x,y| contiguous(x,y).each{|point| points << point}}\n  (points - poly).uniq\nend\n\ndef new_polys(polys)\n  pattern = Set.new\n  polys.each_with_object([]) do |poly, polyomino|\n    new_points(poly).each do |point|\n      next if pattern.include?(pl = translate2origin(poly + [point]))\n      polyomino << canonical(pl).each{|p| pattern << p}.min\n    end\n  end\nend\n\n\ndef rank(n)\n  case n\n  when 0 then [[]]\n  when 1 then [[[0,0]]]\n  else        new_polys(rank(n-1))\n  end\nend\n\n\ndef text_representation(poly)\n  table = Hash.new(' ')\n  poly.each{|x,y| table[[x,y]] = '\n  maxx = poly.map(&:first).max\n  maxy = poly.map(&:last).max\n  (0..maxx).map{|x| (0..maxy).map{|y| table[[x,y]]}.join}\nend\n\np (0..10).map{|n| rank(n).size}\nn = ARGV[0] ? ARGV[0].to_i : 5\nputs \"\\nAll free polyominoes of rank %d:\" % n\nrank(n).sort.each{|poly| puts text_representation(poly),\"\"}\n", "target": "import java.awt.Point;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport java.util.function.Function;\nimport static java.util.Comparator.comparing;\nimport static java.util.stream.Collectors.toList;\n\npublic class FreePolyominoesEnum {\n    static final List<Function<Point, Point>> transforms = new ArrayList<>();\n\n    static {\n        transforms.add(p -> new Point(p.y, -p.x));\n        transforms.add(p -> new Point(-p.x, -p.y));\n        transforms.add(p -> new Point(-p.y, p.x));\n        transforms.add(p -> new Point(-p.x, p.y));\n        transforms.add(p -> new Point(-p.y, -p.x));\n        transforms.add(p -> new Point(p.x, -p.y));\n        transforms.add(p -> new Point(p.y, p.x));\n    }\n\n    static Point findMinima(List<Point> poly) {\n        return new Point(\n                poly.stream().mapToInt(a -> a.x).min().getAsInt(),\n                poly.stream().mapToInt(a -> a.y).min().getAsInt());\n    }\n\n    static List<Point> translateToOrigin(List<Point> poly) {\n        final Point min = findMinima(poly);\n        poly.replaceAll(p -> new Point(p.x - min.x, p.y - min.y));\n        return poly;\n    }\n\n    static List<List<Point>> rotationsAndReflections(List<Point> poly) {\n        List<List<Point>> lst = new ArrayList<>();\n        lst.add(poly);\n        for (Function<Point, Point> t : transforms)\n            lst.add(poly.stream().map(t).collect(toList()));\n        return lst;\n    }\n\n    static Comparator<Point> byCoords = Comparator.<Point>comparingInt(p -> p.x)\n            .thenComparingInt(p -> p.y);\n\n    static List<Point> normalize(List<Point> poly) {\n        return rotationsAndReflections(poly).stream()\n                .map(lst -> translateToOrigin(lst))\n                .map(lst -> lst.stream().sorted(byCoords).collect(toList()))\n                .min(comparing(Object::toString)) \n                .get();\n    }\n\n    static List<Point> neighborhoods(Point p) {\n        return asList(new Point(p.x - 1, p.y), new Point(p.x + 1, p.y),\n                new Point(p.x, p.y - 1), new Point(p.x, p.y + 1));\n    }\n\n    static List<Point> concat(List<Point> lst, Point pt) {\n        List<Point> r = new ArrayList<>();\n        r.addAll(lst);\n        r.add(pt);\n        return r;\n    }\n\n    static List<Point> newPoints(List<Point> poly) {\n        return poly.stream()\n                .flatMap(p -> neighborhoods(p).stream())\n                .filter(p -> !poly.contains(p))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> constructNextRank(List<Point> poly) {\n        return newPoints(poly).stream()\n                .map(p -> normalize(concat(poly, p)))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> rank(int n) {\n        if (n < 0)\n            throw new IllegalArgumentException(\"n cannot be negative\");\n\n        if (n < 2) {\n            List<List<Point>> r = new ArrayList<>();\n            if (n == 1)\n                r.add(asList(new Point(0, 0)));\n            return r;\n        }\n\n        return rank(n - 1).stream()\n                .parallel()\n                .flatMap(lst -> constructNextRank(lst).stream())\n                .distinct()\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        for (List<Point> poly : rank(5)) {\n            for (Point p : poly)\n                System.out.printf(\"(%d,%d) \", p.x, p.y);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 425288, "name": "Solve triangle solitare puzzle", "source": "Translate Ruby to Java: \nG = [[0,1,3],[0,2,5],[1,3,6],[1,4,8],[2,4,7],[2,5,9],[3,4,5],[3,6,10],[3,7,12],[4,7,11],[4,8,13],[5,8,12],[5,9,14],[6,7,8],[7,8,9],[10,11,12],[11,12,13],[12,13,14],\n     [3,1,0],[5,2,0],[6,3,1],[8,4,1],[7,4,2],[9,5,2],[5,4,3],[10,6,3],[12,7,3],[11,7,4],[13,8,4],[12,8,5],[14,9,5],[8,7,6],[9,8,7],[12,11,10],[13,12,11],[14,13,12]]\nFORMAT = (1..5).map{|i| \" \"*(5-i)+\"%d \"*i+\"\\n\"}.join+\"\\n\"\ndef solve n,i,g\n  return \"Solved\" if i == 1\n  return false unless n[g[0]]==0 and n[g[1]]==1 and n[g[2]]==1\n    e = n.clone; g.each{|n| e[n] = 1 - e[n]}\n    l=false; G.each{|g| l=solve(e,i-1,g); break if l}\n  return l ? \"\nend\nputs FORMAT % (N=[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1])\nl=false; G.each{|g| l=solve(N,N.inject(:+),g); break if l}\nputs l ? l : \"No solution found\"\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\npublic class IQPuzzle {\n\n    public static void main(String[] args) {\n        System.out.printf(\"  \");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\" \u00a0%,6d\", start);\n        }\n        System.out.printf(\"%n\");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\"%2d\", start);\n            Map<Integer,Integer> solutions = solve(start);    \n            for ( int end = 1 ; end < Puzzle.MAX_PEGS ; end++ ) {\n                System.out.printf(\" \u00a0%,6d\", solutions.containsKey(end) ? solutions.get(end) : 0);\n            }\n            System.out.printf(\"%n\");\n        }\n        int moveNum = 0;\n        System.out.printf(\"%nOne Solution:%n\");\n        for ( Move m : oneSolution ) {\n            moveNum++;\n            System.out.printf(\"Move %d = %s%n\", moveNum, m);\n        }\n    }\n    \n    private static List<Move> oneSolution = null;\n    \n    private static Map<Integer, Integer> solve(int emptyPeg) {\n        Puzzle puzzle = new Puzzle(emptyPeg);\n        Map<Integer,Integer> solutions = new HashMap<>();\n        Stack<Puzzle> stack = new Stack<Puzzle>();\n        stack.push(puzzle);\n        while ( ! stack.isEmpty() ) {\n            Puzzle p = stack.pop();\n            if ( p.solved() ) {\n                solutions.merge(p.getLastPeg(), 1, (v1,v2) -> v1 + v2);\n                if ( oneSolution == null ) {\n                    oneSolution = p.moves;\n                }\n                continue;\n            }\n            for ( Move move : p.getValidMoves() ) {\n                Puzzle pMove = p.move(move);\n                stack.add(pMove);\n            }\n        }\n        \n        return solutions;\n    }\n    \n    private static class Puzzle {\n        \n        public static int MAX_PEGS = 16;\n        private boolean[] pegs = new boolean[MAX_PEGS];  \n        \n        private List<Move> moves;\n\n        public Puzzle(int emptyPeg) {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            pegs[emptyPeg] = false;\n            moves = new ArrayList<>();\n        }\n\n        public Puzzle() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            moves = new ArrayList<>();\n        }\n\n        private static Map<Integer,List<Move>> validMoves = new HashMap<>(); \n        static {\n            validMoves.put(1, Arrays.asList(new Move(1, 2, 4), new Move(1, 3, 6)));\n            validMoves.put(2, Arrays.asList(new Move(2, 4, 7), new Move(2, 5, 9)));\n            validMoves.put(3, Arrays.asList(new Move(3, 5, 8), new Move(3, 6, 10)));\n            validMoves.put(4, Arrays.asList(new Move(4, 2, 1), new Move(4, 5, 6), new Move(4, 8, 13), new Move(4, 7, 11)));\n            validMoves.put(5, Arrays.asList(new Move(5, 8, 12), new Move(5, 9, 14)));\n            validMoves.put(6, Arrays.asList(new Move(6, 3, 1), new Move(6, 5, 4), new Move(6, 9, 13), new Move(6, 10, 15)));\n            validMoves.put(7, Arrays.asList(new Move(7, 4, 2), new Move(7, 8, 9)));\n            validMoves.put(8, Arrays.asList(new Move(8, 5, 3), new Move(8, 9, 10)));\n            validMoves.put(9, Arrays.asList(new Move(9, 5, 2), new Move(9, 8, 7)));\n            validMoves.put(10, Arrays.asList(new Move(10, 6, 3), new Move(10, 9, 8)));\n            validMoves.put(11, Arrays.asList(new Move(11, 7, 4), new Move(11, 12, 13)));\n            validMoves.put(12, Arrays.asList(new Move(12, 8, 5), new Move(12, 13, 14)));\n            validMoves.put(13, Arrays.asList(new Move(13, 12, 11), new Move(13, 8, 4), new Move(13, 9, 6), new Move(13, 14, 15)));\n            validMoves.put(14, Arrays.asList(new Move(14, 13, 12), new Move(14, 9, 5)));\n            validMoves.put(15, Arrays.asList(new Move(15, 14, 13), new Move(15, 10, 6)));\n        }\n        \n        public List<Move> getValidMoves() {\n            List<Move> moves = new ArrayList<Move>();\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    for ( Move testMove : validMoves.get(i) ) {\n                        if ( pegs[testMove.jump] && ! pegs[testMove.end] ) {\n                            moves.add(testMove);\n                        }\n                    }\n                }\n            }\n            return moves;\n        }\n\n        public boolean solved() {\n            boolean foundFirstPeg = false;\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    if ( foundFirstPeg ) {\n                        return false;\n                    }\n                    foundFirstPeg = true;\n                }\n            }\n            return true;\n        }\n        \n        public Puzzle move(Move move) {\n            Puzzle p = new Puzzle();\n            if ( ! pegs[move.start] || ! pegs[move.jump] || pegs[move.end] ) {\n                throw new RuntimeException(\"Invalid move.\");\n            }\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                p.pegs[i] = pegs[i];\n            }\n            p.pegs[move.start] = false;\n            p.pegs[move.jump] = false;\n            p.pegs[move.end] = true;\n            for ( Move m : moves ) {\n                p.moves.add(new Move(m.start, m.jump, m.end));\n            }\n            p.moves.add(new Move(move.start, move.jump, move.end));\n            return p;\n        }\n        \n        public int getLastPeg() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    return i;\n                }\n            }\n            throw new RuntimeException(\"ERROR:  Illegal position.\");\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"[\");\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                sb.append(pegs[i] ? 1 : 0);\n                sb.append(\",\");\n            }\n            sb.setLength(sb.length()-1);            \n            sb.append(\"]\");\n            return sb.toString();\n        }\n    }\n    \n    private static class Move {\n        int start;\n        int jump;\n        int end;\n        \n        public Move(int s, int j, int e) {\n            start = s; jump = j; end = e;\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"{\");\n            sb.append(\"s=\" + start);\n            sb.append(\", j=\" + jump);\n            sb.append(\", e=\" + end);\n            sb.append(\"}\");\n            return sb.toString();\n        }\n    }\n\n}\n"}
{"id": 425289, "name": "Partition function P", "source": "Translate Ruby to Java: say partitions(6666)   \n", "target": "import java.math.BigInteger;\n\npublic class PartitionFunction {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        BigInteger result = partitions(6666);\n        long end = System.currentTimeMillis();\n        System.out.println(\"P(6666) = \" + result);\n        System.out.printf(\"elapsed time: %d milliseconds\\n\", end - start);\n    }\n\n    private static BigInteger partitions(int n) {\n        BigInteger[] p = new BigInteger[n + 1];\n        p[0] = BigInteger.ONE;\n        for (int i = 1; i <= n; ++i) {\n            p[i] = BigInteger.ZERO;\n            for (int k = 1; ; ++k) {\n                int j = (k * (3 * k - 1))/2;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n                j += k;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n            }\n        }\n        return p[n];\n    }\n}\n"}
{"id": 425290, "name": "Polynomial synthetic division", "source": "Translate Ruby to Java: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 425291, "name": "Polynomial synthetic division", "source": "Translate Ruby to Java: func extended_synthetic_division(dividend, divisor) {\n    var end = divisor.end\n    var out = dividend.clone\n    var normalizer = divisor[0]\n\n    for i in ^(dividend.len - end) {\n        out[i] /= normalizer\n        var coef = out[i]\n        if (coef != 0) {\n            for j in (1 .. end) {\n                out[i+j] += -(divisor[j] * coef)\n            }\n        }\n    }\n\n    var remainder = out.splice(-end)\n    var quotient = out\n\n    return(quotient, remainder)\n}\n\nvar (n, d) = ([1, -12, 0, -42], [1, -3])\nprint(\"  %s / %s =\" % (n, d))\nprint(\" %s remainder %s\\n\" % extended_synthetic_division(n, d))\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 425292, "name": "Color wheel", "source": "Translate Ruby to Java: def settings\n  size(300, 300)\nend\n\ndef setup\n  sketch_title 'Color Wheel'\n  background(0)\n  radius = width / 2.0\n  center = width / 2\n  grid(width, height) do |x, y|\n    rx = x - center\n    ry = y - center\n    sat = Math.hypot(rx, ry) / radius\n    if sat <= 1.0\n      hue = ((Math.atan2(ry, rx) / PI) + 1) / 2.0\n      color_mode(HSB)\n      col = color((hue * 255).to_i, (sat * 255).to_i, 255)\n      set(x, y, col)\n    end\n  end\nend\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class ColorWheel {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                ColorWheelFrame frame = new ColorWheelFrame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class ColorWheelFrame extends JFrame {\n        private ColorWheelFrame() {\n            super(\"Color Wheel\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            getContentPane().add(new ColorWheelPanel());\n            pack();\n        }\n    }\n\n    private static class ColorWheelPanel extends JComponent {\n        private ColorWheelPanel() {\n            setPreferredSize(new Dimension(400, 400));\n        }\n        public void paint(Graphics g) {\n            Graphics2D g2 = (Graphics2D)g;\n            int w = getWidth();\n            int h = getHeight();\n            int margin = 10;\n            int radius = (Math.min(w, h) - 2 * margin)/2;\n            int cx = w/2;\n            int cy = h/2;\n            float[] dist = {0.F, 1.0F};\n            g2.setColor(Color.BLACK);\n            g2.fillRect(0, 0, w, h);\n            for (int angle = 0; angle < 360; ++angle) {\n                Color color = hsvToRgb(angle, 1.0, 1.0);\n                Color[] colors = {Color.WHITE, color};\n                RadialGradientPaint paint = new RadialGradientPaint(cx, cy,\n                        radius, dist, colors);\n                g2.setPaint(paint);\n                g2.fillArc(cx - radius, cy - radius, radius*2, radius*2,\n                        angle, 1);\n            }\n        }\n    }\n\n    private static Color hsvToRgb(int h, double s, double v) {\n        double hp = h/60.0;\n        double c = s * v;\n        double x = c * (1 - Math.abs(hp % 2.0 - 1));\n        double m = v - c;\n        double r = 0, g = 0, b = 0;\n        if (hp <= 1) {\n            r = c;\n            g = x;\n        } else if (hp <= 2) {\n            r = x;\n            g = c;\n        } else if (hp <= 3) {\n            g = c;\n            b = x;\n        } else if (hp <= 4) {\n            g = x;\n            b = c;\n        } else if (hp <= 5) {\n            r = x;\n            b = c;\n        } else {\n            r = c;\n            b = x;\n        }\n        r += m;\n        g += m;\n        b += m;\n        return new Color((int)(r * 255), (int)(g * 255), (int)(b * 255));\n    }\n}\n"}
{"id": 425293, "name": "Factorial primes", "source": "Translate Ruby to Java: require 'openssl'\n\nfactorial_primes = Enumerator.new do |y|\n  fact = 1\n  (1..).each do |i|\n    fact *= i\n    y << [i, \"- 1\", fact - 1] if OpenSSL::BN.new(fact - 1).prime?\n    y << [i, \"+ 1\", fact + 1] if OpenSSL::BN.new(fact + 1).prime?\n  end\nend\n\nfactorial_primes.first(30).each do |a|\n  s = a.last.to_s\n  if s.size > 40 then \n    puts \"%d! %s = \" % a.first(2) + \"\n  else\n    puts \"%d! %s = %d\" % a \n  end\nend\n", "target": "public class MainApp {\n    public static void main(String[] args) {\n        int countOfPrimes = 0;\n        final int targetCountOfPrimes = 10;\n        long f = 1;\n        while (countOfPrimes < targetCountOfPrimes) {\n            long factorialNum = getFactorial(f);\n            boolean primePlus = isPrime(factorialNum + 1);\n            boolean primeMinus = isPrime(factorialNum - 1);\n            if (primeMinus) {\n                countOfPrimes++;\n                System.out.println(countOfPrimes + \": \" + factorialNum + \"! - 1 = \" + (factorialNum - 1));\n\n            }\n            if (primePlus  && f > 1) {\n                countOfPrimes++;\n                System.out.println(countOfPrimes + \": \" + factorialNum + \"! + 1 = \" + (factorialNum + 1));\n            }\n            f++;\n        }\n    }\n\n    private static long getFactorial(long f) {\n        long factorial = 1;\n        for (long i = 1; i < f; i++) {\n            factorial *= i;\n        }\n        return factorial;\n    }\n\n    private static boolean isPrime(long num) {\n        if (num < 2) {return false;}\n        for (long i = 2; i < num; i++) {\n            if (num % i == 0) {return false;}\n        }\n        return true;\n    }\n}\n"}
{"id": 425294, "name": "Pseudorandom number generator image", "source": "Translate Ruby to Java: require('GD')\n\nvar img = %O<GD::Image>.new(500, 500, 1)\n\nfor y in (0..500), x in (0..500) {\n    var color = img.colorAllocate(255.irand, 255.irand, 255.irand)\n    img.setPixel(x, y, color)\n}\n\nFile(\"image500.png\").write(img.png, :raw)\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.Scanner;\n\n\npublic class csprngBBS {\n    public static Scanner input = new Scanner(System.in);\n    private static final String fileformat = \"png\";\n    private static String bitsStri = \"\";\n    private static String parityEven = \"\";\n    private static String leastSig = \"\";\n    private static String randomJavaUtil = \"\";\n    private static int width = 0;\n    private static int BIT_LENGTH = 0;\n    private static final Random rand = new SecureRandom();\n    private static BigInteger p = null; \n    private static BigInteger q = null; \n    private static BigInteger m = null;\n    private static BigInteger seed = null; \n    private static BigInteger seedFinal = null;\n    private static final Random randMathUtil = new SecureRandom();\n    public static void main(String[] args) throws IOException {\n        System.out.print(\"Width: \");\n        width = input.nextInt();\n        System.out.print(\"Bit-Length: \");\n        BIT_LENGTH = input.nextInt();\n        System.out.print(\"Generator format: \");\n        String useGenerator = input.next();\n        p = BigInteger.probablePrime(BIT_LENGTH, rand);\n        q = BigInteger.probablePrime(BIT_LENGTH, rand);\n        m = p.multiply(q);\n        seed = BigInteger.probablePrime(BIT_LENGTH,rand);\n        seedFinal = seed.add(BigInteger.ZERO);\n        if(useGenerator.contains(\"parity\") && useGenerator.contains(\"significant\")) {\n            findLeastSignificant();\n            findBitParityEven();\n            createImage(parityEven, \"parityEven\");\n            createImage(leastSig, \"significant\");\n        }\n\n        if(useGenerator.contains(\"parity\") && !useGenerator.contains(\"significant\")){\n            findBitParityEven();\n        }\n\n        if(useGenerator.contains(\"significant\") && !useGenerator.contains(\"parity\")){\n            findLeastSignificant();\n            createImage(leastSig, \"significant\");\n        }\n\n        if(useGenerator.contains(\"util\")){\n            findRandomJava(randMathUtil);\n            createImage(randomJavaUtil, \"randomUtilJava\");\n        }\n    }\n    public static void findRandomJava(Random random){\n        for(int x = 1; x <= Math.pow(width, 2); x++){\n            randomJavaUtil += random.nextInt(2);\n        }\n    }\n\n    public static void findBitParityEven(){\n        for(int x = 1; x <= Math.pow(width, 2); x++) {\n            seed = seed.pow(2).mod(m);\n            bitsStri = convertBinary(seed);\n            char[] bits = bitsStri.toCharArray();\n            int counter = 0;\n            for (char bit : bits) {\n                if (bit == '1') {\n                    counter++;\n                }\n            }\n            if (counter % 2 != 0) {\n                parityEven += \"1\";\n            } else {\n                parityEven += \"0\";\n            }\n        }\n    }\n\n    public static void findLeastSignificant(){\n        seed = seedFinal;\n        for(int x = 1; x <= Math.pow(width, 2); x++){\n            seed = seed.pow(2).mod(m);\n            leastSig += bitsStri.substring(bitsStri.length() - 1);\n        }\n    }\n\n    public static String convertBinary(BigInteger value){\n        StringBuilder total = new StringBuilder();\n        BigInteger two = BigInteger.TWO;\n        while(value.compareTo(BigInteger.ZERO) > 0){\n            total.append(value.mod(two));\n            value = value.divide(two);\n        }\n        return total.reverse().toString();\n    }\n\n    public static void createImage(String useThis, String fileName) throws IOException {\n        int length = csprngBBS.width;\n        \n        BufferedImage bufferedImage = new BufferedImage(length, length, 1);\n        \n        Graphics2D g2d = bufferedImage.createGraphics();\n        for (int y = 1; y <= length; y++) {\n            for (int x = 1; x <= length; x++) {\n                if (useThis.startsWith(\"1\")) {\n                    useThis = useThis.substring(1);\n                    g2d.setColor(Color.BLACK);\n                    g2d.fillRect(x, y, 1, 1);\n                } else if (useThis.startsWith(\"0\")) {\n                    useThis = useThis.substring(1);\n                    g2d.setColor(Color.WHITE);\n                    g2d.fillRect(x, y, 1, 1);\n                }\n            }\n            System.out.print(y + \"\\t\");\n        }\n        \n        g2d.dispose();\n        \n        File file = new File(\"REPLACEFILEPATHHERE\" + fileName + \".\" + fileformat);\n        ImageIO.write(bufferedImage, fileformat, file);\n    }\n}\n"}
{"id": 425295, "name": "Find duplicate files", "source": "Translate Ruby to Java: require 'digest/md5'\n\ndef find_duplicate_files(dir)\n  puts \"\\nDirectory\u00a0: \n  Dir.chdir(dir) do\n    file_size = Dir.foreach('.').select{|f| FileTest.file?(f)}.group_by{|f| File.size(f)}\n    file_size.each do |size, files|\n      next if files.size==1\n      files.group_by{|f| Digest::MD5.file(f).to_s}.each do |md5,fs|\n        next if fs.size==1\n        puts \"  --------------------------------------------\"\n        fs.each{|file| puts \"  \n      end\n    end\n  end\nend\n\nfind_duplicate_files(\"/Windows/System32\")\n", "target": "import java.io.*;\nimport java.nio.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class DuplicateFiles {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.println(\"Directory name and minimum file size are required.\");\n            System.exit(1);\n        }\n        try {\n            findDuplicateFiles(args[0], Long.parseLong(args[1]));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void findDuplicateFiles(String directory, long minimumSize)\n        throws IOException, NoSuchAlgorithmException {\n        System.out.println(\"Directory: '\" + directory + \"', minimum size: \" + minimumSize + \" bytes.\");\n        Path path = FileSystems.getDefault().getPath(directory);\n        FileVisitor visitor = new FileVisitor(path, minimumSize);\n        Files.walkFileTree(path, visitor);\n        System.out.println(\"The following sets of files have the same size and checksum:\");\n        for (Map.Entry<FileKey, Map<Object, List<String>>> e : visitor.fileMap_.entrySet()) {\n            Map<Object, List<String>> map = e.getValue();\n            if (!containsDuplicates(map))\n                continue;\n            List<List<String>> fileSets = new ArrayList<>(map.values());\n            for (List<String> files : fileSets)\n                Collections.sort(files);\n            Collections.sort(fileSets, new StringListComparator());\n            FileKey key = e.getKey();\n            System.out.println();\n            System.out.println(\"Size: \" + key.size_ + \" bytes\");\n            for (List<String> files : fileSets) {\n                for (int i = 0, n = files.size(); i < n; ++i) {\n                    if (i > 0)\n                        System.out.print(\" = \");\n                    System.out.print(files.get(i));\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    private static class StringListComparator implements Comparator<List<String>> {\n        public int compare(List<String> a, List<String> b) {\n            int len1 = a.size(), len2 = b.size();\n            for (int i = 0; i < len1 && i < len2; ++i) {\n                int c = a.get(i).compareTo(b.get(i));\n                if (c != 0)\n                    return c;\n            }\n            return Integer.compare(len1, len2);\n        }\n    }\n\n    private static boolean containsDuplicates(Map<Object, List<String>> map) {\n        if (map.size() > 1)\n            return true;\n        for (List<String> files : map.values()) {\n            if (files.size() > 1)\n                return true;\n        }\n        return false;\n    }\n\n    private static class FileVisitor extends SimpleFileVisitor<Path> {\n        private MessageDigest digest_;\n        private Path directory_;\n        private long minimumSize_;\n        private Map<FileKey, Map<Object, List<String>>> fileMap_ = new TreeMap<>();\n\n        private FileVisitor(Path directory, long minimumSize) throws NoSuchAlgorithmException {\n            directory_ = directory;\n            minimumSize_ = minimumSize;\n            digest_ = MessageDigest.getInstance(\"MD5\");\n        }\n\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            if (attrs.size() >= minimumSize_) {\n                FileKey key = new FileKey(file, attrs, getMD5Sum(file));\n                Map<Object, List<String>> map = fileMap_.get(key);\n                if (map == null)\n                    fileMap_.put(key, map = new HashMap<>());\n                List<String> files = map.get(attrs.fileKey());\n                if (files == null)\n                    map.put(attrs.fileKey(), files = new ArrayList<>());\n                Path relative = directory_.relativize(file);\n                files.add(relative.toString());\n            }\n            return FileVisitResult.CONTINUE;\n        }\n\n        private byte[] getMD5Sum(Path file) throws IOException {\n            digest_.reset();\n            try (InputStream in = new FileInputStream(file.toString())) {\n                byte[] buffer = new byte[8192];\n                int bytes;\n                while ((bytes = in.read(buffer)) != -1) {\n                    digest_.update(buffer, 0, bytes);\n                }\n            }\n            return digest_.digest();\n        }\n    }\n\n    private static class FileKey implements Comparable<FileKey> {\n        private byte[] hash_;\n        private long size_;\n\n        private FileKey(Path file, BasicFileAttributes attrs, byte[] hash) throws IOException {\n            size_ = attrs.size();\n            hash_ = hash;\n        }\n\n        public int compareTo(FileKey other) {\n            int c = Long.compare(other.size_, size_);\n            if (c == 0)\n                c = hashCompare(hash_, other.hash_);\n            return c;\n        }\n    }\n\n    private static int hashCompare(byte[] a, byte[] b) {\n        int len1 = a.length, len2 = b.length;\n        for (int i = 0; i < len1 && i < len2; ++i) {\n            int c = Byte.compare(a[i], b[i]);\n            if (c != 0)\n                return c;\n        }\n        return Integer.compare(len1, len2);\n    }\n}\n"}
{"id": 425296, "name": "Legendre prime counting function", "source": "Translate Ruby to Java: require 'prime'\n\ndef pi(n)\n  @pr = Prime.each(Integer.sqrt(n)).to_a\n  a = @pr.size\n  case n\n    when 0,1 then 0\n    when 2 then 1\n    else phi(n,a) + a - 1\n  end\nend\n\ndef phi(x,a)\n  case a\n    when 0 then x\n    when 1 then x-(x>>1)\n    else  \n    pa = @pr[a-1]\n    return 1 if x <= pa\n    phi(x, a-1)- phi(x/pa, a-1)\n  end\nend\n\n(0..9).each {|n| puts \"10E\n", "target": "import java.util.*;\n\npublic class LegendrePrimeCounter {\n    public static void main(String[] args) {\n        LegendrePrimeCounter counter = new LegendrePrimeCounter(1000000000);\n        for (int i = 0, n = 1; i < 10; ++i, n *= 10)\n            System.out.printf(\"10^%d\\t%d\\n\", i, counter.primeCount((n)));\n    }\n\n    private List<Integer> primes;\n\n    public LegendrePrimeCounter(int limit) {\n        primes = generatePrimes((int)Math.sqrt((double)limit));\n    }\n\n    public int primeCount(int n) {\n        if (n < 2)\n            return 0;\n        int a = primeCount((int)Math.sqrt((double)n));\n        return phi(n, a) + a - 1;\n    }\n\n    private int phi(int x, int a) {\n        if (a == 0)\n            return x;\n        if (a == 1)\n            return x - (x >> 1);\n        int pa = primes.get(a - 1);\n        if (x <= pa)\n            return 1;\n        return phi(x, a - 1) - phi(x / pa, a - 1);\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 425297, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Ruby to Java: require \"open-uri\"\nrequire \"cgi\" \n\ntasks  = [\"Greatest_common_divisor\", \"Greatest_element_of_a_list\", \"Greatest_subsequential_sum\"]\npart_uri  = \"http://rosettacode.org/wiki?action=raw&title=\"\nReport = Struct.new(:count, :tasks)\nresult = Hash.new{|h,k| h[k] = Report.new(0, [])}\n\ntasks.each do |task|\n  puts \"processing \n  current_lang = \"no language\"\n  open(part_uri + CGI.escape(task)).each_line do |line|\n    current_lang = Regexp.last_match[\"lang\"] if /==\\{\\{header\\|(?<lang>.+)\\}\\}==/ =~ line \n    num_no_langs = line.scan(/<lang\\s*>/).size\n    if num_no_langs > 0 then\n      result[current_lang].count += num_no_langs\n      result[current_lang].tasks << task\n    end\n  end\nend\n\nputs \"\\n\nresult.each{|k,v| puts \"\n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class FindBareTags {\n    private static final String BASE = \"http:\n\n    private static final Pattern TITLE_PATTERN = Pattern.compile(\"\\\"title\\\": \\\"([^\\\"]+)\\\"\");\n    private static final Pattern HEADER_PATTERN = Pattern.compile(\"==\\\\{\\\\{header\\\\|([^}]+)}}==\");\n    private static final Predicate<String> BARE_PREDICATE = Pattern.compile(\"<lang>\").asPredicate();\n\n    public static void main(String[] args) throws Exception {\n        var client = HttpClient.newBuilder().build();\n\n        URI titleUri = URI.create(BASE + \"/mw/api.php?action=query&list=categorymembers&cmtitle=Category:Programming_Tasks\");\n        var titleRequest = HttpRequest.newBuilder(titleUri).GET().build();\n\n        var titleResponse = client.send(titleRequest, HttpResponse.BodyHandlers.ofString());\n        if (titleResponse.statusCode() == 200) {\n            var titleBody = titleResponse.body();\n\n            var titleMatcher = TITLE_PATTERN.matcher(titleBody);\n            var titleList = titleMatcher.results().map(mr -> mr.group(1)).collect(Collectors.toList());\n\n            var countMap = new HashMap<String, Integer>();\n            for (String title : titleList) {\n                var pageUri = new URI(\"http\", null, \"\n                var pageRequest = HttpRequest.newBuilder(pageUri).GET().build();\n                var pageResponse = client.send(pageRequest, HttpResponse.BodyHandlers.ofString());\n                if (pageResponse.statusCode() == 200) {\n                    var pageBody = pageResponse.body();\n\n                    AtomicReference<String> language = new AtomicReference<>(\"no language\");\n                    pageBody.lines().forEach(line -> {\n                        var headerMatcher = HEADER_PATTERN.matcher(line);\n                        if (headerMatcher.matches()) {\n                            language.set(headerMatcher.group(1));\n                        } else if (BARE_PREDICATE.test(line)) {\n                            int count = countMap.getOrDefault(language.get(), 0) + 1;\n                            countMap.put(language.get(), count);\n                        }\n                    });\n                } else {\n                    System.out.printf(\"Got a %d status code%n\", pageResponse.statusCode());\n                }\n            }\n\n            for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n                System.out.printf(\"%d in %s%n\", entry.getValue(), entry.getKey());\n            }\n        } else {\n            System.out.printf(\"Got a %d status code%n\", titleResponse.statusCode());\n        }\n    }\n}\n"}
{"id": 425298, "name": "Wagstaff primes", "source": "Translate Ruby to Java: require 'prime'\nrequire 'gmp'\n\nwagstaffs = Enumerator.new do |y|\n  odd_primes = Prime.each\n  odd_primes.next \n  loop do\n    p = odd_primes.next\n    candidate = (2 ** p + 1)/3\n    y << [p, candidate] unless GMP::Z.new(candidate).probab_prime?.zero?\n  end\nend\n\n10.times{puts \"%5d - %s\" % wagstaffs.next}\n14.times{puts \"%5d\" % wagstaffs.next.first}\n", "target": "import java.math.BigInteger; \n\npublic class Main {\n  public static void main(String[] args) {\n    BigInteger d = new BigInteger(\"3\"), a;\n    int lmt = 25, sl, c = 0;\n    for (int i = 3; i < 5808; ) {\n      a = BigInteger.ONE.shiftLeft(i).add(BigInteger.ONE).divide(d);\n      if (a.isProbablePrime(1)) {\n        System.out.printf(\"%2d %4d \", ++c, i);\n        String s = a.toString(); sl = s.length();\n        if (sl < lmt) System.out.println(a);\n        else System.out.println(s.substring(0, 11) + \"..\" + s.substring(sl - 11, sl) + \" \" + sl + \" digits\");\n      }\n      i = BigInteger.valueOf(i).nextProbablePrime().intValue();\n    }\n  }\n}\n"}
{"id": 425299, "name": "Wagstaff primes", "source": "Translate Ruby to Java: require 'prime'\nrequire 'gmp'\n\nwagstaffs = Enumerator.new do |y|\n  odd_primes = Prime.each\n  odd_primes.next \n  loop do\n    p = odd_primes.next\n    candidate = (2 ** p + 1)/3\n    y << [p, candidate] unless GMP::Z.new(candidate).probab_prime?.zero?\n  end\nend\n\n10.times{puts \"%5d - %s\" % wagstaffs.next}\n14.times{puts \"%5d\" % wagstaffs.next.first}\n", "target": "import java.math.BigInteger; \n\npublic class Main {\n  public static void main(String[] args) {\n    BigInteger d = new BigInteger(\"3\"), a;\n    int lmt = 25, sl, c = 0;\n    for (int i = 3; i < 5808; ) {\n      a = BigInteger.ONE.shiftLeft(i).add(BigInteger.ONE).divide(d);\n      if (a.isProbablePrime(1)) {\n        System.out.printf(\"%2d %4d \", ++c, i);\n        String s = a.toString(); sl = s.length();\n        if (sl < lmt) System.out.println(a);\n        else System.out.println(s.substring(0, 11) + \"..\" + s.substring(sl - 11, sl) + \" \" + sl + \" digits\");\n      }\n      i = BigInteger.valueOf(i).nextProbablePrime().intValue();\n    }\n  }\n}\n"}
{"id": 425300, "name": "Palindromic gapful numbers", "source": "Translate Ruby to Java: def palindromesgapful(digit, pow)\n  r1 = (10_u64**pow + 1) * digit\n  r2 = 10_u64**pow * (digit + 1)\n  nn = digit * 11\n  (r1...r2).select { |i| n = i.to_s; n == n.reverse && i.divisible_by?(nn) }\nend\n\ndef digitscount(digit, count)\n  pow  = 2\n  nums = [] of UInt64\n  while nums.size < count\n    nums += palindromesgapful(digit, pow)\n    pow += 1\n  end\n  nums[0...count]\nend\n\ncount = 20\nputs \"First 20 palindromic gapful numbers ending with:\"\n(1..9).each { |digit| print \"\n\ncount = 100\nputs \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n\ncount = 1000\nputs \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 425301, "name": "Palindromic gapful numbers", "source": "Translate Ruby to Java: def palindromesgapful(digit, pow)\n  r1 = (10_u64**pow + 1) * digit\n  r2 = 10_u64**pow * (digit + 1)\n  nn = digit * 11\n  (r1...r2).select { |i| n = i.to_s; n == n.reverse && i.divisible_by?(nn) }\nend\n\ndef digitscount(digit, count)\n  pow  = 2\n  nums = [] of UInt64\n  while nums.size < count\n    nums += palindromesgapful(digit, pow)\n    pow += 1\n  end\n  nums[0...count]\nend\n\ncount = 20\nputs \"First 20 palindromic gapful numbers ending with:\"\n(1..9).each { |digit| print \"\n\ncount = 100\nputs \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n\ncount = 1000\nputs \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n(1..9).each { |digit| print \"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 425302, "name": "Chernick's Carmichael numbers", "source": "Translate Ruby to Java: func chernick_carmichael_factors (n, m) {\n    [6*m + 1, 12*m + 1, {|i| 2**i * 9*m + 1 }.map(1 .. n-2)...]\n}\n\nfunc is_chernick_carmichael (n, m) {\n    (n == 2) ? (is_prime(6*m + 1) && is_prime(12*m + 1))\n             : (is_prime(2**(n-2) * 9*m + 1) && __FUNC__(n-1, m))\n}\n\nfunc chernick_carmichael_number(n, callback) {\n    var multiplier = (n>4 ? 2**(n-4) : 1)\n    var m = (1..Inf -> first {|m| is_chernick_carmichael(n, m * multiplier) })\n    var f = chernick_carmichael_factors(n, m * multiplier)\n    callback(f...)\n}\n\nfor n in (3..9) {\n    chernick_carmichael_number(n, {|*f| say \"a(\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ChernicksCarmichaelNumbers {\n\n    public static void main(String[] args) {\n        for ( long n = 3 ; n < 10 ; n++ ) {\n            long m = 0;\n            boolean foundComposite = true;\n            List<Long> factors = null;\n            while ( foundComposite ) {\n                m += (n <= 4 ? 1 : (long) Math.pow(2, n-4) * 5);\n                factors = U(n, m);\n                foundComposite = false;\n                for ( long factor : factors ) {\n                    if ( ! isPrime(factor) ) {\n                        foundComposite = true;\n                        break;\n                    }\n                }\n            }\n            System.out.printf(\"U(%d, %d) = %s = %s %n\", n, m, display(factors), multiply(factors));\n        }\n    }\n    \n    private static String display(List<Long> factors) {\n        return factors.toString().replace(\"[\", \"\").replace(\"]\", \"\").replaceAll(\", \", \" * \");\n    }\n    \n    private static BigInteger multiply(List<Long> factors) {\n        BigInteger result = BigInteger.ONE;\n        for ( long factor : factors ) {\n            result = result.multiply(BigInteger.valueOf(factor));\n        }\n        return result;\n    }\n    \n    private static List<Long> U(long n, long m) {\n        List<Long> factors = new ArrayList<>();\n        factors.add(6*m + 1);\n        factors.add(12*m + 1);\n        for ( int i = 1 ; i <= n-2 ; i++ ) {\n            factors.add(((long)Math.pow(2, i)) * 9 * m + 1);\n        }\n        return factors;\n    }\n\n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 425303, "name": "Wilson primes of order n", "source": "Translate Ruby to Java: require \"prime\"\n  \nmodule Modulo\n  refine Integer do\n    def factorial_mod(m) = (1..self).inject(1){|prod, n| (prod *= n) % m }\n  end\nend\n\nusing Modulo\nprimes = Prime.each(11000).to_a\n\n(1..11).each do |n| \n  res = primes.select do |pr|\n    prpr = pr*pr\n    ((n-1).factorial_mod(prpr) * (pr-n).factorial_mod(prpr) - (-1)**n) % (prpr) == 0\n  end\n  puts \"\nend\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class WilsonPrimes {\n    public static void main(String[] args) {\n        final int limit = 11000;\n        BigInteger[] f = new BigInteger[limit];\n        f[0] = BigInteger.ONE;\n        BigInteger factorial = BigInteger.ONE;\n        for (int i = 1; i < limit; ++i) {\n            factorial = factorial.multiply(BigInteger.valueOf(i));\n            f[i] = factorial;\n        }\n        List<Integer> primes = generatePrimes(limit);\n        System.out.printf(\" n | Wilson primes\\n--------------------\\n\");\n        BigInteger s = BigInteger.valueOf(-1);\n        for (int n = 1; n <= 11; ++n) {\n            System.out.printf(\"%2d |\", n);\n            for (int p : primes) {\n                if (p >= n && f[n - 1].multiply(f[p - n]).subtract(s)\n                        .mod(BigInteger.valueOf(p * p))\n                        .equals(BigInteger.ZERO))\n                    System.out.printf(\" %d\", p);\n            }\n            s = s.negate();\n            System.out.println();\n        }\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 425304, "name": "Sphenic numbers", "source": "Translate Ruby to Java: require 'prime'\n\nclass Integer\n  def sphenic? = prime_division.map(&:last) == [1, 1, 1]\nend\n\nsphenics = (1..).lazy.select(&:sphenic?)\n\nn = 1000\nputs \"Sphenic numbers less than \np sphenics.take_while{|s| s < n}.to_a\n\nn = 10_000\nputs \"\\nSphenic triplets less than \nsps = sphenics.take_while{|s| s < n}.to_a\nsps.each_cons(3).select{|a, b, c| a + 2 == c}.each{|ar| p ar}\n\nn = 1_000_000\nsphenics_below10E6 = sphenics.take_while{|s| s < n}.to_a\nputs \"\\nThere are \ntarget = sphenics_below10E6[200_000-1]\nputs \"\\nThe 200000th sphenic number is \ntriplets = sphenics_below10E6.each_cons(3).select{|a,b,c|a+2 == c}\nputs \"\\nThe 5000th sphenic triplet is \n", "target": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SphenicNumbers {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        final int imax = limit / 6;\n        boolean[] sieve = primeSieve(imax + 1);\n        boolean[] sphenic = new boolean[limit + 1];\n        for (int i = 0; i <= imax; ++i) {\n            if (!sieve[i])\n                continue;\n            int jmax = Math.min(imax, limit / (i * i));\n            if (jmax <= i)\n                break;\n            for (int j = i + 1; j <= jmax; ++j) {\n                if (!sieve[j])\n                    continue;\n                int p = i * j;\n                int kmax = Math.min(imax, limit / p);\n                if (kmax <= j)\n                    break;\n                for (int k = j + 1; k <= kmax; ++k) {\n                    if (!sieve[k])\n                        continue;\n                    assert(p * k <= limit);\n                    sphenic[p * k] = true;\n                }\n            }\n        }\n    \n        System.out.println(\"Sphenic numbers < 1000:\");\n        for (int i = 0, n = 0; i < 1000; ++i) {\n            if (!sphenic[i])\n                continue;\n            ++n;\n            System.out.printf(\"%3d%c\", i, n % 15 == 0 ? '\\n' : ' ');\n        }\n    \n        System.out.println(\"\\nSphenic triplets < 10,000:\");\n        for (int i = 0, n = 0; i < 10000; ++i) {\n            if (i > 1 && sphenic[i] && sphenic[i - 1] && sphenic[i - 2]) {\n                ++n;\n                System.out.printf(\"(%d, %d, %d)%c\",\n                                  i - 2, i - 1, i, n % 3 == 0 ? '\\n' : ' ');\n            }\n        }\n    \n        int count = 0, triplets = 0, s200000 = 0, t5000 = 0;\n        for (int i = 0; i < limit; ++i) {\n            if (!sphenic[i])\n                continue;\n            ++count;\n            if (count == 200000)\n                s200000 = i;\n            if (i > 1 && sphenic[i - 1] && sphenic[i - 2]) {\n                ++triplets;\n                if (triplets == 5000)\n                    t5000 = i;\n            }\n        }\n    \n        System.out.printf(\"\\nNumber of sphenic numbers < 1,000,000: %d\\n\", count);\n        System.out.printf(\"Number of sphenic triplets < 1,000,000: %d\\n\", triplets);\n    \n        List<Integer> factors = primeFactors(s200000);\n        assert(factors.size() == 3);\n        System.out.printf(\"The 200,000th sphenic number: %d = %d * %d * %d\\n\",\n                          s200000, factors.get(0), factors.get(1),\n                          factors.get(2));\n        System.out.printf(\"The 5,000th sphenic triplet: (%d, %d, %d)\\n\",\n                          t5000 - 2, t5000 - 1, t5000);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3, sq = 9; sq < limit; p += 2) {\n            if (sieve[p]) {\n                for (int q = sq; q < limit; q += p << 1)\n                    sieve[q] = false;\n            }\n            sq += (p + 1) << 2;\n        }\n        return sieve;\n    }\n    \n    private static List<Integer> primeFactors(int n) {\n        List<Integer> factors = new ArrayList<>();\n        if (n > 1 && (n & 1) == 0) {\n            factors.add(2);\n            while ((n & 1) == 0)\n                n >>= 1;\n        }\n        for (int p = 3; p * p <= n; p += 2) {\n            if (n % p == 0) {\n                factors.add(p);\n                while (n % p == 0)\n                    n /= p;\n            }\n        }\n        if (n > 1)\n            factors.add(n);\n        return factors;\n    }\n}\n"}
{"id": 425305, "name": "XML validation", "source": "Translate Ruby to Java: require('XML::LibXML')\n\nfunc is_valid_xml(str, schema) {\n\n    var parser    = %O<XML::LibXML>.new\n    var xmlschema = %O<XML::LibXML::Schema>.new(string => schema)\n\n    try {\n        xmlschema.validate(parser.parse_string(str))\n        true\n    } catch {\n        false\n    }\n}\n\nvar good_xml = '<a>5</a>'\nvar bad_xml  = '<a>5<b>foobar</b></a>'\n\nvar xmlschema_markup = <<'END'\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\n[good_xml, bad_xml].each { |xml|\n    say \"is_valid_xml(\n}\n", "target": "import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport javax.xml.ws.Holder;\n\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\npublic class XmlValidation {\n\tpublic static void main(String... args) throws MalformedURLException {\n\t\tURL schemaLocation = new URL(\"http:\n\t\tURL documentLocation = new URL(\"http:\n\t\tif (validate(schemaLocation, documentLocation)) {\n\t\t\tSystem.out.println(\"document is valid\");\n\t\t} else {\n\t\t\tSystem.out.println(\"document is invalid\");\n\t\t}\n\t}\n\n\t\n\tpublic static boolean minimalValidate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\n\tpublic static boolean validate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\tfinal Holder<Boolean> valid = new Holder<>(true);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\t\n\t\t\tvalidator.setErrorHandler(new ErrorHandler(){\n\t\t\t\t@Override\n\t\t\t\tpublic void warning(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"warning: \" + exception.getMessage());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void error(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"error: \" + exception.getMessage());\n\t\t\t\t\tvalid.value = false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void fatalError(SAXParseException exception) throws SAXException {\n\t\t\t\t\tSystem.out.println(\"fatal error: \" + exception.getMessage());\n\t\t\t\t\tthrow exception;\n\t\t\t\t}});\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn valid.value;\n\t\t} catch (SAXException e) {\n\t\t\t\n\t\t\treturn false;\n\t\t} catch (Exception e) {\n\t\t\t\n\t\t\tSystem.err.println(e);\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 425306, "name": "Metallic ratios", "source": "Translate Ruby to Java: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MetallicRatios {\n\n    private static String[] ratioDescription = new String[] {\"Platinum\", \"Golden\", \"Silver\", \"Bronze\", \"Copper\", \"Nickel\", \"Aluminum\", \"Iron\", \"Tin\", \"Lead\"};\n    \n    public static void main(String[] args) {\n        int elements = 15;\n        for ( int b = 0 ; b < 10 ; b++ ) {\n            System.out.printf(\"Lucas sequence for %s ratio, where b = %d:%n\", ratioDescription[b], b);\n            System.out.printf(\"First %d elements: %s%n\", elements, lucasSequence(1, 1, b, elements));\n            int decimalPlaces = 32;\n            BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n            System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n            System.out.printf(\"%n\");\n        }\n        int b = 1;\n        int decimalPlaces = 256;\n        System.out.printf(\"%s ratio, where b = %d:%n\", ratioDescription[b], b);\n        BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n        System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n    }\n    \n    private static BigDecimal[] lucasSequenceRatio(int x0, int x1, int b, int digits) {\n        BigDecimal x0Bi = BigDecimal.valueOf(x0);\n        BigDecimal x1Bi = BigDecimal.valueOf(x1);\n        BigDecimal bBi = BigDecimal.valueOf(b);\n        MathContext mc = new MathContext(digits);\n        BigDecimal fractionPrior = x1Bi.divide(x0Bi, mc);\n        int iterations = 0;\n        while ( true ) {\n            iterations++;\n            BigDecimal x = bBi.multiply(x1Bi).add(x0Bi);\n            BigDecimal fractionCurrent = x.divide(x1Bi, mc);\n            if ( fractionCurrent.compareTo(fractionPrior) == 0 ) {\n                break;\n            }\n            x0Bi = x1Bi;\n            x1Bi = x;\n            fractionPrior = fractionCurrent;\n        }\n        return new BigDecimal[] {fractionPrior, BigDecimal.valueOf(iterations)};\n    }\n\n    private static List<BigInteger> lucasSequence(int x0, int x1, int b, int n) {\n        List<BigInteger> list = new ArrayList<>();\n        BigInteger x0Bi = BigInteger.valueOf(x0);\n        BigInteger x1Bi = BigInteger.valueOf(x1);\n        BigInteger bBi = BigInteger.valueOf(b);\n        if ( n > 0 ) {\n            list.add(x0Bi);\n        }\n        if ( n > 1 ) {\n            list.add(x1Bi);\n        }\n        while ( n > 2 ) {\n            BigInteger x = bBi.multiply(x1Bi).add(x0Bi);\n            list.add(x);\n            n--;\n            x0Bi = x1Bi;\n            x1Bi = x;\n        }\n        return list;\n    }\n    \n}\n"}
{"id": 425307, "name": "Metallic ratios", "source": "Translate Ruby to Java: require('bigdecimal')\nrequire('bigdecimal/util')\n\n\n\n\ndef lucas(b)\n  Enumerator.new do |yielder|\n    xn2 = 1 ; yielder.yield(xn2)\n    xn1 = 1 ; yielder.yield(xn1)\n    loop { xn2, xn1 = xn1, b * xn1 + xn2 ; yielder.yield(xn1) }\n  end\nend\n\n\n\n\n\n\n\ndef metallic_ratio(b, precision)\n  xn2 = xn1 = prev = this = 0\n  lucas(b).each.with_index do |xn, inx|\n    case inx\n      when 0\n        xn2 = BigDecimal(xn)\n      when 1\n        xn1 = BigDecimal(xn)\n        prev = xn1.div(xn2, 2 * precision).round(precision)\n      else\n        xn2, xn1 = xn1, BigDecimal(xn)\n        this = xn1.div(xn2, 2 * precision).round(precision)\n        return Struct.new(:ratio, :terms).new(prev, inx - 1) if prev == this\n        prev = this\n    end\n  end\nend\n\nNAMES = [ 'Platinum', 'Golden', 'Silver', 'Bronze', 'Copper',\n          'Nickel', 'Aluminum', 'Iron', 'Tin', 'Lead' ]\n\nputs\nputs('Lucas Sequences...')\nputs('%1s  %s' % ['b', 'sequence'])\n(0..9).each do |b|\n  puts('%1d  %s' % [b, lucas(b).first(15)])\nend\n\nputs\nputs('Metallic Ratios to 32 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\n(0..9).each do |b|\n  rn = metallic_ratio(b, 32)\n  puts('%-9s %1d %3d  %s' % [NAMES[b], b, rn.terms, rn.ratio.to_s('F')])\nend\n\nputs\nputs('Golden Ratio to 256 places...')\nputs('%-9s %1s %3s  %s' % ['name', 'b', 'n', 'ratio'])\ngold_rn = metallic_ratio(1, 256)\nputs('%-9s %1d %3d  %s' % [NAMES[1], 1, gold_rn.terms, gold_rn.ratio.to_s('F')])\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MetallicRatios {\n\n    private static String[] ratioDescription = new String[] {\"Platinum\", \"Golden\", \"Silver\", \"Bronze\", \"Copper\", \"Nickel\", \"Aluminum\", \"Iron\", \"Tin\", \"Lead\"};\n    \n    public static void main(String[] args) {\n        int elements = 15;\n        for ( int b = 0 ; b < 10 ; b++ ) {\n            System.out.printf(\"Lucas sequence for %s ratio, where b = %d:%n\", ratioDescription[b], b);\n            System.out.printf(\"First %d elements: %s%n\", elements, lucasSequence(1, 1, b, elements));\n            int decimalPlaces = 32;\n            BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n            System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n            System.out.printf(\"%n\");\n        }\n        int b = 1;\n        int decimalPlaces = 256;\n        System.out.printf(\"%s ratio, where b = %d:%n\", ratioDescription[b], b);\n        BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n        System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n    }\n    \n    private static BigDecimal[] lucasSequenceRatio(int x0, int x1, int b, int digits) {\n        BigDecimal x0Bi = BigDecimal.valueOf(x0);\n        BigDecimal x1Bi = BigDecimal.valueOf(x1);\n        BigDecimal bBi = BigDecimal.valueOf(b);\n        MathContext mc = new MathContext(digits);\n        BigDecimal fractionPrior = x1Bi.divide(x0Bi, mc);\n        int iterations = 0;\n        while ( true ) {\n            iterations++;\n            BigDecimal x = bBi.multiply(x1Bi).add(x0Bi);\n            BigDecimal fractionCurrent = x.divide(x1Bi, mc);\n            if ( fractionCurrent.compareTo(fractionPrior) == 0 ) {\n                break;\n            }\n            x0Bi = x1Bi;\n            x1Bi = x;\n            fractionPrior = fractionCurrent;\n        }\n        return new BigDecimal[] {fractionPrior, BigDecimal.valueOf(iterations)};\n    }\n\n    private static List<BigInteger> lucasSequence(int x0, int x1, int b, int n) {\n        List<BigInteger> list = new ArrayList<>();\n        BigInteger x0Bi = BigInteger.valueOf(x0);\n        BigInteger x1Bi = BigInteger.valueOf(x1);\n        BigInteger bBi = BigInteger.valueOf(b);\n        if ( n > 0 ) {\n            list.add(x0Bi);\n        }\n        if ( n > 1 ) {\n            list.add(x1Bi);\n        }\n        while ( n > 2 ) {\n            BigInteger x = bBi.multiply(x1Bi).add(x0Bi);\n            list.add(x);\n            n--;\n            x0Bi = x1Bi;\n            x1Bi = x;\n        }\n        return list;\n    }\n    \n}\n"}
{"id": 425308, "name": "Erd\u00f6s-Selfridge categorization of primes", "source": "Translate Ruby to Java: func Erd\u00f6s_Selfridge_class(n, s=1) is cached {\n    var f = factor_exp(n+s)\n    f.last.head > 3 || return 1\n    f.map {|p| __FUNC__(p.head, s) }.max + 1\n}\n\nsay \"First two hundred primes; Erd\u00f6s-Selfridge categorized:\"\n200.pn_primes.group_by(Erd\u00f6s_Selfridge_class).sort_by{.to_i}.each_2d {|k,v|\n    say \"\n}\n\nsay \"\\nSummary of first 10^6 primes; Erd\u00f6s-Selfridge categorized:\";\n1e6.pn_primes.group_by(Erd\u00f6s_Selfridge_class).sort_by{.to_i}.each_2d {|k,v|\n    printf(\"Category %2d: first: %9s  last: %10s  count: %s\\n\", k, v.first, v.last, v.len)\n}\n", "target": "import java.util.*;\n\npublic class ErdosSelfridge {\n    private int[] primes;\n    private int[] category;\n\n    public static void main(String[] args) {\n        ErdosSelfridge es = new ErdosSelfridge(1000000);\n\n        System.out.println(\"First 200 primes:\");\n        for (var e : es.getPrimesByCategory(200).entrySet()) {\n            int category = e.getKey();\n            List<Integer> primes = e.getValue();\n            System.out.printf(\"Category %d:\\n\", category);\n            for (int i = 0, n = primes.size(); i != n; ++i)\n                System.out.printf(\"%4d%c\", primes.get(i), (i + 1) % 15 == 0 ? '\\n' : ' ');\n            System.out.printf(\"\\n\\n\");\n        }\n\n        System.out.println(\"First 1,000,000 primes:\");\n        for (var e : es.getPrimesByCategory(1000000).entrySet()) {\n            int category = e.getKey();\n            List<Integer> primes = e.getValue();\n            System.out.printf(\"Category %2d: first = %7d  last = %8d  count = %d\\n\", category,\n                              primes.get(0), primes.get(primes.size() - 1), primes.size());\n        }\n    }\n\n    private ErdosSelfridge(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 200000);\n        List<Integer> primeList = new ArrayList<>();\n        for (int i = 0; i < limit; ++i)\n            primeList.add(primeGen.nextPrime());\n        primes = new int[primeList.size()];\n        for (int i = 0; i < primes.length; ++i)\n            primes[i] = primeList.get(i);\n        category = new int[primes.length];\n    }\n\n    private Map<Integer, List<Integer>> getPrimesByCategory(int limit) {\n        Map<Integer, List<Integer>> result = new TreeMap<>();\n        for (int i = 0; i < limit; ++i) {\n            var p = result.computeIfAbsent(getCategory(i), k -> new ArrayList<Integer>());\n            p.add(primes[i]);\n        }\n        return result;\n    }\n\n    private int getCategory(int index) {\n        if (category[index] != 0)\n            return category[index];\n        int maxCategory = 0;\n        int n = primes[index] + 1;\n        for (int i = 0; n > 1; ++i) {\n            int p = primes[i];\n            if (p * p > n)\n                break;\n            int count = 0;\n            for (; n % p == 0; ++count)\n                n /= p;\n            if (count != 0) {\n                int category = (p <= 3) ? 1 : 1 + getCategory(i);\n                maxCategory = Math.max(maxCategory, category);\n            }\n        }\n        if (n > 1) {\n            int category = (n <= 3) ? 1 : 1 + getCategory(getIndex(n));\n            maxCategory = Math.max(maxCategory, category);\n        }\n        category[index] = maxCategory;\n        return maxCategory;\n    }\n\n    private int getIndex(int prime) {\n       return Arrays.binarySearch(primes, prime);\n    }\n}\n"}
{"id": 425309, "name": "Earliest difference between prime gaps", "source": "Translate Ruby to Java: func prime_gap_records(upto) {\n\n    var gaps = []\n    var p = 3\n\n    each_prime(p.next_prime, upto, {|q|\n        gaps[q-p] := p\n        p = q\n    })\n\n    gaps.grep { defined(_) }\n}\n\nvar gaps = prime_gap_records(1e8)\n\nfor m in (1 .. gaps.max.len) {\n    gaps.each_cons(2, {|p,q|\n        if (abs(q-p) > 10**m) {\n            say \"10^\n            p.next_prime-p}, \n            break\n        }\n    })\n}\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PrimeGaps {\n    private Map<Integer, Integer> gapStarts = new HashMap<>();\n    private int lastPrime;\n    private PrimeGenerator primeGenerator = new PrimeGenerator(1000, 500000);\n\n    public static void main(String[] args) {\n        final int limit = 100000000;\n        PrimeGaps pg = new PrimeGaps();\n        for (int pm = 10, gap1 = 2;;) {\n            int start1 = pg.findGapStart(gap1);\n            int gap2 = gap1 + 2;\n            int start2 = pg.findGapStart(gap2);\n            int diff = start2 > start1 ? start2 - start1 : start1 - start2;\n            if (diff > pm) {\n                System.out.printf(\n                    \"Earliest difference >\u00a0%,d between adjacent prime gap starting primes:\\n\"\n                    + \"Gap\u00a0%,d starts at\u00a0%,d, gap\u00a0%,d starts at\u00a0%,d, difference is\u00a0%,d.\\n\\n\",\n                    pm, gap1, start1, gap2, start2, diff);\n                if (pm == limit)\n                    break;\n                pm *= 10;\n            } else {\n                gap1 = gap2;\n            }\n        }\n    }\n\n    private int findGapStart(int gap) {\n        Integer start = gapStarts.get(gap);\n        if (start != null)\n            return start;\n        for (;;) {\n            int prev = lastPrime;\n            lastPrime = primeGenerator.nextPrime();\n            int diff = lastPrime - prev;\n            gapStarts.putIfAbsent(diff, prev);\n            if (diff == gap)\n                return prev;\n        }\n    }\n}\n"}
{"id": 425310, "name": "Word ladder", "source": "Translate Ruby to Java: require \"set\"\n\nWords = File.open(\"unixdict.txt\").read.split(\"\\n\").\n  group_by { |w| w.length }.map { |k, v| [k, Set.new(v)] }.\n  to_h\n\ndef word_ladder(from, to)\n  raise \"Length mismatch\" unless from.length == to.length\n  sized_words = Words[from.length]\n  work_queue = [[from]]\n  used = Set.new [from]\n  while work_queue.length > 0\n    new_q = []\n    work_queue.each do |words|\n      last_word = words[-1]\n      new_tails = Enumerator.new do |enum|\n        (\"a\"..\"z\").each do |replacement_letter|\n          last_word.length.times do |i|\n            new_word = last_word.clone\n            new_word[i] = replacement_letter\n            next unless sized_words.include? new_word and\n                        not used.include? new_word\n            enum.yield new_word\n            used.add new_word\n            return words + [new_word] if new_word == to\n          end\n        end\n      end\n      new_tails.each do |t|\n        new_q.push(words + [t])\n      end\n    end\n    work_queue = new_q\n  end\nend\n\n[%w<boy man>, %w<girl lady>, %w<john jane>, %w<child adult>].each do |from, to|\n  if ladder = word_ladder(from, to)\n    puts ladder.join \" \u2192 \"\n  else\n    puts \"\n  end\nend\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class WordLadder {\n    private static int distance(String s1, String s2) {\n        assert s1.length() == s2.length();\n        return (int) IntStream.range(0, s1.length())\n            .filter(i -> s1.charAt(i) != s2.charAt(i))\n            .count();\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw) {\n        wordLadder(words, fw, tw, 8);\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw, int limit) {\n        if (fw.length() != tw.length()) {\n            throw new IllegalArgumentException(\"From word and to word must have the same length\");\n        }\n\n        Set<String> ws = words.get(fw.length());\n        if (ws.contains(fw)) {\n            List<String> primeList = new ArrayList<>();\n            primeList.add(fw);\n\n            PriorityQueue<List<String>> queue = new PriorityQueue<>((chain1, chain2) -> {\n                int cmp1 = Integer.compare(chain1.size(), chain2.size());\n                if (cmp1 == 0) {\n                    String last1 = chain1.get(chain1.size() - 1);\n                    int d1 = distance(last1, tw);\n\n                    String last2 = chain2.get(chain2.size() - 1);\n                    int d2 = distance(last2, tw);\n\n                    return Integer.compare(d1, d2);\n                }\n                return cmp1;\n            });\n            queue.add(primeList);\n\n            while (queue.size() > 0) {\n                List<String> curr = queue.remove();\n                if (curr.size() > limit) {\n                    continue;\n                }\n\n                String last = curr.get(curr.size() - 1);\n                for (String word : ws) {\n                    if (distance(last, word) == 1) {\n                        if (word.equals(tw)) {\n                            curr.add(word);\n                            System.out.println(String.join(\" -> \", curr));\n                            return;\n                        }\n\n                        if (!curr.contains(word)) {\n                            List<String> cp = new ArrayList<>(curr);\n                            cp.add(word);\n                            queue.add(cp);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.err.printf(\"Cannot turn `%s` into `%s`%n\", fw, tw);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<Integer, Set<String>> words = new HashMap<>();\n        for (String line : Files.readAllLines(Path.of(\"unixdict.txt\"))) {\n            Set<String> wl = words.computeIfAbsent(line.length(), HashSet::new);\n            wl.add(line);\n        }\n\n        wordLadder(words, \"boy\", \"man\");\n        wordLadder(words, \"girl\", \"lady\");\n        wordLadder(words, \"john\", \"jane\");\n        wordLadder(words, \"child\", \"adult\");\n        wordLadder(words, \"cat\", \"dog\");\n        wordLadder(words, \"lead\", \"gold\");\n        wordLadder(words, \"white\", \"black\");\n        wordLadder(words, \"bubble\", \"tickle\", 12);\n    }\n}\n"}
{"id": 425311, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to Java: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 425312, "name": "Gauss-Jordan matrix inversion", "source": "Translate Ruby to Java: require 'matrix'\n\nm = Matrix[[-1, -2, 3, 2],\n           [-4, -1, 6, 2],\n           [ 7, -8, 9, 1],\n           [ 1, -2, 1, 3]]\n\npp m.inv.row_vectors\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 425313, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Ruby to Java: func adaptive_Simpson_quadrature(f, left, right, \u03b5 = 1e-9) {\n\n    func quadrature_mid(l, lf, r, rf) {\n        var mid = (l+r)/2\n        var midf = f(mid)\n        (mid, midf, abs(r-l)/6 * (lf + 4*midf + rf))\n    }\n\n    func recursive_asr(a, fa, b, fb, \u03b5, whole, m, fm) {\n        var (lm, flm, left)  = quadrature_mid(a, fa, m, fm)\n        var (rm, frm, right) = quadrature_mid(m, fm, b, fb)\n        var \u0394 = (left + right - whole)\n        abs(\u0394) <= 15*\u03b5\n            ? (left + right + \u0394/15)\n            : (__FUNC__(a, fa, m, fm, \u03b5/2, left,  lm, flm) +\n               __FUNC__(m, fm, b, fb, \u03b5/2, right, rm, frm))\n    }\n\n    var (lf = f(left), rf = f(right))\n    var (mid, midf, whole) = quadrature_mid(left, lf, right, rf)\n    recursive_asr(left, lf, right, rf, \u03b5, whole, mid, midf)\n}\n\nvar (a = 0, b = 1)\nvar area = adaptive_Simpson_quadrature({ .sin }, a, b, 1e-15).round(-15)\nsay \"Simpson's integration of sine from \n", "target": "import java.util.function.Function;\n\npublic class NumericalIntegrationAdaptiveSimpsons {\n\n    public static void main(String[] args) {\n        Function<Double,Double> f = x -> sin(x);\n        System.out.printf(\"integrate sin(x), x = 0 .. Pi = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, Math.PI, 1e-8), functionCount);\n        functionCount = 0;\n        System.out.printf(\"integrate sin(x), x = 0 .. 1 = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, 1, 1e-8), functionCount);\n    }\n    \n    private static double quadratureAdaptiveSimpsons(Function<Double,Double> function, double a, double b, double error) {\n        double fa = function.apply(a);\n        double fb = function.apply(b);\n        Triple t =  quadratureAdaptiveSimpsonsOne(function, a, fa, b ,fb);\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, b, fb, error, t.s, t.x, t.fx);\n    }\n    \n    private static double quadratureAdaptiveSimpsonsRecursive(Function<Double,Double> function, double a, double fa, double b, double fb, double error, double whole, double m, double fm) {\n        Triple left  = quadratureAdaptiveSimpsonsOne(function, a, fa, m, fm);\n        Triple right = quadratureAdaptiveSimpsonsOne(function, m, fm, b, fb);\n        double delta = left.s + right.s - whole;\n        if ( Math.abs(delta) <= 15*error ) {\n            return left.s + right.s + delta / 15;\n        }\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, m, fm, error/2, left.s, left.x, left.fx) +\n               quadratureAdaptiveSimpsonsRecursive(function, m, fm, b, fb, error/2, right.s, right.x, right.fx);\n    }\n    \n    private static Triple quadratureAdaptiveSimpsonsOne(Function<Double,Double> function, double a, double fa, double b, double fb) {\n        double m = (a + b) / 2;\n        double fm = function.apply(m);\n        return new Triple(m, fm, Math.abs(b-a) / 6 * (fa + 4*fm + fb));\n    }\n    \n    private static class Triple {\n        double x, fx, s;\n        private Triple(double m, double fm, double s) {\n            this.x = m;\n            this.fx = fm;\n            this.s = s;\n        }\n    }\n    \n    private static int functionCount = 0;\n    \n    private static double sin(double x) {\n        functionCount++;\n        return Math.sin(x);\n    }\n    \n}\n"}
{"id": 425314, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Ruby to Java: func adaptive_Simpson_quadrature(f, left, right, \u03b5 = 1e-9) {\n\n    func quadrature_mid(l, lf, r, rf) {\n        var mid = (l+r)/2\n        var midf = f(mid)\n        (mid, midf, abs(r-l)/6 * (lf + 4*midf + rf))\n    }\n\n    func recursive_asr(a, fa, b, fb, \u03b5, whole, m, fm) {\n        var (lm, flm, left)  = quadrature_mid(a, fa, m, fm)\n        var (rm, frm, right) = quadrature_mid(m, fm, b, fb)\n        var \u0394 = (left + right - whole)\n        abs(\u0394) <= 15*\u03b5\n            ? (left + right + \u0394/15)\n            : (__FUNC__(a, fa, m, fm, \u03b5/2, left,  lm, flm) +\n               __FUNC__(m, fm, b, fb, \u03b5/2, right, rm, frm))\n    }\n\n    var (lf = f(left), rf = f(right))\n    var (mid, midf, whole) = quadrature_mid(left, lf, right, rf)\n    recursive_asr(left, lf, right, rf, \u03b5, whole, mid, midf)\n}\n\nvar (a = 0, b = 1)\nvar area = adaptive_Simpson_quadrature({ .sin }, a, b, 1e-15).round(-15)\nsay \"Simpson's integration of sine from \n", "target": "import java.util.function.Function;\n\npublic class NumericalIntegrationAdaptiveSimpsons {\n\n    public static void main(String[] args) {\n        Function<Double,Double> f = x -> sin(x);\n        System.out.printf(\"integrate sin(x), x = 0 .. Pi = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, Math.PI, 1e-8), functionCount);\n        functionCount = 0;\n        System.out.printf(\"integrate sin(x), x = 0 .. 1 = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, 1, 1e-8), functionCount);\n    }\n    \n    private static double quadratureAdaptiveSimpsons(Function<Double,Double> function, double a, double b, double error) {\n        double fa = function.apply(a);\n        double fb = function.apply(b);\n        Triple t =  quadratureAdaptiveSimpsonsOne(function, a, fa, b ,fb);\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, b, fb, error, t.s, t.x, t.fx);\n    }\n    \n    private static double quadratureAdaptiveSimpsonsRecursive(Function<Double,Double> function, double a, double fa, double b, double fb, double error, double whole, double m, double fm) {\n        Triple left  = quadratureAdaptiveSimpsonsOne(function, a, fa, m, fm);\n        Triple right = quadratureAdaptiveSimpsonsOne(function, m, fm, b, fb);\n        double delta = left.s + right.s - whole;\n        if ( Math.abs(delta) <= 15*error ) {\n            return left.s + right.s + delta / 15;\n        }\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, m, fm, error/2, left.s, left.x, left.fx) +\n               quadratureAdaptiveSimpsonsRecursive(function, m, fm, b, fb, error/2, right.s, right.x, right.fx);\n    }\n    \n    private static Triple quadratureAdaptiveSimpsonsOne(Function<Double,Double> function, double a, double fa, double b, double fb) {\n        double m = (a + b) / 2;\n        double fm = function.apply(m);\n        return new Triple(m, fm, Math.abs(b-a) / 6 * (fa + 4*fm + fb));\n    }\n    \n    private static class Triple {\n        double x, fx, s;\n        private Triple(double m, double fm, double s) {\n            this.x = m;\n            this.fx = fm;\n            this.s = s;\n        }\n    }\n    \n    private static int functionCount = 0;\n    \n    private static double sin(double x) {\n        functionCount++;\n        return Math.sin(x);\n    }\n    \n}\n"}
{"id": 425315, "name": "Colorful numbers", "source": "Translate Ruby to Java: def colorful?(ar)\n  products = []\n  (1..ar.size).all? do |chunk_size|\n    ar.each_cons(chunk_size) do |chunk|\n      product = chunk.inject(&:*)\n      return false if products.include?(product)\n      products << product\n    end\n  end\nend\n\nbelow100 = (0..100).select{|n| colorful?(n.digits)}\nputs \"The colorful numbers less than 100 are:\", below100.join(\" \"), \"\"\nputs \"Largest colorful number: \n\ntotal = 0\n(1..8).each do |numdigs|\n   digits = (numdigs == 1 ? (0..9).to_a : (2..9).to_a)\n   count  = digits.permutation(numdigs).count{|perm| colorful?(perm)}\n   puts \"\n   total += count\nend\n\nputs \"\\nTotal colorful numbers: \n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425316, "name": "Colorful numbers", "source": "Translate Ruby to Java: def colorful?(ar)\n  products = []\n  (1..ar.size).all? do |chunk_size|\n    ar.each_cons(chunk_size) do |chunk|\n      product = chunk.inject(&:*)\n      return false if products.include?(product)\n      products << product\n    end\n  end\nend\n\nbelow100 = (0..100).select{|n| colorful?(n.digits)}\nputs \"The colorful numbers less than 100 are:\", below100.join(\" \"), \"\"\nputs \"Largest colorful number: \n\ntotal = 0\n(1..8).each do |numdigs|\n   digits = (numdigs == 1 ? (0..9).to_a : (2..9).to_a)\n   count  = digits.permutation(numdigs).count{|perm| colorful?(perm)}\n   puts \"\n   total += count\nend\n\nputs \"\\nTotal colorful numbers: \n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 425317, "name": "Generate random chess position", "source": "Translate Ruby to Java: def hasNK(board, a, b)\n    (-1..1).each do |g|\n        (-1..1).each do |f|\n            aa = a + f; bb = b + g\n            if (0..7).includes?(aa) && (0..7).includes?(bb)\n                p = board[aa + 8 * bb]\n                return true if p == \"K\" || p == \"k\"\n            end \n        end\n    end\n    return false\nend\n\ndef generateBoard(board, pieces)\n    pieces.each_char do |p|\n        while true\n            a = rand(8); b = rand(8)\n            next  if ( (b == 0 || b == 7) && (p == \"P\" || p == \"p\") ) || \n               ( (p == \"k\" || p == \"K\") && hasNK(board, a, b) )\n            break if board[a + b * 8] == '.'\n        end\n        board[a + b * 8] = p\n    end\nend\n\npieces = \"ppppppppkqrrbbnnPPPPPPPPKQRRBBNN\"\n11.times do\n    e = pieces.size - 1\n    while e > 0\n        p = rand(e); t = pieces[e]\n        \n        pieces = pieces.sub(e, pieces[p])             \n        pieces = pieces.sub(p, t); e -= 1             \n    end\nend\n\n\nboard = Array.new(64, '.'); generateBoard(board, pieces)\nputs\ne = 0\n8.times do |j| row_j = j * 8\n    8.times do |i| \n        board[row_j + i ] == '.' ? (e += 1) :\n            ( (print(e); e = 0) if e > 0\n            print board[row_j + i] )\n    end\n    (print(e); e = 0) if e > 0\n    print(\"/\") if j < 7\nend\n\nprint(\" w - - 0 1\\n\")\n8.times do |j| row_j = j * 8\n  8.times { |i| board[row_j + i] == '.' ? print(\".\") : print(board[row_j + i]) }\n  puts\nend\n\n\n8.times{ |row| puts board[row*8..row*8 + 7].join(\"\") }\n", "target": "import static java.lang.Math.abs;\nimport java.util.Random;\n\npublic class Fen {\n    static Random rand = new Random();\n\n    public static void main(String[] args) {\n        System.out.println(createFen());\n    }\n\n    static String createFen() {\n        char[][] grid = new char[8][8];\n\n        placeKings(grid);\n        placePieces(grid, \"PPPPPPPP\", true);\n        placePieces(grid, \"pppppppp\", true);\n        placePieces(grid, \"RNBQBNR\", false);\n        placePieces(grid, \"rnbqbnr\", false);\n\n        return toFen(grid);\n    }\n\n    static void placeKings(char[][] grid) {\n        int r1, c1, r2, c2;\n        while (true) {\n            r1 = rand.nextInt(8);\n            c1 = rand.nextInt(8);\n            r2 = rand.nextInt(8);\n            c2 = rand.nextInt(8);\n            if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1)\n                break;\n        }\n        grid[r1][c1] = 'K';\n        grid[r2][c2] = 'k';\n    }\n\n    static void placePieces(char[][] grid, String pieces, boolean isPawn) {\n        int numToPlace = rand.nextInt(pieces.length());\n        for (int n = 0; n < numToPlace; n++) {\n            int r, c;\n            do {\n                r = rand.nextInt(8);\n                c = rand.nextInt(8);\n\n            } while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n\n            grid[r][c] = pieces.charAt(n);\n        }\n    }\n\n    static String toFen(char[][] grid) {\n        StringBuilder fen = new StringBuilder();\n        int countEmpty = 0;\n        for (int r = 0; r < 8; r++) {\n            for (int c = 0; c < 8; c++) {\n                char ch = grid[r][c];\n                System.out.printf(\"%2c \", ch == 0 ? '.' : ch);\n                if (ch == 0) {\n                    countEmpty++;\n                } else {\n                    if (countEmpty > 0) {\n                        fen.append(countEmpty);\n                        countEmpty = 0;\n                    }\n                    fen.append(ch);\n                }\n            }\n            if (countEmpty > 0) {\n                fen.append(countEmpty);\n                countEmpty = 0;\n            }\n            fen.append(\"/\");\n            System.out.println();\n        }\n        return fen.append(\" w - - 0 1\").toString();\n    }\n}\n"}
{"id": 425318, "name": "Sierpinski square curve", "source": "Translate Ruby to Java: var rules = Hash(\n    x => 'xF-F+F-xF+F+xF-F+F-x',\n)\n\nvar lsys = LSystem(\n    width:  510,\n    height: 510,\n\n    xoff: -505,\n    yoff: -254,\n\n    len:   4,\n    angle: 90,\n    color: 'dark green',\n)\n\nlsys.execute('F+xF+F+xF', 5, \"sierpi\u0144ski_square_curve.png\", rules)\n", "target": "import java.io.*;\n\npublic class SierpinskiSquareCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_square.svg\"))) {\n            SierpinskiSquareCurve s = new SierpinskiSquareCurve(writer);\n            int size = 635, length = 5;\n            s.currentAngle = 0;\n            s.currentX = (size - length)/2;\n            s.currentY = length;\n            s.lineLength = length;\n            s.begin(size);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiSquareCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY += length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F+XF+F+XF\";\n    private static final String PRODUCTION = \"XF-F+F-XF+F+XF-F+F-X\";\n    private static final int ANGLE = 90;\n}\n"}
{"id": 425319, "name": "Rhonda numbers", "source": "Translate Ruby to Java: func is_rhonda_number(n, base = 10) {\n    base.is_composite || return false\n    n > 0             || return false\n    n.digits(base).prod == base*n.factor.sum\n}\n\nfor b in (2..16 -> grep { .is_composite }) {\n    say (\"First 10 Rhonda numbers to base \n        10.by { is_rhonda_number(_, b) })\n}\n", "target": "public class RhondaNumbers {\n    public static void main(String[] args) {\n        final int limit = 15;\n        for (int base = 2; base <= 36; ++base) {\n            if (isPrime(base))\n                continue;\n            System.out.printf(\"First %d Rhonda numbers to base %d:\\n\", limit, base);\n            int numbers[] = new int[limit];\n            for (int n = 1, count = 0; count < limit; ++n) {\n                if (isRhonda(base, n))\n                    numbers[count++] = n;\n            }\n            System.out.printf(\"In base 10:\");\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %d\", numbers[i]);\n            System.out.printf(\"\\nIn base %d:\", base);\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %s\", Integer.toString(numbers[i], base));\n            System.out.printf(\"\\n\\n\");\n        }\n    }\n    \n    private static int digitProduct(int base, int n) {\n        int product = 1;\n        for (; n != 0; n /= base)\n            product *= n % base;\n        return product;\n    }\n     \n    private static int primeFactorSum(int n) {\n        int sum = 0;\n        for (; (n & 1) == 0; n >>= 1)\n            sum += 2;\n        for (int p = 3; p * p <= n; p += 2)\n            for (; n % p == 0; n /= p)\n                sum += p;\n        if (n > 1)\n            sum += n;\n        return sum;\n    }\n     \n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n     \n    private static boolean isRhonda(int base, int n) {\n        return digitProduct(base, n) == base * primeFactorSum(n);\n    }\n}\n"}
{"id": 425320, "name": "Pisano period", "source": "Translate Ruby to Java: func pisano_period_pp(p,k) is cached {\n\n    assert(k.is_pos,   \"k = \n    assert(p.is_prime, \"p = \n\n    var (a, b, n) = (0, 1, p**k)\n\n    1..Inf -> first_by {\n        (a, b) = (b, (a+b) % n)\n        (a == 0) && (b == 1)\n    }\n}\n\nfunc pisano_period(n) {\n    n.factor_map {|p,k| pisano_period_pp(p, k) }.lcm\n}\n\nsay \"Pisano periods for squares of primes p <= 15:\"\nsay  15.primes.map {|p| pisano_period_pp(p, 2) }\n\nsay \"\\nPisano periods for primes p <= 180:\"\nsay 180.primes.map {|p| pisano_period_pp(p, 1) }\n\nsay \"\\nPisano periods for integers n from 1 to 180:\"\nsay pisano_period.map(1..180)\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class PisanoPeriod {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Print pisano(p^2) for every prime p lower than 15%n\");\n        for ( long i = 2 ; i < 15 ; i++ ) { \n            if ( isPrime(i) ) {\n                long n = i*i; \n                System.out.printf(\"pisano(%d) = %d%n\", n, pisano(n));\n            }\n        }\n\n        System.out.printf(\"%nPrint pisano(p) for every prime p lower than 180%n\");\n        for ( long n = 2 ; n < 180 ; n++ ) { \n            if ( isPrime(n) ) { \n                System.out.printf(\"pisano(%d) = %d%n\", n, pisano(n));\n            }\n        }\n\n        System.out.printf(\"%nPrint pisano(n) for every integer from 1 to 180%n\");\n        for ( long n = 1 ; n <= 180 ; n++ ) { \n            System.out.printf(\"%3d  \", pisano(n));\n            if ( n % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n\n        \n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) {\n            return false;\n        }\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private static Map<Long,Long> PERIOD_MEMO = new HashMap<>();\n    static {\n        PERIOD_MEMO.put(2L, 3L);\n        PERIOD_MEMO.put(3L, 8L);\n        PERIOD_MEMO.put(5L, 20L);        \n    }\n    \n    \n    private static long pisano(long n) {\n        if ( PERIOD_MEMO.containsKey(n) ) {\n            return PERIOD_MEMO.get(n);\n        }\n        if ( n == 1 ) {\n            return 1;\n        }\n        Map<Long,Long> factors = getFactors(n);\n        \n        \n        \n        if ( factors.size() == 1 & factors.get(2L) != null && factors.get(2L) > 0 ) {\n            long result = 3 * n / 2;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        if ( factors.size() == 1 & factors.get(5L) != null && factors.get(5L) > 0 ) {\n            long result = 4*n;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        if ( factors.size() == 2 & factors.get(2L) != null && factors.get(2L) == 1 && factors.get(5L) != null && factors.get(5L) > 0 ) {\n            long result = 6*n;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        List<Long> primes = new ArrayList<>(factors.keySet());\n        long prime = primes.get(0);\n        if ( factors.size() == 1 && factors.get(prime) == 1 ) {\n            List<Long> divisors = new ArrayList<>();\n            if ( n % 10 == 1 || n % 10 == 9 ) {\n                for ( long divisor : getDivisors(prime-1) ) {\n                    if ( divisor % 2 == 0 ) {\n                        divisors.add(divisor);\n                    }\n                }\n            }\n            else {\n                List<Long> pPlus1Divisors = getDivisors(prime+1);\n                for ( long divisor : getDivisors(2*prime+2) ) {\n                    if ( !  pPlus1Divisors.contains(divisor) ) {\n                        divisors.add(divisor);\n                    }\n                }\n            }\n            Collections.sort(divisors);\n            for ( long divisor : divisors ) {\n                if ( fibModIdentity(divisor, prime) ) {\n                    PERIOD_MEMO.put(prime, divisor);\n                    return divisor;\n                }\n            }\n            throw new RuntimeException(\"ERROR 144: Divisor not found.\");\n        }\n        long period = (long) Math.pow(prime, factors.get(prime)-1) * pisano(prime);\n        for ( int i = 1 ; i < primes.size() ; i++ ) {\n            prime = primes.get(i);\n            period = lcm(period, (long) Math.pow(prime, factors.get(prime)-1) * pisano(prime));\n        }\n        PERIOD_MEMO.put(n, period);\n        return period;\n    }\n    \n    \n    private static boolean fibModIdentity(long n, long mod) {\n        long aRes = 0;\n        long bRes = 1;\n        long cRes = 1;\n        long aBase = 0;\n        long bBase = 1;\n        long cBase = 1;\n        while ( n > 0 ) {\n            if ( n % 2 == 1 ) {\n                long temp1 = 0, temp2 = 0, temp3 = 0;\n                if ( aRes > SQRT || aBase > SQRT || bRes > SQRT || bBase > SQRT || cBase > SQRT || cRes > SQRT ) {\n                    temp1 = (multiply(aRes, aBase, mod) + multiply(bRes, bBase, mod)) % mod;\n                    temp2 = (multiply(aBase, bRes, mod) + multiply(bBase, cRes, mod)) % mod;\n                    temp3 = (multiply(bBase, bRes, mod) + multiply(cBase, cRes, mod)) % mod;\n                }\n                else {\n                    temp1 = ((aRes*aBase % mod) + (bRes*bBase % mod)) % mod;\n                    temp2 = ((aBase*bRes % mod) + (bBase*cRes % mod)) % mod;\n                    temp3 = ((bBase*bRes % mod) + (cBase*cRes % mod)) % mod;\n                }\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            n >>= 1L;\n            long temp1 = 0, temp2 = 0, temp3 = 0; \n            if ( aBase > SQRT || bBase > SQRT || cBase > SQRT ) {\n                temp1 = (multiply(aBase, aBase, mod) + multiply(bBase, bBase, mod)) % mod;\n                temp2 = (multiply(aBase, bBase, mod) + multiply(bBase, cBase, mod)) % mod;\n                temp3 = (multiply(bBase, bBase, mod) + multiply(cBase, cBase, mod)) % mod;\n            }\n            else {\n                temp1 = ((aBase*aBase % mod) + (bBase*bBase % mod)) % mod;\n                temp2 = ((aBase*bBase % mod) + (bBase*cBase % mod)) % mod;\n                temp3 = ((bBase*bBase % mod) + (cBase*cBase % mod)) % mod;\n            }\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes % mod == 0 && bRes % mod == 1 && cRes % mod == 1;\n    }\n\n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        \n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        \n        return x % modulus;\n    }\n\n    private static final List<Long> getDivisors(long number) {\n        List<Long> divisors = new ArrayList<>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( long i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                long div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n    public static long lcm(long a, long b) {\n        return a*b/gcd(a,b);\n    }\n\n    public static long gcd(long a, long b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n    private static final Map<Long,Map<Long,Long>> allFactors = new TreeMap<Long,Map<Long,Long>>();\n    static {\n        Map<Long,Long> factors = new TreeMap<Long,Long>();\n        factors.put(2L, 1L);\n        allFactors.put(2L, factors);\n    }\n\n    public static Long MAX_ALL_FACTORS = 100000L;\n\n    public static final Map<Long,Long> getFactors(Long number) {\n        if ( allFactors.containsKey(number) ) {\n            return allFactors.get(number);\n        }\n        Map<Long,Long> factors = new TreeMap<Long,Long>();\n        if ( number % 2 == 0 ) {\n            Map<Long,Long> factorsdDivTwo = getFactors(number/2);\n            factors.putAll(factorsdDivTwo);\n            factors.merge(2L, 1L, (v1, v2) -> v1 + v2);\n            if ( number < MAX_ALL_FACTORS ) {\n                allFactors.put(number, factors);\n            }\n            return factors;\n        }\n        boolean prime = true;\n        long sqrt = (long) Math.sqrt(number);\n        for ( long i = 3 ; i <= sqrt ; i += 2 ) {\n            if ( number % i == 0 ) {\n                prime = false;\n                factors.putAll(getFactors(number/i));\n                factors.merge(i, 1L, (v1, v2) -> v1 + v2);\n                if ( number < MAX_ALL_FACTORS ) {\n                    allFactors.put(number, factors);\n                }\n                return factors;\n            }\n        }\n        if ( prime ) {\n            factors.put(number, 1L);\n            if ( number < MAX_ALL_FACTORS ) { \n                allFactors.put(number, factors);\n            }\n        }\n        return factors;\n    }\n\n}\n"}
{"id": 425321, "name": "Welch's t-test", "source": "Translate Ruby to Java: def calculate_p_value(array1, array2)\n  return 1.0 if array1.size <= 1\n  return 1.0 if array2.size <= 1\n  mean1 = array1.sum / array1.size\n  mean2 = array2.sum / array2.size\n  return 1.0 if mean1 == mean2\n  variance1 = 0.0\n  variance2 = 0.0\n  array1.each do |x|\n    variance1 += (mean1 - x)**2\n  end\n  array2.each do |x|\n    variance2 += (mean2 - x)**2\n  end\n  return 1.0 if variance1 == 0.0 && variance2 == 0.0\n  variance1 /= (array1.size - 1)\n  variance2 /= (array2.size - 1)\n  welch_t_statistic = (mean1 - mean2) / Math.sqrt(variance1 / array1.size + variance2 / array2.size)\n  degrees_of_freedom = ((variance1 / array1.size + variance2 / array2.size)**2)\t/\t(\n  (variance1 * variance1) / (array1.size * array1.size * (array1.size - 1)) +\n  (variance2 * variance2) / (array2.size * array2.size * (array2.size - 1)))\n  a = degrees_of_freedom / 2\n  value = degrees_of_freedom / (welch_t_statistic**2 + degrees_of_freedom)\n  beta = Math.lgamma(a)[0] + 0.57236494292470009 - Math.lgamma(a + 0.5)[0]\n  acu = 10**-15\n  return value if a <= 0\n  return value if value < 0.0 || value > 1.0\n  return value if (value == 0) || (value == 1.0)\n  psq = a + 0.5\n  cx = 1.0 - value\n  if a < psq * value\n    xx = cx\n    cx = value\n    pp = 0.5\n    qq = a\n    indx = 1\n  else\n    xx = value\n    pp = a\n    qq = 0.5\n    indx = 0\n  end\n  term = 1.0\n  ai = 1.0\n  value = 1.0\n  ns = (qq + cx * psq).to_i\n  \n  rx = xx / cx\n  temp = qq - ai\n  loop do\n    term = term * temp * rx / (pp + ai)\n    value += term\n    temp = term.abs\n    if temp <= acu && temp <= acu * value\n      value = value * Math.exp(pp * Math.log(xx) + (qq - 1.0) * Math.log(cx) - beta) / pp\n      value = 1.0 - value\n      value = 1.0 - value if indx == 0\n      break\n    end\n    ai += 1.0\n    ns -= 1\n    if ns >= 0\n      temp = qq - ai\n      rx = xx if ns == 0\n    else\n      temp = psq\n      psq += 1.0\n    end\n  end\n  value\nend\n\nd1 = [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4]\nd2 = [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4]\nd3 = [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8]\nd4 = [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8]\nd5 = [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0]\nd6 = [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2]\nd7 = [30.02, 29.99, 30.11, 29.97, 30.01, 29.99]\nd8 = [29.89, 29.93, 29.72, 29.98, 30.02, 29.98]\nx = [3.0, 4.0, 1.0, 2.1]\ny = [490.2, 340.0, 433.9]\ns1 = [1.0 / 15, 10.0 / 62.0]\ns2 = [1.0 / 10, 2 / 50.0]\nv1 = [0.010268, 0.000167, 0.000167]\nv2 = [0.159258, 0.136278, 0.122389]\nz1 = [9 / 23.0, 21 / 45.0, 0 / 38.0]\nz2 = [0 / 44.0, 42 / 94.0, 0 / 22.0]\n\nCORRECT_ANSWERS = [0.021378001462867, 0.148841696605327, 0.0359722710297968,\n                   0.090773324285671, 0.0107515611497845, 0.00339907162713746, 0.52726574965384, 0.545266866977794].freeze\n\npvalue = calculate_p_value(d1, d2)\nerror = (pvalue - CORRECT_ANSWERS[0]).abs\nprintf(\"Test sets 1 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d3, d4)\nerror += (pvalue - CORRECT_ANSWERS[1]).abs\nprintf(\"Test sets 2 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d5, d6)\nerror += (pvalue - CORRECT_ANSWERS[2]).abs\nprintf(\"Test sets 3 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d7, d8)\nerror += (pvalue - CORRECT_ANSWERS[3]).abs\nprintf(\"Test sets 4 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(x, y)\nerror += (pvalue - CORRECT_ANSWERS[4]).abs\nprintf(\"Test sets 5 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(v1, v2)\nerror += (pvalue - CORRECT_ANSWERS[5]).abs\nprintf(\"Test sets 6 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(s1, s2)\nerror += (pvalue - CORRECT_ANSWERS[6]).abs\nprintf(\"Test sets 7 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(z1, z2)\nerror += (pvalue - CORRECT_ANSWERS[7]).abs\nprintf(\"Test sets z p-value =\u00a0%.14g\\n\", pvalue)\n\nprintf(\"the cumulative error is %g\\n\", error)\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 425322, "name": "Welch's t-test", "source": "Translate Ruby to Java: def calculate_p_value(array1, array2)\n  return 1.0 if array1.size <= 1\n  return 1.0 if array2.size <= 1\n  mean1 = array1.sum / array1.size\n  mean2 = array2.sum / array2.size\n  return 1.0 if mean1 == mean2\n  variance1 = 0.0\n  variance2 = 0.0\n  array1.each do |x|\n    variance1 += (mean1 - x)**2\n  end\n  array2.each do |x|\n    variance2 += (mean2 - x)**2\n  end\n  return 1.0 if variance1 == 0.0 && variance2 == 0.0\n  variance1 /= (array1.size - 1)\n  variance2 /= (array2.size - 1)\n  welch_t_statistic = (mean1 - mean2) / Math.sqrt(variance1 / array1.size + variance2 / array2.size)\n  degrees_of_freedom = ((variance1 / array1.size + variance2 / array2.size)**2)\t/\t(\n  (variance1 * variance1) / (array1.size * array1.size * (array1.size - 1)) +\n  (variance2 * variance2) / (array2.size * array2.size * (array2.size - 1)))\n  a = degrees_of_freedom / 2\n  value = degrees_of_freedom / (welch_t_statistic**2 + degrees_of_freedom)\n  beta = Math.lgamma(a)[0] + 0.57236494292470009 - Math.lgamma(a + 0.5)[0]\n  acu = 10**-15\n  return value if a <= 0\n  return value if value < 0.0 || value > 1.0\n  return value if (value == 0) || (value == 1.0)\n  psq = a + 0.5\n  cx = 1.0 - value\n  if a < psq * value\n    xx = cx\n    cx = value\n    pp = 0.5\n    qq = a\n    indx = 1\n  else\n    xx = value\n    pp = a\n    qq = 0.5\n    indx = 0\n  end\n  term = 1.0\n  ai = 1.0\n  value = 1.0\n  ns = (qq + cx * psq).to_i\n  \n  rx = xx / cx\n  temp = qq - ai\n  loop do\n    term = term * temp * rx / (pp + ai)\n    value += term\n    temp = term.abs\n    if temp <= acu && temp <= acu * value\n      value = value * Math.exp(pp * Math.log(xx) + (qq - 1.0) * Math.log(cx) - beta) / pp\n      value = 1.0 - value\n      value = 1.0 - value if indx == 0\n      break\n    end\n    ai += 1.0\n    ns -= 1\n    if ns >= 0\n      temp = qq - ai\n      rx = xx if ns == 0\n    else\n      temp = psq\n      psq += 1.0\n    end\n  end\n  value\nend\n\nd1 = [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4]\nd2 = [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4]\nd3 = [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8]\nd4 = [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8]\nd5 = [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0]\nd6 = [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2]\nd7 = [30.02, 29.99, 30.11, 29.97, 30.01, 29.99]\nd8 = [29.89, 29.93, 29.72, 29.98, 30.02, 29.98]\nx = [3.0, 4.0, 1.0, 2.1]\ny = [490.2, 340.0, 433.9]\ns1 = [1.0 / 15, 10.0 / 62.0]\ns2 = [1.0 / 10, 2 / 50.0]\nv1 = [0.010268, 0.000167, 0.000167]\nv2 = [0.159258, 0.136278, 0.122389]\nz1 = [9 / 23.0, 21 / 45.0, 0 / 38.0]\nz2 = [0 / 44.0, 42 / 94.0, 0 / 22.0]\n\nCORRECT_ANSWERS = [0.021378001462867, 0.148841696605327, 0.0359722710297968,\n                   0.090773324285671, 0.0107515611497845, 0.00339907162713746, 0.52726574965384, 0.545266866977794].freeze\n\npvalue = calculate_p_value(d1, d2)\nerror = (pvalue - CORRECT_ANSWERS[0]).abs\nprintf(\"Test sets 1 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d3, d4)\nerror += (pvalue - CORRECT_ANSWERS[1]).abs\nprintf(\"Test sets 2 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d5, d6)\nerror += (pvalue - CORRECT_ANSWERS[2]).abs\nprintf(\"Test sets 3 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(d7, d8)\nerror += (pvalue - CORRECT_ANSWERS[3]).abs\nprintf(\"Test sets 4 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(x, y)\nerror += (pvalue - CORRECT_ANSWERS[4]).abs\nprintf(\"Test sets 5 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(v1, v2)\nerror += (pvalue - CORRECT_ANSWERS[5]).abs\nprintf(\"Test sets 6 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(s1, s2)\nerror += (pvalue - CORRECT_ANSWERS[6]).abs\nprintf(\"Test sets 7 p-value =\u00a0%.14g\\n\", pvalue)\n\npvalue = calculate_p_value(z1, z2)\nerror += (pvalue - CORRECT_ANSWERS[7]).abs\nprintf(\"Test sets z p-value =\u00a0%.14g\\n\", pvalue)\n\nprintf(\"the cumulative error is %g\\n\", error)\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 425323, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to Java: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 425324, "name": "Fibonacci matrix-exponentiation", "source": "Translate Ruby to Java: func fibonacci(n) {\n    ([[1,1],[1,0]]**n)[0][1]\n}\n\nsay 15.of(fibonacci)    \n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 425325, "name": "Ramanujan's constant", "source": "Translate Ruby to Java: require \"bigdecimal/math\"\ninclude BigMath\n\ne, pi = E(200), PI(200)\n[19, 43, 67, 163].each do |x|\n  puts \"\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 425326, "name": "Ramanujan's constant", "source": "Translate Ruby to Java: require \"bigdecimal/math\"\ninclude BigMath\n\ne, pi = E(200), PI(200)\n[19, 43, 67, 163].each do |x|\n  puts \"\nend\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 425327, "name": "Most frequent k chars distance", "source": "Translate Ruby to Java: func _MostFreqKHashing(string, k) {\n\n    var seen = Hash()\n    var chars = string.chars\n    var freq = chars.freq\n    var schars = freq.keys.sort_by {|c| -freq{c} }\n\n    var mfkh = []\n    for i in ^k {\n        chars.each { |c|\n            seen{c} && next\n            if (freq{c} == freq{schars[i]}) {\n                seen{c} = true\n                mfkh << Hash(c => c, f => freq{c})\n                break\n            }\n        }\n    }\n\n    mfkh << (k-seen.len -> of { Hash(c => :NULL, f => 0) }...)\n    mfkh\n}\n\nfunc MostFreqKSDF(a, b, k, d) {\n\n    var mfkh_a = _MostFreqKHashing(a, k);\n    var mfkh_b = _MostFreqKHashing(b, k);\n\n    d - gather {\n        mfkh_a.each { |s|\n            s{:c} == :NULL && next\n            mfkh_b.each { |t|\n                s{:c} == t{:c} &&\n                    take(s{:f} + (s{:f} == t{:f} ? 0 : t{:f}))\n            }\n        }\n    }.sum\n}\n\nfunc MostFreqKHashing(string, k) {\n    gather {\n        _MostFreqKHashing(string, k).each { |h|\n            take(\"%s%d\" % (h{:c}, h{:f}))\n        }\n    }.join\n}\n\n\nvar str1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\"\nvar str2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\"\n\nsay \"str1 = \nsay \"str2 = \n\nsay ''\n\nsay(\"MostFreqKHashing(str1, 2) = \", MostFreqKHashing(str1, 2))\nsay(\"MostFreqKHashing(str2, 2) = \", MostFreqKHashing(str2, 2))\nsay(\"MostFreqKSDF(str1, str2, 2, 100) = \", MostFreqKSDF(str1, str2, 2, 100))\n\nsay ''\n\nvar arr = [\n    %w(night nacht),\n    %w(my a),\n    %w(research research),\n    %w(aaaaabbbb ababababa),\n    %w(significant capabilities),\n]\n\nvar k = 2\nvar limit = 10\n\nfor s,t in arr {\n    \"mfkh(%s, %s, \n        s.dump, t.dump,\n        MostFreqKHashing(s, k).dump,\n        MostFreqKHashing(t, k).dump,\n        MostFreqKSDF(s, t, k, limit),\n    )\n}\n", "target": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class SDF {\n\n    \n    public static HashMap<Character, Integer> countElementOcurrences(char[] array) {\n\n        HashMap<Character, Integer> countMap = new HashMap<Character, Integer>();\n\n        for (char element : array) {\n            Integer count = countMap.get(element);\n            count = (count == null) ? 1 : count + 1;\n            countMap.put(element, count);\n        }\n\n        return countMap;\n    }\n    \n    \n    private static <K, V extends Comparable<? super V>>\n            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { \n\tList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n\t\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>() {\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t    return o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t    });\n\n\t\n\t\n\tHashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list) {\n\t    sortedHashMap.put(entry.getKey(), entry.getValue());\n\t} \n\treturn sortedHashMap;\n    }\n    \n    public static String mostOcurrencesElement(char[] array, int k) {\n        HashMap<Character, Integer> countMap = countElementOcurrences(array);\n        System.out.println(countMap);\n        Map<Character, Integer> map = descendingSortByValues(countMap); \n        System.out.println(map);\n        int i = 0;\n        String output = \"\";\n        for (Map.Entry<Character, Integer> pairs : map.entrySet()) {\n\t    if (i++ >= k)\n\t\tbreak;\n            output += \"\" + pairs.getKey() + pairs.getValue();\n        }\n        return output;\n    }\n    \n    public static int getDiff(String str1, String str2, int limit) {\n        int similarity = 0;\n\tint k = 0;\n\tfor (int i = 0; i < str1.length() ; i = k) {\n\t    k ++;\n\t    if (Character.isLetter(str1.charAt(i))) {\n\t\tint pos = str2.indexOf(str1.charAt(i));\n\t\t\t\t\n\t\tif (pos >= 0) {\t\n\t\t    String digitStr1 = \"\";\n\t\t    while ( k < str1.length() && !Character.isLetter(str1.charAt(k))) {\n\t\t\tdigitStr1 += str1.charAt(k);\n\t\t\tk++;\n\t\t    }\n\t\t\t\t\t\n\t\t    int k2 = pos+1;\n\t\t    String digitStr2 = \"\";\n\t\t    while (k2 < str2.length() && !Character.isLetter(str2.charAt(k2)) ) {\n\t\t\tdigitStr2 += str2.charAt(k2);\n\t\t\tk2++;\n\t\t    }\n\t\t\t\t\t\n\t\t    similarity += Integer.parseInt(digitStr2)\n\t\t\t+ Integer.parseInt(digitStr1);\n\t\t\t\t\t\n\t\t} \n\t    }\n\t}\n\treturn Math.abs(limit - similarity);\n    }\n    \n    public static int SDFfunc(String str1, String str2, int limit) {\n        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);\n    }\n\n    public static void main(String[] args) {\n        String input1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\";\n        String input2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\";\n        System.out.println(SDF.SDFfunc(input1,input2,100));\n\n    }\n\n}\n"}
{"id": 425328, "name": "Distance and Bearing", "source": "Translate Ruby to Java: require 'open-uri'\nrequire 'csv'\ninclude Math\n\nRADIUS = 6372.8  \n\ndef spherical_distance(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  2 * RADIUS * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))\nend\n\ndef bearing(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  dlon = long2 - long1\n  atan2(sin(dlon) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon))\nend\n\ndef deg2rad(lat, long)\n  [lat * PI / 180, long * PI / 180]\nend\n\nuri = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\"\nheaders = %i(airportID\n    name\n    city\n    country\n    iata\n    icao\n    latitude\n    longitude\n    altitude\n    timezone\n    dst\n    tzOlson\n    type\n    source)\ndata = CSV.parse(URI.open(uri), headers: headers, converters: :numeric)\n\nposition = [51.514669, 2.198581]\n\ndata.each{|r| r[:dist] = (spherical_distance(position, [r[:latitude], r[:longitude]])/1.852).round(1)}\nclosest =  data.min_by(20){|row| row[:dist] }\nclosest.each do |r|\n  bearing = (bearing(position,[r[:latitude], r[:longitude]])*180/PI).round % 360\n  puts \"%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\" % (r.values_at(:name, :country, :ICAO, :dist) << bearing)\nend\n", "target": "\npackage distanceAndBearing;\npublic class Airport {\n\tprivate String airport;\n\tprivate String country;\n\tprivate String icao;\n\tprivate double lat;\n\tprivate double lon;\n\tpublic String getAirportName() {\treturn this.airport;\t}\n\tpublic void setAirportName(String airport) {\tthis.airport = airport; }\n\tpublic String getCountry() {\treturn this.country;\t}\n\tpublic void setCountry(String country) {\tthis.country = country;\t}\n\tpublic String getIcao() { return this.icao; }\n\tpublic void setIcao(String icao) { this.icao = icao;\t}\n\tpublic double getLat() {\treturn this.lat; }\n\tpublic void setLat(double lat) {\tthis.lat = lat;\t}\n\tpublic double getLon() {\treturn this.lon; }\n\tpublic void setLon(double lon) {\tthis.lon = lon;\t}\n\t@Override\n\tpublic String toString() {return \"Airport: \" + getAirportName() + \": ICAO: \" + getIcao();}\n}\n\n\npackage distanceAndBearing;\nimport java.io.File;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\npublic class DistanceAndBearing {\n\tprivate final double earthRadius = 6371;\n\tprivate File datFile;\n\tprivate List<Airport> airports;\n\tpublic DistanceAndBearing() { this.airports = new ArrayList<Airport>(); }\n\tpublic boolean readFile(String filename) {\n\t\tthis.datFile = new File(filename);\n\t\ttry {\n\t\t\tScanner fileScanner = new Scanner(datFile);\n\t\t\tString line;\n\t\t\twhile (fileScanner.hasNextLine()) {\n\t\t\t\tline = fileScanner.nextLine();\n\t\t\t\tline = line.replace(\", \", \"; \"); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tline = line.replace(\",\\\",\\\"\", \"\\\",\\\"\"); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tString[] parts = line.split(\",\");\n\t\t\t\tAirport airport = new Airport();\n\t\t\t\tairport.setAirportName(parts[1].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setCountry(parts[3].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setIcao(parts[5].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setLat(Double.valueOf(parts[6]));\n\t\t\t\tairport.setLon(Double.valueOf(parts[7]));\n\t\t\t\tthis.airports.add(airport);\n\t\t\t}\n\t\t\tfileScanner.close();\n\t\t\treturn true; \n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false; \n\t\t}}\n\tpublic double[] calculate(double lat1, double lon1, double lat2, double lon2) {\n\t\tdouble[] results = new double[2];\n\t\tdouble dLat = Math.toRadians(lat2 - lat1);\n\t\tdouble dLon = Math.toRadians(lon2 - lon1);\n\t\tdouble rlat1 = Math.toRadians(lat1);\n\t\tdouble rlat2 = Math.toRadians(lat2);\n\t\tdouble a = Math.pow(Math.sin(dLat / 2), 2)\n\t\t\t\t+ Math.pow(Math.sin(dLon / 2), 2) * Math.cos(rlat1) * Math.cos(rlat2);\n\t\tdouble c = 2 * Math.asin(Math.sqrt(a));\n\t\tdouble distance = earthRadius * c;\n\t\tDecimalFormat df = new DecimalFormat(\"#0.00\");\n\t\tdistance = Double.valueOf(df.format(distance));\n\t\tresults[0] = distance;\n\t\tdouble X = Math.cos(rlat2) * Math.sin(dLon);\n\t\tdouble Y = Math.cos(rlat1) * Math.sin(rlat2) - Math.sin(rlat1) * Math.cos(rlat2) * Math.cos(dLon);\n\t\tdouble heading = Math.atan2(X, Y);\n\t\theading = Math.toDegrees(heading);\n\t\tresults[1] = heading;\n\t\treturn results;\n\t}\n\tpublic Airport searchByName(final String name) {\n\t\tAirport airport = new Airport();\n\t\tList<Airport> results = this.airports.stream().filter(ap -> ap.getAirportName().contains(name))\n\t\t\t\t.collect(Collectors.toList());\n\t\tairport = results.get(0);\n\t\treturn airport;\n\t}\n\tpublic List<Airport> findClosestAirports(double lat, double lon) {\n\t\t\n\t\tMap<Double, Airport> airportDistances = new HashMap<>();\n\t\tMap<Double, Airport> airportHeading = new HashMap<>();\n\t\tList<Airport> closestAirports = new ArrayList<Airport>();\n\t\t\n\t\t\n\t\tfor (Airport ap : this.airports) {\n\t\t\tdouble[] result = calculate(lat, lon, ap.getLat(), ap.getLon());\n\t\t\tairportDistances.put(result[0], ap);\n\t\t\tairportHeading.put(result[1], ap);\n\t\t}\n\t\t\n\t\tArrayList<Double> distances = new ArrayList<>(airportDistances.keySet());\n\t\tCollections.sort(distances);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfor (int i = 0; i < 20; i++) { closestAirports.add(searchByName((airportDistances.get(distances.get(i)).getAirportName())));}\n\t\t\n\t\tMap<String, Double> distanceMap = new HashMap<>();\n\t\tfor (Double d : airportDistances.keySet()) {\tdistanceMap.put(airportDistances.get(d).getAirportName(), d);}\n\t\tMap<String, Double> headingMap = new HashMap<>();\n\t\tfor (Double d : airportHeading.keySet()) { \n            double d2 = d;\n            if(d2<0){d2+=360'}\n            headingMap.put(airportHeading.get(d).getAirportName(), d2); }\n\n\t\t\n\t\tSystem.out.printf(\"%-4s\u00a0%-40s\u00a0%-25s\u00a0%-6s %12s %15s\\n\", \"Num\", \"Airport\", \"Country\", \"ICAO\", \"Distance\", \"Bearing\");\n\t\tSystem.out.println(\"-----------------------------------------------------------------------------------------------------------\");\n\t\tint i = 0;\n\t\tfor (Airport a : closestAirports) {\n\t\t\tSystem.out.printf(\"%-4s\u00a0%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\\n\", ++i, a.getAirportName(), a.getCountry(), a.getIcao(), distanceMap.get(a.getAirportName())*0.5399568, headingMap.get(a.getAirportName()));\n\t\t}\n\t\treturn closestAirports;\n\t}\n}\n"}
{"id": 425329, "name": "Distance and Bearing", "source": "Translate Ruby to Java: require 'open-uri'\nrequire 'csv'\ninclude Math\n\nRADIUS = 6372.8  \n\ndef spherical_distance(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  2 * RADIUS * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))\nend\n\ndef bearing(start_coords, end_coords)\n  lat1, long1 = deg2rad(*start_coords)\n  lat2, long2 = deg2rad(*end_coords)\n  dlon = long2 - long1\n  atan2(sin(dlon) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dlon))\nend\n\ndef deg2rad(lat, long)\n  [lat * PI / 180, long * PI / 180]\nend\n\nuri = \"https://raw.githubusercontent.com/jpatokal/openflights/master/data/airports.dat\"\nheaders = %i(airportID\n    name\n    city\n    country\n    iata\n    icao\n    latitude\n    longitude\n    altitude\n    timezone\n    dst\n    tzOlson\n    type\n    source)\ndata = CSV.parse(URI.open(uri), headers: headers, converters: :numeric)\n\nposition = [51.514669, 2.198581]\n\ndata.each{|r| r[:dist] = (spherical_distance(position, [r[:latitude], r[:longitude]])/1.852).round(1)}\nclosest =  data.min_by(20){|row| row[:dist] }\nclosest.each do |r|\n  bearing = (bearing(position,[r[:latitude], r[:longitude]])*180/PI).round % 360\n  puts \"%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\" % (r.values_at(:name, :country, :ICAO, :dist) << bearing)\nend\n", "target": "\npackage distanceAndBearing;\npublic class Airport {\n\tprivate String airport;\n\tprivate String country;\n\tprivate String icao;\n\tprivate double lat;\n\tprivate double lon;\n\tpublic String getAirportName() {\treturn this.airport;\t}\n\tpublic void setAirportName(String airport) {\tthis.airport = airport; }\n\tpublic String getCountry() {\treturn this.country;\t}\n\tpublic void setCountry(String country) {\tthis.country = country;\t}\n\tpublic String getIcao() { return this.icao; }\n\tpublic void setIcao(String icao) { this.icao = icao;\t}\n\tpublic double getLat() {\treturn this.lat; }\n\tpublic void setLat(double lat) {\tthis.lat = lat;\t}\n\tpublic double getLon() {\treturn this.lon; }\n\tpublic void setLon(double lon) {\tthis.lon = lon;\t}\n\t@Override\n\tpublic String toString() {return \"Airport: \" + getAirportName() + \": ICAO: \" + getIcao();}\n}\n\n\npackage distanceAndBearing;\nimport java.io.File;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\npublic class DistanceAndBearing {\n\tprivate final double earthRadius = 6371;\n\tprivate File datFile;\n\tprivate List<Airport> airports;\n\tpublic DistanceAndBearing() { this.airports = new ArrayList<Airport>(); }\n\tpublic boolean readFile(String filename) {\n\t\tthis.datFile = new File(filename);\n\t\ttry {\n\t\t\tScanner fileScanner = new Scanner(datFile);\n\t\t\tString line;\n\t\t\twhile (fileScanner.hasNextLine()) {\n\t\t\t\tline = fileScanner.nextLine();\n\t\t\t\tline = line.replace(\", \", \"; \"); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tline = line.replace(\",\\\",\\\"\", \"\\\",\\\"\"); \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\tString[] parts = line.split(\",\");\n\t\t\t\tAirport airport = new Airport();\n\t\t\t\tairport.setAirportName(parts[1].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setCountry(parts[3].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setIcao(parts[5].replace(\"\\\"\", \"\")); \n\t\t\t\tairport.setLat(Double.valueOf(parts[6]));\n\t\t\t\tairport.setLon(Double.valueOf(parts[7]));\n\t\t\t\tthis.airports.add(airport);\n\t\t\t}\n\t\t\tfileScanner.close();\n\t\t\treturn true; \n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false; \n\t\t}}\n\tpublic double[] calculate(double lat1, double lon1, double lat2, double lon2) {\n\t\tdouble[] results = new double[2];\n\t\tdouble dLat = Math.toRadians(lat2 - lat1);\n\t\tdouble dLon = Math.toRadians(lon2 - lon1);\n\t\tdouble rlat1 = Math.toRadians(lat1);\n\t\tdouble rlat2 = Math.toRadians(lat2);\n\t\tdouble a = Math.pow(Math.sin(dLat / 2), 2)\n\t\t\t\t+ Math.pow(Math.sin(dLon / 2), 2) * Math.cos(rlat1) * Math.cos(rlat2);\n\t\tdouble c = 2 * Math.asin(Math.sqrt(a));\n\t\tdouble distance = earthRadius * c;\n\t\tDecimalFormat df = new DecimalFormat(\"#0.00\");\n\t\tdistance = Double.valueOf(df.format(distance));\n\t\tresults[0] = distance;\n\t\tdouble X = Math.cos(rlat2) * Math.sin(dLon);\n\t\tdouble Y = Math.cos(rlat1) * Math.sin(rlat2) - Math.sin(rlat1) * Math.cos(rlat2) * Math.cos(dLon);\n\t\tdouble heading = Math.atan2(X, Y);\n\t\theading = Math.toDegrees(heading);\n\t\tresults[1] = heading;\n\t\treturn results;\n\t}\n\tpublic Airport searchByName(final String name) {\n\t\tAirport airport = new Airport();\n\t\tList<Airport> results = this.airports.stream().filter(ap -> ap.getAirportName().contains(name))\n\t\t\t\t.collect(Collectors.toList());\n\t\tairport = results.get(0);\n\t\treturn airport;\n\t}\n\tpublic List<Airport> findClosestAirports(double lat, double lon) {\n\t\t\n\t\tMap<Double, Airport> airportDistances = new HashMap<>();\n\t\tMap<Double, Airport> airportHeading = new HashMap<>();\n\t\tList<Airport> closestAirports = new ArrayList<Airport>();\n\t\t\n\t\t\n\t\tfor (Airport ap : this.airports) {\n\t\t\tdouble[] result = calculate(lat, lon, ap.getLat(), ap.getLon());\n\t\t\tairportDistances.put(result[0], ap);\n\t\t\tairportHeading.put(result[1], ap);\n\t\t}\n\t\t\n\t\tArrayList<Double> distances = new ArrayList<>(airportDistances.keySet());\n\t\tCollections.sort(distances);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tfor (int i = 0; i < 20; i++) { closestAirports.add(searchByName((airportDistances.get(distances.get(i)).getAirportName())));}\n\t\t\n\t\tMap<String, Double> distanceMap = new HashMap<>();\n\t\tfor (Double d : airportDistances.keySet()) {\tdistanceMap.put(airportDistances.get(d).getAirportName(), d);}\n\t\tMap<String, Double> headingMap = new HashMap<>();\n\t\tfor (Double d : airportHeading.keySet()) { \n            double d2 = d;\n            if(d2<0){d2+=360'}\n            headingMap.put(airportHeading.get(d).getAirportName(), d2); }\n\n\t\t\n\t\tSystem.out.printf(\"%-4s\u00a0%-40s\u00a0%-25s\u00a0%-6s %12s %15s\\n\", \"Num\", \"Airport\", \"Country\", \"ICAO\", \"Distance\", \"Bearing\");\n\t\tSystem.out.println(\"-----------------------------------------------------------------------------------------------------------\");\n\t\tint i = 0;\n\t\tfor (Airport a : closestAirports) {\n\t\t\tSystem.out.printf(\"%-4s\u00a0%-40s\u00a0%-25s\u00a0%-6s %12.1f %15.0f\\n\", ++i, a.getAirportName(), a.getCountry(), a.getIcao(), distanceMap.get(a.getAirportName())*0.5399568, headingMap.get(a.getAirportName()));\n\t\t}\n\t\treturn closestAirports;\n\t}\n}\n"}
{"id": 425330, "name": "Pan base non-primes", "source": "Translate Ruby to Java: require 'prime'\n\ndef int_from_digits(ar, base=10) \n  \n  raise ArgumentError, \"\n  ar.each_with_index.sum {|d, i| d*base**i }\nend\n\nlimit = 2500\na121719 = (2..limit).lazy.select do |n|\n  next false if (n < 10 && n.prime?)\n  digits = n.digits\n  from = digits.max + 1\n  (from..n).none?{|base| int_from_digits(digits, base).prime? }\nend\n\nn = 50\nputs \"First \na121719.take(n).each_slice(10){|s| puts \"%4s\"*s.size % s}\n\nn = 20\nputs \"\\nFirst \na121719.select(&:odd?).take(n).each_slice(10){|s| puts \"%4s\"*s.size % s }\n\ntally = a121719.map(&:odd?).tally\ntotal = tally.values.sum\nputs \"\\nCount of pan-base composites up to and including \nputs \"Number of odds  is \nputs \"Number of evens is \n", "target": "public class PanBaseNonPrimes {\n    public static void main(String[] args) {\n        System.out.printf(\"First 50 prime pan-base composites:\\n\");\n        int count = 0;\n        for (long n = 2; count < 50; ++n) {\n            if (isPanBaseNonPrime(n)) {\n                ++count;\n                System.out.printf(\"%3d%c\", n, count % 10 == 0 ? '\\n' : ' ');\n            }\n        }\n    \n        System.out.printf(\"\\nFirst 20 odd prime pan-base composites:\\n\");\n        count = 0;\n        for (long n = 3; count < 20; n += 2) {\n            if (isPanBaseNonPrime(n)) {\n                ++count;\n                System.out.printf(\"%3d%c\", n, count % 10 == 0 ? '\\n' : ' ');\n            }\n        }\n    \n        final long limit = 10000;\n        count = 0;\n        int odd = 0;\n        for (long n = 2; n <= limit; ++n) {\n            if (isPanBaseNonPrime(n)) {\n                ++count;\n                if (n % 2 == 1)\n                    ++odd;\n            }\n        }\n    \n        System.out.printf(\"\\nCount of pan-base composites up to and including %d: %d\\n\",\n                            limit, count);\n        double percent = 100.0 * odd / count;\n        System.out.printf(\"Percent odd  up to and including %d: %f\\n\",\n                            limit, percent);\n        System.out.printf(\"Percent even up to and including %d: %f\\n\",\n                            limit, 100.0 - percent);\n    }\n\n    private static boolean isPanBaseNonPrime(long n) {\n        if (n < 10)\n            return !isPrime(n);\n        if (n > 10 && n % 10 == 0)\n            return true;\n        byte[] d = new byte[20];\n        int count = digits(n, d);\n        byte max_digit = 0;\n        for (int i = 0; i < count; ++i) {\n            if (max_digit < d[i])\n                max_digit = d[i];\n        }\n        for (long base = max_digit + 1; base <= n; ++base) {\n            if (isPrime(fromDigits(d, count, base)))\n                return false;\n        }\n        return true;\n    }\n\n    private static final long[] WHEEL = {4, 2, 4, 2, 4, 6, 2, 6};\n\n    private static boolean isPrime(long n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        if (n % 5 == 0)\n            return n == 5;\n        for (long p = 7;;) {\n            for (int i = 0; i < 8; ++i) {\n                if (p * p > n)\n                    return true;\n                if (n % p == 0)\n                    return false;\n                p += WHEEL[i];\n            }\n        }\n    }\n\n    \n    private static int digits(long n, byte[] d) {\n        int count = 0;\n        for (; n > 0 && count < d.length; n /= 10, ++count)\n            d[count] = (byte)(n % 10);\n        return count;\n    }\n\n    \n    private static long fromDigits(byte[] a, int count, long base) {\n        long n = 0;\n        while (count-- > 0)\n            n = n * base + a[count];\n        return n;\n    }\n}\n"}
{"id": 425331, "name": "Practical numbers", "source": "Translate Ruby to Java: say is_practical(2**128 + 1)   \nsay is_practical(2**128 + 4)   \n", "target": "import java.util.*;\n\npublic class PracticalNumbers {\n    public static void main(String[] args) {\n        final int from = 1;\n        final int to = 333;\n        List<Integer> practical = new ArrayList<>();\n        for (int i = from; i <= to; ++i) {\n            if (isPractical(i))\n                practical.add(i);\n        }\n        System.out.printf(\"Found %d practical numbers between %d and %d:\\n%s\\n\",\n                practical.size(), from, to, shorten(practical, 10));\n\n        printPractical(666);\n        printPractical(6666);\n        printPractical(66666);\n        printPractical(672);\n        printPractical(720);\n        printPractical(222222);\n    }\n\n    private static void printPractical(int n) {\n        if (isPractical(n))\n            System.out.printf(\"%d is a practical number.\\n\", n);\n        else\n            System.out.printf(\"%d is not a practical number.\\n\", n);\n    }\n\n    private static boolean isPractical(int n) {\n        int[] divisors = properDivisors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, divisors, divisors.length))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean sumOfAnySubset(int n, int[] f, int len) {\n        if (len == 0)\n            return false;\n        int total = 0;\n        for (int i = 0; i < len; ++i) {\n            if (n == f[i])\n                return true;\n            total += f[i];\n        }\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        --len;\n        int d = n - f[len];\n        return (d > 0 && sumOfAnySubset(d, f, len)) || sumOfAnySubset(n, f, len);\n    }\n\n    private static int[] properDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        divisors.add(1);\n        for (int i = 2;; ++i) {\n            int i2 = i * i;\n            if (i2 > n)\n                break;\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i2 != n)\n                    divisors.add(n / i);\n            }\n        }\n        int[] result = new int[divisors.size()];\n        for (int i = 0; i < result.length; ++i)\n            result[i] = divisors.get(i);\n        Arrays.sort(result);\n        return result;\n    }\n\n    private static String shorten(List<Integer> list, int n) {\n        StringBuilder str = new StringBuilder();\n        int len = list.size(), i = 0;\n        if (n > 0 && len > 0)\n            str.append(list.get(i++));\n        for (; i < n && i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        if (len > i + n) {\n            if (n > 0)\n                str.append(\", ...\");\n            i = len - n;\n        }\n        for (; i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        return str.toString();\n    }\n}\n"}
{"id": 425332, "name": "Penrose tiling", "source": "Translate Ruby to Java: var rules = Hash(\n    a => 'cE++dE----bE[-cE----aE]++',\n    b => '+cE--dE[---aE--bE]+',\n    c => '-aE++bE[+++cE++dE]-',\n    d => '--cE++++aE[+dE++++bE]--bE',\n    E => '',\n)\n\nvar lsys = LSystem(\n    width:  1000,\n    height: 1000,\n\n    scale: 1,\n    xoff: -500,\n    yoff: -500,\n\n    len:   40,\n    angle: 36,\n    color: 'dark blue',\n)\n\nlsys.execute('[b]++[b]++[b]++[b]++[b]', 5, \"penrose_tiling.png\", rules)\n", "target": "import java.awt.*;\nimport java.util.List;\nimport java.awt.geom.Path2D;\nimport java.util.*;\nimport javax.swing.*;\nimport static java.lang.Math.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class PenroseTiling extends JPanel {\n    \n    class Tile {\n        double x, y, angle, size;\n        Type type;\n\n        Tile(Type t, double x, double y, double a, double s) {\n            type = t;\n            this.x = x;\n            this.y = y;\n            angle = a;\n            size = s;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Tile) {\n                Tile t = (Tile) o;\n                return type == t.type && x == t.x && y == t.y && angle == t.angle;\n            }\n            return false;\n        }\n    }\n\n    enum Type {\n        Kite, Dart\n    }\n\n    static final double G = (1 + sqrt(5)) / 2; \n    static final double T = toRadians(36); \n\n    List<Tile> tiles = new ArrayList<>();\n\n    public PenroseTiling() {\n        int w = 700, h = 450;\n        setPreferredSize(new Dimension(w, h));\n        setBackground(Color.white);\n\n        tiles = deflateTiles(setupPrototiles(w, h), 5);\n    }\n\n    List<Tile> setupPrototiles(int w, int h) {\n        List<Tile> proto = new ArrayList<>();\n\n        \n        for (double a = PI / 2 + T; a < 3 * PI; a += 2 * T)\n            proto.add(new Tile(Type.Kite, w / 2, h / 2, a, w / 2.5));\n\n        return proto;\n    }\n\n    List<Tile> deflateTiles(List<Tile> tls, int generation) {\n        if (generation <= 0)\n            return tls;\n\n        List<Tile> next = new ArrayList<>();\n\n        for (Tile tile : tls) {\n            double x = tile.x, y = tile.y, a = tile.angle, nx, ny;\n            double size = tile.size / G;\n\n            if (tile.type == Type.Dart) {\n                next.add(new Tile(Type.Kite, x, y, a + 5 * T, size));\n\n                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {\n                    nx = x + cos(a - 4 * T * sign) * G * tile.size;\n                    ny = y - sin(a - 4 * T * sign) * G * tile.size;\n                    next.add(new Tile(Type.Dart, nx, ny, a - 4 * T * sign, size));\n                }\n\n            } else {\n\n                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {\n                    next.add(new Tile(Type.Dart, x, y, a - 4 * T * sign, size));\n\n                    nx = x + cos(a - T * sign) * G * tile.size;\n                    ny = y - sin(a - T * sign) * G * tile.size;\n                    next.add(new Tile(Type.Kite, nx, ny, a + 3 * T * sign, size));\n                }\n            }\n        }\n        \n        tls = next.stream().distinct().collect(toList());\n\n        return deflateTiles(tls, generation - 1);\n    }\n\n    void drawTiles(Graphics2D g) {\n        double[][] dist = {{G, G, G}, {-G, -1, -G}};\n        for (Tile tile : tiles) {\n            double angle = tile.angle - T;\n            Path2D path = new Path2D.Double();\n            path.moveTo(tile.x, tile.y);\n\n            int ord = tile.type.ordinal();\n            for (int i = 0; i < 3; i++) {\n                double x = tile.x + dist[ord][i] * tile.size * cos(angle);\n                double y = tile.y - dist[ord][i] * tile.size * sin(angle);\n                path.lineTo(x, y);\n                angle += T;\n            }\n            path.closePath();\n            g.setColor(ord == 0 ? Color.orange : Color.yellow);\n            g.fill(path);\n            g.setColor(Color.darkGray);\n            g.draw(path);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics og) {\n        super.paintComponent(og);\n        Graphics2D g = (Graphics2D) og;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawTiles(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Penrose Tiling\");\n            f.setResizable(false);\n            f.add(new PenroseTiling(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 425333, "name": "Generalised floating point addition", "source": "Translate Ruby to Java: p 12345679e63 * 81 + 1e63\np 12345679012345679e54 * 81 + 1e54\np 12345679012345679012345679e45 * 81 + 1e45\np 12345679012345679012345679012345679e36 * 81 + 1e36\n", "target": "import java.math.BigDecimal;\n\npublic class GeneralisedFloatingPointAddition {\n\n    public static void main(String[] args) {\n        BigDecimal oneExp72 = new BigDecimal(\"1E72\");\n        for ( int i = 0 ; i <= 21+7 ; i++ ) {\n            String s = \"12345679\";\n            for ( int j = 0 ; j < i ; j++ ) {\n                s += \"012345679\";\n            }\n            int exp = 63 - 9*i;\n            s += \"E\" + exp;\n            BigDecimal num = new BigDecimal(s).multiply(BigDecimal.valueOf(81)).add(new BigDecimal(\"1E\" + exp));\n            System.out.printf(\"Test value (%s) equals computed value: %b.  Computed = %s%n\", oneExp72, num.compareTo(oneExp72) == 0 , num);\n        }\n    }\n\n}\n"}
{"id": 425334, "name": "Generalised floating point addition", "source": "Translate Ruby to Java: p 12345679e63 * 81 + 1e63\np 12345679012345679e54 * 81 + 1e54\np 12345679012345679012345679e45 * 81 + 1e45\np 12345679012345679012345679012345679e36 * 81 + 1e36\n", "target": "import java.math.BigDecimal;\n\npublic class GeneralisedFloatingPointAddition {\n\n    public static void main(String[] args) {\n        BigDecimal oneExp72 = new BigDecimal(\"1E72\");\n        for ( int i = 0 ; i <= 21+7 ; i++ ) {\n            String s = \"12345679\";\n            for ( int j = 0 ; j < i ; j++ ) {\n                s += \"012345679\";\n            }\n            int exp = 63 - 9*i;\n            s += \"E\" + exp;\n            BigDecimal num = new BigDecimal(s).multiply(BigDecimal.valueOf(81)).add(new BigDecimal(\"1E\" + exp));\n            System.out.printf(\"Test value (%s) equals computed value: %b.  Computed = %s%n\", oneExp72, num.compareTo(oneExp72) == 0 , num);\n        }\n    }\n\n}\n"}
{"id": 425335, "name": "Powerful numbers", "source": "Translate Ruby to Java: func powerful(n, k=2) {\n\n    var list = []\n\n    func (m,r) {\n        if (r < k) {\n            list << m\n            return nil\n        }\n        for a in (1 .. iroot(idiv(n,m), r)) {\n            if (r > k) {\n                a.is_coprime(m) || next\n                a.is_squarefree || next\n            }\n            __FUNC__(m * a**r, r-1)\n        }\n    }(1, 2*k - 1)\n\n    return list.sort\n}\n\nfor k in (2..10) {\n    var a = powerful(10**k, k)\n    var h = a.head(5).join(', ')\n    var t = a.tail(5).join(', ')\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", k, a.len, h, t)\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class PowerfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Task:  For k = 2..10, generate the set of k-powerful numbers <= 10^k and show the first 5 and the last 5 terms, along with the length of the set%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            BigInteger max = BigInteger.valueOf(10).pow(k);\n            List<BigInteger> powerfulNumbers = getPowerFulNumbers(max, k);\n            System.out.printf(\"There are %d %d-powerful numbers between 1 and %d.  %nList: %s%n\", powerfulNumbers.size(), k, max, getList(powerfulNumbers));\n        }\n        System.out.printf(\"%nTask:  For k = 2..10, show the number of k-powerful numbers less than or equal to 10^j, for 0 <= j < k+10%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            List<Integer> powCount = new ArrayList<>();\n            for ( int j = 0 ; j < k+10 ; j++ ) {\n                BigInteger max = BigInteger.valueOf(10).pow(j);\n                powCount.add(countPowerFulNumbers(max, k));\n            }\n            System.out.printf(\"Count of %2d-powerful numbers <= 10^j, j in [0, %d]: %s%n\", k, k+9, powCount);\n        }\n        \n    }\n    \n    private static String getList(List<BigInteger> list) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(list.subList(0, 5).toString().replace(\"]\", \"\"));\n        sb.append(\" ... \");\n        sb.append(list.subList(list.size()-5, list.size()).toString().replace(\"[\", \"\"));\n        return sb.toString();\n    }\n\n    private static int countPowerFulNumbers(BigInteger max, int k) {\n        return potentialPowerful(max, k).size();\n    }\n\n    private static List<BigInteger> getPowerFulNumbers(BigInteger max, int k) {\n        List<BigInteger> powerfulNumbers = new ArrayList<>(potentialPowerful(max, k));\n        Collections.sort(powerfulNumbers);\n        return powerfulNumbers;\n    }\n\n    private static Set<BigInteger> potentialPowerful(BigInteger max, int k) {\n        \n        int[] indexes = new int[k];\n        for ( int i = 0 ; i < k ; i++ ) {\n            indexes[i] = 1;\n        }\n\n        Set<BigInteger> powerful = new HashSet<>();\n        boolean foundPower = true;\n        while ( foundPower ) {\n            \n            boolean genPowerful = false;\n            for ( int index = 0 ; index < k ; index++ ) {\n                BigInteger power = BigInteger.ONE;\n                for ( int i = 0 ; i < k ; i++ ) {\n                    power = power.multiply(BigInteger.valueOf(indexes[i]).pow(k+i));\n                }\n                if ( power.compareTo(max) <= 0 ) {\n                    powerful.add(power);\n                    indexes[0] += 1;\n                    genPowerful = true;\n                    break;\n                }\n                else {\n                    indexes[index] = 1;\n                    if ( index < k-1 ) {\n                        indexes[index+1] += 1;\n                    }\n                }\n            }\n            if ( ! genPowerful ) {\n                foundPower = false;\n            }\n        }\n\n        return powerful;\n    }\n    \n}\n"}
{"id": 425336, "name": "Powerful numbers", "source": "Translate Ruby to Java: func powerful(n, k=2) {\n\n    var list = []\n\n    func (m,r) {\n        if (r < k) {\n            list << m\n            return nil\n        }\n        for a in (1 .. iroot(idiv(n,m), r)) {\n            if (r > k) {\n                a.is_coprime(m) || next\n                a.is_squarefree || next\n            }\n            __FUNC__(m * a**r, r-1)\n        }\n    }(1, 2*k - 1)\n\n    return list.sort\n}\n\nfor k in (2..10) {\n    var a = powerful(10**k, k)\n    var h = a.head(5).join(', ')\n    var t = a.tail(5).join(', ')\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", k, a.len, h, t)\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class PowerfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Task:  For k = 2..10, generate the set of k-powerful numbers <= 10^k and show the first 5 and the last 5 terms, along with the length of the set%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            BigInteger max = BigInteger.valueOf(10).pow(k);\n            List<BigInteger> powerfulNumbers = getPowerFulNumbers(max, k);\n            System.out.printf(\"There are %d %d-powerful numbers between 1 and %d.  %nList: %s%n\", powerfulNumbers.size(), k, max, getList(powerfulNumbers));\n        }\n        System.out.printf(\"%nTask:  For k = 2..10, show the number of k-powerful numbers less than or equal to 10^j, for 0 <= j < k+10%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            List<Integer> powCount = new ArrayList<>();\n            for ( int j = 0 ; j < k+10 ; j++ ) {\n                BigInteger max = BigInteger.valueOf(10).pow(j);\n                powCount.add(countPowerFulNumbers(max, k));\n            }\n            System.out.printf(\"Count of %2d-powerful numbers <= 10^j, j in [0, %d]: %s%n\", k, k+9, powCount);\n        }\n        \n    }\n    \n    private static String getList(List<BigInteger> list) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(list.subList(0, 5).toString().replace(\"]\", \"\"));\n        sb.append(\" ... \");\n        sb.append(list.subList(list.size()-5, list.size()).toString().replace(\"[\", \"\"));\n        return sb.toString();\n    }\n\n    private static int countPowerFulNumbers(BigInteger max, int k) {\n        return potentialPowerful(max, k).size();\n    }\n\n    private static List<BigInteger> getPowerFulNumbers(BigInteger max, int k) {\n        List<BigInteger> powerfulNumbers = new ArrayList<>(potentialPowerful(max, k));\n        Collections.sort(powerfulNumbers);\n        return powerfulNumbers;\n    }\n\n    private static Set<BigInteger> potentialPowerful(BigInteger max, int k) {\n        \n        int[] indexes = new int[k];\n        for ( int i = 0 ; i < k ; i++ ) {\n            indexes[i] = 1;\n        }\n\n        Set<BigInteger> powerful = new HashSet<>();\n        boolean foundPower = true;\n        while ( foundPower ) {\n            \n            boolean genPowerful = false;\n            for ( int index = 0 ; index < k ; index++ ) {\n                BigInteger power = BigInteger.ONE;\n                for ( int i = 0 ; i < k ; i++ ) {\n                    power = power.multiply(BigInteger.valueOf(indexes[i]).pow(k+i));\n                }\n                if ( power.compareTo(max) <= 0 ) {\n                    powerful.add(power);\n                    indexes[0] += 1;\n                    genPowerful = true;\n                    break;\n                }\n                else {\n                    indexes[index] = 1;\n                    if ( index < k-1 ) {\n                        indexes[index+1] += 1;\n                    }\n                }\n            }\n            if ( ! genPowerful ) {\n                foundPower = false;\n            }\n        }\n\n        return powerful;\n    }\n    \n}\n"}

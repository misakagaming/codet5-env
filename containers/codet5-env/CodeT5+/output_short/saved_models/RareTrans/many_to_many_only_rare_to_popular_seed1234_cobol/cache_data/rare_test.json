{"id": 388001, "name": "String comparison", "source": "Translate COBOL to Java: \"hello\" = \"hello\"   \n\"helloo\" <> \"hello\" \n\"aello\" < \"hello\"   \n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 388002, "name": "Use another language to call a function", "source": "Translate COBOL to Java:        identification division.\n       program-id. Query.\n\n       environment division.\n       configuration section.\n       special-names.\n           call-convention 0 is extern.\n\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 query-result.\n          05 filler value \"Here I am\".\n\n       linkage section.\n       01 data-reference.\n          05 data-buffer   pic x occurs 0 to 8192 times\n                                 depending on length-reference.\n       01 length-reference usage binary-long.\n\n       procedure division extern using data-reference length-reference.\n\n       if length(query-result) less than or equal to length-reference\n                           and length-reference less than 8193 then\n           move query-result to data-reference\n           move length(query-result) to length-reference\n           move 1 to return-code\n       end-if\n\n       goback.\n       end program Query.\n", "target": "\npublic class Query {\n    public static boolean call(byte[] data, int[] length)\n\tthrows java.io.UnsupportedEncodingException\n    {\n\tString message = \"Here am I\";\n\tbyte[] mb = message.getBytes(\"utf-8\");\n\tif (length[0] < mb.length)\n\t    return false;\n\tlength[0] = mb.length;\n\tSystem.arraycopy(mb, 0, data, 0, mb.length);\n\treturn true;\n    }\n}\n"}
{"id": 388003, "name": "Colour bars_Display", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 388004, "name": "Colour bars_Display", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. terminal-colour-bars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  width           PIC 9(3).\n       01  height          PIC 9(3).\n\n       01  interval        PIC 9(3).\n\n       01  colours-area.\n           03  colour-values.\n               05  FILLER  PIC 9 VALUE 0. \n               05  FILLER  PIC 9 VALUE 4. \n               05  FILLER  PIC 9 VALUE 2. \n               05  FILLER  PIC 9 VALUE 1. \n               05  FILLER  PIC 9 VALUE 5. \n               05  FILLER  PIC 9 VALUE 3. \n               05  FILLER  PIC 9 VALUE 6. \n               05  FILLER  PIC 9 VALUE 7. \n\n           03  colour-table REDEFINES colour-values.\n               05  colours PIC 9 OCCURS 8 TIMES INDEXED BY colour-index.\n\n       01  i               PIC 9(3).\n       01  j               PIC 9(3).\n\n       PROCEDURE DIVISION.\n           ACCEPT width FROM COLUMNS\n           ACCEPT height FROM LINES\n           DIVIDE width BY 8 GIVING interval\n\n           PERFORM VARYING i FROM 1 BY 1 UNTIL height < i\n               PERFORM VARYING j FROM 1 BY 1 UNTIL width < j\n                  COMPUTE colour-index = (j / interval) + 1\n                  \n                  IF 8 < colour-index\n                      SET colour-index TO 8\n                  END-IF\n\n                  \n                  \n                  \n                  DISPLAY SPACE AT LINE i COLUMN j\n                      WITH BACKGROUND-COLOR colours (colour-index)\n               END-PERFORM\n           END-PERFORM\n\n           ACCEPT i \n\n           GOBACK\n           .\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 388005, "name": "Enforced immutability", "source": "Translate COBOL to Java: ENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nSPECIAL-NAMES.\n    SYMBOLIC CHARACTERS NUL IS 0, TAB IS 9.\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 388006, "name": "Strange numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 388007, "name": "Strange numbers", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. STRANGE-NUMBERS.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 COMPUTATION.\n           02 NUM           PIC 999.\n           02 DIGITS        REDEFINES NUM PIC 9 OCCURS 3 TIMES.\n           02 DIGIT-PRIME   PIC 9.\n              88 PRIME      VALUES 2 3 5 7.\n           02 CUR-DIGIT     PIC 9.\n        01 OUTPUT-FORMAT.\n           02 N-OUT         PIC ZZ9.\n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM STRANGE-TEST\n                VARYING NUM FROM 100 BY 1\n                UNTIL NUM IS GREATER THAN 500.\n            STOP RUN.\n        \n        STRANGE-TEST SECTION.\n        BEGIN.\n            SET CUR-DIGIT TO 1.\n        STEP.   \n            IF DIGITS(CUR-DIGIT) IS LESS THAN DIGITS(CUR-DIGIT + 1)\n                SUBTRACT DIGITS(CUR-DIGIT + 1) FROM DIGITS(CUR-DIGIT) \n                    GIVING DIGIT-PRIME\n            ELSE\n                SUBTRACT DIGITS(CUR-DIGIT) FROM DIGITS(CUR-DIGIT + 1)\n                    GIVING DIGIT-PRIME.\n            IF PRIME NEXT SENTENCE ELSE GO TO DONE.\n            ADD 1 TO CUR-DIGIT.\n            IF CUR-DIGIT IS LESS THAN 3 GO TO STEP.\n            MOVE NUM TO N-OUT.\n            DISPLAY N-OUT.\n        DONE. EXIT.\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 388008, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388009, "name": "Hofstadter Q sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. Q-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQ.\n           02 Q         PIC 9(3) OCCURS 1000 TIMES.\n           02 Q-TMP1    PIC 9(3).\n           02 Q-TMP2    PIC 9(3).\n           02 N         PIC 9(4).\n        01 DISPLAYING.\n           02 ITEM      PIC Z(3).\n           02 IX        PIC Z(4).\n            \n        PROCEDURE DIVISION.\n        MAIN-PROGRAM.    \n            PERFORM GENERATE-SEQUENCE.\n            PERFORM SHOW-ITEM\n                VARYING N FROM 1 BY 1 \n                UNTIL N IS GREATER THAN 10.\n            SET N TO 1000.\n            PERFORM SHOW-ITEM.\n            STOP RUN.\n        \n        GENERATE-SEQUENCE.\n            SET Q(1) TO 1.\n            SET Q(2) TO 1.            \n            PERFORM GENERATE-ITEM \n                VARYING N FROM 3 BY 1\n                UNTIL N IS GREATER THAN 1000.\n        \n        GENERATE-ITEM.\n            COMPUTE Q-TMP1 = N - Q(N - 1).\n            COMPUTE Q-TMP2 = N - Q(N - 2).\n            COMPUTE Q(N) = Q(Q-TMP1) + Q(Q-TMP2).\n                        \n        SHOW-ITEM.\n            MOVE N TO IX.\n            MOVE Q(N) TO ITEM.\n            DISPLAY 'Q(' IX ') = ' ITEM.\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388010, "name": "Count occurrences of a substring", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. testing.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  occurrences             PIC 99.\n\n       PROCEDURE DIVISION.\n           INSPECT \"the three truths\" TALLYING occurrences FOR ALL \"th\"\n           DISPLAY occurrences\n\n           MOVE 0 TO occurrences\n           INSPECT \"ababababab\" TALLYING occurrences FOR ALL \"abab\"\n           DISPLAY occurrences\n           \n           MOVE 0 TO occurrences\n           INSPECT \"abaabba*bbaba*bbab\" TALLYING occurrences\n               FOR ALL \"a*b\"\n           DISPLAY occurrences\n\n           GOBACK\n           .\n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 388011, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388012, "name": "Hickerson series of almost integers", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. hickerson-series.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  n                                   PIC 99 COMP.\n\n01  h                                   PIC Z(19)9.9(10).\n\n01  First-Decimal-Digit-Pos             CONSTANT 22.\n\nPROCEDURE DIVISION.\n    PERFORM VARYING n FROM 0 BY 1 UNTIL n > 17\n        COMPUTE h = FACTORIAL(n) / (2 * LOG(2) ** (n + 1))\n        DISPLAY \"h(\" n \") = \" h \" which is \" NO ADVANCING\n        IF h (First-Decimal-Digit-Pos:1) = \"0\" OR \"9\"\n            DISPLAY \"an almost integer.\"\n        ELSE\n            DISPLAY \"not an almost integer.\"\n        END-IF\n    END-PERFORM\n    .\nEND PROGRAM hickerson-series.\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388013, "name": "Read a configuration file", "source": "Translate COBOL to Java:        identification division.\n       program-id. ReadConfiguration.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select config-file     assign to \"Configuration.txt\"\n                                  organization line sequential.\n       data division.\n       file section.\n\n       fd  config-file.\n       01  config-record          pic is x(128).\n\n       working-storage section.\n       77  idx                    pic 9(3).\n       77  pos                    pic 9(3).\n       77  last-pos               pic 9(3).\n       77  config-key             pic x(32).\n       77  config-value           pic x(64).\n       77  multi-value            pic x(64).\n       77  full-name              pic x(64).\n       77  favourite-fruit        pic x(64).\n       77  other-family           pic x(64) occurs 10.\n       77  need-speeling          pic x(5) value \"false\".\n       77  seeds-removed          pic x(5) value \"false\".\n\n       procedure division.\n       main.\n           open input config-file\n           perform until exit\n              read config-file\n                 at end\n                    exit perform\n              end-read  \n              move trim(config-record) to config-record\n              if config-record(1:1) = \"#\" or \";\" or spaces\n                 exit perform cycle\n              end-if\n              unstring config-record delimited by spaces into config-key\n              move trim(config-record(length(trim(config-key)) + 1:)) to config-value\n              if config-value(1:1) = \"=\"\n                 move trim(config-value(2:)) to config-value\n              end-if\n              evaluate upper-case(config-key)\n                 when \"FULLNAME\"\n                    move config-value to full-name\n                 when \"FAVOURITEFRUIT\"\n                    move config-value to favourite-fruit\n                 when \"NEEDSPEELING\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if\n                    if config-value = \"true\" or \"false\"\n                       move config-value to need-speeling\n                    end-if\n                 when \"SEEDSREMOVED\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if,\n                    if config-value = \"true\" or \"false\"\n                       move config-value to seeds-removed\n                    end-if\n                 when \"OTHERFAMILY\"\n                    move 1 to idx, pos\n                    perform until exit\n                       unstring config-value delimited by \",\" into multi-value with pointer pos\n                          on overflow\n                             move trim(multi-value) to other-family(idx)\n                             move pos to last-pos\n                          not on overflow\n                             if config-value(last-pos:) <> spaces\n                                move trim(config-value(last-pos:)) to other-family(idx)\n                             end-if,\n                             exit perform\n                       end-unstring\n                       add 1 to idx\n                    end-perform\n              end-evaluate\n           end-perform\n           close config-file\n\n           display \"fullname = \" full-name\n           display \"favouritefruit = \" favourite-fruit\n           display \"needspeeling = \" need-speeling\n           display \"seedsremoved = \" seeds-removed\n           perform varying idx from 1 by 1 until idx > 10\n              if other-family(idx) <> low-values\n                 display \"otherfamily(\" idx \") = \" other-family(idx)\n              end-if\n           end-perform\n           .\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 388014, "name": "Additive primes", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ADDITIVE-PRIMES.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 MAXIMUM            PIC 999.\n          03 AMOUNT             PIC 999.\n          03 CANDIDATE          PIC 999.\n          03 DIGIT              PIC 9 OCCURS 3 TIMES, \n                                REDEFINES CANDIDATE.\n          03 DIGITSUM           PIC 99.\n          \n       01 PRIME-DATA.\n          03 COMPOSITE-FLAG     PIC X OCCURS 500 TIMES.\n             88 PRIME           VALUE ' '.\n          03 SIEVE-PRIME        PIC 999.\n          03 SIEVE-COMP-START   PIC 999.\n          03 SIEVE-COMP         PIC 999.\n          03 SIEVE-MAX          PIC 999.\n       \n       01 OUT-FMT.\n          03 NUM-FMT            PIC ZZZ9.\n          03 OUT-LINE           PIC X(40).\n          03 OUT-PTR            PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 500 TO MAXIMUM.\n           MOVE 1 TO OUT-PTR.\n           PERFORM SIEVE.\n           MOVE ZERO TO AMOUNT.\n           PERFORM TEST-NUMBER \n               VARYING CANDIDATE FROM 2 BY 1\n               UNTIL CANDIDATE IS GREATER THAN MAXIMUM.\n           DISPLAY OUT-LINE.\n           DISPLAY SPACES.\n           MOVE AMOUNT TO NUM-FMT.\n           DISPLAY 'Amount of additive primes found: ' NUM-FMT.\n           STOP RUN.\n\n       TEST-NUMBER.\n           ADD DIGIT(1), DIGIT(2), DIGIT(3) GIVING DIGITSUM.\n           IF PRIME(CANDIDATE) AND PRIME(DIGITSUM),\n               ADD 1 TO AMOUNT,\n               PERFORM WRITE-NUMBER.\n       \n       WRITE-NUMBER.\n           MOVE CANDIDATE TO NUM-FMT.\n           STRING NUM-FMT DELIMITED BY SIZE INTO OUT-LINE \n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS GREATER THAN 40,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO OUT-PTR.               \n       \n       SIEVE.\n           MOVE SPACES TO PRIME-DATA.\n           DIVIDE MAXIMUM BY 2 GIVING SIEVE-MAX.\n           PERFORM SIEVE-OUTER-LOOP\n               VARYING SIEVE-PRIME FROM 2 BY 1\n               UNTIL SIEVE-PRIME IS GREATER THAN SIEVE-MAX.\n          \n       SIEVE-OUTER-LOOP.\n           IF PRIME(SIEVE-PRIME),\n               MULTIPLY SIEVE-PRIME BY 2 GIVING SIEVE-COMP-START,\n               PERFORM SIEVE-INNER-LOOP\n                   VARYING SIEVE-COMP \n                       FROM SIEVE-COMP-START BY SIEVE-PRIME\n                   UNTIL SIEVE-COMP IS GREATER THAN MAXIMUM.\n       \n       SIEVE-INNER-LOOP.\n           MOVE 'X' TO COMPOSITE-FLAG(SIEVE-COMP).\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 388015, "name": "Sorting algorithms_Stooge sort", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort-test.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  arr-area                            VALUE \"00004001000020000005000230000000000\".\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES\n                                        INDEXED BY arr-idx.\n\nPROCEDURE DIVISION.\n    DISPLAY \"Unsorted: \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n\n    CALL \"stooge-sort\" USING arr-area, OMITTED, OMITTED\n\n    DISPLAY \"Sorted:   \" NO ADVANCING\n    PERFORM VARYING arr-idx FROM 1 BY 1 UNTIL Arr-Len < arr-idx\n        DISPLAY arr-elt (arr-idx) \" \" NO ADVANCING\n    END-PERFORM\n    DISPLAY SPACE\n    .\nEND PROGRAM stooge-sort-test.\n    \n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stooge-sort RECURSIVE.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  Arr-Len                             CONSTANT 7.\n\n01  i                                   PIC 99 COMP.\n01  j                                   PIC 99 COMP.\n\n01  temp                                PIC 9(5).\n\n01  t                                   PIC 99 COMP.\n\nLINKAGE SECTION.\n01  arr-area.\n    03  arr-elt                         PIC 9(5) OCCURS Arr-Len TIMES.\n\n01  i-val                               PIC 99 COMP.\n01  j-val                               PIC 99 COMP.\n\nPROCEDURE DIVISION USING arr-area, OPTIONAL i-val, OPTIONAL j-val.\n    IF i-val IS OMITTED\n        MOVE 1 TO i\n    ELSE\n        MOVE i-val TO i\n    END-IF\n    IF j-val IS OMITTED\n        MOVE Arr-Len TO j\n    ELSE\n        MOVE j-val TO j\n    END-IF\n    \n    IF arr-elt (j) < arr-elt (i)\n        MOVE arr-elt (i) TO temp\n        MOVE arr-elt (j) TO arr-elt (i)\n        MOVE temp TO arr-elt (j)\n    END-IF   \n    \n    IF j - i + 1 >= 3\n        COMPUTE t = (j - i + 1) / 3\n        SUBTRACT t FROM j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        ADD t TO i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n        SUBTRACT t FROM i, j\n        CALL \"stooge-sort\" USING arr-area, CONTENT i, j\n    END-IF\n    .\nEND PROGRAM stooge-sort.\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 388016, "name": "Sorting algorithms_Shell sort", "source": "Translate COBOL to Java:       *******************************************************           \n       IDENTIFICATION DIVISION.                                         \n      *******************************************************           \n       PROGRAM-ID.      SHELLSRT.                                       \n      ************************************************************      \n      *** SHELLSORT                                           ****      \n      ************************************************************      \n       ENVIRONMENT DIVISION.                                            \n       DATA DIVISION.                                                   \n       WORKING-STORAGE SECTION.                                         \n       01 II                        PIC S9(008) COMP-5.                 \n       01 IJ                        PIC S9(008) COMP-5.                 \n       01 IZ                        PIC S9(008) COMP-5.                 \n       01 IA                        PIC S9(008) COMP-5.                 \n       01 STRT1                     PIC S9(008) COMP-5.                 \n       01 STRT2                     PIC S9(008) COMP-5.                 \n       01 LGT                       PIC S9(008) COMP-5.                 \n       01 ORG                       PIC S9(008) COMP-5.                 \n       01 DST                       PIC S9(008) COMP-5.                 \n      *                                                                 \n       01 GAP                       PIC S9(008) COMP-5.                 \n       01 NEGAP                     PIC S9(008) COMP-5.                 \n       01 TEMP                      PIC X(32768).                       \n       77 KEY-RESULT                PIC X.                              \n      *                                                                 \n       LINKAGE SECTION.                                                 \n       01 SRT-ARRAY                 PIC  X(1000000).                    \n       01 NUM-ITEM                  PIC  9(008) COMP-5.                 \n       01 SRT-DATA.                                                     \n          03 LGT-ITEM               PIC  9(004) COMP-5.                 \n          03 SRT-KEYS.                                                  \n             05 SRT-KEY OCCURS 10.                                      \n                07 K-START         PIC S9(004) COMP-5.                  \n                07 K-LENGTH        PIC S9(004) COMP-5.                  \n                07 K-ASC           PIC X.                               \n      *                                                                 \n      *    P R O C E D U R E      D I V I S I O N                       \n      *                                                                 \n       PROCEDURE DIVISION USING SRT-ARRAY NUM-ITEM SRT-DATA.                \n                                                                        \n           COMPUTE GAP = NUM-ITEM / 2.                                  \n           PERFORM UNTIL GAP < 1                                        \n              COMPUTE NEGAP = GAP * -1                                  \n              PERFORM VARYING II FROM GAP BY 1                          \n                        UNTIL II GREATER  NUM-ITEM                      \n                 MOVE ' ' TO KEY-RESULT                                 \n                 COMPUTE ORG = (II - 1) * LGT-ITEM + 1                  \n                 MOVE SRT-ARRAY(ORG:LGT-ITEM) TO TEMP(1:LGT-ITEM)       \n                 PERFORM VARYING IJ FROM II BY NEGAP                    \n                           UNTIL IJ NOT GREATER  GAP                    \n                              OR (KEY-RESULT NOT EQUAL '<' AND ' ')     \n                    COMPUTE IA = IJ - GAP                               \n                    IF IA < 1                                           \n                       MOVE 1 TO IA                                     \n                    END-IF                                              \n                    PERFORM COMPARE-KEYS                                \n                    IF KEY-RESULT = '<'                                 \n                       COMPUTE ORG = (IA - 1) * LGT-ITEM + 1            \n                       COMPUTE DST = (IJ - 1) * LGT-ITEM + 1            \n                       MOVE SRT-ARRAY(ORG:LGT-ITEM)                     \n                         TO SRT-ARRAY(DST:LGT-ITEM)                     \n                       COMPUTE DST = (IA - 1) * LGT-ITEM + 1            \n                       MOVE TEMP(1:LGT-ITEM) TO SRT-ARRAY(DST:LGT-ITEM) \n                    END-IF                                              \n                 END-PERFORM                                            \n              END-PERFORM                                               \n              IF GAP = 2                                                \n                 MOVE 1 TO GAP                                          \n              ELSE                                                      \n                 COMPUTE GAP = GAP / 2.2                                \n              END-IF                                                    \n           END-PERFORM.                                                 \n           GOBACK.                                                      \n      *                                                                 \n       COMPARE-KEYS.                                                    \n           MOVE ' ' TO KEY-RESULT                                       \n           PERFORM VARYING IZ FROM 1 BY 1                               \n                     UNTIL IZ GREATER 10                                \n                        OR (KEY-RESULT NOT EQUAL '=' AND ' ')           \n              IF SRT-KEY(IZ) GREATER LOW-VALUES                         \n                 COMPUTE STRT1 = (IJ - 1) * LGT-ITEM + K-START(IZ)      \n                 COMPUTE STRT2 = (IA - 1) * LGT-ITEM + K-START(IZ)      \n                 MOVE K-LENGTH(IZ) TO LGT                               \n                 IF SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '>' TO KEY-RESULT                              \n                 END-IF                                                 \n                 IF SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '<' TO KEY-RESULT                              \n                 END-IF                                                 \n              END-IF                                                    \n           END-PERFORM.                                                 \n           IF KEY-RESULT = ' '                                          \n              MOVE '=' TO KEY-RESULT                                    \n           END-IF.\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 388017, "name": "McNuggets problem", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MCNUGGETS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NUGGETS.\n          03 NUGGET-FLAGS     PIC X OCCURS 100 TIMES.\n             88 IS-NUGGET     VALUE 'X'.\n\n       01 A                   PIC 999.\n       01 B                   PIC 999.\n       01 C                   PIC 999.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE SPACES TO NUGGETS.\n           PERFORM A-LOOP VARYING A FROM 0 BY 6\n               UNTIL A IS GREATER THAN 100.\n           MOVE 100 TO A.\n\n       FIND-LARGEST.\n           IF IS-NUGGET(A), SUBTRACT 1 FROM A, GO TO FIND-LARGEST.\n           DISPLAY 'Largest non-McNugget number: ', A.\n           STOP RUN.\n \n       A-LOOP.\n           PERFORM B-LOOP VARYING B FROM A BY 9\n               UNTIL B IS GREATER THAN 100.\n\n       B-LOOP.\n           PERFORM C-LOOP VARYING C FROM B BY 20\n               UNTIL C IS GREATER THAN 100.\n \n       C-LOOP.\n           IF C IS NOT EQUAL TO ZERO, MOVE 'X' TO NUGGET-FLAGS(C).\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 388018, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate COBOL to Java:        identification division.\n       program-id. determine.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 tx pic x.\n       01 lower-8bit pic x(256).\n       01 upper-8bit pic x(256).\n\n      \n      \n      \n\n       01 low-slide usage index.\n       01 high-slide usage index.\n\n       procedure division.\n       determining.\n\n      \n       set low-slide to 0\n       set high-slide to 0\n       perform varying tally from 1 by 1 until tally > 256\n           move char(tally) to tx\n           if tx is alphabetic-lower then\n               set low-slide up by 1\n               move tx to lower-8bit(low-slide:1)\n           end-if\n           if tx is alphabetic-upper then\n               set high-slide up by 1\n               move tx to upper-8bit(high-slide:1)\n           end-if\n       end-perform\n       if low-slide equal 0 then\n           display \"no lower case letters detected\" upon syserr\n       else\n           display lower-8bit(1:low-slide)\n       end-if\n       if high-slide equal 0 then\n           display \"no upper case letters detected\" upon syserr\n       else\n           display upper-8bit(1:high-slide)        \n       end-if\n\n      \n      \n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n\n       goback.\n       end program determine.\n", "target": "import java.util.stream.IntStream;\n\npublic class Letters {\n    public static void main(String[] args) throws Exception {\n        System.out.print(\"Upper case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isUpperCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n\n        System.out.print(\"Lower case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isLowerCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 388019, "name": "Jaro similarity", "source": "Translate COBOL to Java:        identification division.\n       program-id. JaroDistance.\n \n       environment division.\n       configuration section.\n       repository.\n           function length intrinsic\n           function trim intrinsic\n           function max intrinsic\n           function min intrinsic\n           .\n \n       data division.\n       working-storage section.\n       77  s                      pic x(255).\n       77  t                      pic x(255).\n       77  s-length               pic 9(3).\n       77  t-length               pic 9(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       77  k                      pic 9(3).\n       77  start-pos              pic 9(3).\n       77  end-pos                pic 9(3).\n       77  match-distance         pic 9(3).\n       77  matches                pic 9(3).\n       77  transpositions         pic 9(3).\n       77  distance               pic 9v9(8).\n       \n       01  jaro-table.\n           05 filler              occurs 255.\n              10 filler           pic 9(1).\n                 88 s-matches     value 1 when set to false is 0.\n              10 filler           pic 9(1).\n                 88 t-matches     value 1 when set to false is 0.\n\n       procedure division.\n       main.\n           move \"MARTHA\" to s\n           move \"MARHTA\" to t\n           perform jaro-calc-and-show\n           move \"DIXON\" to s\n           move \"DICKSONX\" to t\n           perform jaro-calc-and-show\n           move \"JELLYFISH\" to s\n           move \"SMELLYFISH\" to t\n           perform jaro-calc-and-show\n           stop run\n           .\n       jaro-calc-and-show.\n           perform jaro-distance\n           display trim(s) \" -> \" trim(t) \", distance=\" distance\n           .           \n       jaro-distance.\n           move length(trim(s)) to s-length\n           move length(trim(t)) to t-length\n           if s-length = zeros and t-length = zeros\n              move 1 to distance\n              exit paragraph\n           end-if\n\n           compute match-distance = max(s-length, t-length) / 2 - 1\n           move low-values to jaro-table\n           move zeros to matches\n           move zeros to transpositions\n           perform varying i from 1 by 1 until i > s-length\n              move max(1, i - match-distance) to start-pos\n              move min(i + match-distance, t-length) to end-pos\n              perform varying j from start-pos by 1 until j > end-pos\n                 if t-matches(j) or s(i:1) <> t(j:1) \n                    exit perform cycle\n                 end-if,\n                 set s-matches(i), t-matches(j) to true\n                 add 1 to matches\n                 exit perform\n              end-perform\n           end-perform\n           if matches = zeros\n              move matches to distance\n              exit paragraph\n           end-if\n\n           move 1 to k\n           perform varying i from 1 by 1 until i > s-length\n              if not s-matches(i)\n                 exit perform cycle\n              end-if\n              perform until t-matches(k)\n                 add 1 to k\n              end-perform\n              if s(i:1) <> t(k:1)\n                 add 1 to transpositions\n              end-if\n              add 1 to k\n           end-perform\n\n           compute distance = ((matches / s-length) + (matches / t-length) +\n                               ((matches - transpositions / 2) / matches)) / 3\n           .\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 388020, "name": "Decision tables", "source": "Translate COBOL to Java:         >> SOURCE FORMAT FREE\nidentification division.\nprogram-id. 'decisiontable'.\n\nenvironment division.\nconfiguration section.\nrepository.\n    function all intrinsic.\n\ndata division.\n\nworking-storage section.\n\n01  conditions.\n    03  notprinting pic x.\n    03  flashing pic x.\n    03  notrecognized pic x.\n\nprocedure division.\nstart-decision-table.\n\ndisplay space \n\ndisplay 'The printer does not print (Y or N) ' with no advancing\naccept notprinting\n\ndisplay 'A red light is flashing (Y or N) ' with no advancing\naccept flashing\n\ndisplay 'The printer is unrecognized (Y or N) ' with no advancing\naccept notrecognized\n\nmove upper-case(conditions) to conditions\n\ndisplay space\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nevaluate notprinting also flashing also notrecognized\n\nwhen 'Y' also 'Y' also 'Y'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'Y' also 'Y' also 'N'\n    display 'Check/replace ink'\n    display 'Check for paper jam'\n\nwhen 'Y' also 'N' also 'Y'\n    display 'Check the power cable'\n    display 'Check the printer-computer cable'\n    display 'Ensure printer software is installed'\n\nwhen 'Y' also 'N' also 'N'\n    display 'Check for paper jam'\n\nwhen 'N' also 'Y' also 'Y'\n    display 'Ensure printer software is installed'\n    display 'Check/replace ink'\n\nwhen 'N' also 'Y' also 'N'\n    display 'Check/replace ink'\n\nwhen 'N' also 'N' also 'Y'\n    display 'Ensure printer software is installed'\n\nwhen 'N' also 'N' also 'N'\n    display 'no action found'\n\nwhen other\n    display 'invalid input: ' notprinting space flashing space notrecognized\n\nend-evaluate\n\ndisplay space\n\nstop run\n.\n\nend program 'decisiontable'.\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class DecisionTables {\n    private static class Pair<T, U> {\n        private final T t;\n        private final U u;\n\n        public static <T, U> Pair<T, U> of(T t, U u) {\n            return new Pair<>(t, u);\n        }\n\n        public Pair(T t, U u) {\n            this.t = t;\n            this.u = u;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public U getSecond() {\n            return u;\n        }\n    }\n\n    private static final List<Pair<String, String>> conditions = List.of(\n        Pair.of(\"Printer prints\", \"NNNNYYYY\"),\n        Pair.of(\"A red light is flashing\", \"YYNNYYNN\"),\n        Pair.of(\"Printer is recognized by computer\", \"NYNYNYNY\")\n    );\n\n    private static final List<Pair<String, String>> actions = List.of(\n        Pair.of(\"Check the power cable\", \"NNYNNNNN\"),\n        Pair.of(\"Check the printer-computer cable\", \"YNYNNNNN\"),\n        Pair.of(\"Ensure printer software is installed\", \"YNYNYNYN\"),\n        Pair.of(\"Check/replace ink\", \"YYNNNYNN\"),\n        Pair.of(\"Check for paper jam\", \"NYNYNNNN\")\n    );\n\n    public static void main(String[] args) throws IOException {\n        final int nc = conditions.size();\n        final int na = actions.size();\n        final int nr = conditions.get(0).getSecond().length();\n        final int np = 7;\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.println(\"Please answer the following questions with a y or n:\");\n        final boolean[] answers = new boolean[nc];\n        for (int c = 0; c < nc; ++c) {\n            String input;\n            do {\n                System.out.printf(\"  %s\u00a0? \", conditions.get(c).getFirst());\n                input = br.readLine().toUpperCase();\n            } while (!Objects.equals(input, \"Y\") && !Objects.equals(input, \"N\"));\n            answers[c] = Objects.equals(input, \"Y\");\n        }\n        System.out.println(\"\\nRecommended action(s)\");\n\n        outer:\n        for (int r = 0; r < nr; ++r) {\n            for (int c = 0; c < nc; ++c) {\n                char yn = answers[c] ? 'Y' : 'N';\n                if (conditions.get(c).getSecond().charAt(r) != yn) {\n                    continue outer;\n                }\n            }\n            if (r == np) {\n                System.out.println(\"  None (no problem detected)\");\n            } else {\n                for (Pair<String, String> action : actions) {\n                    if (action.getSecond().charAt(r) == 'Y') {\n                        System.out.printf(\"  %s\\n\", action.getFirst());\n                    }\n                }\n            }\n            break;\n        }\n    }\n}\n"}
{"id": 388021, "name": "Hello world_Newbie", "source": "Translate COBOL to Java: program-id. hello-world.\n\nprocedure division.\n  display \"Hello, World!\"\n\n  goback\n  .\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 388022, "name": "Hello world_Newbie", "source": "Translate COBOL to Java: program-id. hello-world.\n\nprocedure division.\n  display \"Hello, World!\"\n\n  goback\n  .\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 388023, "name": "Loops_Infinite", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Spam.\n\n       PROCEDURE DIVISION.\n           PERFORM UNTIL 1 <> 1\n               DISPLAY \"SPAM\"\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "while (true) {\n   System.out.println(\"SPAM\");\n}\n"}
{"id": 388024, "name": "Function definition", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. myTest.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x   PIC 9(3) VALUE 3.\n       01  y   PIC 9(3) VALUE 2.\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION.\n           CALL \"myMultiply\" USING \n               BY CONTENT x, BY CONTENT y, \n               BY REFERENCE z.\n           DISPLAY z.\n           STOP RUN.\n       END PROGRAM myTest.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. myMultiply.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  x   PIC 9(3).\n       01  y   PIC 9(3).\n       01  z   PIC 9(9).\n       PROCEDURE DIVISION USING x, y, z.\n           MULTIPLY x BY y GIVING z.\n           EXIT PROGRAM.\n       END PROGRAM myMultiply.\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 388025, "name": "Create a file on magnetic tape", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. MAKE-TAPE-FILE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT TAPE-FILE\n        ASSIGN \"./TAPE.FILE\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD TAPE-FILE.\n01 TAPE-FILE-RECORD PIC X(51).\n\nPROCEDURE DIVISION.\n    OPEN OUTPUT SHARING WITH ALL OTHER TAPE-FILE\n    WRITE TAPE-FILE-RECORD \n        FROM \"COBOL treats tape files and text files identically.\"\n    END-WRITE\n    STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\npublic class CreateFile {\n    public static void main(String[] args) throws IOException {\n        String os = System.getProperty(\"os.name\");\n        if (os.contains(\"Windows\")) {\n            Path path = Paths.get(\"tape.file\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        } else {\n            Path path = Paths.get(\"/dev/tape\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        }\n    }\n}\n"}
{"id": 388026, "name": "Recaman's sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 388027, "name": "Recaman's sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. RECAMAN.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 RECAMAN-SEQUENCE COMP.\n           02 A     PIC 999 OCCURS 99 TIMES INDEXED BY I.\n           02 N     PIC 999 VALUE 0.\n           \n        01 VARIABLES COMP.\n           02 ADDC  PIC S999.\n           02 SUBC  PIC S999.\n           02 SPTR  PIC 99 VALUE 1.\n           \n        01 OUTPUT-FORMAT.\n           02 OUTI  PIC Z9.\n           02 OUTN  PIC BZ9.\n           02 OUTS  PIC X(79).\n           \n        PROCEDURE DIVISION.\n        BEGIN.\n            PERFORM GENERATE-NEXT-ITEM 15 TIMES.\n            PERFORM COLLATE-ITEM VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN 15.\n            DISPLAY 'First 15 items:' OUTS.\n        \n        FIND-REPEATING.\n            PERFORM GENERATE-NEXT-ITEM.\n            SET I TO 1.\n            SEARCH A VARYING I\n                WHEN I IS NOT LESS THAN N \n                    NEXT SENTENCE\n                WHEN A(I) IS EQUAL TO A(N)\n                    SUBTRACT 1 FROM N GIVING OUTI\n                    MOVE A(N) TO OUTN\n                    DISPLAY 'First repeated item: A(' OUTI ') =' OUTN\n                    STOP RUN.\n            GO TO FIND-REPEATING.\n        \n        GENERATE-NEXT-ITEM.\n            IF N IS EQUAL TO ZERO\n                MOVE ZERO TO A(1)\n            ELSE\n                ADD N, A(N) GIVING ADDC\n                SUBTRACT N FROM A(N) GIVING SUBC\n                IF SUBC IS NOT GREATER THAN ZERO\n                    MOVE ADDC TO A(N + 1)\n                ELSE\n                    SET I TO 1\n                    SEARCH A VARYING I\n                        WHEN I IS NOT LESS THAN N\n                            MOVE SUBC TO A(N + 1)\n                        WHEN A(I) IS EQUAL TO SUBC\n                            MOVE ADDC TO A(N + 1).\n            ADD 1 TO N.\n            \n        COLLATE-ITEM.\n            MOVE A(I) TO OUTN.\n            STRING OUTN DELIMITED BY SIZE INTO OUTS WITH POINTER SPTR.\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 388028, "name": "Sorting algorithms_Bead sort", "source": "Translate COBOL to Java:         >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. beadsort.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  filler.\n    03  row occurs 9 pic x(9).\n    03  r pic 99.\n    03  r1 pic 99.\n    03  r2 pic 99.\n    03  pole pic 99.\n    03  a-lim pic 99 value 9.\n    03  a pic 99.\n    03  array occurs 9 pic 9.\n01  NL pic x value x'0A'.\nprocedure division.\nstart-beadsort.\n\n    \n    compute a = random(seconds-past-midnight)\n    perform varying a from 1 by 1 until a > a-lim\n        compute array(a) = random() * 10\n    end-perform\n\n    perform display-array\n    display space 'initial array'\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move all '.' to row(r)\n        perform varying pole from 1 by 1 until pole > array(r)\n            move 'o' to row(r)(pole:1)\n        end-perform\n    end-perform\n    display NL 'initial beads'\n    perform display-beads\n\n    \n    perform varying pole from 1 by 1 until pole > a-lim\n        move a-lim to r2\n        perform find-opening\n        compute r1 = r2 - 1\n        perform find-bead\n        perform until r1 = 0 \n            \n            move '.' to row(r1)(pole:1)\n            move 'o' to row(r2)(pole:1)\n            \n            compute r2 = r2 - 1\n            perform find-opening\n            compute r1 = r2 - 1\n            perform find-bead\n        end-perform\n    end-perform\n    display NL 'dropped beads'\n    perform display-beads\n\n    \n    perform varying r from 1 by 1 until r > a-lim\n        move 0 to array(r)\n        inspect row(r) tallying array(r)\n            for all 'o' before initial '.'\n    end-perform\n\n    perform display-array\n    display space 'sorted array'\n\n    stop run\n    .\nfind-opening.\n    perform varying r2 from r2 by -1\n    until r2 = 1 or row(r2)(pole:1) = '.'\n        continue\n    end-perform\n    .\nfind-bead.\n    perform varying r1 from r1 by -1\n    until r1 = 0 or row(r1)(pole:1) = 'o'\n        continue\n    end-perform\n    .\ndisplay-array.\n    display space\n    perform varying a from 1 by 1 until a > a-lim\n        display space array(a) with no advancing\n    end-perform\n    .\ndisplay-beads.\n    perform varying r from 1 by 1 until r > a-lim\n        display row(r)\n    end-perform\n    .\nend program beadsort.\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 388029, "name": "Simple database", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. simple-database.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OPTIONAL database-file ASSIGN Database-Path\n               ORGANIZATION INDEXED\n               ACCESS SEQUENTIAL\n               RECORD KEY data-title\n               ALTERNATE RECORD KEY data-tag\n                   WITH DUPLICATES\n               ALTERNATE RECORD KEY date-added\n                   WITH DUPLICATES\n               FILE STATUS file-status\n               .\n       DATA DIVISION.\n       FILE SECTION.\n       FD  database-file.\n       01  database-record.\n           \n           03  date-added          PIC 9(8).\n           03  data-tag            PIC X(20).\n           03  data-title          PIC X(50).\n           03  data-contents       PIC X(200).\n           \n           \n           03  FILLER              PIC X(50).\n\n       WORKING-STORAGE SECTION.\n       78  Database-Path           VALUE \"database.dat\".\n\n       01  file-status             PIC XX.\n           88  file-ok             VALUE \"00\".\n           88  duplicate-key       VALUE \"22\".\n           88  key-not-found       VALUE \"23\".\n\n       01  num-args                PIC 99.\n\n       01  action                  PIC XX.\n           88  create-entry        VALUE \"-c\".\n           88  remove-entry        VALUE \"-r\".\n           88  find-entry          VALUE \"-f\".\n           88  print-latest        VALUE \"-l\".\n           88  print-database      VALUES \"-a\", \"-d\", \"-t\".\n           \n           88  print-by-title      VALUE \"-a\".\n           88  print-by-date       VALUE \"-d\".\n           88  print-by-tag        VALUE \"-t\".\n           88  print-help          VALUES \"-h\", SPACES.\n\n       01  read-direction-flag     PIC X VALUE SPACE.\n           88  read-backwards      VALUE \"B\".\n\n       01  edited-date             PIC 9(4)/99/99.\n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       database-file-error SECTION.\n           USE AFTER ERROR ON database-file\n\n           DISPLAY \"An error has occurred while using \" Database-Path\n               \". Error no. \" file-status\n           DISPLAY \"The program will terminate.\"\n\n           CLOSE database-file\n\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       main-line.\n           DISPLAY 1 UPON ARGUMENT-NUMBER\n           ACCEPT action FROM ARGUMENT-VALUE\n\n           ACCEPT num-args FROM ARGUMENT-NUMBER\n\n           EVALUATE TRUE\n               WHEN create-entry\n                   IF num-args >= 4\n                       PERFORM write-entry\n                   ELSE\n                       DISPLAY \"-a requires arguments to enter in the \"\n                           \"database. See help (-h) for details.\"\n                   END-IF\n\n               WHEN remove-entry\n                   IF num-args >= 2\n                       PERFORM delete-entry\n                   ELSE\n                       DISPLAY \"-r requires the title of the entry to \"\n                           \"delete.\"\n                   END-IF\n\n               WHEN find-entry\n                   IF num-args >= 2\n                       PERFORM display-specified-entry\n                   ELSE\n                       DISPLAY \"-f requires the title of the entry to \"\n                           \"find.\"\n                   END-IF\n\n               WHEN print-latest\n                   PERFORM show-latest\n\n               WHEN print-database\n                   PERFORM show-database\n\n               WHEN print-help\n                   PERFORM show-general-help\n\n               WHEN OTHER\n                   DISPLAY action \" is not a valid option.\"\n           END-EVALUATE\n           \n           GOBACK\n           .\n       write-entry.\n           OPEN EXTEND database-file\n\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-tag FROM ARGUMENT-VALUE\n           DISPLAY 3 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           IF data-title = SPACES\n               DISPLAY \"The title cannot be blank.\"\n               PERFORM close-and-terminate\n           END-IF\n\n           DISPLAY 4 UPON ARGUMENT-NUMBER\n           ACCEPT data-contents FROM ARGUMENT-VALUE\n\n           ACCEPT date-added FROM DATE YYYYMMDD\n\n           WRITE database-record\n               INVALID KEY\n                   IF duplicate-key\n                       DISPLAY \"An entry in the database already has \"\n                           \"that title. Please choose a different \"\n                           \"title or remove the entry.\"\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-WRITE\n\n           PERFORM close-database\n           .\n       delete-entry.\n           PERFORM get-title-arg\n           OPEN I-O database-file\n           PERFORM read-title\n\n           DELETE database-file\n\n           PERFORM close-database\n           .\n       display-specified-entry.\n           PERFORM get-title-arg\n           OPEN INPUT database-file\n           PERFORM read-title\n\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       get-title-arg.\n           DISPLAY 2 UPON ARGUMENT-NUMBER\n           ACCEPT data-title FROM ARGUMENT-VALUE\n           .\n       read-title.\n           START database-file KEY IS = data-title\n               INVALID KEY\n                   IF key-not-found\n                       DISPLAY \"An entry with that title was not found.\"\n                       PERFORM close-and-terminate\n                   ELSE\n                       PERFORM database-file-error\n                   END-IF\n           END-START\n\n           READ database-file\n           .\n       close-and-terminate.\n            PERFORM close-database\n            GOBACK\n            .\n       show-latest.\n           OPEN INPUT database-file\n\n           PERFORM start-at-last-date\n           READ database-file\n           PERFORM show-record\n\n           PERFORM close-database\n           .\n       show-database.\n           OPEN INPUT database-file\n\n           EVALUATE TRUE\n               WHEN print-by-title\n                   \n                   CONTINUE\n               WHEN print-by-tag\n                   MOVE LOW-VALUES TO data-tag\n                   START database-file KEY IS > data-tag\n               WHEN print-by-date\n                   PERFORM start-at-last-date\n                   SET read-backwards TO TRUE\n           END-EVALUATE\n\n           PERFORM FOREVER\n               \n               IF NOT read-backwards\n                   READ database-file NEXT\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               ELSE\n                   READ database-file PREVIOUS\n                       AT END\n                           EXIT PERFORM\n                   END-READ\n               END-IF\n\n               PERFORM show-record\n               DISPLAY SPACE\n           END-PERFORM\n\n           PERFORM close-database\n           .\n       start-at-last-date.\n           MOVE HIGH-VALUES TO date-added\n           START database-file KEY IS < date-added\n           .\n       close-database.\n           CLOSE database-file\n           .\n       show-record.\n           MOVE date-added TO edited-date\n           DISPLAY \"Date added: \" edited-date \" Tag: \" data-tag\n           DISPLAY \"Title: \" data-title\n           DISPLAY \"Contents:\"\n           DISPLAY \"  \" FUNCTION TRIM(data-contents)\n           .\n       show-general-help.\n           DISPLAY \"Help: Possible options are:\"\n           DISPLAY \"  -a - Show all the entries (sorted by title).\"\n           DISPLAY \"  -c - Create a new entry in the database. -c needs\"\n               \" further arguments in this format:\"\n           DISPLAY '    \"tag\" \"title\" \"content\"'\n           DISPLAY \"    Max argument sizes (in characters): tag - 20, \"\n               \"title - 50, content - 200\"\n           DISPLAY \"    The title must be unique and not be blank.\"\n           DISPLAY \"  -d - Show all the entries sorted by date added.\"\n           DISPLAY \"  -f - Finds and displays entry with the title \"\n               \"provided. The title should be specified as shown for \"\n               \"-c.\"\n           DISPLAY \"  -h - Show this help menu.\"\n           DISPLAY \"  -l - Show the latest entry.\"\n           DISPLAY \"  -r - Remove the entry with the title provided. \"\n               \"The title should be specified as shown for -c.\"\n           DISPLAY \"  -t - Show all the entries sorted by tag.\"\n           .\n", "target": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class SimpleDatabase {\n\n    final static String filename = \"simdb.csv\";\n\n    public static void main(String[] args) {\n        if (args.length < 1 || args.length > 3) {\n            printUsage();\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"add\":\n                addItem(args);\n                break;\n            case \"latest\":\n                printLatest(args);\n                break;\n            case \"all\":\n                printAll();\n                break;\n            default:\n                printUsage();\n                break;\n        }\n    }\n\n    private static class Item implements Comparable<Item>{\n        final String name;\n        final String date;\n        final String category;\n\n        Item(String n, String d, String c) {\n            name = n;\n            date = d;\n            category = c;\n        }\n\n        @Override\n        public int compareTo(Item item){\n            return date.compareTo(item.date);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s,%s,%s%n\", name, date, category);\n        }\n    }\n\n    private static void addItem(String[] input) {\n        if (input.length < 2) {\n            printUsage();\n            return;\n        }\n        List<Item> db = load();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String date = sdf.format(new Date());\n        String cat = (input.length == 3) ? input[2] : \"none\";\n        db.add(new Item(input[1], date, cat));\n        store(db);\n    }\n\n    private static void printLatest(String[] a) {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        if (a.length == 2) {\n            for (Item item : db)\n                if (item.category.equals(a[1]))\n                    System.out.println(item);\n        } else {\n            System.out.println(db.get(0));\n        }\n    }\n\n    private static void printAll() {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        for (Item item : db)\n            System.out.println(item);\n    }\n\n    private static List<Item> load() {\n        List<Item> db = new ArrayList<>();\n        try (Scanner sc = new Scanner(new File(filename))) {\n            while (sc.hasNext()) {\n                String[] item = sc.nextLine().split(\",\");\n                db.add(new Item(item[0], item[1], item[2]));\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return db;\n    }\n\n    private static void store(List<Item> db) {\n        try (FileWriter fw = new FileWriter(filename)) {\n            for (Item item : db)\n                fw.write(item.toString());\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    private static void printUsage() {\n         System.out.println(\"Usage:\");\n         System.out.println(\"  simdb cmd [categoryName]\");\n         System.out.println(\"  add     add item, followed by optional category\");\n         System.out.println(\"  latest  print last added item(s), followed by \"\n                 + \"optional category\");\n         System.out.println(\"  all     print all\");\n         System.out.println(\"  For instance: add \\\"some item name\\\" \"\n                 + \"\\\"some category name\\\"\");\n    }\n}\n"}
{"id": 388030, "name": "Tau function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388031, "name": "Tau function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. TAU-FUNCTION.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 TAU-VARS.\n          03 TOTAL              PIC 999.\n          03 N                  PIC 999.\n          03 FILLER             REDEFINES N.\n             05 FILLER          PIC 99.\n             05 FILLER          PIC 9.\n                88 N-EVEN       VALUES 0, 2, 4, 6, 8.\n          03 P                  PIC 999.\n          03 P-SQUARED          PIC 999.\n          03 N-DIV-P            PIC 999V999.\n          03 FILLER             REDEFINES N-DIV-P.\n             05 NEXT-N          PIC 999.\n             05 FILLER          PIC 999.\n                88 DIVISIBLE    VALUE ZERO.\n          03 F-COUNT            PIC 999.\n       01 CONTROL-VARS.\n          03 I                  PIC 999.\n       01 OUT-VARS.\n          03 OUT-ITM            PIC ZZ9.\n          03 OUT-STR            PIC X(80) VALUE SPACES.\n          03 OUT-PTR            PIC 99 VALUE 1.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SHOW-TAU VARYING I FROM 1 BY 1\n               UNTIL I IS GREATER THAN 100.\n           STOP RUN.\n       \n       SHOW-TAU.\n           MOVE I TO N.\n           PERFORM TAU.\n           MOVE TOTAL TO OUT-ITM.\n           STRING OUT-ITM DELIMITED BY SIZE INTO OUT-STR\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 61,\n               DISPLAY OUT-STR,\n               MOVE 1 TO OUT-PTR.\n\n       TAU.\n           MOVE 1 TO TOTAL.\n           PERFORM POWER-OF-2 UNTIL NOT N-EVEN.\n           MOVE ZERO TO P-SQUARED.\n           PERFORM ODD-FACTOR THRU ODD-FACTOR-LOOP\n               VARYING P FROM 3 BY 2\n               UNTIL P-SQUARED IS GREATER THAN N.\n           IF N IS GREATER THAN 1,\n               MULTIPLY 2 BY TOTAL.\n       POWER-OF-2.\n           ADD 1 TO TOTAL.\n           DIVIDE 2 INTO N.\n       ODD-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           MOVE 1 TO F-COUNT.\n       ODD-FACTOR-LOOP.\n           DIVIDE N BY P GIVING N-DIV-P.\n           IF DIVISIBLE,\n               MOVE NEXT-N TO N,\n               ADD 1 TO F-COUNT,\n               GO TO ODD-FACTOR-LOOP.\n           MULTIPLY F-COUNT BY TOTAL.\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388032, "name": "Mertens function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MERTENS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 M             PIC S99 OCCURS 1000 TIMES.\n          03 N             PIC 9(4).\n          03 K             PIC 9(4).\n          03 V             PIC 9(4).\n          03 IS-ZERO       PIC 99 VALUE 0.\n          03 CROSS-ZERO    PIC 99 VALUE 0.\n\n       01 OUTPUT-FORMAT.\n          03 OUT-ITEM. \n             05 OUT-NUM    PIC -9.\n             05 FILLER     PIC X VALUE SPACE.\n          03 OUT-LINE      PIC X(30) VALUE SPACES.\n          03 OUT-PTR       PIC 99 VALUE 4.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM GENERATE-MERTENS.\n           PERFORM WRITE-TABLE.\n           PERFORM COUNT-ZEROES.\n           STOP RUN.\n\n       GENERATE-MERTENS.\n           MOVE 1 TO M(1).\n           PERFORM MERTENS-OUTER-LOOP VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n    \n       MERTENS-OUTER-LOOP.\n           MOVE 1 TO M(N).\n           PERFORM MERTENS-INNER-LOOP VARYING K FROM 2 BY 1\n               UNTIL K IS GREATER THAN N.\n\n       MERTENS-INNER-LOOP.\n           DIVIDE N BY K GIVING V.\n           SUBTRACT M(V) FROM M(N).\n\n       WRITE-TABLE.\n           DISPLAY \"The first 99 Mertens numbers are: \"\n           PERFORM WRITE-ITEM VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 99.\n  \n       WRITE-ITEM.\n           MOVE M(N) TO OUT-NUM.\n           STRING OUT-ITEM DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER OUT-PTR.\n           IF OUT-PTR IS EQUAL TO 31,\n               DISPLAY OUT-LINE,\n               MOVE 1 TO OUT-PTR.\n\n       COUNT-ZEROES.\n           PERFORM TEST-N-ZERO VARYING N FROM 2 BY 1\n               UNTIL N IS GREATER THAN 1000.\n           DISPLAY \"M(N) is zero \" IS-ZERO \" times.\".\n           DISPLAY \"M(N) crosses zero \" CROSS-ZERO \" times.\".\n\n       TEST-N-ZERO.\n           IF M(N) IS EQUAL TO ZERO,\n               ADD 1 TO IS-ZERO,\n               SUBTRACT 1 FROM N GIVING K,\n               IF M(K) IS NOT EQUAL TO ZERO,\n                   ADD 1 TO CROSS-ZERO.\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 388033, "name": "Product of divisors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388034, "name": "Product of divisors", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  PRODUCT-OF-DIVISORS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 DIVISOR-PRODUCTS    PIC 9(9) OCCURS 50 TIMES.\n          03 NUM                 PIC 999.\n          03 MUL                 PIC 999.\n      \n       01 OUTPUT-FORMAT.\n          03 NUM-OUT             PIC Z(9)9.\n          03 LINE-PTR            PIC 99 VALUE 1.\n          03 OUT-LINE            PIC X(50) VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM INIT VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           PERFORM CALCULATE-MULTIPLES VARYING MUL FROM 1 BY 1\n               UNTIL MUL IS GREATER THAN 50.\n           PERFORM OUTPUT-NUM VARYING NUM FROM 1 BY 1\n               UNTIL NUM IS GREATER THAN 50.\n           STOP RUN.\n\n       INIT.\n           MOVE 1 TO DIVISOR-PRODUCTS(NUM).\n       \n       CALCULATE-MULTIPLES.\n           PERFORM MULTIPLY-NUM VARYING NUM FROM MUL BY MUL\n               UNTIL NUM IS GREATER THAN 50.\n \n       MULTIPLY-NUM.\n           MULTIPLY MUL BY DIVISOR-PRODUCTS(NUM).\n\n       OUTPUT-NUM.\n           MOVE DIVISOR-PRODUCTS(NUM) TO NUM-OUT.\n           STRING NUM-OUT DELIMITED BY SIZE INTO OUT-LINE\n               WITH POINTER LINE-PTR.\n           IF LINE-PTR IS EQUAL TO 51,\n               DISPLAY OUT-LINE,\n               MOVE SPACES TO OUT-LINE,\n               MOVE 1 TO LINE-PTR.\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388035, "name": "Playing cards", "source": "Translate COBOL to Java:        identification division.\n       program-id. playing-cards.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       77 card             usage index.\n       01 deck.\n          05 cards occurs 52 times ascending key slot indexed by card.\n             10 slot       pic 99.\n             10 hand       pic 99.\n             10 suit       pic 9.\n             10 symbol     pic x(4).\n             10 rank       pic 99.\n\n       01 filler.\n          05 suit-name     pic x(8) occurs 4 times.\n\n      \n       01 base-s           constant as 4036985504.\n       01 base-h           constant as 4036985520.\n       01 base-d           constant as 4036985728.\n       01 base-c           constant as 4036985744.\n\n       01 sym              pic x(4) comp-x.\n       01 symx             redefines sym pic x(4).\n       77 s                pic 9.\n       77 r                pic 99.\n       77 c                pic 99.\n       77 hit              pic 9.\n       77 limiter          pic 9(6).\n\n       01 spades           constant as 1.\n       01 hearts           constant as 2.\n       01 diamonds         constant as 3.\n       01 clubs            constant as 4.\n\n       01 players          constant as 3.\n       01 cards-per        constant as 5.\n       01 deal             pic 99.\n       01 player           pic 99.\n\n       01 show-tally       pic zz.\n       01 show-rank        pic z(5).\n       01 arg              pic 9(10).\n       \n       procedure division.\n       cards-main.\n       perform seed\n       perform initialize-deck\n       perform shuffle-deck\n       perform deal-deck\n       perform display-hands\n       goback.\n      \n      \n       seed.\n           accept arg from command-line\n           if arg not equal 0 then\n               move random(arg) to c\n           end-if\n       .\n\n       initialize-deck.\n           move \"spades\" to suit-name(spades)\n           move \"hearts\" to suit-name(hearts)\n           move \"diamonds\" to suit-name(diamonds)\n           move \"clubs\" to suit-name(clubs)\n\n           perform varying s from 1 by 1 until s > 4\n                     after r from 1 by 1 until r > 13\n                   compute c = (s - 1) * 13 + r\n                   evaluate s\n                       when spades compute sym = base-s + r\n                       when hearts compute sym = base-h + r\n                       when diamonds compute sym = base-d + r\n                       when clubs compute sym = base-c + r\n                   end-evaluate\n                   if r > 11 then compute sym = sym + 1 end-if\n                   move s to suit(c)\n                   move r to rank(c)\n                   move symx to symbol(c)\n                   move zero to slot(c)\n                   move zero to hand(c)\n           end-perform\n       .\n\n       shuffle-deck.\n           move zero to limiter\n           perform until exit\n               compute c = random() * 52.0 + 1.0\n               move zero to hit\n               perform varying tally from 1 by 1 until tally > 52\n                   if slot(tally) equal c then\n                       move 1 to hit\n                       exit perform\n                   end-if\n                   if slot(tally) equal 0 then\n                       if tally < 52 then move 1 to hit end-if\n                       move c to slot(tally)\n                       exit perform\n                   end-if\n               end-perform\n               if hit equal zero then exit perform end-if\n               if limiter > 999999 then\n                   display \"too many shuffles, deck invalid\" upon syserr\n                   exit perform\n               end-if\n               add 1 to limiter\n           end-perform\n           sort cards ascending key slot\n       .\n\n       display-card.\n       >>IF ENGLISH IS DEFINED\n               move rank(tally) to show-rank\n               evaluate rank(tally) \n                   when 1 display \"  ace\" with no advancing\n                   when 2 thru 10 display show-rank with no advancing\n                   when 11 display \" jack\" with no advancing\n                   when 12 display \"queen\" with no advancing\n                   when 13 display \" king\" with no advancing\n               end-evaluate\n               display \" of \" suit-name(suit(tally)) with no advancing\n       >>ELSE\n               display symbol(tally) with no advancing\n       >>END-IF\n       .\n\n       display-deck.\n           perform varying tally from 1 by 1 until tally > 52\n               move tally to show-tally\n               display \"Card: \" show-tally\n                       \" currently in hand \" hand(tally)\n                       \" is \" with no advancing\n               perform display-card\n               display space\n           end-perform\n       .\n\n       display-hands.\n           perform varying player from 1 by 1 until player > players\n               move player to tally\n               display \"Player \" player \": \" with no advancing\n               perform varying deal from 1 by 1 until deal > cards-per\n                  perform display-card\n                  add players to tally\n               end-perform\n               display space\n           end-perform\n           display \"Stock: \" with no advancing\n           subtract players from tally\n           add 1 to tally\n           perform varying tally from tally by 1 until tally > 52\n               perform display-card\n       >>IF ENGLISH IS DEFINED\n               display space\n       >>END-IF\n           end-perform\n           display space\n       .\n\n       deal-deck.\n           display \"Dealing \" cards-per \" cards to \" players \" players\"\n           move 1 to tally\n           perform varying deal from 1 by 1 until deal > cards-per\n                     after player from 1 by 1 until player > players\n               move player to hand(tally)\n               add 1 to tally\n           end-perform\n       .\n\n       end program playing-cards.\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 388036, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Java:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388037, "name": "Find the last Sunday of each month", "source": "Translate COBOL to Java:        program-id. last-sun.\n       data division.\n       working-storage section.\n       1 wk-date.\n        2 yr pic 9999.\n        2 mo pic 99 value 1.\n        2 da pic 99 value 1.\n       1 rd-date redefines wk-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 sunday pic 9(4) value 7.\n       procedure division.\n           display \"Enter a calendar year (1601 thru 9999): \"\n               with no advancing\n           accept yr\n           if yr >= 1601 and <= 9999\n               continue\n           else\n               display \"Invalid year\"\n               stop run\n           end-if\n           perform 12 times\n               move 1 to da\n               add 1 to mo\n               if mo > 12              \n                   move 12 to mo\n                   move 31 to da\n               end-if\n               compute int-date = function\n                   integer-of-date (rd-date)\n               if mo =12 and da = 31   \n                   continue\n               else\n                   subtract 1 from int-date\n               end-if\n               compute rd-date = function\n                   date-of-integer (int-date)\n               compute dow = function mod\n                   ((int-date - 1) 7) + 1\n               compute dow = function mod ((dow - sunday) 7)\n               subtract dow from da\n               display yr \"-\" mo \"-\" da\n               add 1 to mo\n           end-perform\n           stop run\n           .\n       end program last-sun.\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388038, "name": "Strange plus numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 388039, "name": "Strange plus numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. STRANGE-PLUS-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE            PIC 999.\n          03 DIGITS               REDEFINES CANDIDATE,\n                                  PIC 9 OCCURS 3 TIMES.\n          03 LEFT-PAIR            PIC 99.\n             88 LEFT-PAIR-PRIME   VALUES 2, 3, 5, 7, 11, 13, 17.\n          03 RIGHT-PAIR           PIC 99. \n             88 RIGHT-PAIR-PRIME  VALUES 2, 3, 5, 7, 11, 13, 17.\n       01 OUT.\n          03 ROW                  PIC X(40) VALUE SPACES.\n          03 PTR                  PIC 99 VALUE 1.\n       \n       PROCEDURE DIVISION. \n       BEGIN. \n           PERFORM CHECK-STRANGE-NUMBER\n           VARYING CANDIDATE FROM 100 BY 1\n           UNTIL CANDIDATE IS GREATER THAN 500.\n           DISPLAY ROW.\n           STOP RUN.\n\n       CHECK-STRANGE-NUMBER. \n           ADD DIGITS(1), DIGITS(2) GIVING LEFT-PAIR.\n           ADD DIGITS(2), DIGITS(3) GIVING RIGHT-PAIR. \n           IF LEFT-PAIR-PRIME AND RIGHT-PAIR-PRIME,\n               PERFORM WRITE-STRANGE-NUMBER.\n\n       WRITE-STRANGE-NUMBER.\n           STRING CANDIDATE DELIMITED BY SIZE INTO ROW\n           WITH POINTER PTR.\n           ADD 1 TO PTR.\n           IF PTR IS GREATER THAN 40,\n               DISPLAY ROW,\n               MOVE SPACES TO ROW,\n               MOVE 1 TO PTR.\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 388040, "name": "Test integerness", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. INTEGERNESS-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  INTEGERS-OR-ARE-THEY.\n    05 POSSIBLE-INTEGER PIC S9(9)V9(9).\n    05 DEFINITE-INTEGER PIC S9(9).\n01  COMPLEX-NUMBER.\n    05 REAL-PART        PIC S9(9)V9(9).\n    05 IMAGINARY-PART   PIC S9(9)V9(9).\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE ZERO TO IMAGINARY-PART.\n    DIVIDE -28 BY 7 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 28 BY 18 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    DIVIDE 3 BY 10000000000 GIVING POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\nTEST-COMPLEX-PARAGRAPH.\n    MOVE ZERO TO REAL-PART.\n    MOVE 1 TO IMAGINARY-PART.\n    MOVE REAL-PART TO POSSIBLE-INTEGER.\n    PERFORM INTEGER-PARAGRAPH.\n    STOP RUN.\nINTEGER-PARAGRAPH.\n    IF IMAGINARY-PART IS EQUAL TO ZERO THEN PERFORM REAL-PARAGRAPH,\n    ELSE PERFORM COMPLEX-PARAGRAPH.\nREAL-PARAGRAPH.\n    MOVE POSSIBLE-INTEGER TO DEFINITE-INTEGER.\n    IF DEFINITE-INTEGER IS EQUAL TO POSSIBLE-INTEGER\n    THEN DISPLAY POSSIBLE-INTEGER ' IS AN INTEGER.',\n    ELSE DISPLAY POSSIBLE-INTEGER ' IS NOT AN INTEGER.'.\nCOMPLEX-PARAGRAPH.\n    DISPLAY REAL-PART '+' IMAGINARY-PART 'i IS NOT AN INTEGER.'.\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 388041, "name": "Selective file copy", "source": "Translate COBOL to Java:        01 ws-input-record.\n       :INPUT-RECORD:\n", "target": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\nclass CopysJ {\n\n  public static void main(String[] args) {\n    String ddname_IN  = \"copys.in.txt\";\n    String ddname_OUT = \"copys.out.txt\";\n    if (args.length >= 1) { ddname_IN  = args[0].length() > 0 ? args[0] : ddname_IN; }\n    if (args.length >= 2) { ddname_OUT = args[1].length() > 0 ? args[1] : ddname_OUT; }\n\n    File dd_IN = new File(ddname_IN);\n    File dd_OUT = new File(ddname_OUT);\n\n    try (\n      Scanner scanner_IN = new Scanner(dd_IN);\n      BufferedWriter writer_OUT = new BufferedWriter(new FileWriter(dd_OUT))\n      ) {\n      String a;\n      String b;\n      String c;\n      String d;\n      String c1;\n      String x = \"XXXXX\";\n      String data_IN;\n      String data_OUT;\n      int ib;\n\n      while (scanner_IN.hasNextLine()) {\n        data_IN = scanner_IN.nextLine();\n        ib = 0;\n        a = data_IN.substring(ib, ib += 5);\n        b = data_IN.substring(ib, ib += 5);\n        c = data_IN.substring(ib, ib += 4);\n        c1=Integer.toHexString(new Byte((c.getBytes())[0]).intValue());\n        if (c1.length()<2) { c1=\"0\" + c1; }\n        data_OUT = a + c1 + x;\n        writer_OUT.write(data_OUT);\n        writer_OUT.newLine();\n        System.out.println(data_IN);\n        System.out.println(data_OUT);\n        System.out.println();\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    return;\n  }\n}\n"}
{"id": 388042, "name": "Safe mode", "source": "Translate COBOL to Java:        identification division.\n       program-id. rexxtrial.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n\n       procedure division.\n      \n       display rexx(\"ADDRESS SYSTEM; 'ls rexxtrial.cob'; return 'fail'\")\n       display \"Exception: \" exception-status\n\n      \n       display \"Try with rexx-unrestricted\"\n       display rexx-unrestricted(\n           \"ADDRESS SYSTEM; 'ls -l rexxtrial.cob'; return 'success'\")\n       display \"No exception raised: \" exception-status\n       goback.\n       end program rexxtrial.\n", "target": "frink.parser.Frink interp = new frink.parser.Frink();\ninterp.setRestrictiveSecurity(true);\n"}
{"id": 388043, "name": "Window creation_X11", "source": "Translate COBOL to Java:        identification division.\n       program-id. x11-hello.\n       installation. cobc -x x11-hello.cob -lX11\n       remarks. Use of private data is likely not cross platform.\n\n       data division.\n       working-storage section.\n       01 msg.\n          05 filler            value z\"S'up, Earth?\".\n       01 msg-len              usage binary-long value 12.\n\n       01 x-display            usage pointer.\n       01 x-window             usage binary-c-long.\n\n      \n      \n      \n      \n       01 x-display-private    based.\n          05 x-ext-data        usage pointer sync.\n          05 private1          usage pointer.\n          05 x-fd              usage binary-long.\n          05 private2          usage binary-long.\n          05 proto-major-version   usage binary-long.\n          05 proto-minor-version   usage binary-long.\n          05 vendor            usage pointer sync.\n          05 private3          usage pointer.\n          05 private4          usage pointer.\n          05 private5          usage pointer.\n          05 private6          usage binary-long.\n          05 allocator         usage program-pointer sync.\n          05 byte-order        usage binary-long.\n          05 bitmap-unit       usage binary-long.\n          05 bitmap-pad        usage binary-long.\n          05 bitmap-bit-order  usage binary-long.\n          05 nformats          usage binary-long.\n          05 screen-format     usage pointer sync.\n          05 private8          usage binary-long.\n          05 x-release         usage binary-long.\n          05 private9          usage pointer sync.\n          05 private10         usage pointer sync.\n          05 qlen              usage binary-long.\n          05 last-request-read usage binary-c-long unsigned sync.\n          05 request           usage binary-c-long unsigned sync.\n          05 private11         usage pointer sync.\n          05 private12         usage pointer.\n          05 private13         usage pointer.\n          05 private14         usage pointer.\n          05 max-request-size  usage binary-long unsigned.\n          05 x-db              usage pointer sync.\n          05 private15         usage program-pointer sync.\n          05 display-name      usage pointer.\n          05 default-screen    usage binary-long.\n          05 nscreens          usage binary-long.\n          05 screens           usage pointer sync.\n          05 motion-buffer     usage binary-c-long unsigned.\n          05 private16         usage binary-c-long unsigned.\n          05 min-keycode       usage binary-long.\n          05 max-keycode       usage binary-long.\n          05 private17         usage pointer sync.\n          05 private18         usage pointer.\n          05 private19         usage binary-long.\n          05 x-defaults        usage pointer sync.\n          05 filler            pic x(256).\n\n       01 x-screen-private     based.\n          05 scr-ext-data      usage pointer sync.\n          05 display-back      usage pointer.\n          05 root              usage binary-c-long.\n          05 x-width           usage binary-long.\n          05 x-height          usage binary-long.\n          05 m-width           usage binary-long.\n          05 m-height          usage binary-long.\n          05 x-ndepths         usage binary-long.\n          05 depths            usage pointer sync.\n          05 root-depth        usage binary-long.\n          05 root-visual       usage pointer sync.\n          05 default-gc        usage pointer.\n          05 cmap              usage pointer.\n          05 white-pixel       usage binary-c-long unsigned sync.\n          05 black-pixel       usage binary-c-long unsigned.\n          05 max-maps          usage binary-long.\n          05 min-maps          usage binary-long.\n          05 backing-store     usage binary-long.\n          05 save_unders       usage binary-char.\n          05 root-input-mask   usage binary-c-long sync.\n          05 filler            pic x(256).\n\n       01 event.\n          05 e-type usage      binary-long.\n          05 filler            pic x(188).\n          05 filler            pic x(256).\n       01 Expose               constant as 12.\n       01 KeyPress             constant as 2.\n\n      \n       01 event-mask           usage binary-c-long value 32769.\n\n      \n       01 x-char-struct.\n          05 lbearing          usage binary-short.\n          05 rbearing          usage binary-short.\n          05 string-width      usage binary-short.\n          05 ascent            usage binary-short.\n          05 descent           usage binary-short.\n          05 attributes        usage binary-short unsigned.\n       01 font-direction       usage binary-long.\n       01 font-ascent          usage binary-long.\n       01 font-descent         usage binary-long.\n\n       01 XGContext            usage binary-c-long.\n       01 box-width            usage binary-long.\n       01 box-height           usage binary-long.\n\n      \n       procedure division.\n\n       call \"XOpenDisplay\" using by reference null returning x-display\n           on exception\n               display function module-id \" Error: \"\n                       \"no XOpenDisplay linkage, requires libX11\"\n                  upon syserr\n               stop run returning 1\n       end-call\n       if x-display equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay returned null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-display-private to x-display\n\n       if screens equal null then\n           display function module-id \" Error: \"\n                   \"XOpenDisplay associated screen null\" upon syserr\n           stop run returning 1\n       end-if\n       set address of x-screen-private to screens\n\n       call \"XCreateSimpleWindow\" using\n           by value x-display root 10 10 200 50 1\n                    black-pixel white-pixel\n           returning x-window\n       call \"XStoreName\" using\n           by value x-display x-window by reference msg\n\n       call \"XSelectInput\" using by value x-display x-window event-mask\n\n       call \"XMapWindow\" using by value x-display x-window\n\n       call \"XGContextFromGC\" using by value default-gc\n           returning XGContext\n       call \"XQueryTextExtents\" using by value x-display XGContext\n           by reference msg by value msg-len\n           by reference font-direction font-ascent font-descent\n           x-char-struct\n       compute box-width = string-width + 8\n       compute box-height = font-ascent + font-descent + 8\n\n       perform forever\n          call \"XNextEvent\" using by value x-display by reference event\n          if e-type equal Expose then\n              call \"XDrawRectangle\" using\n                  by value x-display x-window default-gc 5 5\n                           box-width box-height\n              call \"XDrawString\" using\n                  by value x-display x-window default-gc 10 20\n                  by reference msg by value msg-len\n          end-if\n          if e-type equal KeyPress then exit perform end-if\n       end-perform\n\n       call \"XCloseDisplay\" using by value x-display\n\n       goback.\n       end program x11-hello.\n", "target": "import javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class WindowExample {\n\n  public static void main(String[] args) {\n    Runnable runnable = new Runnable() {\n      public void run() {\n\tcreateAndShow();\n      }\n    };\n    SwingUtilities.invokeLater(runnable);\n  }\n\t\n  static void createAndShow() {\n    JFrame frame = new JFrame(\"Hello World\");\n    frame.setSize(640,480);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n  }\n}\n"}
{"id": 388044, "name": "Print debugging statement", "source": "Translate COBOL to Java: gcobol\n      \n      \n      \n      \n       identification division.\n       program-id. steptrace.\n\n       data division.\n       working-storage section.\n\n       procedure division.\n       steptrace-main.\n\n       display \"explicit line\" upon syserr\n\n    >>Ddisplay \"debug line\" upon syserr\n\n       display \"from \" FUNCTION MODULE-ID \" in \" FUNCTION MODULE-SOURCE\n       goback.\n       end program steptrace.\n", "target": "import java.util.Objects;\n\npublic class PrintDebugStatement {\n    \n    private static void printDebug(String message) {\n        Objects.requireNonNull(message);\n\n        RuntimeException exception = new RuntimeException();\n        StackTraceElement[] stackTrace = exception.getStackTrace();\n        \n        \n        StackTraceElement stackTraceElement = stackTrace[1];\n        String fileName = stackTraceElement.getFileName();\n        String className = stackTraceElement.getClassName();\n        String methodName = stackTraceElement.getMethodName();\n        int lineNumber = stackTraceElement.getLineNumber();\n\n        System.out.printf(\"[DEBUG][%s %s.%s#%d] %s\\n\", fileName, className, methodName, lineNumber, message);\n    }\n\n    private static void blah() {\n        printDebug(\"Made It!\");\n    }\n\n    public static void main(String[] args) {\n        printDebug(\"Hello world.\");\n        blah();\n\n        Runnable oops = () -> printDebug(\"oops\");\n        oops.run();\n    }\n}\n"}

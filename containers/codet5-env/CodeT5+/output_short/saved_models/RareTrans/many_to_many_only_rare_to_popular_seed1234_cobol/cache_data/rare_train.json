{"id": 206, "name": "Arithmetic_Integer", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 208, "name": "Arithmetic_Integer", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 209, "name": "Arithmetic_Integer", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          \n*          \n*          \n*          \n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          \n*          \n*          \n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          \n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 446, "name": "Null object", "source": "Translate COBOL to C#:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "if (foo == null)\n    Console.WriteLine(\"foo is null\");\n"}
{"id": 448, "name": "Null object", "source": "Translate COBOL to Java:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "module NullObject\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"Null value={Null}, Null.toString()={Null.toString()}\");\n\n     \n        String? s = Null;       \n        String s2 = \"test\";\n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n\n     \n        Int len = s?.size : 0;\n        console.print($\"len={len}\");\n\n        if (String test ?= s)\n            {\n            \n            }\n        else\n            {\n            s = \"a non-null value\";\n            }\n\n     \n        s2 = s;                 \n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n        }\n    }\n"}
{"id": 449, "name": "Null object", "source": "Translate COBOL to Python:        identification division.\n       program-id. null-objects.\n       remarks. test with cobc -x -j null-objects.cob\n\n       data division.\n       working-storage section.\n       01 thing-not-thing      usage pointer.\n\n      \n      \n      \n      \n      \n       procedure division.\n       call \"test-null\" using thing-not-thing omitted returning nothing\n       goback.\n       end program null-objects.\n\n      \n      \n      \n       identification division.\n       program-id. test-null.\n\n       data division.\n       linkage section.\n       01 thing-one            usage pointer.\n       01 thing-two            pic x.\n\n       procedure division using\n           thing-one\n           optional thing-two\n           returning omitted.\n\n       if thing-one equal null then\n           display \"thing-one pointer to null\" upon syserr\n       end-if\n\n       if thing-two omitted then\n           display \"no thing-two was passed\" upon syserr\n       end-if\n       goback.\n       end program test-null.\n", "target": "x = None\nif x is None:\n  print \"x is None\"\nelse:\n  print \"x is not None\"\n"}
{"id": 938, "name": "Bitwise operations", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 940, "name": "Bitwise operations", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 941, "name": "Bitwise operations", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. bitwise-ops.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  a                       PIC 1(32) USAGE BIT.\n       01  b                       PIC 1(32) USAGE BIT.\n\n       01  result                  PIC 1(32) USAGE BIT.\n       01  result-disp             REDEFINES result PIC S9(9) COMP.\n\n       LINKAGE SECTION.\n       01  a-int                   USAGE BINARY-LONG.\n       01  b-int                   USAGE BINARY-LONG.\n\n       PROCEDURE DIVISION USING a-int, b-int.\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(a-int, 32) TO a\n           MOVE FUNCTION BOOLEAN-OF-INTEGER(b-int, 32) TO b\n\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result-disp\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result-disp\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result-disp\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result-disp\n\n           \n\n           GOBACK\n           .\n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1817, "name": "Calendar", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": "using System;\nusing System.Collections.Generic; \nusing System.Linq;\nusing System.Text;\n\nnamespace CalendarStuff\n{\n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WindowHeight = 46;\n            Console.Write(buildMonths(new DateTime(1969, 1, 1)));\n            Console.Read(); \n        }\n        private static string buildMonths(DateTime date)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(center(\"[Snoop]\", 24 * 3));\n            sb.AppendLine();\n            sb.AppendLine(center(date.Year.ToString(), 24 * 3));\n\n            List<DateTime> dts = new List<DateTime>();\n            while (true)\n            {\n                dts.Add(date);\n                if (date.Year != ((date = date.AddMonths(1)).Year))\n                {\n                    break;\n                }\n            }\n            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();\n            \n            int sCur=0;\n            while (sCur<dts.Count)\n            {\n                sb.AppendLine();\n                int curMonth=0; \n                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); \n                sCur += j.Length; \n                bool breakOut = false;\n                while (!breakOut)\n                {\n                    int inj = 1;\n                    foreach (var cd in j)\n                    {\n                        if (cd.MoveNext())\n                        {\n                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + \"     \");\n                        }\n                        else\n                        {\n                            sb.Append(\"\".PadRight(21, ' ') + \"     \");\n                            breakOut = true;\n                        }\n                        if (inj++ % 3 == 0) sb.AppendLine();\n                    }\n                }\n\n            }\n            return sb.ToString();\n        }\n\n\n        private static IEnumerable<string> buildMonth(DateTime date)\n        {\n            yield return center(date.ToString(\"MMMM\"),7*3);\n            var j = DateTime.DaysInMonth(date.Year, date.Month);\n            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate(\"\", (current, result) => current + (result.Substring(0, 2).ToUpper() + \" \"));\n            string cur = \"\";\n            int total = 0;\n\n            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))\n            {\n                cur += (day < 0 ? \"  \" : ((day < 9 ? \" \" : \"\") + (day + 1))) +\" \";\n                if (total++ > 0 && (total ) % 7 == 0)\n                {\n                    yield return cur;\n                    cur = \"\";\n                }\n            }\n            yield return cur;\n        }\n        private static string center(string s, int len)\n        {\n            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));\n        } \n    }\n}\n"}
{"id": 1818, "name": "Calendar", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class CalendarTask {\n\n    public static void main(String[] args) {\n        printCalendar(1969, 3);\n    }\n\n    static void printCalendar(int year, int nCols) {\n        if (nCols < 1 || nCols > 12)\n            throw new IllegalArgumentException(\"Illegal column width.\");\n\n        Calendar date = new GregorianCalendar(year, 0, 1);\n\n        int nRows = (int) Math.ceil(12.0 / nCols);\n        int offs = date.get(Calendar.DAY_OF_WEEK) - 1;\n        int w = nCols * 24;\n\n        String[] monthNames = new DateFormatSymbols(Locale.US).getMonths();\n\n        String[][] mons = new String[12][8];\n        for (int m = 0; m < 12; m++) {\n\n            String name = monthNames[m];\n            int len = 11 + name.length() / 2;\n            String format = MessageFormat.format(\"%{0}s%{1}s\", len, 21 - len);\n\n            mons[m][0] = String.format(format, name, \"\");\n            mons[m][1] = \" Su Mo Tu We Th Fr Sa\";\n            int dim = date.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n            for (int d = 1; d < 43; d++) {\n                boolean isDay = d > offs && d <= offs + dim;\n                String entry = isDay ? String.format(\" %2s\", d - offs) : \"   \";\n                if (d % 7 == 1)\n                    mons[m][2 + (d - 1) / 7] = entry;\n                else\n                    mons[m][2 + (d - 1) / 7] += entry;\n            }\n            offs = (offs + dim) % 7;\n            date.add(Calendar.MONTH, 1);\n        }\n\n        System.out.printf(\"%\" + (w / 2 + 10) + \"s%n\", \"[Snoopy Picture]\");\n        System.out.printf(\"%\" + (w / 2 + 4) + \"s%n%n\", year);\n\n        for (int r = 0; r < nRows; r++) {\n            for (int i = 0; i < 8; i++) {\n                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)\n                    System.out.printf(\"   %s\", mons[c][i]);\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 1819, "name": "Calendar", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  CALEND.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n       01  WS-DAY-NAMES-DEF.\n         03 FILLER PIC X(09) VALUE 'SUNDAY   '.\n         03 FILLER PIC X(09) VALUE 'MONDAY   '.\n         03 FILLER PIC X(09) VALUE 'TUESDAY  '.\n         03 FILLER PIC X(09) VALUE 'WEDNESDAY'.\n         03 FILLER PIC X(09) VALUE 'THURSDAY '.\n         03 FILLER PIC X(09) VALUE 'FRIDAY   '.\n         03 FILLER PIC X(09) VALUE 'SATURDAY '.\n       01  FILLER REDEFINES WS-DAY-NAMES-DEF.\n         03  WS-DAY-NAME       PIC X(09) OCCURS 07 TIMES.\n \n       01  WS-MTH-INFO-DEF.\n         03 FILLER PIC X(11) VALUE 'JANUARY  31'.\n         03 FILLER PIC X(11) VALUE 'FEBRUARY 28'.\n         03 FILLER PIC X(11) VALUE 'MARCH    31'.\n         03 FILLER PIC X(11) VALUE 'APRIL    30'.\n         03 FILLER PIC X(11) VALUE 'MAY      31'.\n         03 FILLER PIC X(11) VALUE 'JUNE     30'.\n         03 FILLER PIC X(11) VALUE 'JULY     31'.\n         03 FILLER PIC X(11) VALUE 'AUGUST   31'.\n         03 FILLER PIC X(11) VALUE 'SEPTEMBER30'.\n         03 FILLER PIC X(11) VALUE 'OCTOBER  31'.\n         03 FILLER PIC X(11) VALUE 'NOVEMBER 30'.\n         03 FILLER PIC X(11) VALUE 'DECEMBER 31'.\n       01  FILLER REDEFINES WS-MTH-INFO-DEF.\n         03  WS-MTH-INFO-TABLE OCCURS 12 TIMES.\n           05  WS-MTH-INFO-NAME   PIC X(09).\n           05  WS-MTH-INFO-DAYS   PIC 9(02).\n\n       01  WS-MTH-AREA.\n         03  WS-MTH-DD         PIC S99.\n         03  WS-DAY1           PIC   9.\n         03  WS-DAYS           PIC  99.\n         03  WS-DD             PIC   9.\n         03  WS-WK             PIC   9.\n         03  WS-MM             PIC  99.\n         03  WS-QQ             PIC  99.\n \n         03  WS-MTH-MONTH  OCCURS 12 TIMES.\n           05  WS-MTH-WEEK OCCURS 6 TIMES.\n             07  WS-DAY-FLD      OCCURS 7 TIMES.\n               09  WS-DAY        PIC ZZ.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       01  WS-PRT                 PIC X(132).\n       01  WS-COL                 PIC  9(03) VALUE 0.\n       01  WS-PP                  PIC  9(03) VALUE 0.\n       01  WS-CFGN.\n         03  FILLER               PIC  9(03) VALUE  80.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  1.\n         03  FILLER               PIC  9(02) VALUE  5.\n         03  FILLER               PIC  9(01) VALUE  2.\n       01  WS-CFGW.\n         03  FILLER               PIC  9(03) VALUE 120.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  2.\n         03  FILLER               PIC  9(02) VALUE 10.\n         03  FILLER               PIC  9(01) VALUE  3.\n       01  WS-CFG.\n         03  WS-LS                PIC  9(03) VALUE 120.\n         03  WS-LMAR              PIC  9(02) VALUE 10.\n         03  WS-SPBD              PIC  9(01) VALUE  2.\n         03  WS-SPBC              PIC  9(02) VALUE 10.\n         03  WS-DNMW              PIC  9(01) VALUE  3.\n       PROCEDURE DIVISION.\n           MOVE '1969-01-01' TO INPDATE-RECORD\n           MOVE WS-CFGN   TO WS-CFG\n           IF  (FUNCTION MOD ( INPD-YEAR , 400 ) = 0\n           OR  (FUNCTION MOD ( INPD-YEAR , 4   ) = 0\n               AND\n               FUNCTION MOD ( INPD-YEAR , 100 ) NOT = 0))\n             MOVE 29         TO WS-MTH-INFO-DAYS (02)\n           ELSE\n             MOVE 28         TO WS-MTH-INFO-DAYS (02)\n           END-IF\n \n           PERFORM VARYING WS-MM FROM 1 BY +1\n           UNTIL WS-MM > 12\n           MOVE WS-MM TO INPD-MONTH\n           CALL 'DATE2DOW' USING INPDATE-RECORD, WMS-DOW\n           COMPUTE WS-MTH-DD = 1 - WMS-DOW\n           COMPUTE WS-DAYS = WS-MTH-INFO-DAYS (INPD-MONTH)\n           PERFORM VARYING WS-WK FROM 1 BY +1\n           UNTIL WS-WK > 6\n             PERFORM VARYING WS-DD FROM 1 BY +1\n             UNTIL WS-DD > 7\n               COMPUTE WS-MTH-DD = WS-MTH-DD + 1\n               IF (WS-MTH-DD < 1)\n               OR (WS-MTH-DD > WS-DAYS)\n                 MOVE 0         TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               ELSE\n                 MOVE WS-MTH-DD TO WS-DAY (WS-MM, WS-WK, WS-DD)\n               END-IF\n             END-PERFORM\n           END-PERFORM\n           END-PERFORM\n \n           COMPUTE WS-MM = 0\n           PERFORM VARYING WS-QQ FROM 1 BY +1\n           UNTIL WS-QQ > 4\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               MOVE WS-MTH-INFO-NAME (WS-MM)\n                             TO WS-PRT(WS-PP:9)\n               COMPUTE WS-PP\n               =       WS-PP + ( 2 * 7 + WS-SPBD * 6 + WS-SPBD - 1)\n               -       4\n               MOVE INPD-YEAR TO WS-PRT (WS-PP:4)\n               COMPUTE WS-PP = WS-PP + 4\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             INITIALIZE WS-PRT\n             COMPUTE WS-PP = 1\n             PERFORM VARYING WS-COL FROM 1 BY +1\n             UNTIL WS-COL > 3\n             COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n               IF WS-COL = 1\n                 COMPUTE WS-PP = WS-PP + WS-LMAR + 2 - WS-DNMW\n               ELSE\n                 COMPUTE WS-PP = WS-PP + WS-SPBC + 2 - WS-DNMW\n               END-IF\n               PERFORM VARYING WS-DD FROM 1 BY +1\n               UNTIL WS-DD > 7\n                 IF WS-DD > 1\n                   COMPUTE WS-PP = WS-PP + WS-SPBD + 2 - WS-DNMW\n                 END-IF\n                 MOVE WS-DAY-NAME (WS-DD) (1:WS-DNMW)\n                             TO WS-PRT (WS-PP:WS-DNMW)\n                 COMPUTE WS-PP = WS-PP + WS-DNMW\n               END-PERFORM\n             END-PERFORM\n             DISPLAY WS-PRT (1:WS-LS)\n \n             PERFORM VARYING WS-WK FROM 1 BY +1\n             UNTIL WS-WK > 6\n               INITIALIZE WS-PRT\n               COMPUTE WS-PP = 1\n               PERFORM VARYING WS-COL FROM 1 BY +1\n               UNTIL WS-COL > 3\n               COMPUTE WS-MM = 3 * (WS-QQ - 1) + WS-COL\n \n                 IF WS-COL = 1\n                   COMPUTE WS-PP = WS-PP + WS-LMAR\n                 ELSE\n                   COMPUTE WS-PP = WS-PP + WS-SPBC\n                 END-IF\n                 PERFORM VARYING WS-DD FROM 1 BY +1\n                 UNTIL WS-DD > 7\n                   IF WS-DD > 1\n                     COMPUTE WS-PP = WS-PP + WS-SPBD\n                   END-IF\n                   MOVE WS-DAY (WS-MM, WS-WK, WS-DD)\n                               TO WS-PRT (WS-PP:2)\n                   COMPUTE WS-PP = WS-PP + 2\n                 END-PERFORM\n               END-PERFORM\n               DISPLAY WS-PRT (1:WS-LS)\n             END-PERFORM\n             DISPLAY ' '\n           END-PERFORM\n           GOBACK\n           .\n       END PROGRAM CALEND.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  DATE2DOW.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  WMS-WORK-AREA.\n         03  WMS-YEAR       PIC 9(04).\n         03  WMS-MONTH      PIC 9(02).\n         03  WMS-CSYS       PIC 9(01) VALUE 1.\n         03  WMS-SUM        pic 9(04).\n       LINKAGE SECTION.\n       01  INPDATE-RECORD.\n           05  INPD-YEAR          PIC 9(04).\n           05  FILLER             PIC X(01).\n           05  INPD-MONTH         PIC 9(02).\n           05  FILLER             PIC X(01).\n           05  INPD-DAY           PIC 9(02).\n       01  WMS-DOW                PIC 9(01).\n       PROCEDURE DIVISION USING INPDATE-RECORD, WMS-DOW.\n       1010-CONVERT-DATE-TO-DOW.\n           IF INPD-MONTH < 3\n               COMPUTE WMS-MONTH = INPD-MONTH + 12\n               COMPUTE WMS-YEAR  = INPD-YEAR - 1\n           ELSE\n               COMPUTE WMS-MONTH = INPD-MONTH\n               COMPUTE WMS-YEAR  = INPD-YEAR\n           END-IF\n           COMPUTE WMS-SUM  = \n                            ( INPD-DAY + 2 * WMS-MONTH + WMS-YEAR\n                            + FUNCTION INTEGER (6 * (WMS-MONTH + 1) / 10)\n                            + FUNCTION INTEGER ( WMS-YEAR / 4   )\n                            - FUNCTION INTEGER ( WMS-YEAR / 100 )\n                            + FUNCTION INTEGER ( WMS-YEAR / 400 )\n                            + WMS-CSYS )\n           COMPUTE WMS-DOW = FUNCTION MOD (WMS-SUM, 7) + 1\n           GOBACK\n           .\n       END PROGRAM DATE2DOW.\n", "target": ">>> import calendar\n>>> help(calendar.prcal)\nHelp on method pryear in module calendar:\n\npryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance\n    Print a years calendar.\n\n>>> calendar.prcal(1969)\n                                  1969\n\n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2                      1  2\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23\n27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30\n                                                    31\n\n       April                      May                       June\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                1  2  3  4                         1\n 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8\n14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15\n21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22\n28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29\n                                                    30\n\n        July                     August                  September\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7\n 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14\n14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21\n21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28\n28 29 30 31               25 26 27 28 29 30 31      29 30\n\n      October                   November                  December\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2       1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28\n27 28 29 30 31            24 25 26 27 28 29 30      29 30 31\n"}
{"id": 2240, "name": "String interpolation (included)", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2242, "name": "String interpolation (included)", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2243, "name": "String interpolation (included)", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. interpolation-included.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  extra PIC X(6) VALUE \"little\".\n\n       PROCEDURE DIVISION.\n           DISPLAY FUNCTION SUBSTITUTE(\"Mary had a X lamb.\", \"X\", extra)\n\n           GOBACK\n           .\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2683, "name": "Babbage problem", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2684, "name": "Babbage problem", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2687, "name": "Babbage problem", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2688, "name": "Babbage problem", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2689, "name": "Babbage problem", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2690, "name": "Babbage problem", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. BABBAGE-PROGRAM.\n* A line beginning with an asterisk is an explanatory note.\n* The machine will disregard any such line.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n* In this part of the program we reserve the storage space we shall\n* be using for our variables, using a 'PICTURE' clause to specify\n* how many digits the machine is to keep free.\n* The prefixed number 77 indicates that these variables do not form part\n* of any larger 'record' that we might want to deal with as a whole.\n77  N           PICTURE 99999.\n* We know that 99,736 is a valid answer.\n77  N-SQUARED   PICTURE 9999999999.\n77  LAST-SIX    PICTURE 999999.\nPROCEDURE DIVISION.\n* Here we specify the calculations that the machine is to carry out.\nCONTROL-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING N FROM 1 BY 1\n    UNTIL LAST-SIX IS EQUAL TO 269696.\n    STOP RUN.\nCOMPUTATION-PARAGRAPH.\n    MULTIPLY N BY N GIVING N-SQUARED.\n    MOVE N-SQUARED TO LAST-SIX.\n* Since the variable LAST-SIX can hold a maximum of six digits,\n* only the final six digits of N-SQUARED will be moved into it:\n* the rest will not fit and will simply be discarded.\n    IF LAST-SIX IS EQUAL TO 269696 THEN DISPLAY N.\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 3388, "name": "Find limit of recursion", "source": "Translate COBOL to C#: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3389, "name": "Find limit of recursion", "source": "Translate COBOL to C#: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3392, "name": "Find limit of recursion", "source": "Translate COBOL to Java: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3393, "name": "Find limit of recursion", "source": "Translate COBOL to Java: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3394, "name": "Find limit of recursion", "source": "Translate COBOL to Python: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3395, "name": "Find limit of recursion", "source": "Translate COBOL to Python: identification division.\nprogram-id. recurse.\ndata division.\nworking-storage section.\n01 depth-counter\tpic 9(3).\n01  install-address   \tusage is procedure-pointer.\n01  install-flag      \tpic x comp-x value 0.\n01  status-code       \tpic x(2) comp-5.\n01  ind               \tpic s9(9) comp-5.\n\n\nlinkage section.\n01  err-msg           \tpic x(325).\n\nprocedure division.\n100-main.\n\n\tset install-address to entry \"300-err\".\n\t\n\tcall \"CBL_ERROR_PROC\" using install-flag\n\t\tinstall-address\n\t\treturning status-code.\n\n\tif status-code not = 0\n\t\tdisplay \"ERROR INSTALLING ERROR PROC\"\n\t\tstop run\n        end-if\n\n \tmove 0 to depth-counter.\n\tdisplay 'Mung until no good.'.\n\tperform 200-mung.\n\tdisplay 'No good.'.\n\tstop run.\n\n200-mung.\n\tadd 1 to depth-counter.\n\tdisplay depth-counter.\n\tperform 200-mung.\n300-err.\n\tentry \"300-err\" using err-msg.\n\tperform varying ind from 1 by 1\n\t\tuntil (err-msg(ind:1) = x\"00\") or (ind = length of err-msg)\n\t\t\tcontinue\n\tend-perform\n\n\tdisplay err-msg(1:ind).\n\n\n\t\n\texit program.\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 4321, "name": "CSV data manipulation", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4322, "name": "CSV data manipulation", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4325, "name": "CSV data manipulation", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4326, "name": "CSV data manipulation", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4327, "name": "CSV data manipulation", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4328, "name": "CSV data manipulation", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  19 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   CSVs are something COBOL does pretty well.\n      **     The commented out CONCATENATE statements are a\n      **     second method other than the STRING method.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n           REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT CSV-File ASSIGN TO \"csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Out-File ASSIGN TO \"new.csv.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  CSV-File \n           DATA RECORD IS CSV-Record.\n       01  CSV-Record.\n           05 Field1                  PIC X(64).\n       \n       FD  Out-File\n           DATA RECORD IS Out-Line.\n       01  Out-Line   PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       \n       01  CSV-Data.\n           05  CSV-Col1             PIC 9(5).\n           05  CSV-Col2             PIC 9(5).\n           05  CSV-Col3             PIC 9(5).\n           05  CSV-Col4             PIC 9(5).\n           05  CSV-Col5             PIC 9(5).\n\n        01  CSV-Sum                  PIC ZZZ9.\n        01  CSV-Sum-Alpha           \n                REDEFINES     CSV-Sum  PIC X(4).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  CSV-File\n           OPEN OUTPUT Out-File\n           PERFORM Read-a-Record\n           PERFORM Build-Header\n           PERFORM UNTIL Eof = 'T'\n              PERFORM Read-a-Record\n              IF Eof NOT EQUAL 'T' PERFORM Process-a-Record\n           END-PERFORM\n           CLOSE CSV-File\n           CLOSE Out-File\n           STOP RUN.\n       \n       Read-a-Record.\n           READ CSV-File \n              AT END MOVE 'T' TO Eof\n           END-READ.\n\n        Build-Header.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",SUM\"\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",SUM\" INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n\n        Process-a-Record.\n            UNSTRING CSV-Record DELIMITED BY ',' INTO\n                  CSV-Col1 CSV-Col2 CSV-Col3 CSV-Col4 CSV-Col5.\n            COMPUTE CSV-Sum = \n                  CSV-Col1 + CSV-Col2 + CSV-Col3 + CSV-Col4 + CSV-Col5.\n      **    MOVE CONCATENATE(TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha))\n      **        TO Out-Line.\n            STRING TRIM(CSV-Record), \",\" TRIM(CSV-Sum-Alpha)\n                   INTO Out-Line.\n            WRITE Out-Line.\n            MOVE SPACES TO Out-Line.\n       \n       END-PROGRAM.\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 6666, "name": "Collections", "source": "Translate COBOL to C#:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n"}
{"id": 6668, "name": "Collections", "source": "Translate COBOL to Java:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "List arrayList = new ArrayList();\narrayList.add(new Integer(0));\n\narrayList.add(0); \n\n\n\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n"}
{"id": 6669, "name": "Collections", "source": "Translate COBOL to Python:        identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      \n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n", "target": "collection = [0, '1']                 \nx = collection[0]                     \ncollection.append(2)                  \ncollection.insert(0, '-1')            \ny = collection[0]                     \ncollection.extend([2,'3'])            \ncollection += [2,'3']                 \ncollection[2:6]                       \nlen(collection)                       \ncollection = (0, 1)                   \ncollection[:]                         \ncollection[-4:-1]                     \ncollection[::2]                       \ncollection=\"some string\"              \nx = collection[::-1]                  \ncollection[::2] == \"some string\"[::2] \ncollection.__getitem__(slice(0,len(collection),2))  \ncollection = {0: \"zero\", 1: \"one\"}    \ncollection['zero'] = 2                \ncollection = set([0, '1'])            \n"}
{"id": 7950, "name": "Jump anywhere", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7951, "name": "Jump anywhere", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "if (x > 0) goto positive;\nelse goto negative;\n\npositive:\n    Console.WriteLine(\"pos\\n\"); goto both;\n\nnegative:\n    Console.WriteLine(\"neg\\n\");\n\nboth:\n    ...\n"}
{"id": 7954, "name": "Jump anywhere", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7955, "name": "Jump anywhere", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "loop1: while (x != 0) {\n    loop2: for (int i = 0; i < 10; i++) {\n        loop3: do {\n            \n            if () {\n                \n                continue loop1;\n            }\n            \n            if () {\n                \n                break loop2;\n            }\n        } while (y < 10);\n        \n    }\n    \n}\n"}
{"id": 7956, "name": "Jump anywhere", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 7957, "name": "Jump anywhere", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JUMPS-PROGRAM.\n* Nobody writes like this, of course; but...\nPROCEDURE DIVISION.\n* You can jump anywhere you like.\nSTART-PARAGRAPH.\n    GO TO AN-ARBITRARY-PARAGRAPH.\nYET-ANOTHER-PARAGRAPH.\n    ALTER START-PARAGRAPH TO PROCEED TO A-PARAGRAPH-SOMEWHERE.\n* That's right, folks: we don't just have GO TOs, we have GO TOs whose\n* destinations can be changed at will, from anywhere in the program,\n* at run time.\n    GO TO START-PARAGRAPH.\n* But bear in mind: once you get there, the GO TO no longer goes to\n* where it says it goes to.\nA-PARAGRAPH-SOMEWHERE.\n    DISPLAY 'Never heard of him.'\n    STOP RUN.\nSOME-OTHER-PARAGRAPH.\n* You think that's bad? You ain't seen nothing.\n    GO TO YET-ANOTHER-PARAGRAPH.\nAN-ARBITRARY-PARAGRAPH.\n    DISPLAY 'Edsger who now?'\n    GO TO SOME-OTHER-PARAGRAPH.\n", "target": "\nfrom goto import goto, label\nlabel .start\nfor i in range(1, 4):\n    print i\n    if i == 2:\n        try:\n            output = message\n        except NameError:\n            print \"Oops - forgot to define 'message'!  Start again.\"\n            message = \"Hello world\"\n            goto .start\nprint output, \"\\n\"\n"}
{"id": 8782, "name": "Department numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8783, "name": "Department numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8786, "name": "Department numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8787, "name": "Department numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8788, "name": "Department numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8789, "name": "Department numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DEPARTMENT-NUMBERS.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.       \n       01 BANNER        PIC X(24) VALUE \"POLICE  SANITATION  FIRE\".\n       01 COMBINATION.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 POLICE     PIC 9.\n          03 FILLER     PIC X(11) VALUE SPACES.\n          03 SANITATION PIC 9.\n          03 FILLER     PIC X(5)  VALUE SPACES.\n          03 FIRE       PIC 9.\n       01 TOTAL         PIC 99.\n\n       PROCEDURE DIVISION.\n       BEGIN. \n           DISPLAY BANNER.\n           PERFORM POLICE-LOOP VARYING POLICE FROM 2 BY 2\n           UNTIL POLICE IS GREATER THAN 6.\n           STOP RUN.\n \n       POLICE-LOOP. \n           PERFORM SANITATION-LOOP VARYING SANITATION FROM 1 BY 1\n           UNTIL SANITATION IS GREATER THAN 7.\n  \n       SANITATION-LOOP.\n           PERFORM FIRE-LOOP VARYING FIRE FROM 1 BY 1\n           UNTIL FIRE IS GREATER THAN 7.\n \n       FIRE-LOOP.\n           ADD POLICE, SANITATION, FIRE GIVING TOTAL.\n           IF POLICE IS NOT EQUAL TO SANITATION\n               AND POLICE IS NOT EQUAL TO FIRE\n               AND SANITATION IS NOT EQUAL TO FIRE\n               AND TOTAL IS EQUAL TO 12,\n               DISPLAY COMBINATION.\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 10523, "name": "Nth root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10525, "name": "Nth root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10526, "name": "Nth root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 11494, "name": "Hailstone sequence", "source": "Translate COBOL to C#:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11495, "name": "Hailstone sequence", "source": "Translate COBOL to C#:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11498, "name": "Hailstone sequence", "source": "Translate COBOL to Java:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11499, "name": "Hailstone sequence", "source": "Translate COBOL to Java:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11500, "name": "Hailstone sequence", "source": "Translate COBOL to Python:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11501, "name": "Hailstone sequence", "source": "Translate COBOL to Python:        identification division.\n       program-id. hailstones.\n       remarks. cobc -x hailstones.cob.\n\n       data division.\n       working-storage section.\n       01 most                 constant as 1000000.\n       01 coverage             constant as 100000.       \n       01 stones               usage binary-long.\n       01 n                    usage binary-long.\n       01 storm                usage binary-long.\n\n       01 show-arg             pic 9(6).\n       01 show-default         pic 99 value 27.\n       01 show-sequence        usage binary-long.\n       01 longest              usage binary-long occurs 2 times.\n\n       01 filler.\n          05 hail              usage binary-long\n                               occurs 0 to most depending on stones.\n       01 show                 pic z(10).\n       01 low-range            usage binary-long.\n       01 high-range           usage binary-long.\n       01 range                usage binary-long.\n        \n\n       01 remain               usage binary-long.\n       01 unused               usage binary-long.\n\n       procedure division.\n       accept show-arg from command-line\n       if show-arg less than 1 or greater than coverage then\n           move show-default to show-arg\n       end-if\n       move show-arg to show-sequence\n\n       move 1 to longest(1)\n       perform hailstone varying storm\n                         from 1 by 1 until storm > coverage\n       display \"Longest at: \" longest(2) \" with \" longest(1) \" elements\"\n       goback.\n\n      \n       hailstone.\n       move 0 to stones\n       move storm to n\n       perform until n equal 1\n           if stones > most then\n               display \"too many hailstones\" upon syserr\n               stop run\n           end-if\n\n           add 1 to stones\n           move n to hail(stones)\n           divide n by 2 giving unused remainder remain\n           if remain equal 0 then\n               divide 2 into n\n           else\n               compute n = 3 * n + 1\n           end-if\n       end-perform\n       add 1 to stones\n       move n to hail(stones)\n\n       if stones > longest(1) then\n           move stones to longest(1)\n           move storm to longest(2)\n       end-if\n\n       if storm equal show-sequence then\n           display show-sequence \": \" with no advancing\n           perform varying range from 1 by 1 until range > stones\n               move 5 to low-range\n               compute high-range = stones - 4\n               if range < low-range or range > high-range then\n                   move hail(range) to show\n                   display function trim(show) with no advancing\n                   if range < stones then\n                       display \", \" with no advancing\n                   end-if\n               end-if\n               if range = low-range and stones > 8 then\n                   display \"..., \" with no advancing\n               end-if\n           end-perform\n           display \": \" stones \" elements\"\n       end-if\n       .\n\n       end program hailstones.\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 12965, "name": "Hello world_Newline omission", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12967, "name": "Hello world_Newline omission", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 12968, "name": "Hello world_Newline omission", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. GOODBYE-WORLD.\n\nPROCEDURE DIVISION.\nDISPLAY 'Goodbye, World!'\n    WITH NO ADVANCING\nEND-DISPLAY\n.\nSTOP RUN.\n", "target": "import sys\nsys.stdout.write(\"Goodbye, World!\")\n"}
{"id": 13699, "name": "Hello world_Standard error", "source": "Translate COBOL to C#: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13701, "name": "Hello world_Standard error", "source": "Translate COBOL to Java: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13702, "name": "Hello world_Standard error", "source": "Translate COBOL to Python: \tprogram-id. ehello.\n\tprocedure division.\n\t\tdisplay \"Goodbye, world!\"  upon syserr.\n\t\tstop run.\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 13910, "name": "SEDOLs", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };\nstatic int sedolChecksum(string sedol)\n{\n    int len = sedol.Length;\n    int sum = 0;\n\n    if (len == 7) \n        return (int)sedol[6];\n\n    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, \"[AEIOUaeiou]+\")) \n        return -1;\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (Char.IsDigit(sedol[i]))\n            sum += (((int)sedol[i] - 48) * sedol_weights[i]);\n\n        else if (Char.IsLetter(sedol[i]))\n            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);\n\n        else\n            return -1;\n\n    }\n\n    return (10 - (sum % 10)) % 10;\n}\n"}
{"id": 13912, "name": "SEDOLs", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "import java.util.Scanner;\n\npublic class SEDOL{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString sedol = sc.next();\n\t\t\tSystem.out.println(sedol + getSedolCheckDigit(sedol));\n\t\t}\n\t}\n\t\n\tprivate static final int[] mult = {1, 3, 1, 7, 3, 9};\n\t\n\tpublic static int getSedolCheckDigit(String str){\n\t    if(!validateSedol(str)){\n\t    \tSystem.err.println(\"SEDOL strings must contain six characters with no vowels.\");\n\t    \treturn -1;\n\t    }\n\t    str = str.toUpperCase();\n\t    int total = 0;\n\t    for(int i = 0;i < 6; i++){\n\t        char s = str.charAt(i);\n\t        total += Character.digit(s, 36) * mult[i];\n\t    }\n\t    return (10 - (total % 10)) % 10;\n\t}\n\n\tpublic static boolean validateSedol(String str){\n\t\treturn (str.length() == 6) && !str.toUpperCase().matches(\".*?[AEIOU].*?\");\n\t}\n}\n"}
{"id": 13913, "name": "SEDOLs", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. sedol.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT sedol-file ASSIGN \"sedol.txt\"\n        ORGANIZATION LINE SEQUENTIAL\n        FILE STATUS sedol-file-status.\n\nDATA DIVISION.\nFILE SECTION.\nFD  sedol-file.\n01  sedol                               PIC X(6).\n\nWORKING-STORAGE SECTION.\n01  sedol-file-status                   PIC XX.\n    88  sedol-file-ok                   VALUE \"00\".\n\n01  digit-num                           PIC 9 COMP.\n    \n01  digit-weights-area                  VALUE \"1317391\".\n    03  digit-weights                   PIC 9 OCCURS 7 TIMES.\n    \n01  weighted-sum-parts-area.\n    03  weighted-sum-parts              PIC 9(3) COMP OCCURS 6 TIMES.\n\n01  weighted-sum                        PIC 9(3) COMP.\n\n01  check-digit                         PIC 9.\n\nPROCEDURE DIVISION.\n    OPEN INPUT sedol-file\n    PERFORM UNTIL NOT sedol-file-ok\n        READ sedol-file\n            AT END\n                EXIT PERFORM\n        END-READ\n\n        MOVE FUNCTION UPPER-CASE(sedol) TO sedol\n        \n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            EVALUATE TRUE\n                WHEN sedol (digit-num:1) IS ALPHABETIC-UPPER\n                    IF sedol (digit-num:1) = \"A\" OR \"E\" OR \"I\" OR \"O\" OR \"U\"\n                        DISPLAY \"Invalid SEDOL: \" sedol\n                        EXIT PERFORM CYCLE\n                    END-IF\n                \n                    COMPUTE weighted-sum-parts (digit-num) =\n                        (FUNCTION ORD(sedol (digit-num:1)) - FUNCTION ORD(\"A\")\n                        + 10) * digit-weights (digit-num)\n                        \n                WHEN sedol (digit-num:1) IS NUMERIC\n                    MULTIPLY FUNCTION NUMVAL(sedol (digit-num:1))\n                        BY digit-weights (digit-num)\n                        GIVING weighted-sum-parts (digit-num)\n                        \n                WHEN OTHER\n                    DISPLAY \"Invalid SEDOL: \" sedol\n                    EXIT PERFORM CYCLE\n            END-EVALUATE\n        END-PERFORM\n\n        INITIALIZE weighted-sum\n        PERFORM VARYING digit-num FROM 1 BY 1 UNTIL digit-num > 6\n            ADD weighted-sum-parts (digit-num) TO weighted-sum\n        END-PERFORM\n        \n        COMPUTE check-digit =\n            FUNCTION MOD(10 - FUNCTION MOD(weighted-sum, 10), 10)\n\n        DISPLAY sedol check-digit\n    END-PERFORM\n    \n    CLOSE sedol-file\n    .\nEND PROGRAM sedol.\n", "target": "def char2value(c):\n  assert c not in 'AEIOU', \"No vowels\"\n  return int(c, 36)\n\nsedolweight = [1,3,1,7,3,9]\n\ndef checksum(sedol):\n    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,\n                  sedol, sedolweight)\n               )\n    return str((10 - (tmp % 10)) % 10)\n\nfor sedol in .split():\n    print sedol + checksum(sedol)\n"}
{"id": 14566, "name": "Create a file", "source": "Translate COBOL to C#:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Create(\"output.txt\");\n        File.Create(@\"\\output.txt\");\n\n        Directory.CreateDirectory(\"docs\");\n        Directory.CreateDirectory(@\"\\docs\");\n    }\n}\n"}
{"id": 14568, "name": "Create a file", "source": "Translate COBOL to Java:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "import java.io.*;\npublic class CreateFileTest {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tnew File(\"output.txt\").createNewFile();\n\t\t\tnew File(File.separator + \"output.txt\").createNewFile();\n\t\t\tnew File(\"docs\").mkdir();\n\t\t\tnew File(File.separator + \"docs\").mkdir();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 14569, "name": "Create a file", "source": "Translate COBOL to Python:        identification division.\n       program-id. create-a-file.\n\n       data division.\n       working-storage section.\n       01 skip                 pic 9 value 2.\n       01 file-name.\n          05 value \"/output.txt\".\n       01 dir-name.\n          05 value \"/docs\".\n       01 file-handle          usage binary-long.\n\n       procedure division.\n       files-main.\n\n      \n       perform create-file-and-dir\n\n      \n       move 1 to skip\n       perform create-file-and-dir\n\n       goback.\n\n       create-file-and-dir.\n      \n       call \"CBL_CREATE_FILE\" using file-name(skip:) 3 0 0 file-handle\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_FILE \" file-name(skip:) \": \"\n                   file-handle \", \" return-code upon syserr\n       end-if\n\n      \n       call \"CBL_CREATE_DIR\" using dir-name(skip:)\n       if return-code not equal 0 then\n           display \"error: CBL_CREATE_DIR \" dir-name(skip:) \": \"\n                   return-code upon syserr\n       end-if\n       .\n\n       end program create-a-file.\n", "target": "import os\nfor directory in ['/', './']:\n  open(directory + 'output.txt', 'w').close()  \n  os.mkdir(directory + 'docs')                 \n"}
{"id": 15003, "name": "Almost prime", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 15005, "name": "Almost prime", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 15006, "name": "Almost prime", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. ALMOST-PRIME.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 CONTROL-VARS.\n          03 K              PIC 9.\n          03 I              PIC 999.\n          03 SEEN           PIC 99.\n          03 N              PIC 999.\n          03 P              PIC 99.\n          03 P-SQUARED      PIC 9(4).\n          03 F              PIC 99.\n          03 N-DIV-P        PIC 999V999.\n          03 FILLER         REDEFINES N-DIV-P.\n             05 NEXT-N      PIC 999.\n             05 FILLER      PIC 999.\n                88 N-DIVS-P VALUE ZERO.\n          \n       01 OUT-VARS.\n          03 K-LN           PIC X(70).\n          03 K-LN-PTR       PIC 99.\n          03 LN-HDR.\n             05 FILLER      PIC X(4) VALUE \"K = \".\n             05 K-OUT       PIC 9.\n             05 FILLER      PIC X VALUE \":\".\n          03 I-FMT.\n             05 FILLER      PIC X VALUE SPACE.\n             05 I-OUT       PIC ZZ9.\n       \n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM K-ALMOST-PRIMES VARYING K FROM 1 BY 1\n               UNTIL K IS GREATER THAN 5.\n           STOP RUN.\n           \n       K-ALMOST-PRIMES.\n           MOVE SPACES TO K-LN.\n           MOVE 1 TO K-LN-PTR.\n           MOVE ZERO TO SEEN.\n           MOVE K TO K-OUT.\n           STRING LN-HDR DELIMITED BY SIZE INTO K-LN \n               WITH POINTER K-LN-PTR.\n           PERFORM I-K-ALMOST-PRIME VARYING I FROM 2 BY 1\n               UNTIL SEEN IS EQUAL TO 10.\n           DISPLAY K-LN.\n       \n       I-K-ALMOST-PRIME.\n           MOVE ZERO TO F, P-SQUARED.\n           MOVE I TO N.\n           PERFORM PRIME-FACTOR VARYING P FROM 2 BY 1\n               UNTIL F IS NOT LESS THAN K \n               OR P-SQUARED IS GREATER THAN N. \n           IF N IS GREATER THAN 1, ADD 1 TO F.\n           IF F IS EQUAL TO K,\n               MOVE I TO I-OUT,\n               ADD 1 TO SEEN,\n               STRING I-FMT DELIMITED BY SIZE INTO K-LN\n                   WITH POINTER K-LN-PTR.\n       \n       PRIME-FACTOR.\n           MULTIPLY P BY P GIVING P-SQUARED.\n           DIVIDE N BY P GIVING N-DIV-P.\n           PERFORM DIVIDE-FACTOR UNTIL NOT N-DIVS-P.\n           \n       DIVIDE-FACTOR.\n           MOVE NEXT-N TO N.\n           ADD 1 TO F.\n           DIVIDE N BY P GIVING N-DIV-P.\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15283, "name": "Integer comparison", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15285, "name": "Integer comparison", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15286, "name": "Integer comparison", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Compare.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A PIC 9(10).\n       01  B PIC 9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B \n\n*          \n*          \n           IF A < B\n               DISPLAY A \" is less than \" B\n           ELSE IF A = B\n               DISPLAY A \" is equal to \" B\n           ELSE IF A > B\n               DISPLAY A \" is larger than \" B\n           END-IF.\n\n           GOBACK\n           .\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15499, "name": "Environment variables", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15501, "name": "Environment variables", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15502, "name": "Environment variables", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Environment-Vars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  home PIC X(75).\n\n       PROCEDURE DIVISION.\n*          \n           ACCEPT home FROM ENVIRONMENT \"HOME\"\n           DISPLAY home\n\n*          \n           DISPLAY \"HOME\" UPON ENVIRONMENT-NAME\n           ACCEPT home FROM ENVIRONMENT-VALUE\n\n           GOBACK\n           .\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15746, "name": "Substring", "source": "Translate COBOL to C#:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15748, "name": "Substring", "source": "Translate COBOL to Java:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15749, "name": "Substring", "source": "Translate COBOL to Python:        identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 16241, "name": "Append a record to the end of a text file", "source": "Translate COBOL to C#:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "using System;\nusing System.IO;\n\nnamespace AppendPwdRosetta\n{\n    class PasswordRecord\n    {\n        public string account, password, fullname, office, extension, homephone, email, directory, shell;\n        public int UID, GID;\n        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, \n            string email, string directory, string shell)\n        {\n            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;\n            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;\n        }\n        public override string ToString()\n        {\n            var gecos = string.Join(\",\", new string[] { fullname, office, extension, homephone, email });\n            return string.Join(\":\", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var jsmith = new PasswordRecord(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\", \n                \"/home/jsmith\", \"/bin/bash\");\n            var jdoe = new PasswordRecord(\"jdoe\", \"x\", 1002, 1000, \"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\", \"/home/jdoe\", \n                \"/bin/bash\");\n            var xyz = new PasswordRecord(\"xyz\", \"x\", 1003, 1000, \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\", \"/home/xyz\", \"/bin/bash\");\n\n            \n            File.WriteAllLines(\"passwd.txt\", new string[] { jsmith.ToString(), jdoe.ToString() });\n\n            \n            File.AppendAllText(\"passwd.txt\", xyz.ToString());\n\n            \n            string[] lines = File.ReadAllLines(\"passwd.txt\");\n            Console.WriteLine(\"Appended record: \" + lines[2]);\n        }\n    }\n}\n"}
{"id": 16243, "name": "Append a record to the end of a text file", "source": "Translate COBOL to Java:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"}
{"id": 16244, "name": "Append a record to the end of a text file", "source": "Translate COBOL to Python:       \n      \n      \n      \n       identification division.\n       program-id. append.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select pass-file\n           assign to pass-filename\n           organization is line sequential\n           status is pass-status.\n\n       REPLACE ==:LRECL:== BY ==2048==.\n\n       data division.\n       file section.\n       fd pass-file record varying depending on pass-length.\n       01 fd-pass-record.\n          05 filler pic x occurs 0 to :LRECL: times\n                          depending on pass-length.\n\n       working-storage section.\n       01 pass-filename.\n          05 filler            value \"passfile\".\n       01 pass-status          pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-pass          value '10'.\n\n       01 pass-length          usage index.\n       01 total-length         usage index.\n\n       77 file-action          pic x(11).\n\n       01 pass-record.\n          05 account           pic x(64).\n             88 key-account    value \"xyz\".\n          05 password          pic x(64).\n          05 uid               pic z(4)9.\n          05 gid               pic z(4)9.\n          05 details.\n             10 fullname       pic x(128).\n             10 office         pic x(128).\n             10 extension      pic x(32).\n             10 homephone      pic x(32).\n             10 email          pic x(256).\n          05 homedir           pic x(256).\n          05 shell             pic x(256).\n\n       77 colon                pic x value \":\".\n       77 comma-mark           pic x value \",\".\n       77 newline              pic x value x\"0a\".\n\n      \n       procedure division.\n       main-routine.\n       perform initial-fill\n\n       >>IF DEBUG IS DEFINED \n       display \"Initial data:\"\n       perform show-records\n       >>END-IF\n\n       perform append-record\n \n       >>IF DEBUG IS DEFINED \n       display newline \"After append:\"\n       perform show-records\n       >>END-IF\n\n       perform verify-append\n       goback\n       .\n\n      \n       initial-fill.\n       perform open-output-pass-file\n\n       move \"jsmith\" to account\n       move \"x\" to password\n       move 1001 to uid\n       move 1000 to gid\n       move \"Joe Smith\" to fullname\n       move \"Room 1007\" to office\n       move \"(234)555-8917\" to extension\n       move \"(234)555-0077\" to homephone\n       move \"jsmith@rosettacode.org\" to email\n       move \"/home/jsmith\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       move \"jdoe\" to account\n       move \"x\" to password\n       move 1002 to uid\n       move 1000 to gid\n       move \"Jane Doe\" to fullname\n       move \"Room 1004\" to office\n       move \"(234)555-8914\" to extension\n       move \"(234)555-0044\" to homephone\n       move \"jdoe@rosettacode.org\" to email\n       move \"/home/jdoe\" to homedir\n       move \"/bin/bash\" to shell\n       perform write-pass-record\n\n       perform close-pass-file\n       .\n\n      \n       check-pass-file.\n       if not ok-status then\n           perform file-error\n       end-if\n       .\n\n      \n       check-pass-with-eof.\n       if not ok-status and not eof-pass then\n           perform file-error\n       end-if\n       .\n\n      \n       file-error.\n       display \"error \" file-action space pass-filename\n               space pass-status upon syserr\n       move 1 to return-code\n       goback\n       .\n\n      \n       append-record.\n       move \"xyz\" to account\n       move \"x\" to password\n       move 1003 to uid\n       move 1000 to gid\n       move \"X Yz\" to fullname\n       move \"Room 1003\" to office\n       move \"(234)555-8913\" to extension\n       move \"(234)555-0033\" to homephone\n       move \"xyz@rosettacode.org\" to email\n       move \"/home/xyz\" to homedir\n       move \"/bin/bash\" to shell\n\n       perform open-extend-pass-file\n       perform write-pass-record\n       perform close-pass-file\n       .\n\n      \n       open-output-pass-file.\n       open output pass-file with lock\n       move \"open output\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-extend-pass-file.\n       open extend pass-file with lock\n       move \"open extend\" to file-action\n       perform check-pass-file\n       .\n\n      \n       open-input-pass-file.\n       open input pass-file\n       move \"open input\" to file-action\n       perform check-pass-file\n       .\n\n      \n       close-pass-file.\n       close pass-file\n       move \"closing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       write-pass-record.\n       set total-length to 1\n       set pass-length to :LRECL:\n       string\n           account delimited by space\n           colon\n           password delimited by space\n           colon\n           trim(uid leading) delimited by size\n           colon\n           trim(gid leading) delimited by size\n           colon\n           trim(fullname trailing) delimited by size\n           comma-mark\n           trim(office trailing) delimited by size\n           comma-mark\n           trim(extension trailing) delimited by size\n           comma-mark\n           trim(homephone trailing) delimited by size\n           comma-mark\n           email delimited by space\n           colon\n           trim(homedir trailing) delimited by size\n           colon\n           trim(shell trailing) delimited by size\n           into fd-pass-record with pointer total-length\n           on overflow\n               display \"error: fd-pass-record truncated at \"\n                       total-length upon syserr\n       end-string\n       set pass-length to total-length\n       set pass-length down by 1\n\n       write fd-pass-record\n       move \"writing\" to file-action\n       perform check-pass-file\n       .\n\n      \n       read-pass-file.\n       read pass-file\n       move \"reading\" to file-action\n       perform check-pass-with-eof\n       .\n\n      \n       show-records.\n       perform open-input-pass-file\n\n       perform read-pass-file\n       perform until eof-pass\n           perform show-pass-record\n           perform read-pass-file\n       end-perform\n\n       perform close-pass-file\n       .\n\n      \n       show-pass-record.\n       display fd-pass-record\n       .\n\n      \n       verify-append.\n       perform open-input-pass-file\n\n       move 0 to tally\n       perform read-pass-file\n       perform until eof-pass\n           add 1 to tally\n           unstring fd-pass-record delimited by colon\n               into account\n           if key-account then exit perform end-if\n           perform read-pass-file\n       end-perform\n       if (key-account and tally not > 2) or (not key-account) then\n           display\n               \"error: appended record not found in correct position\"\n              upon syserr\n       else\n           display \"Appended record: \" with no advancing\n           perform show-pass-record\n       end-if\n\n       perform close-pass-file\n       .\n\n       end program append.\n", "target": "\n\n\n\npasswd_list=[\n  dict(account='jsmith', password='x', UID=1001, GID=1000, \n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\n                  directory='/home/jsmith', shell='/bin/bash'),\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\n       directory='/home/jdoe', shell='/bin/bash')\n]\n\npasswd_fields=\"account password UID GID GECOS directory shell\".split()\nGECOS_fields=\"fullname office extension homephone email\".split()\n\ndef passwd_text_repr(passwd_rec):\n\n  passwd_rec[\"GECOS\"]=\",\".join([ passwd_rec[\"GECOS\"][field] for field in GECOS_fields])\n  for field in passwd_rec: \n    if not isinstance(passwd_rec[field], str):\n      passwd_rec[field]=`passwd_rec[field]`\n  return \":\".join([ passwd_rec[field] for field in passwd_fields ])\n\npasswd_text=open(\"passwd.txt\",\"w\")\nfor passwd_rec in passwd_list:\n  print >> passwd_text,passwd_text_repr(passwd_rec)\npasswd_text.close()\n\n\n\n\npasswd_text=open(\"passwd.txt\",\"a+\")\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\n             directory='/home/xyz', shell='/bin/bash')\nprint >> passwd_text,  passwd_text_repr(new_rec)\npasswd_text.close()\n\n\n\n\npasswd_list=list(open(\"passwd.txt\",\"r\"))\nif \"xyz\" in passwd_list[-1]:\n  print \"Appended record:\",passwd_list[-1][:-1]\n"}
{"id": 16635, "name": "Perfect numbers", "source": "Translate COBOL to C#:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16637, "name": "Perfect numbers", "source": "Translate COBOL to Java:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16638, "name": "Perfect numbers", "source": "Translate COBOL to Python:       $set REPOSITORY \"UPDATE ON\"\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. perfect-main.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION perfect\n           .\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i                      PIC 9(8).  \n       \n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 2 BY 1 UNTIL 33550337 = i\n               IF FUNCTION perfect(i) = 0\n                   DISPLAY i\n               END-IF\n           END-PERFORM\n       \n           GOBACK\n           .\n       END PROGRAM perfect-main.\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 16960, "name": "Abbreviations, automatic", "source": "Translate COBOL to C#:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16961, "name": "Abbreviations, automatic", "source": "Translate COBOL to C#:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Abbreviations {\n    class Program {\n        static void Main(string[] args) {\n            string[] lines = System.IO.File.ReadAllLines(\"days_of_week.txt\");\n            int i = 0;\n\n            foreach (string line in lines) {\n                i++;\n                if (line.Length > 0) {\n                    var days = line.Split();\n                    if (days.Length != 7) {\n                        throw new Exception(\"There aren't 7 days in line \" + i);\n                    }\n\n                    Dictionary<string, int> temp = new Dictionary<string, int>();\n                    foreach (string day in days) {\n                        if (temp.ContainsKey(day)) {\n                            Console.WriteLine(\" \u221e  {0}\", line);\n                            continue;\n                        }\n                        temp.Add(day, 1);\n                    }\n\n                    int len = 1;\n                    while (true) {\n                        temp.Clear();\n                        foreach(string day in days) {\n                            string key;\n                            if (len < day.Length) {\n                                key = day.Substring(0, len);\n                            } else {\n                                key = day;\n                            }\n                            if (temp.ContainsKey(key)) {\n                                break;\n                            }\n                            temp.Add(key, 1);\n                        }\n                        if (temp.Count == 7) {\n                            Console.WriteLine(\"{0,2:D}  {1}\", len, line);\n                            break;\n                        }\n                        len++;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 16964, "name": "Abbreviations, automatic", "source": "Translate COBOL to Java:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16965, "name": "Abbreviations, automatic", "source": "Translate COBOL to Java:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Abbreviations {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"days_of_week.txt\");\n        List<String> readAllLines = Files.readAllLines(path);\n        for (int i = 0; i < readAllLines.size(); i++) {\n            String line = readAllLines.get(i);\n            if (line.length() == 0) continue;\n\n            String[] days = line.split(\" \");\n            if (days.length != 7) throw new RuntimeException(\"There aren't 7 days on line \" + (i + 1));\n\n            Map<String, Integer> temp = new HashMap<>();\n            for (String day : days) {\n                Integer count = temp.getOrDefault(day, 0);\n                temp.put(day, count + 1);\n            }\n            if (temp.size() < 7) {\n                System.out.print(\" \u221e  \");\n                System.out.println(line);\n                continue;\n            }\n\n            int len = 1;\n            while (true) {\n                temp.clear();\n                for (String day : days) {\n                    String sd;\n                    if (len >= day.length()) {\n                        sd = day;\n                    } else {\n                        sd = day.substring(0, len);\n                    }\n                    Integer count = temp.getOrDefault(sd, 0);\n                    temp.put(sd, count + 1);\n                }\n                if (temp.size() == 7) {\n                    System.out.printf(\"%2d  %s\\n\", len, line);\n                    break;\n                }\n                len++;\n            }\n        }\n    }\n}\n"}
{"id": 16966, "name": "Abbreviations, automatic", "source": "Translate COBOL to Python:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 16967, "name": "Abbreviations, automatic", "source": "Translate COBOL to Python:             IDENTIFICATION DIVISION.\n            PROGRAM-ID. AUTO-ABBREVIATIONS.\n\n            ENVIRONMENT DIVISION.\n\n            INPUT-OUTPUT SECTION.\n            FILE-CONTROL.\n              SELECT DOW ASSIGN TO \"days-of-week.txt\"\n              ORGANIZATION IS LINE SEQUENTIAL.\n\n            DATA DIVISION.\n              FILE SECTION.\n              FD DOW.\n              01 DOW-FILE PIC X(200).\n\n              WORKING-STORAGE SECTION. \n              01 DOW-LINE PIC X(200).\n              01 ENDO PIC 9(1).\n              01 ENDO2 PIC 9(1).\n              01 CURDAY PIC X(50).\n              01 ABPTR PIC 999.\n              01 LINE-NUM PIC 9(3) VALUE 1.\n              01 CHARAMT PIC 9(3) VALUE 1.\n              01 LARGESTCHARAMT PIC 9(3).\n              01 DAYNUM PIC 9(3) VALUE 1.\n              01 ABRESTART PIC 9(1).\n              01 CURABBR PIC X(50).\n              01 TMP1 PIC 9(3).\n              01 TMP2 PIC 9(3).\n              01 TINDEX PIC 9(3) VALUE 1.\n              01 ABBRLIST.\n                05 ABBRITEM PIC X(50) OCCURS 7 TIMES.\n              \n\n            PROCEDURE DIVISION.\n              OPEN INPUT DOW.\n                PERFORM UNTIL ENDO = 1\n                  READ DOW INTO DOW-LINE\n                    AT END MOVE 1 TO ENDO\n                    NOT AT END PERFORM\n                      \n                      IF DOW-LINE = \"\" THEN\n                        DISPLAY \"\"\n                      ELSE\n                        MOVE 0 TO ENDO2\n                        MOVE 0 TO CHARAMT\n\n                        PERFORM UNTIL ENDO2 > 0\n                          MOVE 1 TO ABPTR\n                          MOVE 1 TO DAYNUM\n                          MOVE 0 TO ABRESTART\n\n                          ADD 1 TO CHARAMT\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE SPACE TO ABBRITEM(TINDEX)\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n\n                          \n                          PERFORM 7 TIMES\n                            UNSTRING DOW-LINE DELIMITED BY SPACE\n                              INTO CURDAY\n                              WITH POINTER ABPTR\n                            END-UNSTRING\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURDAY\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURDAY\n                              TALLYING TMP2 FOR ALL SPACE\n                            SUBTRACT TMP2 FROM TMP1\n                            IF TMP1 > LARGESTCHARAMT THEN\n                              MOVE TMP1 TO LARGESTCHARAMT\n                            END-IF\n\n                            \n                            IF CURDAY = \"\" THEN\n                              MOVE 3 TO ENDO2\n                            END-IF\n\n                            MOVE CURDAY(1:CHARAMT) TO CURABBR\n\n                            \n                            MOVE 1 TO TINDEX\n                            PERFORM 7 TIMES\n                              IF ABBRITEM(TINDEX) = CURABBR THEN\n                                MOVE 1 TO ABRESTART\n                              END-IF\n                              ADD 1 TO TINDEX\n                            END-PERFORM\n\n                            MOVE CURABBR TO ABBRITEM(DAYNUM)\n\n                            ADD 1 TO DAYNUM\n\n                          END-PERFORM\n\n                          IF ABRESTART = 0 THEN\n                            MOVE 1 TO ENDO2\n                          END-IF\n\n                          \n                          IF CHARAMT > LARGESTCHARAMT THEN\n                            MOVE 2 TO ENDO2\n                          END-IF\n\n                        END-PERFORM\n\n                        DISPLAY \"Line \" LINE-NUM \": \" WITH NO ADVANCING\n\n                        IF ENDO2 = 3 THEN\n                          DISPLAY \"Error: not enough \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE IF ENDO2 = 2 THEN\n                          DISPLAY \"Error: identical \" WITH NO ADVANCING\n                          DISPLAY \"days\"\n                        ELSE\n                          DISPLAY CHARAMT \": \" WITH NO ADVANCING\n\n                          \n                          MOVE 1 TO TINDEX\n                          PERFORM 7 TIMES\n                            MOVE ABBRITEM(TINDEX) TO CURABBR\n\n                            MOVE 0 TO TMP1\n                            MOVE 0 TO TMP2\n                            INSPECT CURABBR\n                              TALLYING TMP1 FOR ALL CHARACTERS\n                            INSPECT CURABBR\n                              TALLYING TMP2 FOR TRAILING SPACES\n                            SUBTRACT TMP2 FROM TMP1\n\n                            DISPLAY CURABBR(1:TMP1) WITH NO ADVANCING\n                            DISPLAY \".\" WITH NO ADVANCING\n\n                            IF TINDEX < 7 THEN\n                              DISPLAY SPACE WITH NO ADVANCING\n                            ELSE\n                              DISPLAY X\"0a\" WITH NO ADVANCING \n                            END-IF\n\n                            ADD 1 TO TINDEX\n                          END-PERFORM\n                        END-IF\n\n                      END-IF\n\n                    END-PERFORM\n                  END-READ\n\n                  ADD 1 TO LINE-NUM\n                END-PERFORM.\n              CLOSE DOW.\n              STOP RUN.\n", "target": "def shortest_abbreviation_length(line, list_size):\n    words = line.split()\n    word_count = len(words)\n    \n    if word_count != list_size:\n        raise ValueError(f'Not enough entries, expected {list_size} found {word_count}')\n\n    \n    abbreviation_length = 1\n    abbreviations = set()\n    while(True):\n        abbreviations = {word[:abbreviation_length] for word in words}\n        if len(abbreviations) == list_size:\n            return abbreviation_length\n        abbreviation_length += 1\n        abbreviations.clear()\n\ndef automatic_abbreviations(filename, words_per_line):\n    with open(filename) as file:\n        for line in file:\n            line = line.rstrip()\n            if len(line) > 0:\n                length = shortest_abbreviation_length(line, words_per_line)\n                print(f'{length:2} {line}')\n            else:\n                print()\n\nautomatic_abbreviations('daysOfWeek.txt', 7)\n"}
{"id": 17294, "name": "Cantor set", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17295, "name": "Cantor set", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "using System;\n\nnamespace CantorSet {\n    class Program {\n        const int WIDTH = 81;\n        const int HEIGHT = 5;\n        private static char[,] lines = new char[HEIGHT, WIDTH];\n\n        static Program() {\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    lines[i, j] = '*';\n                }\n            }\n        }\n\n        private static void Cantor(int start, int len, int index) {\n            int seg = len / 3;\n            if (seg == 0) return;\n            for (int i = index; i < HEIGHT; i++) {\n                for (int j = start + seg; j < start + seg * 2; j++) {\n                    lines[i, j] = ' ';\n                }\n            }\n            Cantor(start, seg, index + 1);\n            Cantor(start + seg * 2, seg, index + 1);\n        }\n\n        static void Main(string[] args) {\n            Cantor(0, WIDTH, 1);\n            for (int i = 0; i < HEIGHT; i++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    Console.Write(lines[i,j]);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 17298, "name": "Cantor set", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17299, "name": "Cantor set", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "public class App {\n    private static final int WIDTH = 81;\n    private static final int HEIGHT = 5;\n\n    private static char[][] lines;\n    static {\n        lines = new char[HEIGHT][WIDTH];\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                lines[i][j] = '*';\n            }\n        }\n    }\n\n    private static void cantor(int start, int len, int index) {\n        int seg = len / 3;\n        if (seg == 0) return;\n        for (int i = index; i < HEIGHT; i++) {\n            for (int j = start + seg; j < start + seg * 2; j++) {\n                lines[i][j] = ' ';\n            }\n        }\n        cantor(start, seg, index + 1);\n        cantor(start + seg * 2, seg, index + 1);\n    }\n\n    public static void main(String[] args) {\n        cantor(0, WIDTH, 1);\n        for (int i = 0; i < HEIGHT; i++) {\n            for (int j = 0; j < WIDTH; j++) {\n                System.out.print(lines[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 17300, "name": "Cantor set", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 17301, "name": "Cantor set", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. CANTOR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 SETTINGS.\n          03 NUM-LINES     PIC 9 VALUE 5.\n          03 FILL-CHAR     PIC X VALUE '#'.\n       01 VARIABLES.\n          03 CUR-LINE.\n             05 CHAR       PIC X OCCURS 81 TIMES.\n          03 WIDTH         PIC 99.\n          03 CUR-SIZE      PIC 99.\n          03 POS           PIC 99.\n          03 MAXPOS        PIC 99.\n          03 NEXTPOS       PIC 99.\n          03 I             PIC 99.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           COMPUTE WIDTH = 3 ** (NUM-LINES - 1).\n           PERFORM INIT.\n           MOVE WIDTH TO CUR-SIZE.\n           DISPLAY CUR-LINE.\n           PERFORM DO-LINE UNTIL CUR-SIZE IS EQUAL TO 1.\n           STOP RUN.\n           \n       INIT.\n           PERFORM INIT-CHAR VARYING I FROM 1 BY 1\n                UNTIL I IS GREATER THAN WIDTH.\n       \n       INIT-CHAR.\n           MOVE FILL-CHAR TO CHAR(I).\n           \n       DO-LINE.\n           DIVIDE 3 INTO CUR-SIZE.\n           MOVE 1 TO POS.\n           SUBTRACT CUR-SIZE FROM WIDTH GIVING MAXPOS.\n           PERFORM BLANK-REGIONS UNTIL POS IS GREATER THAN MAXPOS.\n           DISPLAY CUR-LINE.\n       \n       BLANK-REGIONS.\n           ADD CUR-SIZE TO POS.\n           PERFORM BLANK-CHAR CUR-SIZE TIMES.\n           \n       BLANK-CHAR.\n           MOVE SPACE TO CHAR(POS).\n           ADD 1 TO POS.\n", "target": "WIDTH = 81\nHEIGHT = 5\n\nlines=[]\ndef cantor(start, len, index):\n    seg = len / 3\n    if seg == 0:\n        return None\n    for it in xrange(HEIGHT-index):\n        i = index + it\n        for jt in xrange(seg):\n            j = start + seg + jt\n            pos = i * WIDTH + j\n            lines[pos] = ' '\n    cantor(start,           seg, index + 1)\n    cantor(start + seg * 2, seg, index + 1)\n    return None\n\nlines = ['*'] * (WIDTH*HEIGHT)\ncantor(0, WIDTH, 1)\n\nfor i in xrange(HEIGHT):\n    beg = WIDTH * i\n    print ''.join(lines[beg : beg+WIDTH])\n"}
{"id": 18097, "name": "Munchausen numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18098, "name": "Munchausen numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18101, "name": "Munchausen numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18102, "name": "Munchausen numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18103, "name": "Munchausen numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18104, "name": "Munchausen numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  MUNCHAUSEN.\n \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 CANDIDATE   PIC 9(4).\n          03 DIGITS      PIC 9 OCCURS 4 TIMES, REDEFINES CANDIDATE.\n          03 DIGIT       PIC 9.\n          03 POWER-SUM   PIC 9(5).\n\n       01 OUTPUT-LINE.\n          03 OUT-NUM     PIC ZZZ9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM MUNCHAUSEN-TEST VARYING CANDIDATE FROM 1 BY 1\n               UNTIL CANDIDATE IS GREATER THAN 6000.\n           STOP RUN.\n\n       MUNCHAUSEN-TEST.\n           MOVE ZERO TO POWER-SUM.\n           MOVE 1 TO DIGIT.\n           INSPECT CANDIDATE TALLYING DIGIT FOR LEADING '0'.\n           PERFORM ADD-DIGIT-POWER VARYING DIGIT FROM DIGIT BY 1\n               UNTIL DIGIT IS GREATER THAN 4.\n           IF POWER-SUM IS EQUAL TO CANDIDATE,\n               MOVE CANDIDATE TO OUT-NUM,\n               DISPLAY OUTPUT-LINE.\n        \n       ADD-DIGIT-POWER.\n           COMPUTE POWER-SUM = \n                     POWER-SUM + DIGITS(DIGIT) ** DIGITS(DIGIT)\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18705, "name": "Arithmetic_Complex", "source": "Translate COBOL to C#:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18707, "name": "Arithmetic_Complex", "source": "Translate COBOL to Java:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18708, "name": "Arithmetic_Complex", "source": "Translate COBOL to Python:       $SET SOURCEFORMAT \"FREE\"\n$SET ILUSING \"System\"\n$SET ILUSING \"System.Numerics\"\nclass-id Prog.\nmethod-id. Main static.\nprocedure division.\n    declare num as type Complex = type Complex::ImaginaryOne()\n    declare results as type Complex occurs any\n    set content of results to ((num + num), (num * num), (- num), (1 / num), type Complex::Conjugate(num))\n    perform varying result as type Complex thru results\n        display result\n    end-perform\nend method.\nend class.\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 19446, "name": "Handle a signal", "source": "Translate COBOL to C#:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19448, "name": "Handle a signal", "source": "Translate COBOL to Java:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19449, "name": "Handle a signal", "source": "Translate COBOL to Python:        identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 20689, "name": "Call a function in a shared library", "source": "Translate COBOL to C#:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "using System.Runtime.InteropServices;\n\nclass Program {\n    [DllImport(\"fakelib.dll\")]\n    public static extern int fakefunction(int args);\n\n    static void Main(string[] args) {\n        int r = fakefunction(10);\n    }\n}\n"}
{"id": 20690, "name": "Call a function in a shared library", "source": "Translate COBOL to Java:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "\n\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class TrySort {\n    static boolean useC;\n    static {\n\ttry {\n\t    System.loadLibrary(\"TrySort\");\n\t    useC = true;\n\t} catch(UnsatisfiedLinkError e) {\n\t    useC = false;\n\t}\n    }\n    \n    static native void sortInC(int[] ary);\n    \n    static class IntList extends java.util.AbstractList<Integer> {\n\tint[] ary;\n\tIntList(int[] ary) { this.ary = ary; }\n\tpublic Integer get(int i) { return ary[i]; }\n\tpublic Integer set(int i, Integer j) {\n\t    Integer o = ary[i]; ary[i] = j; return o;\n\t}\n\tpublic int size() { return ary.length; }\n    }\n\n    static class ReverseAbsCmp\n\timplements java.util.Comparator<Integer>\n    {\n\tpublic int compare(Integer pa, Integer pb) {\n\t    \n\t    int a = pa > 0 ? -pa : pa;\n\t    int b = pb > 0 ? -pb : pb;\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t}\n    }\n    \n    static void sortInJava(int[] ary) {\n\tCollections.sort(new IntList(ary), new ReverseAbsCmp());\n    }\n\n    public static void main(String[] args) {\n\t\n\tint[] ary = new int[1000000];\n\tRandom rng = new Random();\n\tfor (int i = 0; i < ary.length; i++)\n\t    ary[i] = rng.nextInt();\n\n\t\n\tif (useC) {\n\t    System.out.print(\"Sorting in C...  \");\n\t    sortInC(ary);\n\t} else {\n\t    System.out.print\n\t\t(\"Missing library for C!  Sorting in Java...  \");\n\t    sortInJava(ary);\n\t}\n\n\tfor (int i = 0; i < ary.length - 1; i++) {\n\t    int a = ary[i];\n\t    int b = ary[i + 1];\n\t    if ((a > 0 ? -a : a) > (b > 0 ? -b : b)) {\n\t\tSystem.out.println(\"*BUG IN SORT*\");\n\t\tSystem.exit(1);\n\t    }\n\t}\n\tSystem.out.println(\"ok\");\n    }\n}\n"}
{"id": 20691, "name": "Call a function in a shared library", "source": "Translate COBOL to Python:        identification division.\n       program-id. callsym.\n\n       data division.\n       working-storage section.\n       01 handle usage pointer.\n       01 addr   usage program-pointer.\n\n       procedure division.\n       call \"dlopen\" using\n           by reference null\n           by value 1\n           returning handle\n           on exception\n               display function exception-statement upon syserr\n               goback\n       end-call\n       if handle equal null then\n           display function module-id \": error getting dlopen handle\"\n             upon syserr\n           goback\n       end-if\n\n       call \"dlsym\" using\n           by value handle\n           by content z\"perror\"\n           returning addr\n       end-call\n       if addr equal null then\n           display function module-id \": error getting perror symbol\"\n              upon syserr\n       else\n           call addr returning omitted\n       end-if\n\n       goback.\n       end program callsym.\n", "target": "import ctypes\n  \nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\nprint user32_dll.GetDoubleClickTime()\n"}
{"id": 21757, "name": "Formatted numeric output", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "class Program\n    {\n\n\n        static void Main(string[] args)\n        {\n\n            float myNumbers = 7.125F;\n            \n            string strnumber = Convert.ToString(myNumbers);\n                       \n            Console.WriteLine(strnumber.PadLeft(9, '0'));\n           \n            Console.ReadLine();\n        }\n        \n\n             \n       \n    }\n"}
{"id": 21759, "name": "Formatted numeric output", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "public class Printing{\n\tpublic static void main(String[] args){\n\t\tdouble value = 7.125;\n\t\tSystem.out.printf(\"%09.3f\",value); \n\t\tSystem.out.println(String.format(\"%09.3f\",value));\n\t}\n}\n"}
{"id": 21760, "name": "Formatted numeric output", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. NUMERIC-OUTPUT-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-EXAMPLE.\n    05 X            PIC  9(5)V9(3).\nPROCEDURE DIVISION.\n    MOVE     7.125  TO   X.\n    DISPLAY  X      UPON CONSOLE.\n    STOP RUN.\n", "target": "from math import pi, exp\nr = exp(pi)-pi\nprint r\nprint \"e=%e f=%f g=%g G=%G s=%s r=%r!\"%(r,r,r,r,r,r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(-r,-r,-r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(r,r,r)\nprint \"e=%-9.4e f=%-9.4f g=%-9.4g!\"%(r,r,r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(-r,-r,-r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(r,r,r)\nprint \"e=%-09.4e f=%-09.4f g=%-09.4g!\"%(r,r,r)\n"}
{"id": 23620, "name": "String case", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23622, "name": "String case", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23623, "name": "String case", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           \n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           \n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 24460, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24461, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24464, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24465, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24466, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24467, "name": "Arithmetic-geometric mean", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. ARITHMETIC-GEOMETRIC-MEAN-PROG.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  AGM-VARS.\n    05 A       PIC 9V9(16).\n    05 A-ZERO  PIC 9V9(16).\n    05 G       PIC 9V9(16).\n    05 DIFF    PIC 9V9(16) VALUE 1.\n* Initialize DIFF with a non-zero value, otherwise AGM-PARAGRAPH\n* is never performed at all.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    MOVE    1 TO A.\n    COMPUTE G = 1 / FUNCTION SQRT(2).\n* The program will run with the test values. If you would rather\n* calculate the AGM of numbers input at the console, comment out\n* TEST-PARAGRAPH and un-comment-out INPUT-A-AND-G-PARAGRAPH.\n* INPUT-A-AND-G-PARAGRAPH.\n*     DISPLAY 'Enter two numbers.'\n*     ACCEPT  A.\n*     ACCEPT  G.\nCONTROL-PARAGRAPH.\n    PERFORM AGM-PARAGRAPH UNTIL DIFF IS LESS THAN 0.000000000000001.\n    DISPLAY A.\n    STOP RUN.\nAGM-PARAGRAPH.\n    MOVE     A TO A-ZERO.\n    COMPUTE  A = (A-ZERO + G) / 2.\n    MULTIPLY A-ZERO BY G GIVING G.\n    COMPUTE  G = FUNCTION SQRT(G).\n    SUBTRACT A FROM G GIVING DIFF.\n    COMPUTE  DIFF = FUNCTION ABS(DIFF).\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 25622, "name": "Day of the week", "source": "Translate COBOL to C#:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25624, "name": "Day of the week", "source": "Translate COBOL to Java:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25625, "name": "Day of the week", "source": "Translate COBOL to Python:        program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. \n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  \n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26702, "name": "ISBN13 check digit", "source": "Translate COBOL to C#:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26703, "name": "ISBN13 check digit", "source": "Translate COBOL to C#:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26706, "name": "ISBN13 check digit", "source": "Translate COBOL to Java:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26707, "name": "ISBN13 check digit", "source": "Translate COBOL to Java:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26708, "name": "ISBN13 check digit", "source": "Translate COBOL to Python:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26709, "name": "ISBN13 check digit", "source": "Translate COBOL to Python:       ******************************************************************\n      * Author: Jay Moseley\n      * Date: November 10, 2019\n      * Purpose: Testing various subprograms/ functions.\n      * Tectonics: cobc -xj testSubs.cbl\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       PROGRAM-ID. testSubs.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC\n           FUNCTION validISBN13.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  IX                          PIC S9(4) COMP.\n       01  TEST-ISBNS.\n           02  FILLER                  PIC X(14) VALUE '978-1734314502'.\n           02  FILLER                  PIC X(14) VALUE '978-1734314509'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399081'.\n           02  FILLER                  PIC X(14) VALUE '978-1788399083'.\n       01  TEST-ISBN                   REDEFINES TEST-ISBNS\n                                       OCCURS 4 TIMES\n                                       PIC X(14).\n\n       PROCEDURE DIVISION.\n\n       MAIN-PROCEDURE.\n\n           PERFORM \n             VARYING IX \n             FROM 1\n             BY 1\n             UNTIL IX > 4\n\n             DISPLAY TEST-ISBN (IX) '   ' WITH NO ADVANCING\n             END-DISPLAY\n             IF validISBN13(TEST-ISBN (IX)) = -1\n               DISPLAY '(bad)'\n             ELSE\n               DISPLAY '(good)'\n             END-IF\n\n           END-PERFORM.\n\n           GOBACK.\n\n       END PROGRAM testSubs.\n\n      ******************************************************************\n      * Author: Jay Moseley\n      * Date: May 19, 2016\n      * Purpose: validate ISBN-13 (International Standard\n      *          Book Number).\n      ******************************************************************\n       IDENTIFICATION DIVISION.\n\n       FUNCTION-ID. validISBN13.\n       ENVIRONMENT DIVISION.\n\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION ALL INTRINSIC.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       WORKING-STORAGE SECTION.\n\n       01  PASSED-SIZE                 PIC S9(6) COMP-5.\n       01  IX                          PIC S9(4) COMP.\n\n       01  WORK-FIELDS.\n           02  WF-DIGIT                PIC X.\n           02  WF-COUNT                PIC 9(2).\n               88  WEIGHT-1  VALUE 1, 3, 5, 7, 9, 11, 13.\n               88  WEIGHT-3  VALUE 2, 4, 6, 8, 10, 12.\n           02  WF-SUM                  PIC S9(8) COMP.\n\n       LINKAGE SECTION.\n\n       01  PASSED-ISBN                 PIC X ANY LENGTH.\n       01  RETURN-VALUE                PIC S9.\n\n       PROCEDURE DIVISION USING PASSED-ISBN\n                          RETURNING RETURN-VALUE.\n\n           CALL 'C$PARAMSIZE'\n             USING 1\n             GIVING PASSED-SIZE\n           END-CALL.\n       \n       COMPUTE-CKDIGIT.\n\n           INITIALIZE WORK-FIELDS.\n           PERFORM \n             VARYING IX \n             FROM 1 \n             BY 1\n             UNTIL IX GREATER THAN PASSED-SIZE\n\n               MOVE PASSED-ISBN (IX:1) TO WF-DIGIT\n               IF WF-DIGIT IS NUMERIC\n                 ADD 1 TO WF-COUNT\n                 IF WEIGHT-1\n                   ADD NUMVAL(WF-DIGIT) TO WF-SUM\n                 ELSE\n                   COMPUTE WF-SUM = WF-SUM + \n                     (NUMVAL(WF-DIGIT) * 3)\n                   END-COMPUTE\n                 END-IF\n               END-IF\n\n           END-PERFORM.\n\n           IF MOD(WF-SUM, 10) = 0\n             MOVE +0 TO RETURN-VALUE\n           ELSE\n             MOVE -1 TO RETURN-VALUE\n           END-IF.\n\n           GOBACK.\n      * - - - - - - - - - - - - - - - - - - - - - - PROGRAM EXIT POINT\n\n       END FUNCTION validISBN13.\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26997, "name": "Days between dates", "source": "Translate COBOL to C#: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 26998, "name": "Days between dates", "source": "Translate COBOL to C#: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27001, "name": "Days between dates", "source": "Translate COBOL to Java: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27002, "name": "Days between dates", "source": "Translate COBOL to Java: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27003, "name": "Days between dates", "source": "Translate COBOL to Python: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27004, "name": "Days between dates", "source": "Translate COBOL to Python: COBOL \n      \n\n       identification division.\n       program-id. days-between.\n\n       procedure division.\n       compute tally = \n         function integer-of-formatted-date('YYYY-MM-DD', '2019-11-24')\n         -\n         function integer-of-formatted-date('YYYY-MM-DD', '2000-01-01')\n       display tally\n\n       compute tally = \n         function integer-of-formatted-date('YYYYMMDD', '20191124')\n         -\n         function integer-of-formatted-date('YYYYMMDD', '20000101')\n       display tally\n\n       goback.\n       end program days-between.\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27269, "name": "Look-and-say sequence", "source": "Translate COBOL to C#:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27271, "name": "Look-and-say sequence", "source": "Translate COBOL to Java:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27272, "name": "Look-and-say sequence", "source": "Translate COBOL to Python:         IDENTIFICATION DIVISION.\n        PROGRAM-ID. LOOK-AND-SAY-SEQ.\n        \n        DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        01 SEQUENCES.\n           02 CUR-SEQ       PIC X(80) VALUE \"1\".\n           02 CUR-CHARS     REDEFINES CUR-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY CI.\n           02 CUR-LENGTH    PIC 99 COMP VALUE 1.\n           02 NEXT-SEQ      PIC X(80).\n           02 NEXT-CHARS    REDEFINES NEXT-SEQ \n                            PIC X OCCURS 80 TIMES INDEXED BY NI.\n        01 ALG-STATE.\n           02 STEP-AMOUNT   PIC 99 VALUE 14.\n           02 ITEM-COUNT    PIC 9.\n           \n        PROCEDURE DIVISION.\n        LOOK-AND-SAY.\n            DISPLAY CUR-SEQ.\n            SET CI TO 1.\n            SET NI TO 1.\n        MAKE-NEXT-ENTRY.\n            MOVE 0 TO ITEM-COUNT.\n            IF CI IS GREATER THAN CUR-LENGTH GO TO STEP-DONE.\n        TALLY-ITEM.\n            ADD 1 TO ITEM-COUNT.\n            SET CI UP BY 1.\n            IF CI IS NOT GREATER THAN CUR-LENGTH\n               AND CUR-CHARS(CI) IS EQUAL TO CUR-CHARS(CI - 1) \n                GO TO TALLY-ITEM.\n        INSERT-ENTRY.\n            MOVE ITEM-COUNT TO NEXT-CHARS(NI).\n            MOVE CUR-CHARS(CI - 1) TO NEXT-CHARS(NI + 1).\n            SET NI UP BY 2.\n            GO TO MAKE-NEXT-ENTRY.\n        STEP-DONE.\n            MOVE NEXT-SEQ TO CUR-SEQ.\n            SET NI DOWN BY 1.\n            SET CUR-LENGTH TO NI.\n            SUBTRACT 1 FROM STEP-AMOUNT.\n            IF STEP-AMOUNT IS NOT EQUAL TO ZERO GO TO LOOK-AND-SAY.\n            STOP RUN.\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 28366, "name": "Caesar cipher", "source": "Translate COBOL to C#:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28368, "name": "Caesar cipher", "source": "Translate COBOL to Java:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28369, "name": "Caesar cipher", "source": "Translate COBOL to Python:        identification division.\n       program-id. caesar.\n       data division.\n       1 msg pic x(50)\n           value \"The quick brown fox jumped over the lazy dog.\".\n       1 offset binary pic 9(4) value 7.\n       1 from-chars pic x(52).\n       1 to-chars pic x(52).\n       1 tabl.\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n        2 pic x(26) value \"abcdefghijklmnopqrstuvwxyz\".\n        2 pic x(26) value \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       procedure division.\n       begin.\n           display msg\n           perform encrypt\n           display msg\n           perform decrypt\n           display msg\n           stop run\n           .\n\n       encrypt.\n           move tabl (1:52) to from-chars\n           move tabl (1 + offset:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n\n       decrypt.\n           move tabl (1 + offset:52) to from-chars\n           move tabl (1:52) to to-chars\n           inspect msg converting from-chars\n               to to-chars\n           .\n       end program caesar.\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28935, "name": "FizzBuzz", "source": "Translate COBOL to C#:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28937, "name": "FizzBuzz", "source": "Translate COBOL to Java:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28938, "name": "FizzBuzz", "source": "Translate COBOL to Python:       * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29173, "name": "Monty Hall problem", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29175, "name": "Monty Hall problem", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29176, "name": "Monty Hall problem", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. monty-hall.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Num-Games               VALUE 1000000.\n\n       \n       \n       01  One                     PIC 9 VALUE 1.\n       01  Three                   PIC 9 VALUE 3.\n\n       01  doors-area.\n           03  doors               PIC 9 OCCURS 3 TIMES.\n\n       01  choice                  PIC 9.\n       01  shown                   PIC 9.\n       01  winner                  PIC 9.\n\n       01  switch-wins             PIC 9(7).\n       01  stay-wins               PIC 9(7).\n\n       01  stay-wins-percent       PIC Z9.99.\n       01  switch-wins-percent     PIC Z9.99.\n\n       PROCEDURE DIVISION.\n           PERFORM Num-Games TIMES\n               MOVE 0 TO doors (winner)\n\n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE winner\n               MOVE 1 TO doors (winner)\n               \n               CALL \"get-rand-int\" USING CONTENT One, Three,\n                   REFERENCE choice\n    \n               PERFORM WITH TEST AFTER\n                       UNTIL NOT(shown = winner OR choice)\n                   CALL \"get-rand-int\" USING CONTENT One, Three,\n                       REFERENCE shown\n               END-PERFORM\n    \n               ADD doors (choice) TO stay-wins\n               ADD doors (6 - choice - shown) TO switch-wins\n           END-PERFORM\n    \n           COMPUTE stay-wins-percent ROUNDED =\n               stay-wins / Num-Games * 100\n           COMPUTE switch-wins-percent ROUNDED =\n               switch-wins / Num-Games * 100\n\n           DISPLAY \"Staying wins   \" stay-wins \" times (\"\n               stay-wins-percent \"%).\"\n           DISPLAY \"Switching wins \" switch-wins \" times (\"\n               switch-wins-percent \"%).\"\n           .\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. get-rand-int.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  call-flag               PIC X VALUE \"Y\".\n           88  first-call          VALUE \"Y\", FALSE \"N\".\n\n       01  num-range               PIC 9.\n\n       LINKAGE SECTION.\n       01  min-num                 PIC 9.\n       01  max-num                 PIC 9.\n\n       01  ret                     PIC 9.\n\n       PROCEDURE DIVISION USING min-num, max-num, ret.\n           \n           IF first-call\n               MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:8))\n                   TO num-range\n               SET first-call TO FALSE\n           END-IF\n\n           COMPUTE num-range = max-num - min-num + 1\n           COMPUTE ret =\n              FUNCTION MOD(FUNCTION RANDOM * 100000, num-range)\n              + min-num\n           .\n       END PROGRAM get-rand-int.\n\n       END PROGRAM monty-hall.\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29588, "name": "User input_Text", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29590, "name": "User input_Text", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29591, "name": "User input_Text", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Get-Input.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Input-String PIC X(30).\n       01  Input-Int    PIC 9(5).\n\n       PROCEDURE DIVISION.\n       DISPLAY \"Enter a string:\"\n       ACCEPT Input-String\n\n       DISPLAY \"Enter a number:\"\n       ACCEPT Input-Int\n\n       GOBACK\n       .\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 29994, "name": "Show the epoch", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 29995, "name": "Show the epoch", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new DateTime());\n    }\n}\n"}
{"id": 29998, "name": "Show the epoch", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 29999, "name": "Show the epoch", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": "import java.text.DateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\n\npublic class DateTest{\n    public static void main(String[] args) {\n        Date date = new Date(0);\n        DateFormat format = DateFormat.getDateTimeInstance();\n        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n        System.out.println(format.format(date));\n    }\n}\n"}
{"id": 30000, "name": "Show the epoch", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30001, "name": "Show the epoch", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. epoch.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  epoch-date.\n           03  year                PIC 9(4).\n           03  month               PIC 99.\n           03  dday                PIC 99.\n\n       PROCEDURE DIVISION.\n           MOVE FUNCTION DATE-OF-INTEGER(1) TO epoch-date\n\n           DISPLAY year \"-\" month \"-\" dday\n\n           GOBACK\n           .\n", "target": ">>> import time\n>>> time.asctime(time.gmtime(0))\n'Thu Jan  1 00:00:00 1970'\n>>>\n"}
{"id": 30317, "name": "File size", "source": "Translate COBOL to C#:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(new FileInfo(\"/input.txt\").Length);\n        Console.WriteLine(new FileInfo(\"input.txt\").Length);\n    }\n}\n"}
{"id": 30319, "name": "File size", "source": "Translate COBOL to Java:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "import java.io.File;\n\npublic class FileSize\n{\n    public static void main ( String[] args )\n    {\n        System.out.println(\"input.txt \u00a0: \" + new File(\"input.txt\").length() + \" bytes\");\n        System.out.println(\"/input.txt\u00a0: \" + new File(\"/input.txt\").length() + \" bytes\");\n    }\n}\n"}
{"id": 30320, "name": "File size", "source": "Translate COBOL to Python:        identification division.\n       program-id. FileInfo.\n\n       data division.\n       working-storage section.\n       01  file-name              pic x(256).\n       01  file-size-edited       pic zzz,zzz,zzz.\n       01  file-details.\n           05 file-size           pic x(8) comp-x.\n           05 file-date.\n              10 file-day         pic x comp-x.\n              10 file-month       pic x comp-x.\n              10 file-year        pic xx comp-x.\n           05 file-time.\n              10 file-hour        pic x comp-x.\n              10 file-minute      pic x comp-x.\n              10 file-second      pic x comp-x.\n              10 file-hundredths  pic x comp-x.\n\n       procedure division.\n       main.\n           move \"input.txt\" to file-name\n           perform file-info\n           \n           move \"\\input.txt\" to file-name\n           perform file-info\n\n           stop run\n           .\n\n       file-info.\n           call \"CBL_CHECK_FILE_EXIST\" \n              using file-name, file-details\n              returning return-code\n           if return-code = 0\n              move file-size to file-size-edited\n              display function trim(file-name) \" \"\n                      function trim(file-size-edited) \" Bytes\"\n           else\n              display function trim(file-name) \" not found!\"\n           end-if\n           .\n", "target": "import os\n\nsize = os.path.getsize('input.txt')\nsize = os.path.getsize('/input.txt')\n"}
{"id": 31205, "name": "Sort numbers lexicographically", "source": "Translate COBOL to C#:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    public static void Main() {\n        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($\"{n}: {string.Join(\", \", LexOrder(n))}\");\n    }\n\n    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());\n}\n"}
{"id": 31207, "name": "Sort numbers lexicographically", "source": "Translate COBOL to Java:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "import java.util.List;\nimport java.util.stream.*;\n\npublic class LexicographicalNumbers {\n\n    static List<Integer> lexOrder(int n) {\n        int first = 1, last = n;\n        if (n < 1) {\n            first = n;\n            last = 1;\n        }\n        return IntStream.rangeClosed(first, last)\n                        .mapToObj(Integer::toString)\n                        .sorted()\n                        .map(Integer::valueOf)\n                        .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"In lexicographical order:\\n\");\n        int[] ints = {0, 5, 13, 21, -22};\n        for (int n : ints) {\n           System.out.printf(\"%3d: %s\\n\", n, lexOrder(n));\n        }\n    }\n}\n"}
{"id": 31208, "name": "Sort numbers lexicographically", "source": "Translate COBOL to Python:        identification division.\n       program-id. LexicographicalNumbers.\n\n       data division.\n       working-storage section.\n       78  MAX-NUMBERS            value 21.\n       77  i                      pic 9(2).\n       77  edited-number          pic z(2).\n       \n       01  lex-table.\n           05 table-itms occurs MAX-NUMBERS.\n              10 number-lex       pic x(2).\n\n       procedure division.\n       main.\n      \n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              move i to edited-number\n              move edited-number to number-lex(i)\n              call \"C$JUSTIFY\" using number-lex(i), \"Left\"\n           end-perform\n\n      \n           sort table-itms ascending number-lex\n\n      \n           display \"[\" no advancing\n           perform varying i from 1 by 1 until i > MAX-NUMBERS\n              display function trim(number-lex(i)) no advancing\n              if i < MAX-NUMBERS\n                 display \", \" no advancing\n              end-if\n           end-perform\n           display \"]\"\n           stop run\n           .\n", "target": "n=13\nprint(sorted(range(1,n+1), key=str))\n"}
{"id": 32036, "name": "Guess the number_With feedback", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 32038, "name": "Guess the number_With feedback", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 32039, "name": "Guess the number_With feedback", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Guess-With-Feedback.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  Seed       PIC 9(8).\n       01  Random-Num PIC 99.\n       01  Guess      PIC 99.\n \n       PROCEDURE DIVISION.\n           ACCEPT Seed FROM TIME\n           COMPUTE Random-Num =\n               FUNCTION REM(FUNCTION RANDOM(Seed) * 1000, 10) + 1\n\n           DISPLAY \"Guess a number between 1 and 10:\"\n \n           PERFORM FOREVER\n               ACCEPT Guess\n \n               IF Guess > Random-Num\n                   DISPLAY \"Your guess was too high.\"\n               ELSE IF Guess < Random-Num\n                   DISPLAY \"Your guess was too low.\"\n               ELSE\n                   DISPLAY \"Well guessed!\"\n                   EXIT PERFORM\n           END-PERFORM\n \n           GOBACK\n           .\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32279, "name": "Compound data type", "source": "Translate COBOL to C#: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32281, "name": "Compound data type", "source": "Translate COBOL to Java: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32282, "name": "Compound data type", "source": "Translate COBOL to Python: 01 Point.\n   05 x            pic 9(3).\n   05 y            pic 9(3).\n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32545, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to C#: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32547, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to Java: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32548, "name": "Sorting algorithms_Bogosort", "source": "Translate COBOL to Python: identification division.\nprogram-id. bogo-sort-program.\ndata division.\nworking-storage section.\n01  array-to-sort.\n    05 item-table.\n        10 item          pic 999\n            occurs 10 times.\n01  randomization.\n    05 random-seed       pic 9(8).\n    05 random-index      pic 9.\n01  flags-counters-etc.\n    05 array-index       pic 99.\n    05 adjusted-index    pic 99.\n    05 temporary-storage pic 999.\n    05 shuffles          pic 9(8)\n        value zero.\n    05 sorted            pic 9.\n01  numbers-without-leading-zeros.\n    05 item-no-zeros     pic z(4).\n    05 shuffles-no-zeros pic z(8).\nprocedure division.\ncontrol-paragraph.\n    accept random-seed from time.\n    move function random(random-seed) to item(1).\n    perform random-item-paragraph varying array-index from 2 by 1\n    until array-index is greater than 10.\n    display 'BEFORE SORT:' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    perform shuffle-paragraph through is-it-sorted-paragraph\n    until sorted is equal to 1.\n    display 'AFTER SORT: ' with no advancing.\n    perform show-array-paragraph varying array-index from 1 by 1\n    until array-index is greater than 10.\n    display ''.\n    move shuffles to shuffles-no-zeros.\n    display shuffles-no-zeros ' SHUFFLES PERFORMED.'\n    stop run.\nrandom-item-paragraph.\n    move function random to item(array-index).\nshow-array-paragraph.\n    move item(array-index) to item-no-zeros.\n    display item-no-zeros with no advancing.\nshuffle-paragraph.\n    perform shuffle-items-paragraph,\n    varying array-index from 1 by 1\n    until array-index is greater than 10.\n    add 1 to shuffles.\nis-it-sorted-paragraph.\n    move 1 to sorted.\n    perform item-in-order-paragraph varying array-index from 1 by 1,\n    until sorted is equal to zero\n    or array-index is equal to 10.\nshuffle-items-paragraph.\n    move function random to random-index.\n    add 1 to random-index giving adjusted-index.\n    move item(array-index) to temporary-storage.\n    move item(adjusted-index) to item(array-index).\n    move temporary-storage to item(adjusted-index).\nitem-in-order-paragraph.\n    add 1 to array-index giving adjusted-index.\n    if item(array-index) is greater than item(adjusted-index)\n    then move zero to sorted.\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32815, "name": "Cumulative standard deviation", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32817, "name": "Cumulative standard deviation", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32818, "name": "Cumulative standard deviation", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. run-stddev.\nenvironment division.\ninput-output section.\nfile-control.\n  select input-file assign to \"input.txt\"\n    organization is line sequential.\ndata division.\nfile section.\nfd input-file.\n  01  inp-record.\n    03  inp-fld  pic 9(03).\nworking-storage section.\n01  filler pic 9(01)   value 0.\n  88 no-more-input     value 1.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01 ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION.\n  move 0 to ws-tb-size \n  open  input input-file\n    read input-file\n    at end\n      set no-more-input to true\n    end-read\n    perform\n      test after\n    until no-more-input\n      add 1 to ws-tb-size\n      move inp-fld to ws-tb-fld (ws-tb-size)\n      call 'stddev' using  by reference ws-tb-data \n         ws-stddev\n      display  'inp=' inp-fld ' stddev=' ws-stddev\n      read input-file at end set no-more-input to true end-read\n    end-perform\n  close input-file\n  stop run.\nend program run-stddev.\nIDENTIFICATION DIVISION.\nPROGRAM-ID. stddev.\ndata division.\nworking-storage section.\n01 ws-tbx             pic s9(03) comp.\n01 ws-tb-work.\n  03  ws-sum          pic s9(05)v9999 comp-3 value +0.\n  03  ws-sumsq        pic s9(05)v9999 comp-3 value +0.\n  03  ws-avg          pic s9(05)v9999 comp-3 value +0.\nlinkage section.\n01  ws-tb-data.\n  03  ws-tb-size         pic 9(03).\n  03  ws-tb-table.\n    05  ws-tb-fld     pic s9(05)v9999 comp-3 occurs 0 to 100 times \n        depending on ws-tb-size.\n01  ws-stddev       pic s9(05)v9999 comp-3.\nPROCEDURE DIVISION using  ws-tb-data  ws-stddev.\n    compute ws-sum = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sum = ws-sum + ws-tb-fld (ws-tbx) \n    end-perform\n    compute ws-avg rounded = ws-sum / ws-tb-size\n    compute ws-sumsq = 0\n    perform test before varying ws-tbx from 1 by +1 until ws-tbx > ws-tb-size\n        compute ws-sumsq = ws-sumsq\n        + (ws-tb-fld (ws-tbx) - ws-avg) ** 2.0\n    end-perform\n    compute ws-stddev = ( ws-sumsq / ws-tb-size) ** 0.5 \n    goback.\nend program stddev.\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 33096, "name": "Palindrome detection", "source": "Translate COBOL to C#:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 33098, "name": "Palindrome detection", "source": "Translate COBOL to Java:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 33099, "name": "Palindrome detection", "source": "Translate COBOL to Python:        identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33374, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33376, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33377, "name": "Loop over multiple arrays simultaneously", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-Over-Multiple-Tables.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  A VALUE \"abc\".\n           03  A-Vals PIC X OCCURS 3 TIMES.\n\n       01  B VALUE \"ABC\".\n           03  B-Vals PIC X OCCURS 3 TIMES.\n\n       01  C VALUE \"123\".\n           03  C-Vals PIC 9 OCCURS 3 TIMES.\n\n       01  I PIC 9.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING I FROM 1 BY 1 UNTIL 3 < I\n               DISPLAY A-Vals (I) B-Vals (I) C-Vals (I)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33625, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to C#:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33627, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to Java:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33628, "name": "Sorting algorithms_Cocktail sort", "source": "Translate COBOL to Python:        C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 2       TO WC-START\n           MOVE WC-SIZE TO WC-END.\n           MOVE 1       TO WC-DIRECTION\n                           WC-LAST-CHANGE.\n           PERFORM E-SHAKER UNTIL WC-END * WC-DIRECTION <\n                                  WC-START * WC-DIRECTION.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       E-SHAKER SECTION.\n       E-000.\n           PERFORM F-PASS VARYING WB-IX-1 FROM WC-START BY WC-DIRECTION\n                          UNTIL WB-IX-1 = WC-END + WC-DIRECTION.\n\n           MOVE WC-START TO WC-END.\n           SUBTRACT WC-DIRECTION FROM WC-LAST-CHANGE GIVING WC-START.\n           MULTIPLY WC-DIRECTION BY -1 GIVING WC-DIRECTION.\n\n       E-999.\n           EXIT.\n\n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1 - 1) > WB-ENTRY(WB-IX-1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1 - 1) TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1)     TO WB-ENTRY(WB-IX-1 - 1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1).\n\n       F-999.\n           EXIT.\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 34706, "name": "Check output device is a terminal", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34707, "name": "Check output device is a terminal", "source": "Translate COBOL to C#:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "using System;\n\nnamespace CheckTerminal {\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Stdout is tty: {0}\", Console.IsOutputRedirected);\n        }\n    }\n}\n"}
{"id": 34710, "name": "Check output device is a terminal", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 34711, "name": "Check output device is a terminal", "source": "Translate COBOL to Python:       \n      \n      \n      \n      \n       identification division.\n       program-id. istty.\n\n       data division.\n       working-storage section.\n       01 rc usage binary-long.\n\n       procedure division.\n       sample-main.\n\n       call \"isatty\" using by value 0 returning rc\n       display \"fd 0 tty: \" rc\n\n       call \"isatty\" using by value 1 returning rc\n       display \"fd 1 tty: \" rc upon syserr\n\n       call \"isatty\" using by value 2 returning rc\n       display \"fd 2 tty: \" rc\n\n       goback.\n       end program istty.\n", "target": "from sys import stdout\nif stdout.isatty():\n    print 'The output device is a teletype. Or something like a teletype.'\nelse:\n    print 'The output device isn\\'t like a teletype.'\n"}
{"id": 35001, "name": "Averages_Median", "source": "Translate COBOL to C#: FUNCTION MEDIAN(some-table (ALL))\n", "target": "using System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            \n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                \n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                \n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 35003, "name": "Averages_Median", "source": "Translate COBOL to Java: FUNCTION MEDIAN(some-table (ALL))\n", "target": "\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"}
{"id": 35004, "name": "Averages_Median", "source": "Translate COBOL to Python: FUNCTION MEDIAN(some-table (ALL))\n", "target": "def median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n"}
{"id": 35161, "name": "Pointers and references", "source": "Translate COBOL to C#:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": "static void Main(string[] args)\n{\n\tint p;\n\n\tp = 1;\n\tConsole.WriteLine(\"Ref Before: \" + p);\n\tValue(ref p);\n\tConsole.WriteLine(\"Ref After\u00a0: \" + p);\n\n\tp = 1;\n\tConsole.WriteLine(\"Val Before: \" + p);\n\tValue(p);\n\tConsole.WriteLine(\"Val After\u00a0: \" + p);\n\n\tConsole.ReadLine();\n}\n\nprivate static void Value(ref int Value)\n{\n\tValue += 1;\n}\nprivate static void Value(int Value)\n{\n\tValue += 1;\n}\n"}
{"id": 35163, "name": "Pointers and references", "source": "Translate COBOL to Java:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": " public class Foo { public int x = 0; }\n\n void somefunction() {\n     Foo a; \n     a = new Foo(); \n     Foo b = a; \n     a.x = 5; \n     System.out.println(b.x); \n }\n"}
{"id": 35164, "name": "Pointers and references", "source": "Translate COBOL to Python:        01  ptr                     USAGE POINTER TO Some-Type.\n       01  prog-ptr                USAGE PROGRAM-POINTER \"some-program\". \n", "target": " \n a = \"foo\"\n \n b = []\n \n class Foo(object):\n     pass\n c = Foo()\n \n class Bar(object):\n     def __init__(self, initializer = None)\n         \n         if initializer is not None:\n            self.value = initializer\n d = Bar(10)\n print d.value\n \n if a is b: pass\n \n if id(a) == id(b): pass\n \n def a(fmt, *args):\n     if fmt is None:\n         fmt = \"%s\"\n      print fmt % (args)\n \n b.append(a)\n \n del(a)\n \n b[0](\"foo\")  \n              \n"}
{"id": 35422, "name": "Sierpinski triangle", "source": "Translate COBOL to C#: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "using System;\nusing System.Collections;\n\nnamespace RosettaCode {\n    class SierpinskiTriangle {\n        int len;\n        BitArray b;\n\n        public SierpinskiTriangle(int n) {\n            if (n < 1) {\n                throw new ArgumentOutOfRangeException(\"Order must be greater than zero\");\n            }\n            len = 1 << (n+1);\n            b = new BitArray(len+1, false);\n            b[len>>1] = true;\n        }\n\n        public void Display() {\n            for (int j = 0; j < len / 2; j++) {\n                for (int i = 0; i < b.Count; i++) {\n                    Console.Write(\"{0}\", b[i] ? \"*\" : \" \");\n                }\n                Console.WriteLine();\n                NextGen();\n            }\n        }\n\n        private void NextGen() {\n            BitArray next = new BitArray(b.Count, false);\n            for (int i = 0; i < b.Count; i++) {\n                if (b[i]) {\n                    next[i - 1] = next[i - 1] ^ true;\n                    next[i + 1] = next[i + 1] ^ true;\n                }\n            }\n            b = next;\n        }\n    }\n}\n"}
{"id": 35424, "name": "Sierpinski triangle", "source": "Translate COBOL to Java: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "public class SierpinskiTriangle {\n\n    public static void main(String[] args) {\n        System.out.println(getSierpinskiTriangle(4));\n    }\n    \n    private static final String getSierpinskiTriangle(int n) {\n        if ( n == 0 ) {\n            return \"*\";\n        }\n\n        String s = getSierpinskiTriangle(n-1);\n        String [] split = s.split(\"\\n\");\n        int length = split.length;\n\n        \n        StringBuilder sb = new StringBuilder();\n        String top = buildSpace((int)Math.pow(2, n-1));\n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(top);\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        \n        \n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(split[i]);\n            sb.append(buildSpace(length-i));\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n    \n    private static String buildSpace(int n) {\n        StringBuilder sb = new StringBuilder();\n        while ( n > 0 ) {\n            sb.append(\" \");\n            n--;\n        }\n        return sb.toString();\n    }\n    \n}\n"}
{"id": 35425, "name": "Sierpinski triangle", "source": "Translate COBOL to Python: identification division.\nprogram-id. sierpinski-triangle-program.\ndata division.\nworking-storage section.\n01  sierpinski.\n    05 n              pic 99.\n    05 i              pic 999.\n    05 k              pic 999.\n    05 m              pic 999.\n    05 c              pic 9(18).\n    05 i-limit        pic 999.\n    05 q              pic 9(18).\n    05 r              pic 9.\nprocedure division.\ncontrol-paragraph.\n    move 4 to n.\n    multiply n by 4 giving i-limit.\n    subtract 1 from i-limit.\n    perform sierpinski-paragraph\n    varying i from 0 by 1 until i is greater than i-limit.\n    stop run.\nsierpinski-paragraph.\n    subtract i from i-limit giving m.\n    multiply m by 2 giving m.\n    perform m times,\n    display space with no advancing,\n    end-perform.\n    move 1 to c.\n    perform inner-loop-paragraph\n    varying k from 0 by 1 until k is greater than i.\n    display ''.\ninner-loop-paragraph.\n    divide c by 2 giving q remainder r.\n    if r is equal to zero then display '  * ' with no advancing.\n    if r is not equal to zero then display '    ' with no advancing.\n    compute c = c * (i - k) / (k + 1).\n", "target": "def sierpinski(n):\n    d = [\"*\"]\n    for i in xrange(n):\n        sp = \" \" * (2 ** i)\n        d = [sp+x+sp for x in d] + [x+\" \"+x for x in d]\n    return d\n\nprint \"\\n\".join(sierpinski(4))\n"}
{"id": 36154, "name": "Continued fraction", "source": "Translate COBOL to C#:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36155, "name": "Continued fraction", "source": "Translate COBOL to C#:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36158, "name": "Continued fraction", "source": "Translate COBOL to Java:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36159, "name": "Continued fraction", "source": "Translate COBOL to Java:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36160, "name": "Continued fraction", "source": "Translate COBOL to Python:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36161, "name": "Continued fraction", "source": "Translate COBOL to Python:        identification division.\n       program-id. show-continued-fractions.\n\n       environment division.\n       configuration section.\n       repository.\n           function continued-fractions\n           function all intrinsic.\n\n       procedure division.\n       fractions-main.\n\n       display \"Square root 2 approximately  \u00a0: \"\n               continued-fractions(\"sqrt-2-alpha\", \"sqrt-2-beta\", 100)\n       display \"Napier constant approximately\u00a0: \"\n               continued-fractions(\"napier-alpha\", \"napier-beta\", 40)\n       display \"Pi approximately             \u00a0: \"\n               continued-fractions(\"pi-alpha\", \"pi-beta\", 10000)\n\n       goback.\n       end program show-continued-fractions.\n\n      \n       identification division.\n       function-id. continued-fractions.\n      \n       data division.\n       working-storage section.\n       01 alpha-function       usage program-pointer.\n       01 beta-function        usage program-pointer.\n       01 alpha                usage float-long.\n       01 beta                 usage float-long.\n       01 running              usage float-long.\n       01 i                    usage binary-long.\n\n       linkage section.\n       01 alpha-name           pic x any length.\n       01 beta-name            pic x any length.\n       01 iterations           pic 9 any length.\n       01 approximation        usage float-long.\n\n       procedure division using\n           alpha-name beta-name iterations\n           returning approximation.\n\n       set alpha-function to entry alpha-name\n       if alpha-function = null then\n           display \"error: no \" alpha-name \" function\" upon syserr\n           goback\n       end-if\n       set beta-function to entry beta-name\n       if beta-function = null then\n           display \"error: no \" beta-name \" function\" upon syserr\n           goback\n       end-if\n\n       move 0 to alpha beta running\n       perform varying i from iterations by -1 until i = 0\n           call alpha-function using i returning alpha\n           call beta-function using i returning beta\n           compute running = beta / (alpha + running)\n       end-perform\n       call alpha-function using 0 returning alpha\n       compute approximation = alpha + running\n\n       goback.\n       end function continued-fractions.\n\n      \n       identification division.\n       program-id. sqrt-2-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 1.0 to result\n       else\n           move 2.0 to result\n       end-if\n\n       goback.\n       end program sqrt-2-alpha.\n\n      \n       identification division.\n       program-id. sqrt-2-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       move 1.0 to result\n\n       goback.\n       end program sqrt-2-beta.\n\n      \n       identification division.\n       program-id. napier-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 2.0 to result\n       else\n           move iteration to result\n       end-if\n\n       goback.\n       end program napier-alpha.\n\n      \n       identification division.\n       program-id. napier-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration = 1 then\n           move 1.0 to result\n       else\n           compute result = iteration - 1.0\n       end-if\n\n       goback.\n       end program napier-beta.\n\n      \n       identification division.\n       program-id. pi-alpha.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       if iteration equal 0 then\n           move 3.0 to result\n       else\n           move 6.0 to result\n       end-if\n\n       goback.\n       end program pi-alpha.\n\n      \n       identification division.\n       program-id. pi-beta.\n\n       data division.\n       working-storage section.\n       01 result               usage float-long.\n\n       linkage section.\n       01 iteration            usage binary-long unsigned.\n\n       procedure division using iteration returning result.\n       compute result = (2 * iteration - 1) ** 2\n\n       goback.\n       end program pi-beta.\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36644, "name": "Quine", "source": "Translate COBOL to C#: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36645, "name": "Quine", "source": "Translate COBOL to C#: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36648, "name": "Quine", "source": "Translate COBOL to Java: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36649, "name": "Quine", "source": "Translate COBOL to Java: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36650, "name": "Quine", "source": "Translate COBOL to Python: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36651, "name": "Quine", "source": "Translate COBOL to Python: linkage section. 78 c value \"display 'linkage section. 78 c value ' x'22' c x'222e20' c.\". display 'linkage section. 78 c value ' x'22' c x'222e20' c.\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37310, "name": "Sequence of non-squares", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": "using System;\nusing System.Diagnostics;\n\nnamespace sons\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i < 23; i++)            \n                Console.WriteLine(nonsqr(i));            \n\n            for (int i = 1; i < 1000000; i++)\n            {\n                double j = Math.Sqrt(nonsqr(i));\n                Debug.Assert(j != Math.Floor(j),\"Square\");\n            }            \n        }\n\n        static int nonsqr(int i)\n        {\n            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));\n        }\n    }\n}\n"}
{"id": 37312, "name": "Sequence of non-squares", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": "public class SeqNonSquares {\n    public static int nonsqr(int n) {\n        return n + (int)Math.round(Math.sqrt(n));\n    }\n    \n    public static void main(String[] args) {\n        \n        for (int i = 1; i < 23; i++)\n            System.out.print(nonsqr(i) + \" \");\n        System.out.println();\n        \n        \n        for (int i = 1; i < 1000000; i++) {\n            double j = Math.sqrt(nonsqr(i));\n            assert j != Math.floor(j);\n        }\n    }\n}\n"}
{"id": 37313, "name": "Sequence of non-squares", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. NONSQR.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 NEWTON.\n          03 SQR-INP           PIC 9(7)V9(5).\n          03 SQUARE-ROOT       PIC 9(7)V9(5).\n          03 FILLER            REDEFINES SQUARE-ROOT.\n             05 FILLER         PIC 9(7).\n             05 FILLER         PIC 9(5).\n                88 SQUARE      VALUE ZERO.\n          03 SQR-TEMP          PIC 9(7)V9(5).\n       01 SEQUENCE-VARS.\n          03 N                 PIC 9(7).\n          03 SEQ               PIC 9(7).\n       01 SMALL-FMT.\n          03 N-O               PIC Z9.\n          03 FILLER            PIC XX VALUE \": \".  \n          03 SEQ-O             PIC Z9.\n          \n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY \"Sequence of non-squares from 1 to 22:\"\n           PERFORM SMALL-NUMS VARYING N FROM 1 BY 1\n               UNTIL N IS GREATER THAN 22.\n           \n           DISPLAY SPACES.\n           DISPLAY \"Checking items up to 1 million...\"\n           PERFORM CHECK-NONSQUARE VARYING N FROM 1 BY 1\n               UNTIL SQUARE OR N IS GREATER THAN 1000000.\n           \n           IF SQUARE, DISPLAY \"Square found at N = \" N,\n           ELSE, DISPLAY \"No squares found up to 1 million.\".\n           STOP RUN.\n           \n       SMALL-NUMS.\n           PERFORM NONSQUARE.\n           MOVE N TO N-O.\n           MOVE SEQ TO SEQ-O.\n           DISPLAY SMALL-FMT.\n           \n       CHECK-NONSQUARE.\n           PERFORM NONSQUARE.\n           MOVE SEQ TO SQR-INP.\n           PERFORM SQRT.\n       \n       NONSQUARE.\n           MOVE N TO SQR-INP.\n           PERFORM SQRT.\n           ADD 0.5, SQUARE-ROOT GIVING SEQ.\n           ADD N TO SEQ.\n       \n       SQRT.\n           MOVE SQR-INP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n           PERFORM SQRT-LOOP UNTIL SQUARE-ROOT IS EQUAL TO SQR-TEMP.\n       SQRT-LOOP.\n           MOVE SQR-TEMP TO SQUARE-ROOT.\n           COMPUTE SQR-TEMP = \n               (SQUARE-ROOT + SQR-INP / SQUARE-ROOT) / 2.\n", "target": ">>> from math import floor, sqrt\n>>> def non_square(n):\n        return n + floor(1/2 + sqrt(n))\n\n>>> \n>>> print(*map(non_square, range(1, 23)))\n2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27\n\n>>> \n>>> def is_square(n):\n        return sqrt(n).is_integer()\n\n>>> non_squares = map(non_square, range(1, 10 ** 6))\n>>> next(filter(is_square, non_squares))\nStopIteration                             Traceback (most recent call last)\n<ipython-input-45-f32645fc1c0a> in <module>()\n      1 non_squares = map(non_square, range(1, 10 ** 6))\n----> 2 next(filter(is_square, non_squares))\n\nStopIteration:\n"}
{"id": 38069, "name": "Character codes", "source": "Translate COBOL to C#:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 38071, "name": "Character codes", "source": "Translate COBOL to Java:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 38072, "name": "Character codes", "source": "Translate COBOL to Python:        identification division.\n       program-id. character-codes.\n       remarks. COBOL is an ordinal language, first is 1.\n       remarks. 42nd ASCII code is \")\" not, \"*\".\n       procedure division.\n       display function char(42)\n       display function ord('*')\n       goback.\n       end program character-codes.\n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38892, "name": "Generic swap", "source": "Translate COBOL to C#:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38894, "name": "Generic swap", "source": "Translate COBOL to Java:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38895, "name": "Generic swap", "source": "Translate COBOL to Python:        PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n", "target": "a, b = b, a\n"}
{"id": 39615, "name": "String append", "source": "Translate COBOL to C#:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39617, "name": "String append", "source": "Translate COBOL to Java:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39618, "name": "String append", "source": "Translate COBOL to Python:       identification division.                                         \n       program-id. string-append.                                       \n\n       data division.\n       working-storage section.\n       01 some-string.\n          05 elements pic x occurs 0 to 80 times depending on limiter.\n       01 limiter     usage index value 7.\n       01 current     usage index.\n\n       procedure division.\n       append-main.\n\n       move \"Hello, \" to some-string\n\n      \n       set current to length of some-string\n       set limiter up by 5\n       move \"world\" to some-string(current + 1:)\n       display some-string\n\n       goback.\n       end program string-append.\n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39847, "name": "Count in octal", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39849, "name": "Count in octal", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39850, "name": "Count in octal", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec \n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40118, "name": "Delete a file", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.IO;\n\nnamespace DeleteFile {\n  class Program {\n    static void Main() {\n      File.Delete(\"input.txt\");\n      Directory.Delete(\"docs\");\n      File.Delete(\"/input.txt\");\n      Directory.Delete(\"/docs\");\n    }\n  }\n}\n"}
{"id": 40120, "name": "Delete a file", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "import java.io.File;\n\npublic class FileDeleteTest {\n    public static boolean deleteFile(String filename) {\n        boolean exists = new File(filename).delete();\n        return exists;\n    }\n    \n    public static void test(String type, String filename) {\n        System.out.println(\"The following \" + type + \" called \" + filename + \n            (deleteFile(filename) ? \" was deleted.\" : \" could not be deleted.\")\n        );\n    }\n\n    public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.seperator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.seperator + \"docs\" + File.seperator);\n    }\n}\n"}
{"id": 40121, "name": "Delete a file", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Delete-Files.\n\n       PROCEDURE DIVISION.\n           CALL \"CBL_DELETE_FILE\" USING \"input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"docs\"\n           CALL \"CBL_DELETE_FILE\" USING \"/input.txt\"\n           CALL \"CBL_DELETE_DIR\"  USING \"/docs\"\n\n           GOBACK\n           .\n", "target": "import os\n\nos.remove(\"output.txt\")\nos.rmdir(\"docs\")\n\nos.remove(\"/output.txt\")\nos.rmdir(\"/docs\")\n"}
{"id": 40401, "name": "Sum of a series", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40403, "name": "Sum of a series", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40404, "name": "Sum of a series", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. sum-of-series.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  N                       VALUE 1000.\n\n       01  series-term             USAGE FLOAT-LONG.\n       01  i                       PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL N < i\n               COMPUTE series-term = series-term + (1 / i ** 2)\n           END-PERFORM\n\n           DISPLAY series-term\n\n           GOBACK\n           .\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 41303, "name": "Read a file line by line", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "foreach (string readLine in File.ReadLines(\"FileName\"))\n  DoSomething(readLine);\n"}
{"id": 41305, "name": "Read a file line by line", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\n\npublic class ReadFileByLines {\n    private static void processLine(int lineNo, String line) {\n        \n    }\n\n    public static void main(String[] args) {\n        for (String filename : args) {\n            BufferedReader br = null;\n            FileReader fr = null;\n            try {\n                fr = new FileReader(filename);\n                br = new BufferedReader(fr);\n                String line;\n                int lineNo = 0;\n                while ((line = br.readLine()) != null) {\n                    processLine(++lineNo, line);\n                }\n            }\n            catch (Exception x) {\n                x.printStackTrace();\n            }\n            finally {\n                if (fr != null) {\n                    try {br.close();} catch (Exception ignoreMe) {}\n                    try {fr.close();} catch (Exception ignoreMe) {}\n                }\n            }\n        }\n    }\n}\n"}
{"id": 41306, "name": "Read a file line by line", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. read-file-line-by-line.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT input-file ASSIGN TO \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS input-file-status.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  input-file.\n       01  input-record PIC X(256).\n\n       WORKING-STORAGE SECTION.\n       01  input-file-status PIC 99.\n           88  file-is-ok    VALUE 0.\n           88  end-of-file   VALUE 10.\n\n       01  line-count        PIC 9(6).\n\n       PROCEDURE DIVISION.\n           OPEN INPUT input-file\n           IF NOT file-is-ok\n               DISPLAY \"The file could not be opened.\"\n               GOBACK\n           END-IF\n\n           PERFORM VARYING line-count FROM 1 BY 1 UNTIL end-of-file\n               READ input-file\n               DISPLAY line-count \": \" FUNCTION TRIM(input-record)\n           END-PERFORM\n\n           CLOSE input-file\n\n           GOBACK\n           .\n", "target": "for line in lines open('input.txt'):\n    print line\n"}
{"id": 41541, "name": "Write entire file", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "System.IO.File.WriteAllText(\"filename.txt\", \"This file contains a string.\");\n"}
{"id": 41543, "name": "Write entire file", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "import java.io.*;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"))) {\n            bw.write(\"abc\");\n        }\n    }\n}\n"}
{"id": 41544, "name": "Write entire file", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Overwrite.\n       AUTHOR. Bill Gunshannon. \n       INSTALLATION.  Home.\n       DATE-WRITTEN.  31 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Simple COBOL task.  Open file for output.  Write\n      **     data to file. Close file.  Done...        \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT File-Name ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  File-Name\n           DATA RECORD IS Record-Name.\n       01  Record-Name.\n           02 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01 New-Val                   PIC X(80)\n              VALUE 'Hello World'.\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT File-Name.\n           WRITE Record-Name FROM New-Val.\n           CLOSE File-Name.\n           STOP RUN.\n       \n       END-PROGRAM.\n", "target": "with open(filename, 'w') as f:\n    f.write(data)\n"}
{"id": 42538, "name": "Narcissistic decimal number", "source": "Translate COBOL to C#:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42539, "name": "Narcissistic decimal number", "source": "Translate COBOL to C#:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42542, "name": "Narcissistic decimal number", "source": "Translate COBOL to Java:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42543, "name": "Narcissistic decimal number", "source": "Translate COBOL to Java:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42544, "name": "Narcissistic decimal number", "source": "Translate COBOL to Python:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42545, "name": "Narcissistic decimal number", "source": "Translate COBOL to Python:        PROGRAM-ID. NARCISSIST-NUMS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n \n           01 num-length PIC 9(2) value 0.\n           01 in-sum PIC  9(9) value 0.\n           01 counter PIC  9(9) value 0.\n           01 current-number PIC  9(9) value 0.\n           01 narcissist PIC Z(9).\n           01 temp PIC  9(9) value 0.\n           01 modulo PIC  9(9) value 0.\n           01 answer PIC  9 .\n \n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"the first 20 narcissist numbers:\" .\n \n           MOVE 20 TO counter.\n           PERFORM UNTIL counter=0\n \n               PERFORM 000-NARCISSIST-PARA\n \n                   IF answer = 1 \n                       SUBTRACT 1 from counter\n                       GIVING counter\n                       MOVE current-number TO narcissist\n                       DISPLAY narcissist\n                   END-IF\n \n                   ADD 1 TO current-number\n \n               END-PERFORM\n \n            STOP RUN.\n \n       000-NARCISSIST-PARA.\n \n             MOVE ZERO TO in-sum.\n             MOVE current-number TO temp.\n             COMPUTE num-length =1+  FUNCTION Log10(temp)\n \n             PERFORM  UNTIL temp=0\n \n                  DIVIDE temp BY 10 GIVING temp\n                            REMAINDER  modulo\n \n                  COMPUTE modulo=modulo**num-length\n                  ADD modulo to in-sum GIVING in-sum\n \n            END-PERFORM.\n \n               IF current-number=in-sum\n                   MOVE 1 TO answer\n                   ELSE MOVE 0 TO answer\n               END-IF.\n \n       END PROGRAM NARCISSIST-NUMS.\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42822, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to C#: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": "using System;\n\npublic class TrimExample\n{\n    public static void Main(String[] args)\n    {\n        const string toTrim = \" Trim me \";\n        Console.WriteLine(Wrap(toTrim.TrimStart()));\n        Console.WriteLine(Wrap(toTrim.TrimEnd()));\n        Console.WriteLine(Wrap(toTrim.Trim()));\n    }\n\n    private static string Wrap(string s)\n    {\n        return \"'\" + s + \"'\";\n    }\n}\n"}
{"id": 42824, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to Java: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": "public class Trims{\n    public static String ltrim(String s) {\n        int i = 0;\n        while (i < s.length() && Character.isWhitespace(s.charAt(i))) {\n            i++;\n        }\n        return s.substring(i);\n    }\n\n    public static String rtrim(String s) {\n        int i = s.length() - 1;\n        while (i > 0 && Character.isWhitespace(s.charAt(i))) {\n            i--;\n        }\n        return s.substring(0, i + 1);\n    }\n\n    public static String trim(String s) {\n    \treturn rtrim(ltrim(s));\n    }\n\n    public static void main(String[] args) {\n        String s = \" \\t \\r \\n String with spaces \\u2009 \\t  \\r  \\n  \";\n        System.out.printf(\"[%s]\\n\", ltrim(s));\n        System.out.printf(\"[%s]\\n\", rtrim(s));\n        System.out.printf(\"[%s]\\n\", trim(s));\n    }\n}\n"}
{"id": 42825, "name": "Strip whitespace from a string_Top and tail", "source": "Translate COBOL to Python: DISPLAY \"'\" FUNCTION TRIM(str, LEADING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str, TRAILING) \"'\"\nDISPLAY \"'\" FUNCTION TRIM(str) \"'\"\n", "target": ">>> s = ' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s\n' \\t \\r \\n String with spaces  \\t  \\r  \\n  '\n>>> s.lstrip()\n'String with spaces  \\t  \\r  \\n  '\n>>> s.rstrip()\n' \\t \\r \\n String with spaces'\n>>> s.strip()\n'String with spaces'\n>>>\n"}
{"id": 43078, "name": "Strip comments from a string", "source": "Translate COBOL to C#:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "using System.Text.RegularExpressions;\n\nstring RemoveComments(string str, string delimiter)\n        {\n            \n            \n            \n            return Regex.Replace(str, delimiter + \".+\", string.Empty).Trim();\n        }\n"}
{"id": 43080, "name": "Strip comments from a string", "source": "Translate COBOL to Java:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "import java.io.*;\n\npublic class StripLineComments{\n    public static void main( String[] args ){\n\tif( args.length < 1 ){\n\t    System.out.println(\"Usage: java StripLineComments StringToProcess\");\n\t}\n\telse{\n\t    String inputFile = args[0];\n\t    String input = \"\";\n\t    try{\n\t\tBufferedReader reader = new BufferedReader( new FileReader( inputFile ) );\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t    System.out.println( line.split(\"[#;]\")[0] );\n\t\t}\n\t    }\n\t    catch( Exception e ){\n\t\te.printStackTrace();\n\t    }\n\t}\n    }\n}\n"}
{"id": 43081, "name": "Strip comments from a string", "source": "Translate COBOL to Python:        identification division.\n       program-id. StripComments.\n\n       data division.\n       working-storage section.\n       01  line-text              pic x(64).\n\n       procedure division.\n       main.\n           move \"apples, pears # and bananas\" to line-text\n           perform show-striped-text\n\n           move \"apples, pears\u00a0; and bananas\" to line-text\n           perform show-striped-text\n\n           stop run\n           .\n       show-striped-text.\n           unstring line-text delimited by \"#\" or \";\" into line-text\n           display quote, function trim(line-text), quote\n           .\n", "target": "def remove_comments(line, sep):\n    for s in sep:\n        i = line.find(s)\n        if i >= 0:\n            line = line[:i]\n    return line.strip()\n\n\nprint remove_comments('apples\u00a0; pears \nprint remove_comments('apples\u00a0; pears \n"}
{"id": 43438, "name": "Function prototype", "source": "Translate COBOL to C#:        \n       PROGRAM-ID. no-args PROTOTYPE.\n       END PROGRAM no-args.\n\n       \n       \n       PROGRAM-ID. two-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       01  ret   PIC 9(8).\n       PROCEDURE DIVISION USING arg-1, arg-2 RETURNING ret.\n       END PROGRAM two-args.\n\n       \n       \n       \n       PROGRAM-ID. optional-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       PROCEDURE DIVISION USING OPTIONAL arg-1, OPTIONAL arg-2.\n       END PROGRAM optional-args.\n\n       \n\n       \n       \n       PROGRAM-ID. foreign-func PROTOTYPE.\n       OPTIONS.\n           ENTRY-CONVENTION some-langauge.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  arg PIC S9(9) USAGE COMP-5.\n       01  ret PIC S9(9) USAGE COMP-5.\n       PROCEDURE DIVISION USING arg RETURNING ret.\n       END PROGRAM foreign-func.\n", "target": "using System;\nabstract class Printer\n{\n    public abstract void Print();\n}\n\nclass PrinterImpl : Printer\n{\n    public override void Print() {\n        Console.WriteLine(\"Hello world!\");\n    }\n}\n"}
{"id": 43439, "name": "Function prototype", "source": "Translate COBOL to C#:        \n       PROGRAM-ID. no-args PROTOTYPE.\n       END PROGRAM no-args.\n\n       \n       \n       PROGRAM-ID. two-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       01  ret   PIC 9(8).\n       PROCEDURE DIVISION USING arg-1, arg-2 RETURNING ret.\n       END PROGRAM two-args.\n\n       \n       \n       \n       PROGRAM-ID. optional-args PROTOTYPE.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  arg-1 PIC 9(8).\n       01  arg-2 PIC 9(8).\n       PROCEDURE DIVISION USING OPTIONAL arg-1, OPTIONAL arg-2.\n       END PROGRAM optional-args.\n\n       \n\n       \n       \n       PROGRAM-ID. foreign-func PROTOTYPE.\n       OPTIONS.\n           ENTRY-CONVENTION some-langauge.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  arg PIC S9(9) USAGE COMP-5.\n       01  ret PIC S9(9) USAGE COMP-5.\n       PROCEDURE DIVISION USING arg RETURNING ret.\n       END PROGRAM foreign-func.\n", "target": "using System;\nabstract class Printer\n{\n    public abstract void Print();\n}\n\nclass PrinterImpl : Printer\n{\n    public override void Print() {\n        Console.WriteLine(\"Hello world!\");\n    }\n}\n"}
{"id": 43965, "name": "Determine if a string is numeric", "source": "Translate COBOL to C#:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43967, "name": "Determine if a string is numeric", "source": "Translate COBOL to Java:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43968, "name": "Determine if a string is numeric", "source": "Translate COBOL to Python:         program-id. is-numeric.\n        procedure division.\n        display function test-numval-f(\"abc\") end-display\n        display function test-numval-f(\"-123.01E+3\") end-display\n        if function test-numval-f(\"+123.123\") equal zero then\n            display \"is numeric\" end-display\n        else\n            display \"failed numval-f test\" end-display\n        end-if\n        goback.\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44218, "name": "One-dimensional cellular automata", "source": "Translate COBOL to C#:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 44220, "name": "One-dimensional cellular automata", "source": "Translate COBOL to Java:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "public class Life{\n\tpublic static void main(String[] args) throws Exception{\n\t\tString start= \"_###_##_#_#_#_#__#__\";\n\t\tint numGens = 10;\n\t\tfor(int i= 0; i < numGens; i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \": \" + start);\n\t\t\tstart= life(start);\n\t\t}\n\t}\n\n\tpublic static String life(String lastGen){\n\t\tString newGen= \"\";\n\t\tfor(int i= 0; i < lastGen.length(); i++){\n\t\t\tint neighbors= 0;\n\t\t\tif (i == 0){\n\t\t\t\tneighbors= lastGen.charAt(1) == '#' ? 1 : 0;\n\t\t\t} else if (i == lastGen.length() - 1){\n\t\t\t\tneighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;\n\t\t\t} else{\n\t\t\t\tneighbors= getNeighbors(lastGen.substring(i - 1, i + 2));\n\t\t\t}\n\n\t\t\tif (neighbors == 0){\n\t\t\t\tnewGen+= \"_\";\n\t\t\t}\n\t\t\tif (neighbors == 1){\n\t\t\t\tnewGen+= lastGen.charAt(i);\n\t\t\t}\n\t\t\tif (neighbors == 2){\n\t\t\t\tnewGen+= lastGen.charAt(i) == '#' ? \"_\" : \"#\";\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String group){\n\t\tint ans= 0;\n\t\tif (group.charAt(0) == '#') ans++;\n\t\tif (group.charAt(2) == '#') ans++;\n\t\treturn ans;\n\t}\n}\n"}
{"id": 44221, "name": "One-dimensional cellular automata", "source": "Translate COBOL to Python:  Identification division.                                        \n Program-id. rc-1d-cell.                                         \n \n Data division.                                                  \n Working-storage section.                                        \n \n\n 01 max-gens            pic  999  value   9.                     \n 01 state-width         pic   99  value  20.                     \n 01 state-table-init    pic x(20) value \".@@@.@@.@.@.@.@..@..\".  \n 01 alive               pic    x  value \"@\".                     \n 01 dead                pic    x  value \".\".                     \n \n\n 01 state-gen           pic  999  value   0.                     \n 01 state-row.                                                  \n    05 state-row-gen   pic zz9.                                \n    05 filler          pic  xx   value \": \".                   \n    05 state-table.                                            \n        10 state-cells pic   x   occurs 20 times.              \n \n\n 01 new-state-table.                                            \n    05 new-state-cells pic   x   occurs 20 times.              \n \n\n 01 cell-index          pic   99.                               \n    88 at-beginning    value  1.                               \n    88 is-inside       values 2 thru 19.                       \n    88 at-end          value 20.                               \n \n\n 01 neighbor-count-def.                          \n   03 neighbor-count      pic   9.\n     88 is-comfy        value 1.                    \n     88 is-ripe         value 2.                    \n \n Procedure division.                                \n     Perform Init-state-table.                      \n     Perform max-gens times                         \n         perform Display-row                        \n         perform Next-state                         \n     end-perform.                                   \n     Perform Display-row.                           \n     Stop run.                                      \n \n Display-row.                                       \n     Move state-gen to state-row-gen.     \n     Display state-row.                   \n \n\n Next-state.                              \n     Add 1 to state-gen.                  \n     Move state-table to new-state-table. \n \n     Perform with test after              \n         varying cell-index from 1 by 1   \n         until at-end                     \n         perform Count-neighbors          \n         perform Die-off                             \n         perform New-births                          \n     end-perform                                     \n \n     move new-state-table to state-table.            \n \n\n Die-off.                                            \n     if state-cells(cell-index) =                    \n     alive and not is-comfy    \n         then move dead to new-state-cells(cell-index)           \n     end-if                                                      \n     .                                                           \n \n\n New-births.                                                     \n     if state-cells(cell-index) = dead and is-ripe\n         then move alive to new-state-cells(cell-index)          \n     end-if                                                      \n    .                                                           \n\n Count-neighbors.                                                \n     Move 0 to neighbor-count                        \n     if at-beginning or at-end then                              \n         add 1 to neighbor-count                      \n     else                                                        \n       if is-inside and state-cells(cell-index - 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                      \n       if is-inside and state-cells(cell-index + 1) = alive        \n       then                                                        \n           add 1 to neighbor-count                     \n       end-if                                                       \n     end-if                                                        \n     .                                                             \n \n\n\n\n \n Init-state-table.                                                 \n     Perform with test after                    \n         varying cell-index from 1 by 1         \n         until at-end                           \n         move state-table-init(cell-index:1)    \n           to state-cells(cell-index)           \n      end-perform\n      .\n", "target": "import random\n\nprintdead, printlive = '_\nmaxgenerations = 10\ncellcount = 20\noffendvalue = '0'\n\nuniverse = ''.join(random.choice('01') for i in range(cellcount))\n\nneighbours2newstate = {\n '000': '0',\n '001': '0',\n '010': '0',\n '011': '1',\n '100': '0',\n '101': '1',\n '110': '1',\n '111': '0',\n }\n\nfor i in range(maxgenerations):\n    print \"Generation %3i:  %s\" % ( i,\n          universe.replace('0', printdead).replace('1', printlive) )\n    universe = offendvalue + universe + offendvalue\n    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))\n"}
{"id": 44751, "name": "Inheritance_Multiple", "source": "Translate COBOL to C#:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "interface ICamera {\n    \n}\n\nclass MobilePhone {\n    \n}\n\nclass CameraPhone: ICamera, MobilePhone {\n    \n}\n"}
{"id": 44753, "name": "Inheritance_Multiple", "source": "Translate COBOL to Java:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "public interface Camera{\n   \n   \n   \n}\n"}
{"id": 44754, "name": "Inheritance_Multiple", "source": "Translate COBOL to Python:        CLASS-ID. Camera.\n           \n       END CLASS Camera.\n       \n       CLASS-ID. Mobile-Phone.\n           \n       END CLASS Mobile-Phone.\n       \n       CLASS-ID. Camera-Phone INHERITS Camera, Mobile-Phone.    \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Camera\n           CLASS Mobile-Phone.\n           \n           \n       END CLASS Camera-Phone.\n", "target": "class Camera:\n  pass \n"}
{"id": 45079, "name": "Zero to the zero power", "source": "Translate COBOL to C#: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45080, "name": "Zero to the zero power", "source": "Translate COBOL to C#: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45083, "name": "Zero to the zero power", "source": "Translate COBOL to Java: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45084, "name": "Zero to the zero power", "source": "Translate COBOL to Java: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 45085, "name": "Zero to the zero power", "source": "Translate COBOL to Python: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45086, "name": "Zero to the zero power", "source": "Translate COBOL to Python: identification division.\nprogram-id. zero-power-zero-program.\ndata division.\nworking-storage section.\n77  n                         pic 9.\nprocedure division.\n    compute n = 0**0.\n    display n upon console.\n    stop run.\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45726, "name": "Multiplication tables", "source": "Translate COBOL to C#:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45728, "name": "Multiplication tables", "source": "Translate COBOL to Java:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45729, "name": "Multiplication tables", "source": "Translate COBOL to Python:        identification division.\n       program-id. multiplication-table.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 multiplication.\n          05 rows occurs 12 times.\n             10 colm occurs 12 times.\n                15 num    pic 999.\n       77 cand pic 99.\n       77 ier  pic 99.\n       77 ind  pic z9.\n       77 show pic zz9.\n\n       procedure division.\n       sample-main.\n       perform varying cand from 1 by 1 until cand greater than 12\n                  after ier from 1 by 1 until ier greater than 12\n           multiply cand by ier giving num(cand, ier)\n       end-perform\n\n       perform varying cand from 1 by 1 until cand greater than 12\n           move cand to ind\n           display \"x \" ind \"| \" with no advancing\n           perform varying ier from 1 by 1 until ier greater than 12\n               if ier greater than or equal to cand then\n                   move num(cand, ier) to show\n                   display show with no advancing\n                   if ier equal to 12 then\n                       display \"|\"\n                   else\n                       display space with no advancing\n                   end-if\n               else\n                   display \"    \" with no advancing\n               end-if\n           end-perform\n       end-perform\n\n       goback.\n       end program multiplication-table.\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 46109, "name": "Comma quibbling", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46110, "name": "Comma quibbling", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46113, "name": "Comma quibbling", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46114, "name": "Comma quibbling", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46115, "name": "Comma quibbling", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46116, "name": "Comma quibbling", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. comma-quibbling-test.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION comma-quibbling\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\nPROCEDURE DIVISION.\n    MOVE \"ABC\" TO strs (1)\n    MOVE \"DEF\" TO strs (2)\n    MOVE \"G\" TO strs (3)\n    MOVE \"H\" TO strs (4)\n\n    PERFORM VARYING strs-len FROM 0 BY 1 UNTIL strs-len > 4\n        DISPLAY FUNCTION comma-quibbling(strs-area)\n    END-PERFORM\n    .\nEND PROGRAM comma-quibbling-test.\n\n \nIDENTIFICATION DIVISION.\nFUNCTION-ID. comma-quibbling.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                             PIC 9.\n\n01  num-extra-words               PIC 9.\n\nLINKAGE SECTION.\n01  strs-area.\n    03  strs-len                  PIC 9.\n    03  strs                      PIC X(5)\n                                  OCCURS 0 TO 9 TIMES\n                                  DEPENDING ON strs-len.\n\n01  str                           PIC X(50).\n\nPROCEDURE DIVISION USING strs-area RETURNING str.\n    EVALUATE strs-len\n        WHEN ZERO\n            MOVE \"{}\" TO str\n            GOBACK\n\n        WHEN 1\n            MOVE FUNCTION CONCATENATE(\"{\", FUNCTION TRIM(strs (1)), \"}\")\n                TO str\n            GOBACK\n    END-EVALUATE\n\n    MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (strs-len - 1)),\n        \" and \", FUNCTION TRIM(strs (strs-len)), \"}\")\n        TO str\n\n    IF strs-len > 2\n        SUBTRACT 2 FROM strs-len GIVING num-extra-words\n        PERFORM VARYING i FROM num-extra-words BY -1 UNTIL i = 0\n            MOVE FUNCTION CONCATENATE(FUNCTION TRIM(strs (i)), \", \", str)\n                TO str\n        END-PERFORM\n    END-IF\n    \n    MOVE FUNCTION CONCATENATE(\"{\", str) TO str\n    .\nEND FUNCTION comma-quibbling.\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46603, "name": "Count the coins", "source": "Translate COBOL to C#:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46604, "name": "Count the coins", "source": "Translate COBOL to C#:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46607, "name": "Count the coins", "source": "Translate COBOL to Java:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46608, "name": "Count the coins", "source": "Translate COBOL to Java:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46609, "name": "Count the coins", "source": "Translate COBOL to Python:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46610, "name": "Count the coins", "source": "Translate COBOL to Python:        identification division.\n       program-id. CountCoins.\n\n       data division.\n       working-storage section.\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).  \n       77  m                      pic 9(3) value 4.\n       77  n                      pic 9(3) value 100.  \n       77  edited-value           pic z(18).\n       01  coins-table            value \"01051025\".\n           05 coin                pic 9(2) occurs 4.\n       01  ways-table.\n           05 way                 pic 9(18) occurs 100.\n\n       procedure division.\n       main.\n           perform calc-count\n           move way(n) to edited-value\n           display function trim(edited-value)\n           stop run\n           .\n       calc-count.\n           initialize ways-table\n           move 1 to way(1)\n           perform varying i from 1 by 1 until i > m\n              perform varying j from coin(i) by 1 until j > n\n                 add way(j - coin(i)) to way(j)\n              end-perform\n           end-perform\n           .\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 47108, "name": "Ackermann function", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 47110, "name": "Ackermann function", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 47111, "name": "Ackermann function", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47926, "name": "Hello world_Text", "source": "Translate COBOL to C#: \tprogram-id. hello.\n\tprocedure division.\n\t\tdisplay \"Hello world!\".\n\t\tstop run.\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47928, "name": "Hello world_Text", "source": "Translate COBOL to Java: \tprogram-id. hello.\n\tprocedure division.\n\t\tdisplay \"Hello world!\".\n\t\tstop run.\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 49040, "name": "Digital root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49041, "name": "Digital root", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 49044, "name": "Digital root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49045, "name": "Digital root", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 49046, "name": "Digital root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49047, "name": "Digital root", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. DIGITAL-ROOT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 VARIABLES.\n          03 INPUT-NUMBER     PIC 9(16).\n          03 INPUT-DIGITS     REDEFINES INPUT-NUMBER,\n                              PIC 9 OCCURS 16 TIMES.\n          03 DIGIT-SUM        PIC 999.\n          03 DIGIT-NO         PIC 99.\n          03 PERSISTENCE      PIC 9.\n\n       01 OUTPUT-FORMAT.\n          03 O-NUMBER         PIC Z(15)9.\n          03 FILLER           PIC X(16) VALUE ': PERSISTENCE = '.\n          03 O-PERSISTENCE    PIC Z9.\n          03 FILLER           PIC X(9) VALUE ', ROOT = '.\n          03 O-ROOT           PIC Z9.\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           MOVE 627615 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 39390 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           MOVE 393900588225 TO INPUT-NUMBER, PERFORM FIND-DIGITAL-ROOT.\n           STOP RUN.\n\n       FIND-DIGITAL-ROOT.\n           MOVE ZERO TO PERSISTENCE.\n           MOVE INPUT-NUMBER TO O-NUMBER.\n           PERFORM SUMMATION UNTIL INPUT-NUMBER IS LESS THAN 10.\n           MOVE INPUT-NUMBER TO O-ROOT.\n           MOVE PERSISTENCE TO O-PERSISTENCE.\n           DISPLAY OUTPUT-FORMAT.\n\n       SUMMATION.\n           MOVE ZERO TO DIGIT-SUM.\n           ADD 1 TO PERSISTENCE.\n           PERFORM ADD-DIGIT VARYING DIGIT-NO FROM 1 BY 1\n               UNTIL DIGIT-NO IS GREATER THAN 16.\n           MOVE DIGIT-SUM TO INPUT-NUMBER.\n\n       ADD-DIGIT.\n           ADD INPUT-DIGITS(DIGIT-NO) TO DIGIT-SUM.\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49390, "name": "Loops_Continue", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49392, "name": "Loops_Continue", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49393, "name": "Loops_Continue", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-continue.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               DISPLAY i WITH NO ADVANCING\n\n               IF FUNCTION MOD(i, 5) = 0\n                   DISPLAY SPACE\n                   EXIT PERFORM CYCLE\n               END-IF\n\n               DISPLAY \", \" WITH NO ADVANCING\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 50135, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to C#: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50137, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to Java: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50138, "name": "Sieve of Eratosthenes", "source": "Translate COBOL to Python: \n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Sieve-Of-Eratosthenes.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Max-Number       USAGE UNSIGNED-INT.\n       01  Max-Prime        USAGE UNSIGNED-INT.\n\n       01  Num-Group.\n           03  Num-Table PIC X VALUE \"P\"\n                   OCCURS 1 TO 10000000 TIMES DEPENDING ON Max-Number\n                   INDEXED BY Num-Index.\n               88  Is-Prime VALUE \"P\" FALSE \"N\".\n               \n       01  Current-Prime    USAGE UNSIGNED-INT.\n\n       01  I                USAGE UNSIGNED-INT.\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Enter the limit: \" WITH NO ADVANCING\n           ACCEPT Max-Number\n           DIVIDE Max-Number BY 2 GIVING Max-Prime\n\n*          \n           SET Is-Prime (1) TO FALSE\n           PERFORM UNTIL Max-Prime < Current-Prime\n*              \n               ADD 1 TO Current-Prime\n               PERFORM VARYING Num-Index FROM Current-Prime BY 1\n                   UNTIL Is-Prime (Num-Index)\n               END-PERFORM\n               MOVE Num-Index TO Current-Prime\n\n*              \n*              \n               COMPUTE Num-Index = Current-Prime ** 2\n               PERFORM UNTIL Max-Number < Num-Index\n                   SET Is-Prime (Num-Index) TO FALSE\n                   SET Num-Index UP BY Current-Prime\n               END-PERFORM\n           END-PERFORM\n\n*          \n           PERFORM VARYING Num-Index FROM 1 BY 1\n                   UNTIL Max-Number < Num-Index\n               IF Is-Prime (Num-Index)\n                   DISPLAY Num-Index\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 51032, "name": "Split a character string based on change of character", "source": "Translate COBOL to C#:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51033, "name": "Split a character string based on change of character", "source": "Translate COBOL to C#:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51036, "name": "Split a character string based on change of character", "source": "Translate COBOL to Java:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51037, "name": "Split a character string based on change of character", "source": "Translate COBOL to Java:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51038, "name": "Split a character string based on change of character", "source": "Translate COBOL to Python:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51039, "name": "Split a character string based on change of character", "source": "Translate COBOL to Python:        identification division.\n       program-id. split-ch.\n       data division.\n       1 split-str pic x(30) value space.\n       88 str-1 value \"gHHH5YY++///\\\".\n       88 str-2 value \"gHHH5  ))YY++,,,///\\\".\n       1 binary.\n        2 ptr pic 9(4) value 1.\n        2 str-start pic 9(4) value 1.\n        2 delim-len pic 9(4) value 1.\n        2 split-str-len pic 9(4) value 0.\n        2 trash-9 pic 9(4) value 0.\n       1 delim-char pic x value space.\n       1 delim-str pic x(6) value space.\n       1 trash-x pic x.\n       procedure division.\n           display \"Requested string\"\n           set str-1 to true\n           perform split-init-and-go\n           display space\n           display \"With spaces and commas\"\n           set str-2 to true\n           perform split-init-and-go\n           stop run\n           .\n\n       split-init-and-go.\n           move 1 to ptr\n           move 0 to split-str-len\n           perform split\n           .\n\n       split.\n           perform get-split-str-len\n           display split-str (1:split-str-len)\n           perform until ptr > split-str-len\n               move ptr to str-start\n               move split-str (ptr:1) to delim-char\n               unstring split-str (1:split-str-len)\n                   delimited all delim-char\n                   into trash-x delimiter delim-str\n                   pointer ptr\n               end-unstring\n               subtract str-start from ptr giving delim-len\n               move split-str (str-start:delim-len)\n                   to delim-str (1:delim-len)\n               display delim-str (1:delim-len) with no advancing\n               if ptr <= split-str-len\n                   display \", \" with no advancing\n               end-if\n           end-perform\n           display space\n           .\n\n       get-split-str-len.\n           inspect function reverse (split-str) tallying\n               trash-9 for leading space\n               split-str-len for characters after space\n           .\n\n       end program split-ch.\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51985, "name": "Sorting algorithms_Merge sort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      MERGESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    APRIL 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n      ******************************************************************\n      *                            MERGE SORT                          *\n      *  The Merge sort uses a completely different paradigm, one of   *\n      * divide and conquer, to many of the other sorts. The data set   *\n      * is split into smaller sub sets upon which are sorted and then  *\n      * merged together to form the final sorted data set.             *\n      *  This version uses the recursive method. Split the data set in *\n      * half and perform a merge sort on each half. This in turn splits*\n      * each half again and again until each set is just one or 2 items*\n      * long. A set of one item is already sorted so is ignored, a set *\n      * of two is compared and swapped as necessary. The smaller data  *\n      * sets are then repeatedly merged together to eventually form the*\n      * full, sorted, set.                                             *\n      *  Since cobol cannot do recursion this module only simulates it *\n      * so is not as fast as a normal recursive version would be.      *\n      *  Scales very well to larger data sets, its relative complexity *\n      * means it is not suited to sorting smaller data sets: use an    *\n      * Insertion sort instead as the Merge sort is a stable sort.     *\n      ******************************************************************\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC 9(6).\n\n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC 9(6).\n\n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"MERGESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n\n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                 INDEXED BY WB-IX-1\n                                                            WB-IX-2.\n\n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-START                   PIC S9(8) COMP SYNC.\n         03  WC-MIDDLE                  PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n\n       01  WD-FIRST-HALF.\n         03  WD-FH-MAX                  PIC S9(8) COMP SYNC.\n         03  WD-ENTRY                   PIC 9(8) COMP SYNC OCCURS 50000\n                                                 INDEXED BY WD-IX.\n\n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n\n       01  WS-STACK.\n      * This stack is big enough to sort a list of 1million items.\n         03  WS-STACK-ENTRY OCCURS 20 INDEXED BY WS-STACK-TOP.\n           05  WS-START                 PIC S9(8) COMP SYNC.\n           05  WS-MIDDLE                PIC S9(8) COMP SYNC.\n           05  WS-END                   PIC S9(8) COMP SYNC.\n           05  WS-FS-FLAG               PIC X.\n             88  FIRST-HALF             VALUE \"F\".\n             88  SECOND-HALF            VALUE \"S\".\n             88  WS-ALL                 VALUE \"A\".\n           05  WS-IO-FLAG               PIC X.\n             88  WS-IN                  VALUE \"I\".\n             88  WS-OUT                 VALUE \"O\".\n\n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n\n           IF NOT EMPTY-FILE\n              PERFORM C-PROCESS.\n\n           PERFORM D-FINISH.\n\n       A-999.\n           STOP RUN.\n\n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n\n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n\n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n\n           CLOSE FA-INPUT-FILE.\n\n           SET WC-SIZE TO WB-IX-1.\n\n       B-999.\n           EXIT.\n\n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n\n       BA-999.\n           EXIT.\n\n       C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 1           TO WS-START(1).\n           MOVE WC-SIZE     TO WS-END(1).\n           MOVE \"F\"         TO WS-FS-FLAG(1).\n           MOVE \"I\"         TO WS-IO-FLAG(1).\n           SET WS-STACK-TOP TO 2.\n\n           PERFORM E-MERGE-SORT UNTIL WS-OUT(1).\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n\n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n\n           CLOSE FB-OUTPUT-FILE.\n\n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n\n       D-999.\n           EXIT.\n\n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n\n       DA-999.\n           EXIT.\n\n      ******************************************************************\n       E-MERGE-SORT SECTION.\n      *=====================                                           *\n      * This section controls the simulated recursion.                 *\n      ******************************************************************\n       E-000.\n           IF WS-OUT(WS-STACK-TOP - 1)\n              GO TO E-010. \n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n\n      * First check size of part we are dealing with.\n           IF WC-END - WC-START = 0\n      * Only 1 number in range, so simply set for output, and move on\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              GO TO E-010.\n\n           IF WC-END - WC-START = 1\n      * 2 numbers, so compare and swap as necessary. Set for output\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              IF WB-ENTRY(WC-START) > WB-ENTRY(WC-END)\n                 MOVE WB-ENTRY(WC-START) TO WC-TEMP\n                 MOVE WB-ENTRY(WC-END) TO WB-ENTRY(WC-START)\n                 MOVE WC-TEMP TO WB-ENTRY(WC-END)\n                 GO TO E-010\n              ELSE\n                 GO TO E-010.\n\n      * More than 2, so split and carry on down\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n\n           MOVE WC-START  TO WS-START(WS-STACK-TOP).\n           MOVE WC-MIDDLE TO WS-END(WS-STACK-TOP).\n           MOVE \"F\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-010.\n           SET WS-STACK-TOP DOWN BY 1.\n\n           IF SECOND-HALF(WS-STACK-TOP)\n              GO TO E-020.\n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2 + 1.\n\n           MOVE WC-MIDDLE TO WS-START(WS-STACK-TOP).\n           MOVE WC-END    TO WS-END(WS-STACK-TOP).\n           MOVE \"S\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-020.\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n           PERFORM H-PROCESS-MERGE.\n           MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1).\n\n       E-999.\n           EXIT.\n\n      ******************************************************************\n       H-PROCESS-MERGE SECTION.\n      *========================                                        *\n      * This section identifies which data is to be merged, and then   *\n      * merges the two data streams into a single larger data stream.  *\n      ******************************************************************\n       H-000.\n           INITIALISE WD-FIRST-HALF.\n           COMPUTE WD-FH-MAX = WC-MIDDLE - WC-START + 1.\n           SET WD-IX                        TO 1.\n\n           PERFORM HA-COPY-OUT VARYING WB-IX-1 FROM WC-START BY 1\n                               UNTIL WB-IX-1 > WC-MIDDLE.\n\n           SET WB-IX-1 TO WC-START.\n           SET WB-IX-2 TO WC-MIDDLE.\n           SET WB-IX-2 UP BY 1.\n           SET WD-IX   TO 1.\n          \n           PERFORM HB-MERGE UNTIL WD-IX > WD-FH-MAX OR WB-IX-2 > WC-END.\n\n           PERFORM HC-COPY-BACK UNTIL WD-IX > WD-FH-MAX.\n\n       H-999.\n           EXIT.\n\n       HA-COPY-OUT SECTION.\n       HA-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WD-ENTRY(WD-IX).\n           SET WD-IX UP BY 1.\n\n       HA-999.\n           EXIT.\n\n       HB-MERGE SECTION.\n       HB-000.\n           IF WB-ENTRY(WB-IX-2) < WD-ENTRY(WD-IX)\n              MOVE WB-ENTRY(WB-IX-2) TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-2            UP BY 1\n           ELSE\n              MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1)\n              SET WD-IX            UP BY 1.\n\n           SET WB-IX-1 UP BY 1.\n\n       HB-999.\n           EXIT.\n\n       HC-COPY-BACK SECTION.\n       HC-000.\n           MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1).\n           SET WD-IX            UP BY 1.\n           SET WB-IX-1          UP BY 1.\n\n       HC-999.\n           EXIT.\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 51986, "name": "Sorting algorithms_Merge sort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      MERGESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    APRIL 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n      ******************************************************************\n      *                            MERGE SORT                          *\n      *  The Merge sort uses a completely different paradigm, one of   *\n      * divide and conquer, to many of the other sorts. The data set   *\n      * is split into smaller sub sets upon which are sorted and then  *\n      * merged together to form the final sorted data set.             *\n      *  This version uses the recursive method. Split the data set in *\n      * half and perform a merge sort on each half. This in turn splits*\n      * each half again and again until each set is just one or 2 items*\n      * long. A set of one item is already sorted so is ignored, a set *\n      * of two is compared and swapped as necessary. The smaller data  *\n      * sets are then repeatedly merged together to eventually form the*\n      * full, sorted, set.                                             *\n      *  Since cobol cannot do recursion this module only simulates it *\n      * so is not as fast as a normal recursive version would be.      *\n      *  Scales very well to larger data sets, its relative complexity *\n      * means it is not suited to sorting smaller data sets: use an    *\n      * Insertion sort instead as the Merge sort is a stable sort.     *\n      ******************************************************************\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC 9(6).\n\n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC 9(6).\n\n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"MERGESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n\n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                 INDEXED BY WB-IX-1\n                                                            WB-IX-2.\n\n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-START                   PIC S9(8) COMP SYNC.\n         03  WC-MIDDLE                  PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n\n       01  WD-FIRST-HALF.\n         03  WD-FH-MAX                  PIC S9(8) COMP SYNC.\n         03  WD-ENTRY                   PIC 9(8) COMP SYNC OCCURS 50000\n                                                 INDEXED BY WD-IX.\n\n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n\n       01  WS-STACK.\n      * This stack is big enough to sort a list of 1million items.\n         03  WS-STACK-ENTRY OCCURS 20 INDEXED BY WS-STACK-TOP.\n           05  WS-START                 PIC S9(8) COMP SYNC.\n           05  WS-MIDDLE                PIC S9(8) COMP SYNC.\n           05  WS-END                   PIC S9(8) COMP SYNC.\n           05  WS-FS-FLAG               PIC X.\n             88  FIRST-HALF             VALUE \"F\".\n             88  SECOND-HALF            VALUE \"S\".\n             88  WS-ALL                 VALUE \"A\".\n           05  WS-IO-FLAG               PIC X.\n             88  WS-IN                  VALUE \"I\".\n             88  WS-OUT                 VALUE \"O\".\n\n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n\n           IF NOT EMPTY-FILE\n              PERFORM C-PROCESS.\n\n           PERFORM D-FINISH.\n\n       A-999.\n           STOP RUN.\n\n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n\n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n\n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n\n           CLOSE FA-INPUT-FILE.\n\n           SET WC-SIZE TO WB-IX-1.\n\n       B-999.\n           EXIT.\n\n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n\n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n\n       BA-999.\n           EXIT.\n\n       C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           MOVE 1           TO WS-START(1).\n           MOVE WC-SIZE     TO WS-END(1).\n           MOVE \"F\"         TO WS-FS-FLAG(1).\n           MOVE \"I\"         TO WS-IO-FLAG(1).\n           SET WS-STACK-TOP TO 2.\n\n           PERFORM E-MERGE-SORT UNTIL WS-OUT(1).\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n\n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n\n           CLOSE FB-OUTPUT-FILE.\n\n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n\n       D-999.\n           EXIT.\n\n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n\n       DA-999.\n           EXIT.\n\n      ******************************************************************\n       E-MERGE-SORT SECTION.\n      *=====================                                           *\n      * This section controls the simulated recursion.                 *\n      ******************************************************************\n       E-000.\n           IF WS-OUT(WS-STACK-TOP - 1)\n              GO TO E-010. \n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n\n      * First check size of part we are dealing with.\n           IF WC-END - WC-START = 0\n      * Only 1 number in range, so simply set for output, and move on\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              GO TO E-010.\n\n           IF WC-END - WC-START = 1\n      * 2 numbers, so compare and swap as necessary. Set for output\n              MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1)\n              IF WB-ENTRY(WC-START) > WB-ENTRY(WC-END)\n                 MOVE WB-ENTRY(WC-START) TO WC-TEMP\n                 MOVE WB-ENTRY(WC-END) TO WB-ENTRY(WC-START)\n                 MOVE WC-TEMP TO WB-ENTRY(WC-END)\n                 GO TO E-010\n              ELSE\n                 GO TO E-010.\n\n      * More than 2, so split and carry on down\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n\n           MOVE WC-START  TO WS-START(WS-STACK-TOP).\n           MOVE WC-MIDDLE TO WS-END(WS-STACK-TOP).\n           MOVE \"F\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-010.\n           SET WS-STACK-TOP DOWN BY 1.\n\n           IF SECOND-HALF(WS-STACK-TOP)\n              GO TO E-020.\n\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2 + 1.\n\n           MOVE WC-MIDDLE TO WS-START(WS-STACK-TOP).\n           MOVE WC-END    TO WS-END(WS-STACK-TOP).\n           MOVE \"S\"       TO WS-FS-FLAG(WS-STACK-TOP).\n           MOVE \"I\"       TO WS-IO-FLAG(WS-STACK-TOP).\n           SET WS-STACK-TOP UP BY 1.\n\n           GO TO E-999.\n\n       E-020.\n           MOVE WS-START(WS-STACK-TOP - 1) TO WC-START.\n           MOVE WS-END(WS-STACK-TOP - 1)   TO WC-END.\n           COMPUTE WC-MIDDLE = ( WC-START + WC-END ) / 2.\n           PERFORM H-PROCESS-MERGE.\n           MOVE \"O\" TO WS-IO-FLAG(WS-STACK-TOP - 1).\n\n       E-999.\n           EXIT.\n\n      ******************************************************************\n       H-PROCESS-MERGE SECTION.\n      *========================                                        *\n      * This section identifies which data is to be merged, and then   *\n      * merges the two data streams into a single larger data stream.  *\n      ******************************************************************\n       H-000.\n           INITIALISE WD-FIRST-HALF.\n           COMPUTE WD-FH-MAX = WC-MIDDLE - WC-START + 1.\n           SET WD-IX                        TO 1.\n\n           PERFORM HA-COPY-OUT VARYING WB-IX-1 FROM WC-START BY 1\n                               UNTIL WB-IX-1 > WC-MIDDLE.\n\n           SET WB-IX-1 TO WC-START.\n           SET WB-IX-2 TO WC-MIDDLE.\n           SET WB-IX-2 UP BY 1.\n           SET WD-IX   TO 1.\n          \n           PERFORM HB-MERGE UNTIL WD-IX > WD-FH-MAX OR WB-IX-2 > WC-END.\n\n           PERFORM HC-COPY-BACK UNTIL WD-IX > WD-FH-MAX.\n\n       H-999.\n           EXIT.\n\n       HA-COPY-OUT SECTION.\n       HA-000.\n           MOVE WB-ENTRY(WB-IX-1) TO WD-ENTRY(WD-IX).\n           SET WD-IX UP BY 1.\n\n       HA-999.\n           EXIT.\n\n       HB-MERGE SECTION.\n       HB-000.\n           IF WB-ENTRY(WB-IX-2) < WD-ENTRY(WD-IX)\n              MOVE WB-ENTRY(WB-IX-2) TO WB-ENTRY(WB-IX-1)\n              SET WB-IX-2            UP BY 1\n           ELSE\n              MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1)\n              SET WD-IX            UP BY 1.\n\n           SET WB-IX-1 UP BY 1.\n\n       HB-999.\n           EXIT.\n\n       HC-COPY-BACK SECTION.\n       HC-000.\n           MOVE WD-ENTRY(WD-IX) TO WB-ENTRY(WB-IX-1).\n           SET WD-IX            UP BY 1.\n           SET WB-IX-1          UP BY 1.\n\n       HC-999.\n           EXIT.\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52671, "name": "Word frequency", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52672, "name": "Word frequency", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52675, "name": "Word frequency", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52676, "name": "Word frequency", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52677, "name": "Word frequency", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 52678, "name": "Word frequency", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. WordFrequency.\n       AUTHOR.  Bill Gunshannon.\n       DATE-WRITTEN.  30 Jan 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Given a text file and an integer n, print the n most\n      **   common words in the file (and the number of their\n      **   occurrences) in decreasing frequency.\n      **\n      **   A file named Parameter.txt provides this information.\n      **   Format is:\n      **   12345678901234567890123456789012345678901234567890\n      **   |------------------|----|\n      **     ^^^^^^^^^^^^^^^^  ^^^^\n      **          |              |\n      **     Source Text File   Number of words with count\n      **       20 Characters      5 digits with leading zeroes\n      **\n      **\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Parameter-File ASSIGN TO \"Parameter.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Input-File ASSIGN TO Source-Text\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Word-File ASSIGN TO \"Word.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Output-File ASSIGN TO \"Output.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Print-File ASSIGN TO \"Printer.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n            SELECT Sort-File     ASSIGN TO DISK.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Parameter-File\n           DATA RECORD IS Parameter-Record.\n       01  Parameter-Record.\n           05 Source-Text               PIC X(20).\n           05 How-Many                  PIC 99999.\n\n       FD  Input-File\n           DATA RECORD IS Input-Record.\n       01  Input-Record.\n           05 Input-Line                PIC X(80).\n\n       FD  Word-File\n           DATA RECORD IS Word-Record.\n       01  Word-Record.\n           05 Input-Word               PIC X(20).\n\n       FD  Output-File\n           DATA RECORD IS Output-Rec.\n       01  Output-Rec.\n           05  Output-Rec-Word         PIC X(20).\n           05  Output-Rec-Word-Cnt     PIC 9(5).\n\n       FD  Print-File\n           DATA RECORD IS Print-Rec.\n       01  Print-Rec.\n           05  Print-Rec-Word          PIC X(20).\n           05  Print-Rec-Word-Cnt      PIC 9(5).\n       \n       SD  Sort-File.\n       01  Sort-Rec.\n           05  Sort-Word               PIC X(20).\n           05  Sort-Word-Cnt           PIC 9(5).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                    PIC X     VALUE 'F'.\n       01 InLine                 PIC X(80).\n       01 Word1                  PIC X(20).\n       01 Current-Word           PIC X(20).\n       01 Current-Word-Cnt       PIC 9(5).\n       01 Pos                    PIC 99\n                 VALUE 1.\n       01 Cnt                    PIC 99.\n       01 Report-Rank.\n          05  IRank              PIC 99999\n                 VALUE 1.\n          05 Rank                PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n      **\n      **  Read the Parameters\n      **\n         OPEN INPUT Parameter-File.\n         READ Parameter-File.\n         CLOSE Parameter-File.\n\n      **\n      **  Open Files for first stage\n      **\n         OPEN INPUT  Input-File.\n         OPEN OUTPUT  Word-File.\n\n      **\n      **  Pare\\se the Source Text into a file of invidual words\n      **\n         PERFORM UNTIL Eof = 'T'\n            READ Input-File \n               AT END MOVE 'T' TO Eof\n            END-READ\n\n         PERFORM Parse-a-Words\n\n         MOVE SPACES TO Input-Record\n         MOVE 1 TO Pos\n         END-PERFORM.\n     \n      **\n      **  Cleanup from the first stage\n      **\n         CLOSE Input-File Word-File\n\n      **\n      **  Sort the individual words in alphabetical order\n      **\n         SORT Sort-File\n              ON ASCENDING KEY Sort-Word\n              USING Word-File\n              GIVING Word-File.\n\n      **\n      **  Count each time a word is used\n      **\n         PERFORM Collect-Totals.\n\n      **\n      **  Sort data by number of usages per word\n      **\n         SORT Sort-File\n              ON DESCENDING KEY Sort-Word-Cnt\n              USING Output-File\n              GIVING Print-File.\n\n      **\n      **  Show the work done\n      **\n         OPEN INPUT Print-File.\n            DISPLAY \" Rank  Word               Frequency\"\n         PERFORM How-Many TIMES\n            READ Print-File\n            MOVE IRank TO Rank\n            DISPLAY Rank \"  \" Print-Rec\n            ADD 1 TO IRank\n         END-PERFORM.\n\n      **\n      **  Cleanup\n      **\n         CLOSE Print-File.\n         CALL \"C$DELETE\" USING \"Word.txt\" ,0\n         CALL \"C$DELETE\" USING \"Output.txt\" ,0\n\n         STOP RUN.\n         \n\n        Parse-a-Words.\n          INSPECT Input-Record CONVERTING '-.,\"();:/[]{}!?|' TO SPACE \n          PERFORM UNTIL Pos > FUNCTION STORED-CHAR-LENGTH(Input-Record) \n\n\n          UNSTRING Input-Record DELIMITED BY SPACE INTO Word1 \n                    WITH POINTER Pos TALLYING IN Cnt \n          MOVE FUNCTION TRIM(FUNCTION LOWER-CASE(Word1)) TO Word-Record\n          \n          IF Word-Record NOT EQUAL SPACES AND Word-Record IS ALPHABETIC\n             THEN WRITE Word-Record\n          END-IF\n\n          END-PERFORM.\n\n       Collect-Totals.\n          MOVE 'F' to Eof\n          OPEN INPUT Word-File\n          OPEN OUTPUT Output-File\n             READ Word-File\n             MOVE Input-Word TO Current-Word\n             MOVE 1 to Current-Word-Cnt\n          PERFORM UNTIL Eof = 'T'\n             READ Word-File\n                AT END MOVE 'T' TO Eof\n             END-READ\n\n             IF FUNCTION TRIM(Word-Record) \n                    EQUAL \n                           FUNCTION TRIM(Current-Word)\n                THEN\n                     ADD 1 to Current-Word-Cnt\n                ELSE\n                     MOVE Current-Word TO Output-Rec-Word\n                     MOVE Current-Word-Cnt TO Output-Rec-Word-Cnt\n                     WRITE Output-Rec\n                     MOVE 1 to Current-Word-Cnt\n                     MOVE Word-Record TO Current-Word\n                     MOVE SPACES TO Input-Record\n            END-IF \n           \n          END-PERFORM.\n          CLOSE Word-File Output-File.\n       END-PROGRAM.\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 53472, "name": "Pick random element", "source": "Translate COBOL to C#:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53474, "name": "Pick random element", "source": "Translate COBOL to Java:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53475, "name": "Pick random element", "source": "Translate COBOL to Python:        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. random-element.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"123456789\".\n    03  nums                            PIC 9 OCCURS 9 TIMES.\n    \n01  random-idx                          PIC 9 COMP.\n    \nPROCEDURE DIVISION.\n    COMPUTE random-idx = FUNCTION RANDOM(FUNCTION CURRENT-DATE (9:7)) * 9 + 1\n    DISPLAY nums (random-idx)\n    .\nEND PROGRAM random-element.\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 54005, "name": "Greatest element of a list", "source": "Translate COBOL to C#: DISPLAY FUNCTION MAX(nums (ALL))\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 54007, "name": "Greatest element of a list", "source": "Translate COBOL to Java: DISPLAY FUNCTION MAX(nums (ALL))\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 54671, "name": "Binary digits", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54673, "name": "Binary digits", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54674, "name": "Binary digits", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 55292, "name": "Create an HTML table", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55293, "name": "Create an HTML table", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "using System;\nusing System.Text;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\tRandom rnd = new Random();\n\t\t\t\n\t\t\ts.AppendLine(\"<table>\");\n\t\t\ts.AppendLine(\"<thead align = \\\"right\\\">\");\n\t\t\ts.Append(\"<tr><th></th>\");\n\t\t\tfor(int i=0; i<3; i++)\n\t\t\t\ts.Append(\"<td>\" + \"XYZ\"[i] + \"</td>\");\n\t\t\ts.AppendLine(\"</tr>\");\n\t\t\ts.AppendLine(\"</thead>\");\n\t\t\ts.AppendLine(\"<tbody align = \\\"right\\\">\");\n\t\t\tfor( int i=0; i<3; i++ )\n\t\t\t{\n\t\t\t\ts.Append(\"<tr><td>\"+i+\"</td>\");\n\t\t\t\tfor( int j=0; j<3; j++ )\n\t\t\t\t\ts.Append(\"<td>\"+rnd.Next(10000)+\"</td>\");\t\t\t\t\n\t\t\t\ts.AppendLine(\"</tr>\");\n\t\t\t}\n\t\t\ts.AppendLine(\"</tbody>\");\n\t\t\ts.AppendLine(\"</table>\");\n\t\t\t\n\t\t\tConsole.WriteLine( s );\n\t\t}\n\t}\n}\n"}
{"id": 55296, "name": "Create an HTML table", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55297, "name": "Create an HTML table", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "public class HTML {\n\n\tpublic static String array2HTML(Object[][] array){\n\t\tStringBuilder html = new StringBuilder(\n\t\t\t\t\"<table>\");\n\t\tfor(Object elem:array[0]){\n\t\t\thtml.append(\"<th>\" + elem.toString() + \"</th>\");\n\t\t}\n\t\tfor(int i = 1; i < array.length; i++){\n\t\t\tObject[] row = array[i];\n\t\t\thtml.append(\"<tr>\");\n\t\t\tfor(Object elem:row){\n\t\t\t\thtml.append(\"<td>\" + elem.toString() + \"</td>\");\n\t\t\t}\n\t\t\thtml.append(\"</tr>\");\n\t\t}\n\t\thtml.append(\"</table>\");\n\t\treturn html.toString();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tObject[][] ints = {{\"\",\"X\",\"Y\",\"Z\"},{1,1,2,3},{2,4,5,6},{3,7,8,9},{4,10,11,12}};\n\t\tSystem.out.println(array2HTML(ints));\n\t}\n}\n"}
{"id": 55298, "name": "Create an HTML table", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55299, "name": "Create an HTML table", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Table.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  1 January 2022.\n      ************************************************************\n      ** Program Abstract:\n      **   Data values are hardcoded in this example but they\n      **     could come from anywhere.  Computed, read from a\n      **     file, input from the keyboard.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Table-File ASSIGN TO \"index.html\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Table-File\n           DATA RECORD IS Table-Record.\n       01  Table-Record.\n           05 Field1                  PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Table-Data.\n           05  Line3.\n               10  Line3-Value1  PIC S9(4)  VALUE  1234.\n               10  Line3-Value2  PIC S9(4)  VALUE  23.\n               10  Line3-Value3  PIC S9(4)  VALUE  -123.\n           05  Line4.\n               10  Line4-Value1  PIC S9(4)  VALUE  123.\n               10  Line4-Value2  PIC S9(4)  VALUE  12.\n               10  Line4-Value3  PIC S9(4)  VALUE  -1234.\n           05  Line5.\n               10  Line5-Value1  PIC S9(4)  VALUE  567.\n               10  Line5-Value2  PIC S9(4)  VALUE  6789.\n               10  Line5-Value3  PIC S9(4)  VALUE  3.\n\n       \n       01  Table-HTML.\n           05  Line1  PIC X(16)  VALUE\n               \"<table border=1>\".\n           05  Line2  PIC X(40)  VALUE\n               \"<th></th><th>X</th><th>Y</th><th>Z</th>\".\n           05  Line3.\n               10  Line3-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>1</th><td>\".\n               10  Line3-Value1   PIC -ZZZ9.\n               10  Line3-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value2   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line3-Value3   PIC -ZZZ9.\n               10  Line3-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line4.\n               10  Line4-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>2</th><td>\".\n               10  Line4-Value1   PIC -ZZZ9.\n               10  Line4-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value2   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line4-Value3   PIC -ZZZ9.\n               10  Line4-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line5.\n               10  Line5-Field1  PIC X(31)  VALUE\n                   \"<tr align=center><th>3</th><td>\".\n               10  Line5-Value1   PIC -ZZZ9.\n               10  Line5-Field3  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value2   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(9)  VALUE\n                   \"</td><td>\".\n               10  Line5-Value3   PIC -ZZZ9.\n               10  Line5-Field5  PIC X(10)  VALUE\n                   \"</td></tr>\".\n           05  Line6  PIC X(8)  VALUE\n               \"</table>\".\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN OUTPUT Table-File.\n           MOVE CORRESPONDING Table-Data TO Table-HTML.\n           PERFORM Write-Table.\n           CLOSE Table-File.\n           STOP RUN.\n       \n       \n       Write-Table.\n           WRITE Table-Record FROM Line1 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line2 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line3 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line4 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line5 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n           WRITE Table-Record FROM Line6 OF Table-HTML\n                              AFTER  ADVANCING 1 LINE.\n          \n       \n       END-PROGRAM.\n", "target": "import random\n\ndef rand9999():\n    return random.randint(1000, 9999)\n\ndef tag(attr='', **kwargs):\n    for tag, txt in kwargs.items():\n        return '<{tag}{attr}>{txt}</{tag}>'.format(**locals())\n\nif __name__ == '__main__':\n    header = tag(tr=''.join(tag(th=txt) for txt in ',X,Y,Z'.split(','))) + '\\n'\n    rows = '\\n'.join(tag(tr=tag(' style=\"font-weight: bold;\"', td=i)\n                                    + ''.join(tag(td=rand9999())\n                                              for j in range(3)))\n                     for i in range(1, 6))\n    table = tag(table='\\n' + header + rows + '\\n')\n    print(table)\n"}
{"id": 55944, "name": "Conditional structures", "source": "Translate COBOL to C#: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if (condition)\n{\n   \n}\n\nif (condition)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}\n"}
{"id": 55946, "name": "Conditional structures", "source": "Translate COBOL to Java: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if (s == 'Hello World') {\n    foo();\n} else if (s == 'Bye World') {\n    bar();\n} else {\n    deusEx();\n}\n"}
{"id": 55947, "name": "Conditional structures", "source": "Translate COBOL to Python: if condition-1\n    imperative-statement-1\nelse\n    imperative-statement-2\nend-if\n\nif condition-1\n    if condition-a\n        imperative-statement-1a\n    else\n        imperative-statement-1\n    end-if\nelse\n    if condition-a\n        imperative-statement-2a\n    else\n        imperative-statement-2\n    end-if\nend-if\n", "target": "if x == 0:\n    foo()\nelif x == 1:\n    bar()\nelif x == 2:\n    baz()\nelse:\n    qux()\n\nmatch x:\n    0 => foo()\n    1 => bar()\n    2 => baz()\n    _ => qux()\n\n(a) ? b : c\n"}
{"id": 56155, "name": "Align columns", "source": "Translate COBOL to C#:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56156, "name": "Align columns", "source": "Translate COBOL to Java:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56157, "name": "Align columns", "source": "Translate COBOL to Python:        identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      \n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      \n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      \n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      \n       01 w-line-out              pic is x(120).\n      \n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 57029, "name": "Real constants and functions", "source": "Translate COBOL to C#: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 57031, "name": "Real constants and functions", "source": "Translate COBOL to Java: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 57032, "name": "Real constants and functions", "source": "Translate COBOL to Python: E          \nPI         \nSQRT(n)    \nLOG(n)     \nLOG10(n)   \nEXP(n)     \nABS(n)     \nINTEGER(n) \n\nADD 1 TO N\nMOVE INTEGER(N) TO Result\n\nCOMPUTE Result = N ** 2\n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57513, "name": "System time", "source": "Translate COBOL to C#:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "Console.WriteLine(DateTime.Now);\n"}
{"id": 57515, "name": "System time", "source": "Translate COBOL to Java:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57516, "name": "System time", "source": "Translate COBOL to Python:        WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE-FIELDS.\n           05  WS-CURRENT-DATE.\n               10  WS-CURRENT-YEAR    PIC  9(4).\n               10  WS-CURRENT-MONTH   PIC  9(2).\n               10  WS-CURRENT-DAY     PIC  9(2).\n           05  WS-CURRENT-TIME.\n               10  WS-CURRENT-HOUR    PIC  9(2).\n               10  WS-CURRENT-MINUTE  PIC  9(2).\n               10  WS-CURRENT-SECOND  PIC  9(2).\n               10  WS-CURRENT-MS      PIC  9(2).\n           05  WS-DIFF-FROM-GMT       PIC S9(4).\n \n       PROCEDURE DIVISION.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE-FIELDS.\n", "target": "import time\nprint time.ctime()\n"}
{"id": 58862, "name": "Box the compass", "source": "Translate COBOL to C#:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58863, "name": "Box the compass", "source": "Translate COBOL to C#:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58866, "name": "Box the compass", "source": "Translate COBOL to Java:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58867, "name": "Box the compass", "source": "Translate COBOL to Java:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58868, "name": "Box the compass", "source": "Translate COBOL to Python:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 58869, "name": "Box the compass", "source": "Translate COBOL to Python:        identification division.\n       program-id. box-compass.\n       data division.\n       working-storage section.\n       01 point                pic 99.\n       01 degrees              usage float-short.\n       01 degrees-rounded      pic 999v99.\n       01 show-degrees         pic zz9.99.\n       01 box                  pic z9.\n       01 fudge                pic 9.\n       01 compass              pic x(4).\n       01 compass-point        pic x(18).\n       01 shortform            pic x.\n       01 short-names.\n          05 short-name        pic x(4) occurs 33 times.\n       01 overlay.\n          05 value \"N   \" & \"NbE \" & \"N-NE\" & \"NEbN\" & \"NE  \" &\n                   \"NEbE\" & \"E-NE\" & \"EbN \" & \"E   \" & \"EbS \" &\n                   \"E-SE\" & \"SEbE\" & \"SE  \" & \"SEbS\" & \"S-SE\" &\n                   \"SbE \" & \"S   \" & \"SbW \" & \"S-SW\" & \"SWbS\" &\n                   \"SW  \" & \"SWbW\" & \"W-SW\" & \"WbS \" & \"W   \" &\n                   \"WbN \" & \"W-NW\" & \"NWbW\" & \"NW  \" & \"NWbN\" &\n                   \"N-NW\" & \"NbW \" & \"N   \".\n\n       procedure division.\n       display \"Index Compass point      Degree\"\n\n       move overlay to short-names.\n       perform varying point from 0 by 1 until point > 32\n           compute box = function mod(point 32) + 1\n           compute degrees = point * 11.25\n           compute fudge = function mod(point 3)\n           evaluate fudge\n              when equal 1\n                  add 5.62 to degrees\n              when equal 2\n                  subtract 5.62 from degrees\n           end-evaluate\n\n           compute degrees-rounded rounded = degrees\n           move degrees-rounded to show-degrees\n           inspect show-degrees replacing trailing '00' by '0 '\n           inspect show-degrees replacing trailing '50' by '5 '\n\n           move short-name(point + 1) to compass\n           move spaces to compass-point\n           display space box space space space with no advancing\n           perform varying tally from 1 by 1 until tally > 4\n               move compass(tally:1) to shortform\n               move function concatenate(function trim(compass-point),\n                    function substitute(shortform,\n                        \"N\", \"North\",\n                        \"E\", \"East\",\n                        \"S\", \"South\",\n                        \"W\", \"West\",\n                        \"b\", \" byZ\",\n                        \"-\", \"-\"))\n                 to compass-point\n           end-perform\n           move function substitute(compass-point, \"Z\", \" \")\n             to compass-point\n           move function lower-case(compass-point) to compass-point\n           move function upper-case(compass-point(1:1))\n             to compass-point(1:1)\n           display compass-point space show-degrees\n       end-perform\n       goback.\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 59918, "name": "99 bottles of beer", "source": "Translate COBOL to C#: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59919, "name": "99 bottles of beer", "source": "Translate COBOL to C#: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59922, "name": "99 bottles of beer", "source": "Translate COBOL to Java: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59923, "name": "99 bottles of beer", "source": "Translate COBOL to Java: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59924, "name": "99 bottles of beer", "source": "Translate COBOL to Python: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59925, "name": "99 bottles of beer", "source": "Translate COBOL to Python: identification division.\nprogram-id. ninety-nine.\nenvironment division.\ndata division.\nworking-storage section.\n01\tcounter\tpic 99.\n\t88 no-bottles-left value 0.\n\t88 one-bottle-left value 1.\n\n01\tparts-of-counter redefines counter.\n\t05\ttens\t\tpic 9.\n\t05\tdigits\t\tpic 9.\n\n01\tafter-ten-words.\n\t05\tfiller\tpic x(7) value spaces.\n\t05\tfiller\tpic x(7) value \"Twenty\".\n\t05\tfiller\tpic x(7) value \"Thirty\".\n\t05\tfiller\tpic x(7) value \"Forty\".\n\t05\tfiller\tpic x(7) value \"Fifty\".\n\t05\tfiller\tpic x(7) value \"Sixty\".\n\t05\tfiller\tpic x(7) value \"Seventy\".\n\t05\tfiller\tpic x(7) value \"Eighty\".\n\t05\tfiller\tpic x(7) value \"Ninety\".\n\t05\tfiller\tpic x(7) value spaces.\n\n01\tafter-ten-array redefines after-ten-words.\n\t05\tatens occurs 10 times pic x(7).\n\n01\tdigit-words.\n\t05\tfiller\tpic x(9) value \"One\".\n\t05\tfiller\tpic x(9) value \"Two\".\n\t05\tfiller\tpic x(9) value \"Three\".\n\t05\tfiller\tpic x(9) value \"Four\".\n\t05\tfiller\tpic x(9) value \"Five\".\n\t05\tfiller\tpic x(9) value \"Six\".\n\t05\tfiller\tpic x(9) value \"Seven\".\n\t05\tfiller\tpic x(9) value \"Eight\".\n\t05\tfiller\tpic x(9) value \"Nine\".\n\t05\tfiller\tpic x(9) value \"Ten\".\n\t05\tfiller\tpic x(9) value \"Eleven\".\n\t05\tfiller\tpic x(9) value \"Twelve\".\n\t05\tfiller\tpic x(9) value \"Thirteen\".\n\t05\tfiller\tpic x(9) value \"Fourteen\".\n\t05\tfiller\tpic x(9) value \"Fifteen\".\n\t05\tfiller\tpic x(9) value \"Sixteen\".\n\t05\tfiller\tpic x(9) value \"Seventeen\".\n\t05\tfiller\tpic x(9) value \"Eighteen\".\n\t05\tfiller\tpic x(9) value \"Nineteen\".\n\t05\tfiller\tpic x(9) value spaces.\n\t\n01\tdigit-array redefines digit-words.\n\t05\tadigits occurs 20 times \tpic x(9).\n\t\n01\tnumber-name pic x(15).\n\nprocedure division.\n100-main section.\n100-setup.\n\tperform varying counter from 99 by -1 until no-bottles-left\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tperform 100-show-number\n\t\tdisplay \" of beer\"\n\t\tdisplay \"Take \" with no advancing\n\t\tif one-bottle-left \n\t\t\tdisplay \"it \" with no advancing\n\t\telse\n\t\t\tdisplay \"one \" with no advancing\n\t\tend-if\n\t\tdisplay \"down and pass it round\"\n\t\tsubtract 1 from counter giving counter\n\t\tperform 100-show-number\n\t\tdisplay \" of beer on the wall\"\n\t\tadd 1 to counter giving counter\n\t\tdisplay space\n\tend-perform.\n\tdisplay \"No more bottles of beer on the wall\"\n\tdisplay \"No more bottles of beer\"\n\tdisplay \"Go to the store and buy some more\"\n\tdisplay \"Ninety Nine bottles of beer on the wall\"\n\tstop run.\n\t\n100-show-number.\n\tif no-bottles-left \n\t\tdisplay \"No more\" with no advancing\n\telse \n\t\tif counter < 20\n\t\t\tdisplay function trim( adigits( counter ) ) with no advancing\n\t\telse \n\t\t\tif counter < 100\n\t\t\t\tmove spaces to number-name\n\t\t\t\tstring atens( tens ) delimited by space, space delimited by size, adigits( digits ) delimited by space into number-name\n\t\t\t\tdisplay function trim( number-name) with no advancing\n\t\t\tend-if\n\t\tend-if\n\tend-if.\n\tif one-bottle-left\n\t\tdisplay \" bottle\" with no advancing\n\telse\n\t\tdisplay \" bottles\" with no advancing\n\tend-if.\n\n100-end.\nend-program.\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60452, "name": "Strip a set of characters from a string", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60454, "name": "Strip a set of characters from a string", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60455, "name": "Strip a set of characters from a string", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Strip-Chars.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Str-Size  CONSTANT 128.\n\n       LOCAL-STORAGE SECTION.\n       01  I       PIC 999.\n       01  Str-Pos PIC 999.\n\n       01  Offset  PIC 999.\n       01  New-Pos PIC 999.\n\n       01  Str-End PIC 999.\n\n       LINKAGE SECTION.\n       01  Str     PIC X(Str-Size).\n       01  Chars-To-Replace PIC X(256).\n\n       PROCEDURE DIVISION USING Str BY VALUE Chars-To-Replace.\n       Main.\n           PERFORM VARYING I FROM 1 BY 1\n                   UNTIL Chars-To-Replace (I:1) = X\"00\"\n\n               MOVE ZERO TO Offset\n\n*              \n*              \n               PERFORM VARYING Str-Pos FROM 1 BY 1\n                       UNTIL Str-Size < Str-Pos\n                   IF Str (Str-Pos:1) = Chars-To-Replace (I:1)\n                       ADD 1 TO Offset\n                   ELSE IF Offset NOT = ZERO\n                       COMPUTE New-Pos = Str-Pos - Offset\n                       MOVE Str (Str-Pos:1) TO Str (New-Pos:1)\n                   END-IF\n               END-PERFORM\n               \n*              \n*              \n               COMPUTE Str-End = Str-Size - Offset\n               MOVE SPACES TO Str (Str-End:Offset)\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60799, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60800, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60803, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60804, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60805, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60806, "name": "Isqrt (integer square root) of X", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. I-SQRT.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 QUAD-RET-VARS.\n          03 X          PIC 9(18).\n          03 Q          PIC 9(18).\n          03 Z          PIC 9(18).\n          03 T          PIC S9(18).\n          03 R          PIC 9(18).\n\n       01 TO-65-VARS.\n          03 ISQRT-N    PIC 99.\n          03 DISP-LN    PIC X(22) VALUE SPACES.\n          03 DISP-FMT   PIC Z9.\n          03 PTR        PIC 99 VALUE 1.\n\n       01 BIG-SQRT-VARS.\n          03 POW-7      PIC 9(18) VALUE 7.\n          03 POW-N      PIC 99 VALUE 1.\n          03 POW-N-OUT  PIC Z9.\n          03 POW-7-OUT  PIC Z(10).\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           PERFORM SQRTS-TO-65.\n           PERFORM BIG-SQRTS.\n           STOP RUN.\n\n       SQRTS-TO-65.\n           PERFORM DISP-SMALL-SQRT\n           VARYING ISQRT-N FROM 0 BY 1\n           UNTIL ISQRT-N IS GREATER THAN 65.\n\n       DISP-SMALL-SQRT.\n           MOVE ISQRT-N TO X.\n           PERFORM ISQRT.\n           MOVE R TO DISP-FMT.\n           STRING DISP-FMT DELIMITED BY SIZE INTO DISP-LN \n           WITH POINTER PTR.\n           IF PTR IS GREATER THAN 22, \n               DISPLAY DISP-LN, \n               MOVE 1 TO PTR.\n\n       BIG-SQRTS.\n           PERFORM BIG-SQRT 10 TIMES.\n \n       BIG-SQRT.\n           MOVE POW-7 TO X.\n           PERFORM ISQRT.\n           MOVE POW-N TO POW-N-OUT. \n           MOVE R TO POW-7-OUT. \n           DISPLAY \"ISQRT(7^\" POW-N-OUT \") = \" POW-7-OUT.\n           ADD 2 TO POW-N.\n           MULTIPLY 49 BY POW-7.\n\n       ISQRT.\n           MOVE 1 TO Q.\n           PERFORM MUL-Q-BY-4 UNTIL Q IS GREATER THAN X.\n           MOVE X TO Z.\n           MOVE ZERO TO R.\n           PERFORM ISQRT-STEP UNTIL Q IS NOT GREATER THAN 1. \n\n       MUL-Q-BY-4.\n           MULTIPLY 4 BY Q.\n\n       ISQRT-STEP.\n           DIVIDE 4 INTO Q.\n           COMPUTE T = Z - R - Q.\n           DIVIDE 2 INTO R.\n           IF T IS NOT LESS THAN ZERO,\n               MOVE T TO Z,\n               ADD Q TO R.\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61413, "name": "Factorial", "source": "Translate COBOL to C#: MOVE FUNCTION FACTORIAL(num) TO result\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61415, "name": "Factorial", "source": "Translate COBOL to Java: MOVE FUNCTION FACTORIAL(num) TO result\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61856, "name": "Menu", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61858, "name": "Menu", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61859, "name": "Menu", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Test-Prompt-Menu.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01  Num-Options    USAGE UNSIGNED-INT VALUE 4.\n       01  Example-Menu.\n           03  Example-Options-Data.\n               05  FILLER PIC X(30) VALUE \"fee fie\".\n               05  FILLER PIC X(30) VALUE \"huff and puff\".\n               05  FILLER PIC X(30) VALUE \"mirror mirror\".\n               05  FILLER PIC X(30) VALUE \"tick tock\".\n\n           03  Example-Options-Values REDEFINES Example-Options-Data.\n               05  Example-Options PIC X(30) OCCURS 4 TIMES.\n\n       01  Chosen-Option PIC X(30).\n\n       PROCEDURE DIVISION.\n           CALL \"Prompt-Menu\" USING BY CONTENT Num-Options\n               BY CONTENT Example-Menu\n               BY REFERENCE Chosen-Option\n\n           DISPLAY \"You chose: \" Chosen-Option\n\n           GOBACK\n           .\n\n       END PROGRAM Test-Prompt-Menu.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Prompt-Menu.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  User-Input        USAGE UNSIGNED-INT.\n       01  Input-Flag        PIC X.\n           88  Valid-Input   VALUE \"Y\".\n\n       01  Options-Index     USAGE UNSIGNED-INT.\n       01  Index-Display     PIC Z(10).\n\n       LINKAGE SECTION.\n\n       01  Num-Options       USAGE UNSIGNED-INT.\n       01  Menu-Options.\n           03  Options-Table PIC X(30) OCCURS 0 TO 10000000 TIMES\n               DEPENDING ON Num-Options.\n\n       01  Chosen-Option     PIC X(30).\n\n       PROCEDURE DIVISION USING Num-Options Menu-Options Chosen-Option.\n       Main.\n           IF Num-Options = 0\n               MOVE SPACES TO Chosen-Option\n               GOBACK\n           END-IF\n\n           PERFORM UNTIL Valid-Input\n               PERFORM Display-Menu-Options\n\n               DISPLAY \"Choose an option: \" WITH NO ADVANCING\n               ACCEPT User-Input\n\n               PERFORM Validate-Input\n           END-PERFORM\n\n           MOVE Options-Table (User-Input) TO Chosen-Option\n\n           GOBACK\n           .\n\n       Display-Menu-Options.\n           PERFORM VARYING Options-Index FROM 1 BY 1\n                   UNTIL Num-Options < Options-Index\n               MOVE Options-Index TO Index-Display\n               DISPLAY\n                   Index-Display \". \" Options-Table (Options-Index)\n               END-DISPLAY\n           END-PERFORM\n           .\n\n       Validate-Input.\n           IF User-Input = 0 OR > Num-Options\n               DISPLAY \"Invalid input.\"\n           ELSE\n               SET Valid-Input TO TRUE\n           END-IF\n           .\n\n       END PROGRAM Prompt-Menu.\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62770, "name": "Integer sequence", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62771, "name": "Integer sequence", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62774, "name": "Integer sequence", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62775, "name": "Integer sequence", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62776, "name": "Integer sequence", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62777, "name": "Integer sequence", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Sequence.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n*      \n       01  I PIC 9(36).\n\n       PROCEDURE DIVISION.\n*          \n           PERFORM VARYING I FROM 1 BY 1 UNTIL I = 0\n               DISPLAY I\n           END-PERFORM\n\n           GOBACK\n           .\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 63061, "name": "Fibonacci sequence", "source": "Translate COBOL to C#: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 63063, "name": "Fibonacci sequence", "source": "Translate COBOL to Java: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 63064, "name": "Fibonacci sequence", "source": "Translate COBOL to Python: Program-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63341, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to C#: FUNCTION MEAN(some-table (ALL))\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63343, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to Java: FUNCTION MEAN(some-table (ALL))\n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63344, "name": "Averages_Arithmetic mean", "source": "Translate COBOL to Python: FUNCTION MEAN(some-table (ALL))\n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63920, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "class Program\n{\n    static void Main()\n    {\n        System.Console.WriteLine(\"\u00a3\");\n    }\n}\n"}
{"id": 63922, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "import java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        PrintStream writer = new PrintStream(System.out, true, \"UTF-8\");\n        writer.println(\"\u00a3\");\n        writer.println(\"\u672d\u5e4c\");\n    }\n}\n"}
{"id": 63923, "name": "Terminal control_Display an extended character", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. Display-Pound.\n\n       PROCEDURE DIVISION.\n       DISPLAY \"\u00a3\"\n\n       GOBACK\n       .\n", "target": "print u'\\u00a3'\n"}
{"id": 64154, "name": "Julia set", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64155, "name": "Julia set", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64158, "name": "Julia set", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64159, "name": "Julia set", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64160, "name": "Julia set", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64161, "name": "Julia set", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. JULIA-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-COMPLEX-CONSTANT.\n    05 C-REAL             PIC S9V999.\n    05 C-IMAGINARY        PIC S9V999.\n01  WS-ARGAND-PLANE.\n    05 X                  PIC S9(9)V999.\n    05 Y                  PIC S9(9)V999.\n01  WS-COMPLEX-VARIABLE.\n    05 Z-REAL             PIC S9(9)V999.\n    05 Z-IMAGINARY        PIC S9(9)V999.\n01  WS-TEMPORARY-RESULTS.\n    05 X-SQUARED          PIC S9(9)V999.\n    05 Y-SQUARED          PIC S9(9)V999.\n    05 X-TIMES-Y          PIC S9(9)V999.\n    05 Z-REAL-SQUARED     PIC S9(9)V999.\n01  WS-LOOP-COUNTERS.\n    05 HORIZONTAL         PIC 999.\n    05 VERTICAL           PIC 999.\n    05 ITERATIONS         PIC 99.\n77  WS-PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nINPUT-COMPLEX-CONSTANT-PARAGRAPH.\n    ACCEPT C-REAL      FROM CONSOLE.\n    ACCEPT C-IMAGINARY FROM CONSOLE.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH  VARYING VERTICAL   FROM 1 BY 10\n    UNTIL VERTICAL IS GREATER THAN 320.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM COMPUTATION-PARAGRAPH VARYING HORIZONTAL FROM 1 BY 10\n    UNTIL HORIZONTAL IS GREATER THAN 560.\n    DISPLAY '' UPON CONSOLE.\nCOMPUTATION-PARAGRAPH.\n    SUBTRACT 280   FROM HORIZONTAL GIVING X.\n    SUBTRACT 160   FROM VERTICAL   GIVING Y.\n    DIVIDE   X     BY   200        GIVING X.\n    DIVIDE   Y     BY   100        GIVING Y.\n    MOVE     '#'   TO   WS-PLOT-CHARACTER.\n    PERFORM COMPLEX-MULTIPLICATION-PARAGRAPH\n    VARYING ITERATIONS FROM   1  BY      1\n    UNTIL   ITERATIONS        IS GREATER THAN 50\n    OR      WS-PLOT-CHARACTER IS EQUAL   TO   SPACE.\n    DISPLAY WS-PLOT-CHARACTER UPON CONSOLE WITH NO ADVANCING.\nCOMPLEX-MULTIPLICATION-PARAGRAPH.\n    MULTIPLY X         BY   X         GIVING X-SQUARED.\n    MULTIPLY Y         BY   Y         GIVING Y-SQUARED.\n    SUBTRACT Y-SQUARED FROM X-SQUARED GIVING Z-REAL.\n    ADD      C-REAL    TO   Z-REAL.\n    MULTIPLY X         BY   Y         GIVING X-TIMES-Y.\n    MULTIPLY X-TIMES-Y BY   2         GIVING Z-IMAGINARY.\n    ADD C-IMAGINARY    TO   Z-IMAGINARY.\n    MULTIPLY Z-REAL    BY   Z-REAL    GIVING Z-REAL-SQUARED.\n    IF  Z-REAL-SQUARED IS   GREATER   THAN   10000 THEN\n    MOVE SPACE         TO   WS-PLOT-CHARACTER.\n    MOVE Z-REAL        TO   X.\n    MOVE Z-IMAGINARY   TO   Y.\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64596, "name": "Calculating the value of e", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64597, "name": "Calculating the value of e", "source": "Translate COBOL to C#:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64600, "name": "Calculating the value of e", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64601, "name": "Calculating the value of e", "source": "Translate COBOL to Java:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64602, "name": "Calculating the value of e", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64603, "name": "Calculating the value of e", "source": "Translate COBOL to Python:        >>SOURCE FORMAT IS FIXED\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EULER.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n           01 EPSILON USAGE COMPUTATIONAL-2 VALUE 1.0E-15.\n           01 FACT USAGE BINARY-DOUBLE UNSIGNED VALUE 1.\n           01 N USAGE BINARY-INT UNSIGNED.\n           01 E USAGE COMPUTATIONAL-2 VALUE 2.0.\n           01 E0 USAGE COMPUTATIONAL-2 value 0.0.\n           01 RESULT-MESSAGE.\n              03 FILLER PIC X(4) VALUE 'e = '.\n              03 RESULT-VALUE PIC 9.9(18) USAGE DISPLAY.\n       PROCEDURE DIVISION.\n       MAIN SECTION.\n           PERFORM\n              VARYING N FROM 2 BY 1\n              UNTIL FUNCTION ABS(E - E0) < EPSILON\n              MOVE E TO E0\n              COMPUTE FACT = FACT * N\n              COMPUTE E = E + 1.0 / FACT\n           END-PERFORM.\n           MOVE E TO RESULT-VALUE.\n           DISPLAY RESULT-MESSAGE.\n           STOP RUN.\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 65263, "name": "Inheritance_Single", "source": "Translate COBOL to C#:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65265, "name": "Inheritance_Single", "source": "Translate COBOL to Java:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65266, "name": "Inheritance_Single", "source": "Translate COBOL to Python:        CLASS-ID. Animal.\n           \n       END CLASS Animal.\n       \n       CLASS-ID. Dog INHERITS Animal.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal.\n\n           \n       END CLASS Dog.\n       \n       CLASS-ID. Cat INHERITS Animal. \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Animal. \n\n           \n       END CLASS Cat.\n           \n       CLASS-ID. Lab INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Lab.\n       \n       CLASS-ID. Collie INHERITS Dog.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           CLASS Dog.\n\n           \n       END CLASS Collie.\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 66110, "name": "N'th", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66112, "name": "N'th", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66113, "name": "N'th", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. NTH-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  WS-NUMBER.\n    05 N               PIC 9(8).\n    05 LAST-TWO-DIGITS PIC 99.\n    05 LAST-DIGIT      PIC 9.\n    05 N-TO-OUTPUT     PIC Z(7)9.\n    05 SUFFIX          PIC AA.\nPROCEDURE DIVISION.\nTEST-PARAGRAPH.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 0 BY 1 UNTIL N IS GREATER THAN 25.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 250 BY 1 UNTIL N IS GREATER THAN 265.\n    PERFORM NTH-PARAGRAPH VARYING N FROM 1000 BY 1 UNTIL N IS GREATER THAN 1025.\n    STOP RUN.\nNTH-PARAGRAPH.\n    MOVE 'TH' TO SUFFIX.\n    MOVE N (7:2) TO LAST-TWO-DIGITS.\n    IF LAST-TWO-DIGITS IS LESS THAN 4,\n    OR LAST-TWO-DIGITS IS GREATER THAN 20,\n    THEN PERFORM DECISION-PARAGRAPH.\n    MOVE N TO N-TO-OUTPUT.\n    DISPLAY N-TO-OUTPUT WITH NO ADVANCING.\n    DISPLAY SUFFIX WITH NO ADVANCING.\n    DISPLAY SPACE WITH NO ADVANCING.\nDECISION-PARAGRAPH.\n    MOVE N (8:1) TO LAST-DIGIT.\n    IF LAST-DIGIT IS EQUAL TO 1 THEN MOVE 'ST' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 2 THEN MOVE 'ND' TO SUFFIX.\n    IF LAST-DIGIT IS EQUAL TO 3 THEN MOVE 'RD' TO SUFFIX.\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66567, "name": "Levenshtein distance", "source": "Translate COBOL to C#:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66568, "name": "Levenshtein distance", "source": "Translate COBOL to C#:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66571, "name": "Levenshtein distance", "source": "Translate COBOL to Java:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66572, "name": "Levenshtein distance", "source": "Translate COBOL to Java:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66573, "name": "Levenshtein distance", "source": "Translate COBOL to Python:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66574, "name": "Levenshtein distance", "source": "Translate COBOL to Python:        identification division.\n       program-id. Levenshtein.\n \n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n \n       data division.\n       working-storage section.\n       77  string-a               pic x(255).\n       77  string-b               pic x(255).\n       77  length-a               pic 9(3).\n       77  length-b               pic 9(3).\n       77  distance               pic z(3).\n       77  i                      pic 9(3).\n       77  j                      pic 9(3).\n       01  tab.\n           05 filler              occurs 256.\n              10 filler           occurs 256.\n                 15 costs         pic 9(3).\n\n       procedure division.\n       main.\n           move \"kitten\" to string-a\n           move \"sitting\" to string-b\n           perform levenshtein-dist\n\n           move \"rosettacode\" to string-a\n           move \"raisethysword\" to string-b\n           perform levenshtein-dist\n           stop run\n           .\n       levenshtein-dist.\n           move length(trim(string-a)) to length-a\n           move length(trim(string-b)) to length-b\n\n           initialize tab\n           \n           perform varying i from 0 by 1 until i > length-a\n              move i to costs(i + 1, 1)\n           end-perform\n\n           perform varying j from 0 by 1 until j > length-b\n              move j to costs(1, j + 1)\n           end-perform\n           \n           perform with test after varying i from 2 by 1 until i > length-a\n              perform with test after varying j from 2 by 1 until j > length-b\n                 if string-a(i - 1:1) = string-b(j - 1:1)\n                    move costs(i - 1, j - 1) to costs(i, j)\n                 else\n                    move min(min(costs(i - 1, j) + 1,     \n                                 costs(i, j - 1) + 1),    \n                             costs(i - 1, j - 1) + 1)     \n                       to costs(i, j)\n                 end-if\n              end-perform\n           end-perform\n           move costs(length-a + 1, length-b + 1) to distance\n           display trim(string-a) \" -> \" trim(string-b) \" = \" trim(distance)\n           .\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 67021, "name": "15 puzzle game", "source": "Translate COBOL to C#:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67022, "name": "15 puzzle game", "source": "Translate COBOL to C#:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 67025, "name": "15 puzzle game", "source": "Translate COBOL to Java:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67026, "name": "15 puzzle game", "source": "Translate COBOL to Java:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 67027, "name": "15 puzzle game", "source": "Translate COBOL to Python:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67028, "name": "15 puzzle game", "source": "Translate COBOL to Python:          >>SOURCE FORMAT FREE\n\n\nidentification division.\nprogram-id. fifteen.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n\n01  r pic 9.\n01  r-empty pic 9.\n01  r-to pic 9.\n01  r-from pic 9.\n\n01  c pic 9.\n01  c-empty pic 9.\n01  c-to pic 9.\n01  c-from pic 9.\n\n01  display-table.\n    03  display-row occurs 4.\n        05  display-cell occurs 4 pic 99.\n\n01  tile-number pic 99.\n01  tile-flags pic x(16).\n\n01  display-move value spaces.\n    03  tile-id pic 99.\n\n01  row-separator pic x(21) value all '.'.\n01  column-separator pic x(3) value ' . '.\n\n01  inversions pic 99.\n01  current-tile pic 99.\n\n01  winning-display pic x(32) value\n        '01020304'\n    &   '05060708'\n    &   '09101112'\n    &   '13141500'.\n\nprocedure division.\nstart-fifteen.\n    display 'start fifteen puzzle'\n    display '    enter a two-digit tile number and press <enter> to move'\n    display '    press <enter> only to exit'\n\n    \n    perform initialize-table with test after until inversions = 0\n    perform show-table\n    accept display-move\n    perform until display-move = spaces\n        perform move-tile\n        perform show-table\n        move spaces to display-move\n        accept display-move\n    end-perform\n    stop run\n    .\ninitialize-table.\n    compute tile-number = random(seconds-past-midnight) \n    move spaces to tile-flags\n    move 0 to current-tile inversions\n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        perform with test after\n        until tile-flags(tile-number + 1:1) = space\n            compute tile-number = random() * 100\n            compute tile-number = mod(tile-number, 16)\n        end-perform\n        move 'x' to tile-flags(tile-number + 1:1)\n        if tile-number > 0 and < current-tile\n            add 1 to inversions\n        end-if\n        move tile-number to display-cell(r,c) current-tile\n    end-perform\n    compute inversions = mod(inversions,2)\n    .\nshow-table.\n    if display-table = winning-display\n        display 'winning'\n    end-if\n    display space row-separator\n    perform varying r from 1 by 1 until r > 4\n        perform varying c from 1 by 1 until c > 4\n            display column-separator with no advancing\n            if display-cell(r,c) = 00\n                display '  ' with no advancing\n                move r to r-empty\n                move c to c-empty\n            else\n                display display-cell(r,c) with no advancing\n            end-if\n        end-perform\n        display column-separator\n    end-perform\n    display space row-separator\n    .\nmove-tile.\n    if not (tile-id numeric and tile-id >= 01 and <= 15)\n        display 'invalid tile number'\n        exit paragraph\n    end-if\n\n    \n    perform varying r from 1 by 1 until r > 4\n    after c from 1 by 1 until c > 4\n        if display-cell(r,c) = tile-id\n            exit perform\n        end-if\n    end-perform\n\n    \n    evaluate true\n    when r = r-empty\n        if c-empty < c\n            \n            perform varying c-to from c-empty by 1 until c-to > c\n                compute c-from = c-to + 1\n                move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n            end-perform\n        else\n           \n           perform varying c-to from c-empty by -1 until c-to < c\n               compute c-from = c-to - 1\n               move display-cell(r-empty,c-from) to display-cell(r-empty,c-to)\n           end-perform\n       end-if\n       move 00 to display-cell(r,c)\n    when c = c-empty\n        if r-empty < r\n            \n            perform varying r-to from r-empty by 1 until r-to > r\n                compute r-from = r-to + 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        else\n            \n            perform varying r-to from r-empty by -1 until r-to < r\n                compute r-from = r-to - 1\n                move display-cell(r-from,c-empty) to display-cell(r-to,c-empty)\n            end-perform\n        end-if\n        move 00 to display-cell(r,c)\n    when other\n         display 'invalid move'\n    end-evaluate\n    .\nend program fifteen.\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67756, "name": "Array length", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67757, "name": "Array length", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67760, "name": "Array length", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67761, "name": "Array length", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67762, "name": "Array length", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67763, "name": "Array length", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-length.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 str-field pic x(7) occurs 0 to 5 depending on t1.\n\n       77 t1           pic 99.\n\n       procedure division.\n       array-length-main.\n       perform initialize-table\n       perform display-table-info\n       goback.\n\n       initialize-table.\n           move 1 to t1\n           move \"apples\" to str-field(t1)\n\n           add 1 to t1\n           move \"oranges\" to str-field(t1).\n\n      \n           add 1 to t1\n           move \"bananas\" to str-field(t1).\n           subtract 1 from t1\n       .\n\n       display-table-info.\n           display \"Elements: \" t1 \", using \" length(table-one) \" bytes\"\n           display table-one\n       .\n\n       end program array-length.\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 69328, "name": "Averages_Root mean square", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69329, "name": "Averages_Root mean square", "source": "Translate COBOL to C#: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69332, "name": "Averages_Root mean square", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69333, "name": "Averages_Root mean square", "source": "Translate COBOL to Java: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69334, "name": "Averages_Root mean square", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69335, "name": "Averages_Root mean square", "source": "Translate COBOL to Python: IDENTIFICATION DIVISION.\nPROGRAM-ID. QUADRATIC-MEAN-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  QUADRATIC-MEAN-VARS.\n    05 N               PIC 99        VALUE 0.\n    05 N-SQUARED       PIC 999.\n    05 RUNNING-TOTAL   PIC 999       VALUE 0.\n    05 MEAN-OF-SQUARES PIC 99V9(16).\n    05 QUADRATIC-MEAN  PIC 9V9(15).\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM MULTIPLICATION-PARAGRAPH 10 TIMES.\n    DIVIDE  RUNNING-TOTAL BY 10 GIVING MEAN-OF-SQUARES.\n    COMPUTE QUADRATIC-MEAN = FUNCTION SQRT(MEAN-OF-SQUARES).\n    DISPLAY QUADRATIC-MEAN UPON CONSOLE.\n    STOP RUN.\nMULTIPLICATION-PARAGRAPH.\n    ADD      1         TO N.\n    MULTIPLY N         BY N GIVING N-SQUARED.\n    ADD      N-SQUARED TO RUNNING-TOTAL.\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 70075, "name": "Terminal control_Coloured text", "source": "Translate COBOL to C#: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70076, "name": "Terminal control_Coloured text", "source": "Translate COBOL to C#: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 70077, "name": "Terminal control_Coloured text", "source": "Translate COBOL to Python: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70078, "name": "Terminal control_Coloured text", "source": "Translate COBOL to Python: \n       IDENTIFICATION  DIVISION.\n       PROGRAM-ID. coloured-text.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example-str VALUE \"COBOL\".\n\n       01  fore-colour PIC 9.\n       01  back-colour PIC 9.\n\n       01  line-num    PIC 99 VALUE 1.\n       01  col-num     PIC 99 VALUE 1.\n\n       01  pause       PIC X.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"With HIGHLIGHT:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour HIGHLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With LOWLIGHT: (has no effect on many terminals)\"\n               AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour LOWLIGHT\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM           \n\n           DISPLAY \"With BLINK:\" AT LINE line-num, COLUMN 1\n           ADD 1 TO line-num\n\n           PERFORM VARYING fore-colour FROM 0 BY 1 UNTIL fore-colour > 7\n               PERFORM VARYING back-colour FROM 0 BY 1\n                       UNTIL back-colour > 7\n                   DISPLAY example-str AT LINE line-num, COLUMN col-num\n                       WITH FOREGROUND-COLOR fore-colour,\n                       BACKGROUND-COLOR back-colour BLINK\n    \n                   ADD 6 TO col-num\n               END-PERFORM\n\n               ADD 1 TO line-num\n               MOVE 1 TO col-num\n           END-PERFORM\n\n           DISPLAY \"Press enter to continue.\"\n               AT LINE line-num, COLUMN 1\n           ACCEPT pause AT LINE line-num, COLUMN 40\n\n           GOBACK\n           .\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70312, "name": "Loops_Foreach", "source": "Translate COBOL to C#: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70314, "name": "Loops_Foreach", "source": "Translate COBOL to Java: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 70315, "name": "Loops_Foreach", "source": "Translate COBOL to Python: 01  things occurs 3.\n...\nset content of things to (\"Apple\", \"Banana\", \"Coconut\")\nperform varying thing as string through things\n    display thing\nend-perform\n", "target": "for i in collection:\n   print i\n"}
{"id": 72522, "name": "Five weekends", "source": "Translate COBOL to C#:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "using System;\n\nnamespace _5_Weekends\n{\n    class Program\n    {\n        const int FIRST_YEAR = 1900;\n        const int LAST_YEAR = 2100;\n        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; \n\n        static void Main(string[] args)\n        {\n            int totalNum = 0;\n            int totalNo5Weekends = 0;\n\n            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)\n            {\n                bool has5Weekends = false;\n\n                foreach (int month in _31_MONTHS)\n                {\n                    DateTime firstDay = new DateTime(year, month, 1);\n                    if (firstDay.DayOfWeek == DayOfWeek.Friday)\n                    {\n                        totalNum++;\n                        has5Weekends = true;\n                        Console.WriteLine(firstDay.ToString(\"yyyy - MMMM\"));\n                    }\n                }\n\n                if (!has5Weekends) totalNo5Weekends++;\n            }\n            Console.WriteLine(\"Total 5-weekend months between {0} and {1}: {2}\", FIRST_YEAR, LAST_YEAR, totalNum);\n            Console.WriteLine(\"Total number of years with no 5-weekend months {0}\", totalNo5Weekends);\n        }\n    }\n}\n"}
{"id": 72524, "name": "Five weekends", "source": "Translate COBOL to Java:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class FiveFSS {\n    private static boolean[] years = new boolean[201];\n    private static int[] month31 = {Calendar.JANUARY, Calendar.MARCH, Calendar.MAY,\n        Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER};\n\n    public static void main(String[] args) {\n        StringBuilder months = new StringBuilder();\n        int numMonths = 0;\n        for (int year = 1900; year <= 2100; year++) {\n            for (int month : month31) {\n                Calendar date = new GregorianCalendar(year, month, 1);\n                if (date.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n                    years[year - 1900] = true;\n                    numMonths++;\n                    \n                    months.append((date.get(Calendar.MONTH) + 1) + \"-\" + year +\"\\n\");\n                }\n            }\n        }\n        System.out.println(\"There are \"+numMonths+\" months with five weekends from 1900 through 2100:\");\n        System.out.println(months);\n        System.out.println(\"Years with no five-weekend months:\");\n        for (int year = 1900; year <= 2100; year++) {\n            if(!years[year - 1900]){\n                System.out.println(year);\n            }\n        }\n    }\n}\n"}
{"id": 72525, "name": "Five weekends", "source": "Translate COBOL to Python:        program-id. five-we.\n       data division.\n       working-storage section.\n       1 wk binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n        2 friday pic 9(4) value 5.\n        2 mo-sub pic 9(4).\n        2 months-with-5 pic 9(4) value 0.\n        2 years-no-5 pic 9(4) value 0.\n        2 5-we-flag pic 9(4) value 0.\n         88 5-we-true value 1 when false 0.\n       1 31-day-mos pic 9(14) value 01030507081012.\n       1 31-day-table redefines 31-day-mos.\n        2 mo-no occurs 7 pic 99.\n       1 cal-date.\n        2 yr pic 9(4).\n        2 mo pic 9(2).\n        2 da pic 9(2) value 1.\n       procedure division.\n           perform varying yr from 1900 by 1\n           until yr > 2100\n               set 5-we-true to false\n               perform varying mo-sub from 1 by 1\n               until mo-sub > 7\n                   move mo-no (mo-sub) to mo\n                   compute int-date = function\n                       integer-of-date (function numval (cal-date))\n                   compute dow = function mod\n                       ((int-date - 1) 7) + 1\n                   if dow = friday\n                       perform output-date\n                       add 1 to months-with-5\n                       set 5-we-true to true\n                   end-if\n               end-perform\n               if not 5-we-true\n                   add 1 to years-no-5\n               end-if\n           end-perform\n           perform output-counts\n           stop run\n           .\n\n       output-counts.\n           display \"Months with 5 weekends: \" months-with-5\n           display \"Years without 5 weekends: \" years-no-5\n           .\n\n       output-date.\n           display yr \"-\" mo\n           .\n       end program five-we.\n", "target": "from datetime import (date,\n                      timedelta)\n\nDAY = timedelta(days=1)\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\nWEEKEND = {6, 5, 4}  \nFMT = '%Y %m(%B)'\n\n\ndef five_weekends_per_month(start: date = START,\n                            stop: date = STOP) -> list[date]:\n    \n    current_date = start\n    last_month = weekend_days = 0\n    five_weekends = []\n    while current_date < stop:\n        if current_date.month != last_month:\n            if weekend_days >= 15:\n                five_weekends.append(current_date - DAY)\n            weekend_days = 0\n            last_month = current_date.month\n        if current_date.weekday() in WEEKEND:\n            weekend_days += 1\n        current_date += DAY\n    return five_weekends\n\n\ndates = five_weekends_per_month()\nindent = '  '\nprint(f\"There are {len(dates)} months of which the first and last five are:\")\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[:5]))\nprint(indent + '...')\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[-5:]))\n\nyears_without_five_weekends_months = (STOP.year - START.year\n                                      - len({d.year for d in dates}))\nprint(f\"\\nThere are {years_without_five_weekends_months} years in the \"\n      f\"range that do not have months with five weekends\")\n"}
{"id": 74437, "name": "Array concatenation", "source": "Translate COBOL to C#:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74439, "name": "Array concatenation", "source": "Translate COBOL to Java:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74440, "name": "Array concatenation", "source": "Translate COBOL to Python:        identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 75500, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75501, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.Text;\n\nnamespace Language_name_in_3D_ascii\n{\n    public class F5\n    {\n        char[] z = { ' ', ' ', '_', '/', };\n        long[,] f ={\n            {87381,87381,87381,87381,87381,87381,87381,},\n            {349525,375733,742837,742837,375733,349525,349525,},\n            {742741,768853,742837,742837,768853,349525,349525,},\n            {349525,375733,742741,742741,375733,349525,349525,},\n            {349621,375733,742837,742837,375733,349525,349525,},\n            {349525,375637,768949,742741,375733,349525,349525,},\n            {351157,374101,768949,374101,374101,349525,349525,},\n            {349525,375733,742837,742837,375733,349621,351157,},\n            {742741,768853,742837,742837,742837,349525,349525,},\n            {181,85,181,181,181,85,85,},\n            {1461,1365,1461,1461,1461,1461,2901,},\n            {742741,744277,767317,744277,742837,349525,349525,},\n            {181,181,181,181,181,85,85,},\n            {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n            {349525,768853,742837,742837,742837,349525,349525,},\n            {349525,375637,742837,742837,375637,349525,349525,},\n            {349525,768853,742837,742837,768853,742741,742741,},\n            {349525,375733,742837,742837,375733,349621,349621,},\n            {349525,744373,767317,742741,742741,349525,349525,},\n            {349525,375733,767317,351157,768853,349525,349525,},\n            {374101,768949,374101,374101,351157,349525,349525,},\n            {349525,742837,742837,742837,375733,349525,349525,},\n            {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n            {349525,742837,375637,742837,742837,349525,349525,},\n            {349525,742837,742837,742837,375733,349621,375637,},\n            {349525,768949,351061,374101,768949,349525,349525,},\n            {375637,742837,768949,742837,742837,349525,349525,},\n            {768853,742837,768853,742837,768853,349525,349525,},\n            {375733,742741,742741,742741,375733,349525,349525,},\n            {192213,185709,185709,185709,192213,87381,87381,},\n            {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n            {768949,742741,768853,742741,742741,349525,349525,},\n            {375733,742741,744373,742837,375733,349525,349525,},\n            {742837,742837,768949,742837,742837,349525,349525,},\n            {48053,23381,23381,23381,48053,21845,21845,},\n            {349621,349621,349621,742837,375637,349525,349525,},\n            {742837,744277,767317,744277,742837,349525,349525,},\n            {742741,742741,742741,742741,768949,349525,349525,},\n            {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n            {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n            {375637,742837,742837,742837,375637,349525,349525,},\n            {768853,742837,768853,742741,742741,349525,349525,},\n            {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n            {768853,742837,768853,742837,742837,349525,349525,},\n            {375733,742741,375637,349621,768853,349525,349525,},\n            {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n            {742837,742837,742837,742837,375637,349525,349525,},\n            {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n            {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n            {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n            {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n            {12303285,5593941,5616981,5985621,12303285,5592405,5592405,}\n            };\n\n        private F5(string s)\n        {\n            StringBuilder[] o = new StringBuilder[7];\n            for (int i = 0; i < 7; i++) o[i] = new StringBuilder();\n            for (int i = 0, l = s.Length; i < l; i++)\n            {\n                int c = s[i];\n                if (65 <= c && c <= 90) c -= 39;\n                else if (97 <= c && c <= 122) c -= 97;\n                else c = -1;\n                long[] d = new long[7];\n                Buffer.BlockCopy(f, (++c * sizeof(long) * 7), d, 0, 7 * sizeof(long));\n                for (int j = 0; j < 7; j++)\n                {\n                    StringBuilder b = new StringBuilder();\n                    long v = d[j];\n                    while (v > 0)\n                    {\n                        b.Append(z[(int)(v & 3)]);\n                        v >>= 2;\n                    }\n                    char[] charArray = b.ToString().ToCharArray();\n                    Array.Reverse(charArray);\n                    o[j].Append(new string(charArray));\n                }\n            }\n            for (int i = 0; i < 7; i++)\n            {\n                for (int j = 0; j < 7 - i; j++)\n                    System.Console.Write(' ');\n                System.Console.WriteLine(o[i]);\n            }\n        }\n\n        public static void Main(string[] args)\n        {\n            new F5(args.Length > 0 ? args[0] : \"C sharp\");\n        }\n    }\n}\n"}
{"id": 75504, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75505, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "public class F5{\n    char[]z={' ',' ','_','/',};\n    long[][]f={\n        {87381,87381,87381,87381,87381,87381,87381,},\n        {349525,375733,742837,742837,375733,349525,349525,},\n        {742741,768853,742837,742837,768853,349525,349525,},\n        {349525,375733,742741,742741,375733,349525,349525,},\n        {349621,375733,742837,742837,375733,349525,349525,},\n        {349525,375637,768949,742741,375733,349525,349525,},\n        {351157,374101,768949,374101,374101,349525,349525,},\n        {349525,375733,742837,742837,375733,349621,351157,},\n        {742741,768853,742837,742837,742837,349525,349525,},\n        {181,85,181,181,181,85,85,},\n        {1461,1365,1461,1461,1461,1461,2901,},\n        {742741,744277,767317,744277,742837,349525,349525,},\n        {181,181,181,181,181,85,85,},\n        {1431655765,3149249365L,3042661813L,3042661813L,3042661813L,1431655765,1431655765,},\n        {349525,768853,742837,742837,742837,349525,349525,},\n        {349525,375637,742837,742837,375637,349525,349525,},\n        {349525,768853,742837,742837,768853,742741,742741,},\n        {349525,375733,742837,742837,375733,349621,349621,},\n        {349525,744373,767317,742741,742741,349525,349525,},\n        {349525,375733,767317,351157,768853,349525,349525,},\n        {374101,768949,374101,374101,351157,349525,349525,},\n        {349525,742837,742837,742837,375733,349525,349525,},\n        {5592405,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {366503875925L,778827027893L,778827027893L,392374737749L,368114513237L,366503875925L,366503875925L,},\n        {349525,742837,375637,742837,742837,349525,349525,},\n        {349525,742837,742837,742837,375733,349621,375637,},\n        {349525,768949,351061,374101,768949,349525,349525,},\n        {375637,742837,768949,742837,742837,349525,349525,},\n        {768853,742837,768853,742837,768853,349525,349525,},\n        {375733,742741,742741,742741,375733,349525,349525,},\n        {192213,185709,185709,185709,192213,87381,87381,},\n        {1817525,1791317,1817429,1791317,1817525,1398101,1398101,},\n        {768949,742741,768853,742741,742741,349525,349525,},\n        {375733,742741,744373,742837,375733,349525,349525,},\n        {742837,742837,768949,742837,742837,349525,349525,},\n        {48053,23381,23381,23381,48053,21845,21845,},\n        {349621,349621,349621,742837,375637,349525,349525,},\n        {742837,744277,767317,744277,742837,349525,349525,},\n        {742741,742741,742741,742741,768949,349525,349525,},\n        {11883957,12278709,11908533,11883957,11883957,5592405,5592405,},\n        {11883957,12277173,11908533,11885493,11883957,5592405,5592405,},\n        {375637,742837,742837,742837,375637,349525,349525,},\n        {768853,742837,768853,742741,742741,349525,349525,},\n        {6010197,11885397,11909973,11885397,6010293,5592405,5592405,},\n        {768853,742837,768853,742837,742837,349525,349525,},\n        {375733,742741,375637,349621,768853,349525,349525,},\n        {12303285,5616981,5616981,5616981,5616981,5592405,5592405,},\n        {742837,742837,742837,742837,375637,349525,349525,},\n        {11883957,11883957,11883957,5987157,5616981,5592405,5592405,},\n        {3042268597L,3042268597L,3042661813L,1532713813,1437971797,1431655765,1431655765,},\n        {11883957,5987157,5616981,5987157,11883957,5592405,5592405,},\n        {11883957,5987157,5616981,5616981,5616981,5592405,5592405,},\n        {12303285,5593941,5616981,5985621,12303285,5592405,5592405,},};\n    public static void main(String[]a){\n        new F5(a.length>0?a[0]:\"Java\");}\n    private F5(String s){\n        StringBuilder[]o=new StringBuilder[7];\n        for(int i=0;i<7;i++)o[i]=new StringBuilder();\n        for(int i=0,l=s.length();i<l;i++){\n            int c=s.charAt(i);\n            if(65<=c&&c<=90)c-=39;\n            else if(97<=c&&c<=122)c-=97;\n            else c=-1;\n            long[]d=f[++c];\n            for(int j=0;j<7;j++){\n                StringBuilder b=new StringBuilder();\n                long v=d[j];\n                while(v>0){\n                    b.append(z[(int)(v&3)]);\n                    v>>=2;}\n                o[j].append(b.reverse().toString());}}\n        for(int i=0;i<7;i++){\n            for(int j=0;j<7-i;j++)\n                System.out.print(' ');\n            System.out.println(o[i]);}}}\n"}
{"id": 75506, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 75507, "name": "Write language name in 3D ASCII", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. cobol-3d.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  cobol-area.\n           03  cobol-text-data PIC X(1030) VALUE \"________/\\\\\\\\\\\\\\\\\\____\n      -        \"____/\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\________\n      -        \"/\\\\\\_____________         _____/\\\\\\////////_______/\\\\\\//\n      -        \"/\\\\\\_____\\/\\\\\\/////////\\\\\\______/\\\\\\///\\\\\\_____\\/\\\\\\____\n      -        \"_________         ___/\\\\\\/______________/\\\\\\/__\\///\\\\\\__\n      -        \"_\\/\\\\\\_______\\/\\\\\\____/\\\\\\/__\\///\\\\\\___\\/\\\\\\____________\n      -        \"_         __/\\\\\\_______________/\\\\\\______\\//\\\\\\__\\/\\\\\\\\\\\n      -        \"\\\\\\\\\\\\\\\\\\____/\\\\\\______\\//\\\\\\__\\/\\\\\\_____________       \n      -      \"  _\\/\\\\\\______________\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\/////////\\\\\\\n      -        \"__\\/\\\\\\_______\\/\\\\\\__\\/\\\\\\_____________         _\\//\\\\\\_\n      -        \"____________\\//\\\\\\______/\\\\\\___\\/\\\\\\_______\\/\\\\\\__\\//\\\\\\\n      -        \"______/\\\\\\___\\/\\\\\\_____________         __\\///\\\\\\_______\n      -        \"_____\\///\\\\\\__/\\\\\\_____\\/\\\\\\_______\\/\\\\\\___\\///\\\\\\__/\\\\\\\n      -        \"_____\\/\\\\\\_____________         ____\\////\\\\\\\\\\\\\\\\\\_____\\\n      -        \"///\\\\\\\\\\/______\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/______\\///\\\\\\\\\\/______\\/\\\n      -        \"\\\\\\\\\\\\\\\\\\\\\\\\\\\\_         _______\\/////////________\\/////_\n      -        \"_______\\/////////////__________\\/////________\\//////////\n      -        \"/////__\" \n               .\n           03  cobol-text-table REDEFINES cobol-text-data.\n               05  cobol-text  PIC X(103) OCCURS 10 TIMES.\n\n       01  i                   PIC 99.\n       01  j                   PIC 9(4).\n\n       PROCEDURE DIVISION.\n           \n           PERFORM VARYING i FROM 1 BY 1 UNTIL 10 < i\n               MOVE 1 TO j\n               PERFORM UNTIL 103 < j\n                   \n                   \n                   IF cobol-text (i) (j:4) = \"\\\\\\/\"\n                       DISPLAY cobol-text (i) (j:3) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7, HIGHLIGHT\n                           \n                       ADD 3 TO j\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n\n                       ADD 1 TO j\n                           \n                       EXIT PERFORM CYCLE\n                   END-IF\n                       \n                   \n                   \n                   IF cobol-text (i) (j:1) = \"/\" \n                          OR cobol-text (i) (FUNCTION SUM(j, 1):1) = \"/\"\n                          OR cobol-text (i) (FUNCTION SUM(j, 1):2)\n                              = \"\\/\"\n                       DISPLAY cobol-text (i) (j:1)  AT LINE i COL j\n                           WITH FOREGROUND-COLOR 0, HIGHLIGHT\n                   \n                   ELSE\n                       DISPLAY cobol-text (i) (j:1) AT LINE i COL j\n                           WITH FOREGROUND-COLOR 7 , HIGHLIGHT\n                   END-IF\n\n                   ADD 1 TO j\n               END-PERFORM\n           END-PERFORM\n\n           \n           \n           \n           DISPLAY \"Press enter to stop appreciating COBOL in 3D.\"\n               AT LINE 11 COL 1\n           ACCEPT i AT LINE 11 COL 46\n\n           GOBACK\n           .\n", "target": "py = '''\\\n \n \n \n \n \n\nlines = py.replace('\n        .replace('X', '   ').replace('\\n', ' Y') \\\n        .replace('< ', '<>').split('Y')\n\nfor i, l in enumerate(lines): \n    print('  ' * (len(lines) - i) + l)\n"}
{"id": 76003, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 76005, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 76006, "name": "Sorting algorithms_Bubble sort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.                      BUBBLESORT.\n       AUTHOR.                          DAVE STRATFORD.\n       DATE-WRITTEN.                    MARCH 2010.\n       INSTALLATION.                    HEXAGON SYSTEMS LIMITED.\n \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER.                 ICL VME.\n       OBJECT-COMPUTER.                 ICL VME.\n \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FA-INPUT-FILE  ASSIGN FL01.\n           SELECT FB-OUTPUT-FILE ASSIGN FL02.\n \n       DATA DIVISION.\n       FILE SECTION.\n \n       FD  FA-INPUT-FILE.\n       01  FA-INPUT-REC.\n         03  FA-DATA                    PIC S9(6).\n \n       FD  FB-OUTPUT-FILE.\n       01  FB-OUTPUT-REC                PIC S9(6).\n \n       WORKING-STORAGE SECTION.\n       01  WA-IDENTITY.\n         03  WA-PROGNAME                PIC X(10) VALUE \"BUBBLESORT\".\n         03  WA-VERSION                 PIC X(6) VALUE \"000001\".\n \n       01  WB-TABLE.\n         03  WB-ENTRY                   PIC 9(8) COMP SYNC OCCURS 100000\n                                                  INDEXED BY WB-IX-1.\n \n       01  WC-VARS.\n         03  WC-SIZE                    PIC S9(8) COMP SYNC.\n         03  WC-TEMP                    PIC S9(8) COMP SYNC.\n         03  WC-END                     PIC S9(8) COMP SYNC.\n         03  WC-LAST-CHANGE             PIC S9(8) COMP SYNC.\n \n       01  WF-CONDITION-FLAGS.\n         03  WF-EOF-FLAG                PIC X.\n           88  END-OF-FILE              VALUE \"Y\".\n         03  WF-EMPTY-FILE-FLAG         PIC X.\n           88  EMPTY-FILE               VALUE \"Y\".\n \n       PROCEDURE DIVISION.\n       A-MAIN SECTION.\n       A-000.\n           PERFORM B-INITIALISE.\n           IF NOT EMPTY-FILE\n              PERFORM C-SORT.\n           PERFORM D-FINISH.\n \n       A-999.\n           STOP RUN.\n \n       B-INITIALISE SECTION.\n       B-000.\n           DISPLAY \"*** \" WA-PROGNAME \" VERSION \"\n                          WA-VERSION \" STARTING ***\".\n \n           MOVE ALL \"N\" TO WF-CONDITION-FLAGS.\n           OPEN INPUT FA-INPUT-FILE.\n           SET WB-IX-1 TO 0.\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG\n                                                 WF-EMPTY-FILE-FLAG.\n \n           PERFORM BA-READ-INPUT UNTIL END-OF-FILE.\n \n           CLOSE FA-INPUT-FILE.\n \n           SET WC-SIZE TO WB-IX-1.\n \n       B-999.\n           EXIT.\n \n       BA-READ-INPUT SECTION.\n       BA-000.\n           SET WB-IX-1 UP BY 1.\n           MOVE FA-DATA TO WB-ENTRY(WB-IX-1).\n \n           READ FA-INPUT-FILE AT END MOVE \"Y\" TO WF-EOF-FLAG.\n \n       BA-999.\n           EXIT.\n \n       C-SORT SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n \n           MOVE WC-SIZE TO WC-END.\n           PERFORM E-BUBBLE UNTIL WC-END = 1.\n \n           DISPLAY \"SORT FINISHED\".\n \n       C-999.\n           EXIT.\n \n       D-FINISH SECTION.\n       D-000.\n           OPEN OUTPUT FB-OUTPUT-FILE.\n           SET WB-IX-1 TO 1.\n \n           PERFORM DA-WRITE-OUTPUT UNTIL WB-IX-1 > WC-SIZE.\n \n           CLOSE FB-OUTPUT-FILE.\n \n           DISPLAY \"*** \" WA-PROGNAME \" FINISHED ***\".\n \n       D-999.\n           EXIT.\n \n       DA-WRITE-OUTPUT SECTION.\n       DA-000.\n           WRITE FB-OUTPUT-REC FROM WB-ENTRY(WB-IX-1).\n           SET WB-IX-1 UP BY 1.\n \n       DA-999.\n           EXIT.\n \n       E-BUBBLE SECTION.\n       E-000.\n           MOVE 1 TO WC-LAST-CHANGE.\n \n           PERFORM F-PASS VARYING WB-IX-1 FROM 1 BY 1\n                          UNTIL WB-IX-1 = WC-END.\n \n           MOVE WC-LAST-CHANGE TO WC-END.\n \n       E-999.\n           EXIT.\n \n       F-PASS SECTION.\n       F-000.\n           IF WB-ENTRY(WB-IX-1) > WB-ENTRY(WB-IX-1 + 1)\n              SET  WC-LAST-CHANGE        TO WB-IX-1\n              MOVE WB-ENTRY(WB-IX-1)     TO WC-TEMP\n              MOVE WB-ENTRY(WB-IX-1 + 1) TO WB-ENTRY(WB-IX-1)\n              MOVE WC-TEMP               TO WB-ENTRY(WB-IX-1 + 1).\n \n       F-999.\n           EXIT.\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 77125, "name": "Greatest common divisor", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77127, "name": "Greatest common divisor", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77128, "name": "Greatest common divisor", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n", "target": "from fractions import gcd\n"}
{"id": 77403, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77405, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77406, "name": "Luhn test of credit card numbers", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77684, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77686, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77687, "name": "Sorting algorithms_Quicksort", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 77906, "name": "Date manipulation", "source": "Translate COBOL to C#:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n"}
{"id": 77908, "name": "Date manipulation", "source": "Translate COBOL to Java:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "import java.time.*;\nimport java.time.format.*;\n\nclass Main {  \n  public static void main(String args[]) { \n    String dateStr = \"March 7 2009 7:30pm EST\";\n\n    DateTimeFormatter df = new DateTimeFormatterBuilder()\n\t\t\t\t.parseCaseInsensitive()\n\t\t\t\t.appendPattern(\"MMMM d yyyy h:mma zzz\")\n\t\t\t\t.toFormatter();\n\t\t\n    ZonedDateTime after12Hours = ZonedDateTime.parse(dateStr, df).plusHours(12);\n  \n    System.out.println(\"Date: \" + dateStr);\n    System.out.println(\"+12h: \" + after12Hours.format(df));\n\n    ZonedDateTime after12HoursInCentralEuropeTime = after12Hours.withZoneSameInstant(ZoneId.of(\"CET\"));\n    System.out.println(\"+12h (in Central Europe): \" + after12HoursInCentralEuropeTime.format(df));\n  }\n}\n"}
{"id": 77909, "name": "Date manipulation", "source": "Translate COBOL to Python:        identification division.\n       program-id. date-manipulation.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 given-date.\n          05 filler            value z\"March 7 2009 7:30pm EST\".\n       01 date-spec.\n          05 filler            value z\"%B %d %Y %I:%M%p %Z\".\n\n       01 time-struct.\n          05 tm-sec            usage binary-long.\n          05 tm-min            usage binary-long.\n          05 tm-hour           usage binary-long.\n          05 tm-mday           usage binary-long.\n          05 tm-mon            usage binary-long.\n          05 tm-year           usage binary-long.\n          05 tm-wday           usage binary-long.\n          05 tm-yday           usage binary-long.\n          05 tm-isdst          usage binary-long.\n          05 tm-gmtoff         usage binary-c-long.\n          05 tm-zone           usage pointer.\n       01 scan-index           usage pointer.\n\n       01 time-t               usage binary-c-long.\n       01 time-tm              usage pointer.\n\n       01 reform-buffer        pic x(64).\n       01 reform-length        usage binary-long.\n\n       01 current-locale       usage pointer.\n\n       01 iso-spec             constant as \"YYYY-MM-DDThh:mm:ss+hh:mm\".\n       01 iso-date             constant as \"2009-03-07T19:30:00-05:00\".\n       01 date-integer         pic 9(9).\n       01 time-integer         pic 9(9).\n       \n       procedure division.\n      \n       call \"strptime\" using\n           by reference given-date\n           by reference date-spec\n           by reference time-struct\n           returning scan-index\n           on exception\n               display \"error calling strptime\" upon syserr\n       end-call\n       display \"Given: \" given-date\n\n       if scan-index not equal null then\n           \n           call \"mktime\" using time-struct returning time-t\n           add 43200 to time-t\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"PST8PDT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n           \n           set environment \"TZ\" to \"GMT\"\n           call \"tzset\" returning omitted\n           perform form-datetime\n\n\n           \n           set environment \"TZ\" to \"Japan\"\n           call \"tzset\" returning omitted\n           call \"setlocale\" using by value 6 by content z\"en_HK.utf8\"\n               returning current-locale\n               on exception\n                   display \"error with setlocale\" upon syserr\n           end-call\n           move z\"%c\" to date-spec\n           perform form-datetime\n       else\n           display \"date parse error\" upon syserr\n       end-if\n\n      \n       display \"Given: \" iso-date\n       move integer-of-formatted-date(iso-spec, iso-date)\n         to date-integer\n\n       move seconds-from-formatted-time(iso-spec, iso-date)\n         to time-integer\n\n       add 43200 to time-integer\n       if time-integer greater than 86400 then\n           subtract 86400 from time-integer\n           add 1 to date-integer\n       end-if\n       display \"       \" substitute(formatted-datetime(iso-spec\n                   date-integer, time-integer, -300), \"T\", \"/\")\n\n       goback.\n\n       form-datetime.\n       call \"localtime\" using time-t returning time-tm\n       call \"strftime\" using\n           by reference reform-buffer\n           by value length(reform-buffer)\n           by reference date-spec\n           by value time-tm\n           returning reform-length\n           on exception\n               display \"error calling strftime\" upon syserr\n       end-call\n       if reform-length > 0 and <= length(reform-buffer) then\n           display \"       \" reform-buffer(1 : reform-length)\n       else\n           display \"date format error\" upon syserr\n       end-if\n       .\n       end program date-manipulation.\n", "target": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n"}
{"id": 78188, "name": "Rot-13", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78190, "name": "Rot-13", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78191, "name": "Rot-13", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       78  STR-LENGTH   VALUE 100.\n \n       78  normal-lower VALUE \"abcdefghijklmnopqrstuvwxyz\".\n       78  rot13-lower  VALUE \"nopqrstuvwxyzabcdefghijklm\".\n\n       78  normal-upper VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n       78  rot13-upper  VALUE \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\n\n       LINKAGE SECTION.\n       01  in-str       PIC X(STR-LENGTH).\n       01  out-str      PIC X(STR-LENGTH).\n\n       PROCEDURE DIVISION USING VALUE in-str, REFERENCE out-str.\n           MOVE in-str TO out-str\n\n           INSPECT out-str CONVERTING normal-lower TO rot13-lower\n           INSPECT out-str CONVERTING normal-upper TO rot13-upper\n\n           GOBACK\n           .\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78698, "name": "Write float arrays to a text file", "source": "Translate COBOL to C#:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78699, "name": "Write float arrays to a text file", "source": "Translate COBOL to C#:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78702, "name": "Write float arrays to a text file", "source": "Translate COBOL to Java:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78703, "name": "Write float arrays to a text file", "source": "Translate COBOL to Java:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78704, "name": "Write float arrays to a text file", "source": "Translate COBOL to Python:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78705, "name": "Write float arrays to a text file", "source": "Translate COBOL to Python:        identification division.\n       program-id. wr-float.\n       environment division.\n       input-output section.\n       file-control.\n           select report-file assign \"float.txt\"\n               organization sequential.\n       data division.\n       file section.\n       fd report-file\n           report is floats.\n       working-storage section.\n       1 i binary pic 9(4).\n       1 x-values comp-2.\n        2 value 1.0.\n        2 value 2.0.\n        2 value 3.0.\n        2 value 1.0e11.\n       1 redefines x-values comp-2.\n        2 x occurs 4.\n       1 comp-2.\n        2 y occurs 4.\n       report section.\n       rd floats.\n       1 float-line type de.\n        2 line plus 1.\n         3 column 1 pic -9.99e+99 source x(i).\n         2 column 12 pic -9.9999e+99 source y(i).\n       procedure division.\n       begin.\n           open output report-file\n           initiate floats\n           perform varying i from 1 by 1\n           until i > 4\n               compute y(i) = function sqrt (x(i))\n               generate float-line\n           end-perform\n           terminate floats\n           close report-file\n           stop run\n           .\n       end program wr-float.\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 79477, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to C#: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79478, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to C#: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79481, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Java: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79482, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Java: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79483, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Python: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79484, "name": "Sum multiples of 3 and 5", "source": "Translate COBOL to Python: Identification division.\nProgram-id. three-five-sum.\n\nData division.\nWorking-storage section.\n01 ws-the-limit  pic 9(18) value 1000.\n01 ws-the-number pic 9(18).\n01 ws-the-sum    pic 9(18).\n01 ws-sum-out    pic z(18).\n\nProcedure division.\nMain-program.\n    Perform Do-sum\n        varying ws-the-number from 1 by 1 \n        until ws-the-number = ws-the-limit.\n    Move ws-the-sum to ws-sum-out.\n    Display \"Sum = \" ws-sum-out.\n    End-run.\n\nDo-sum.\n    If function mod(ws-the-number, 3) = zero\n       or function mod(ws-the-number, 5) = zero\n       then add ws-the-number to ws-the-sum.\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 80121, "name": "Logical operations", "source": "Translate COBOL to C#:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80123, "name": "Logical operations", "source": "Translate COBOL to Java:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80124, "name": "Logical operations", "source": "Translate COBOL to Python:        IDENTIFICATION DIVISION.\n       PROGRAM-ID. print-logic.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  result                  PIC 1 USAGE BIT.\n\n       LINKAGE SECTION.\n       01  a                       PIC 1 USAGE BIT.\n       01  b                       PIC 1 USAGE BIT.\n\n       PROCEDURE DIVISION USING a, b.\n           COMPUTE result = a B-AND b\n           DISPLAY \"a and b is \" result\n\n           COMPUTE result = a B-OR b\n           DISPLAY \"a or b is \" result\n\n           COMPUTE result = B-NOT a\n           DISPLAY \"Not a is \" result\n\n           COMPUTE result = a B-XOR b\n           DISPLAY \"a exclusive-or b is \" result\n\n           GOBACK\n           .\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80713, "name": "Abstract type", "source": "Translate COBOL to C#:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}\n"}
{"id": 80715, "name": "Abstract type", "source": "Translate COBOL to Java:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"}
{"id": 80716, "name": "Abstract type", "source": "Translate COBOL to Python:        INTERFACE-ID. Shape.\n       \n       PROCEDURE DIVISION.\n       \n       METHOD-ID. perimeter.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD perimeter.\n       \n       METHOD-ID. shape-area.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  ret USAGE FLOAT-LONG.\n       PROCEDURE DIVISION RETURNING ret.\n       END METHOD shape-area.\n       \n       END INTERFACE Shape.\n       \n\n       CLASS-ID. Rectangle. \n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           INTERFACE Shape.\n       \n       OBJECT IMPLEMENTS Shape.\n           DATA DIVISION.\n           WORKING-STORAGE SECTION.\n           01  width  USAGE FLOAT-LONG PROPERTY.\n           01  height USAGE FLOAT-LONG PROPERTY.\n           \n           PROCEDURE DIVISION.\n           \n           METHOD-ID. perimeter.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * 2.0 + height * 2.0\n               GOBACK\n               .\n           END METHOD perimeter.\n       \n           METHOD-ID. shape-area.\n           DATA DIVISION.\n           LINKAGE SECTION.\n           01  ret USAGE FLOAT-LONG.\n           PROCEDURE DIVISION RETURNING ret.\n               COMPUTE ret = width * height\n               GOBACK\n               .\n           END METHOD shape-area.\n       END OBJECT.\n       \n       END CLASS Rectangle.\n", "target": "class BaseQueue(object):\n    \n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"}
{"id": 80964, "name": "Conway's Game of Life", "source": "Translate COBOL to C#: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80966, "name": "Conway's Game of Life", "source": "Translate COBOL to Java: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80967, "name": "Conway's Game of Life", "source": "Translate COBOL to Python: identification division.\nprogram-id. game-of-life-program.\ndata division.\nworking-storage section.\n01  grid.\n    05 cell-table.\n        10 row occurs 5 times.\n            15 cell pic x value space occurs 5 times.\n    05 next-gen-cell-table.\n        10 next-gen-row occurs 5 times.\n            15 next-gen-cell pic x occurs 5 times.\n01  counters.\n    05 generation pic 9.\n    05 current-row pic 9.\n    05 current-cell pic 9.\n    05 living-neighbours pic 9.\n    05 neighbour-row pic 9.\n    05 neighbour-cell pic 9.\n    05 check-row pic s9.\n    05 check-cell pic s9.\nprocedure division.\ncontrol-paragraph.\n    perform blinker-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    perform show-grid-paragraph through life-paragraph\n    varying generation from 0 by 1\n    until generation is greater than 2.\n    stop run.\nblinker-paragraph.\n    move '#' to cell(3,current-cell).\nshow-grid-paragraph.\n    display 'GENERATION ' generation ':'.\n    display '   +---+'.\n    perform show-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    display '   +---+'.\n    display ''.\nlife-paragraph.\n    perform update-row-paragraph varying current-row from 2 by 1\n    until current-row is greater than 4.\n    move next-gen-cell-table to cell-table.\nshow-row-paragraph.\n    display '   |' with no advancing.\n    perform show-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\n    display '|'.\nshow-cell-paragraph.\n    display cell(current-row,current-cell) with no advancing.\nupdate-row-paragraph.\n    perform update-cell-paragraph varying current-cell from 2 by 1\n    until current-cell is greater than 4.\nupdate-cell-paragraph.\n    move 0 to living-neighbours.\n    perform check-row-paragraph varying check-row from -1 by 1\n    until check-row is greater than 1.\n    evaluate living-neighbours,\n        when 2 move cell(current-row,current-cell) to next-gen-cell(current-row,current-cell),\n        when 3 move '#' to next-gen-cell(current-row,current-cell),\n        when other move space to next-gen-cell(current-row,current-cell),\n    end-evaluate.\ncheck-row-paragraph.\n    add check-row to current-row giving neighbour-row.\n    perform check-cell-paragraph varying check-cell from -1 by 1\n    until check-cell is greater than 1.\ncheck-cell-paragraph.\n    add check-cell to current-cell giving neighbour-cell.\n    if cell(neighbour-row,neighbour-cell) is equal to '#',\n    and check-cell is not equal to zero or check-row is not equal to zero,\n    then add 1 to living-neighbours.\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}

{"id": 392489, "name": "Numeric error propagation", "source": "Translate Swift to Java: import Foundation\n\nprecedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\ninfix operator \u00b1\n\nfunc \u00b1(_ lhs: Double, _ rhs: Double) -> UncertainDouble { UncertainDouble(value: lhs, error: rhs) }\n\nstruct UncertainDouble {\n  var value: Double\n  var error: Double\n\n  static func +(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func +(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value + rhs, error: lhs.error)\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs.value, error: pow(pow(lhs.error, 2) + pow(rhs.error, 2), 0.5))\n  }\n\n  static func -(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value - rhs, error: lhs.error)\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value * rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2)), 0.5)\n    )\n  }\n\n  static func *(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value * rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: UncertainDouble) -> UncertainDouble {\n    let val = lhs.value / rhs.value\n\n    return UncertainDouble(\n      value: val,\n      error: pow(val, 2) * (pow(lhs.error / lhs.value, 2) + pow(rhs.error / rhs.value, 2))\n    )\n  }\n\n  static func /(_ lhs: UncertainDouble, _ rhs: Double) -> UncertainDouble {\n    return UncertainDouble(value: lhs.value / rhs, error: abs(lhs.error * rhs))\n  }\n\n  static func **(_ lhs: UncertainDouble, _ power: Double) -> UncertainDouble {\n    let val = pow(lhs.value, power)\n\n    return UncertainDouble(value: val, error: abs((val * power) * (lhs.error / lhs.value)))\n  }\n}\n\nextension UncertainDouble: CustomStringConvertible {\n  public var description: String { \"\\(value) \u00b1 \\(error)\" }\n}\n\nlet (x1, y1) = (100 \u00b1 1.1, 50 \u00b1 1.2)\nlet (x2, y2) = (200 \u00b1 2.2, 100 \u00b1 2.3)\n\nlet d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\nprint(d)\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 392490, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Swift to Java: import Foundation\n\nprint(\"Enter 11 numbers for the Trabb\u2500Pardo\u2500Knuth algorithm:\")\n\nlet f: (Double) -> Double = { sqrt(fabs($0)) + 5 * pow($0, 3) }\n\n(1...11)\n    .generate()\n    .map { i -> Double in\n        print(\"\\(i): \", terminator: \"\")\n        guard let s = readLine(), let n = Double(s) else { return 0 }\n        return n\n    }\n    .reverse()\n    .forEach {\n        let result = f($0)\n        print(\"f(\\($0))\", result > 400.0 ? \"OVERFLOW\" : result, separator: \"\\t\")\n    }\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 392491, "name": "Rep-string", "source": "Translate Swift to Java: import Foundation\n\nfunc repString(_ input: String) -> [String] {\n  return (1..<(1 + input.count / 2)).compactMap({x -> String? in\n    let i = input.index(input.startIndex, offsetBy: x)\n    return input.hasPrefix(input[i...]) ? String(input.prefix(x)) : nil\n  })\n}\n\nlet testCases = \"\"\"\n                1001110011\n                1110111011\n                0010010010\n                1010101010\n                1111111111\n                0100101101\n                0100100\n                101\n                11\n                00\n                1\n                \"\"\".components(separatedBy: \"\\n\")\n\nfor testCase in testCases {\n  print(\"\\(testCase) has reps: \\(repString(testCase))\")\n}\n", "target": "public class RepString {\n\n    static final String[] input = {\"1001110011\", \"1110111011\", \"0010010010\",\n        \"1010101010\", \"1111111111\", \"0100101101\", \"0100100\", \"101\", \"11\",\n        \"00\", \"1\", \"0100101\"};\n\n    public static void main(String[] args) {\n        for (String s : input)\n            System.out.printf(\"%s\u00a0: %s%n\", s, repString(s));\n    }\n\n    static String repString(String s) {\n        int len = s.length();\n        outer:\n        for (int part = len / 2; part > 0; part--) {\n            int tail = len % part;\n            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))\n                continue;\n            for (int j = 0; j < len / part - 1; j++) {\n                int a = j * part;\n                int b = (j + 1) * part;\n                int c = (j + 2) * part;\n                if (!s.substring(a, b).equals(s.substring(b, c)))\n                    continue outer;\n            }\n            return s.substring(0, part);\n        }\n        return \"none\";\n    }\n}\n"}
{"id": 392492, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Swift to Java: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 32\nvar n = 1\nvar next = 1\nwhile next <= limit {\n    if next == divisorCount(number: n) {\n        print(n, terminator: \" \")\n        next += 1\n        if next > 4 && divisorCount(number: next) == 2 {\n            n = 1 << (next - 1) - 1;\n        }\n    }\n    n += 1\n}\nprint()\n", "target": "public class AntiPrimesPlus {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, next = 1; next <= max; ++i) {\n            if (next == count_divisors(i)) {           \n                System.out.printf(\"%d \", i);\n                next++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 392493, "name": "McNuggets problem", "source": "Translate Swift to Java: func maxNugget(limit: Int) -> Int {\n  var (max, sixes, nines, twenties, i) = (0, 0, 0, 0, 0)\n\n  mainLoop: while i < limit {\n    sixes = 0\n\n    while sixes * 6 < i {\n      if sixes * 6 == i {\n        i += 1\n        continue mainLoop\n      }\n\n      nines = 0\n\n      while nines * 9 < i {\n        if sixes * 6 + nines * 9 == i {\n          i += 1\n          continue mainLoop\n        }\n\n        twenties = 0\n\n        while twenties * 20 < i {\n          if sixes * 6 + nines * 9 + twenties * 20 == i {\n            i += 1\n            continue mainLoop\n          }\n\n          twenties += 1\n        }\n\n        nines += 1\n      }\n\n      sixes += 1\n    }\n\n    max = i\n    i += 1\n  }\n\n  return max\n}\n\nprint(maxNugget(limit: 100))\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 392494, "name": "Jaro similarity", "source": "Translate Swift to Java:  func jaroWinklerMatch(_ s: String, _ t: String) -> Double {\n    let s_len: Int = s.count\n    let t_len: Int = t.count\n    \n    if s_len == 0 && t_len == 0 {\n        return 1.0\n    }\n    \n    if s_len == 0 || t_len == 0 {\n        return 0.0\n    }\n    \n    var match_distance: Int = 0\n    \n    if s_len == 1 && t_len == 1 {\n        match_distance = 1\n    } else {\n        match_distance = ([s_len, t_len].max()!/2) - 1\n    }\n    \n    \n    var s_matches = [Bool]()\n    var t_matches = [Bool]()\n    \n    for _ in 1...s_len {\n        s_matches.append(false)\n    }\n    \n    for _ in 1...t_len {\n        t_matches.append(false)\n    }\n    \n    var matches: Double = 0.0\n    var transpositions: Double = 0.0\n    \n    for i in 0...s_len-1 {\n        \n        let start = [0, (i-match_distance)].max()!\n        let end = [(i + match_distance), t_len-1].min()!\n        \n        if start > end {\n            break\n        }\n        \n        for j in start...end {\n\n            if t_matches[j] {\n                continue\n            }\n\n            if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: j)] {\n                continue\n            }\n            \n            s_matches[i] = true\n            t_matches[j] = true\n            matches += 1\n            break\n        }\n    }\n    \n    if matches == 0 {\n        return 0.0\n    }\n    \n    var k = 0\n    for i in 0...s_len-1 {\n        if !s_matches[i] {\n            continue\n        }\n        while !t_matches[k] {\n            k += 1\n        }\n        if s[String.Index.init(encodedOffset: i)] != t[String.Index.init(encodedOffset: k)] {\n            \n            transpositions += 1\n        }\n        \n        k += 1\n    }\n    \n    let top = (matches / Double(s_len)) + (matches / Double(t_len)) + (matches - (transpositions / 2)) / matches\n    return top/3\n}\n\nprint(\"DWAYNE/DUANE:\", jaroWinklerMatch(\"DWAYNE\", \"DUANE\"))\nprint(\"MARTHA/MARHTA:\", jaroWinklerMatch(\"MARTHA\", \"MARHTA\"))\nprint(\"DIXON/DICKSONX:\", jaroWinklerMatch(\"DIXON\", \"DICKSONX\"))\nprint(\"JELLYFISH/SMELLYFISH:\", jaroWinklerMatch(\"JELLYFISH\", \"SMELLYFISH\"))\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 392495, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Swift to Java: import Foundation\n\nstruct XorshiftStar {\n  private let magic: UInt64 = 0x2545F4914F6CDD1D\n  private var state: UInt64\n\n  init(seed: UInt64) {\n    state = seed\n  }\n  \n  mutating func nextInt() -> UInt64 {\n    state ^= state &>> 12\n    state ^= state &<< 25\n    state ^= state &>> 27\n\n    return (state &* magic) &>> 32\n  }\n\n  mutating func nextFloat() -> Float {\n    return Float(nextInt()) / Float(1 << 32)\n  }\n}\n\nextension XorshiftStar: RandomNumberGenerator, IteratorProtocol, Sequence {\n  mutating func next() -> UInt64 {\n    return nextInt()\n  }\n\n  mutating func next() -> UInt64? {\n    return nextInt()\n  }\n}\n\nfor (i, n) in XorshiftStar(seed: 1234567).lazy.enumerated().prefix(5) {\n  print(\"\\(i): \\(n)\")\n}\n\nvar gen = XorshiftStar(seed: 987654321)\nvar counts = [Float: Int]()\n\nfor _ in 0..<100_000 {\n  counts[floorf(gen.nextFloat() * 5), default: 0] += 1\n}\n\nprint(counts)\n", "target": "public class XorShiftStar {\n    private static final long MAGIC = Long.parseUnsignedLong(\"2545F4914F6CDD1D\", 16);\n    private long state;\n\n    public void seed(long num) {\n        state = num;\n    }\n\n    public int nextInt() {\n        long x;\n        int answer;\n\n        x = state;\n        x = x ^ (x >>> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >>> 27);\n        state = x;\n        answer = (int) ((x * MAGIC) >> 32);\n\n        return answer;\n    }\n\n    public float nextFloat() {\n        return (float) Integer.toUnsignedLong(nextInt()) / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var rng = new XorShiftStar();\n        rng.seed(1234567);\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[j]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 392496, "name": "Numbers with equal rises and falls", "source": "Translate Swift to Java: import Foundation\n\nfunc equalRisesAndFalls(_ n: Int) -> Bool {\n    var total = 0\n    var previousDigit = -1\n    var m = n\n    while m > 0 {\n        let digit = m % 10\n        m /= 10\n        if previousDigit > digit {\n            total += 1\n        } else if previousDigit >= 0 && previousDigit < digit {\n            total -= 1\n        }\n        previousDigit = digit\n    }\n    return total == 0\n}\n\nvar count = 0\nvar n = 0\nlet limit1 = 200\nlet limit2 = 10000000\nprint(\"The first \\(limit1) numbers in the sequence are:\")\nwhile count < limit2 {\n    n += 1\n    if equalRisesAndFalls(n) {\n        count += 1\n        if count <= limit1 {\n            print(String(format: \"%3d\", n), terminator: count % 20 == 0 ? \"\\n\" : \" \")\n        }\n    }\n}\nprint(\"\\nThe \\(limit2)th number in the sequence is \\(n).\")\n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 392497, "name": "Self-describing numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isSelfDescribing: Bool {\n    let stringChars = String(self).map({ String($0) })\n    let counts = stringChars.reduce(into: [Int: Int](), {res, char in res[Int(char), default: 0] += 1})\n\n    for (i, n) in stringChars.enumerated() where counts[i, default: 0] != Int(n) {\n      return false\n    }\n\n    return true\n  }\n}\n\nprint(\"Self-describing numbers less than 100,000,000:\")\n\nDispatchQueue.concurrentPerform(iterations: 100_000_000) {i in\n  defer {\n    if i == 100_000_000 - 1 {\n      exit(0)\n    }\n  }\n\n  guard i.isSelfDescribing else {\n    return\n  }\n\n  print(i)\n}\n\ndispatchMain()\n", "target": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}\n"}
{"id": 392498, "name": "Air mass", "source": "Translate Swift to Java: import Foundation\n\nextension Double {\n  var radians: Double { self * .pi / 180 }\n}\n\nfunc columnDensity(_ a: Double, _ z: Double) -> Double {\n  func rho(_ a: Double) -> Double {\n    exp(-a / 8500)\n  }\n\n  func height(_ d: Double) -> Double {\n    let aa = 6_371_000 + a\n    let hh = aa * aa + d * d - 2 * d * aa * cos((180 - z).radians)\n\n    return hh.squareRoot() - 6_371_000\n  }\n\n  var sum = 0.0\n  var d = 0.0\n\n  while d < 1e7 {\n    let delta = max(0.001, 0.001 * d)\n\n    sum += rho(height(d + 0.5 * delta)) * delta\n    d += delta\n  }\n\n  return sum\n}\n\nfunc airMass(altitude: Double, zenith: Double) -> Double {\n  return columnDensity(altitude, zenith) / columnDensity(altitude, 0)\n}\n\nprint(\"Angle     0 m              13700 m\")\nprint(\"------------------------------------\")\n\nfor z in stride(from: 0.0, through: 90.0, by: 5.0) {\n  let air = String(\n    format: \"%2.0f      %11.8f      %11.8f\",\n    z,\n    airMass(altitude: 0, zenith: z),\n    airMass(altitude: 13700, zenith: z)\n  )\n\n  print(air)\n}\n", "target": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}\n"}
{"id": 392499, "name": "Odd words", "source": "Translate Swift to Java: import Foundation\n\nlet minLength = 5\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{$0.count >= minLength})\n}\n\nfunc pad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc printWords(words: [(String,String)]) {\n    for (n, (word1, word2)) in words.enumerated() {\n        print(\"\\(String(format: \"%2d\", n + 1)): \\(pad(string: word1, width: 14))\\(word2)\")\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    var oddWords: [(String, String)] = []\n    var evenWords: [(String, String)] = []\n    for word in dictionary {\n        if word.count < minLength + 2*(minLength/2) {\n            continue\n        }\n        var oddWord = \"\"\n        var evenWord = \"\"\n        for (i, c) in word.enumerated() {\n            if (i & 1) == 0 {\n                oddWord.append(c)\n            } else {\n                evenWord.append(c)\n            }\n        }\n        if dictionary.contains(oddWord) {\n            oddWords.append((word, oddWord))\n        }\n        if dictionary.contains(evenWord) {\n            evenWords.append((word, evenWord))\n        }\n    }\n    oddWords.sort(by: {$0.0 < $1.0})\n    evenWords.sort(by: {$0.0 < $1.0})\n    print(\"Odd words:\")\n    printWords(words: oddWords)\n    print(\"\\nEven words:\")\n    printWords(words: evenWords)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class OddWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            final int minLength = 5;\n            String fileName = \"unixdict.txt\";\n            if (args.length != 0)\n                fileName = args[0];\n            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() >= minLength)\n                        dictionary.add(line);\n                }\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            List<StringPair> evenWords = new ArrayList<>();\n            List<StringPair> oddWords = new ArrayList<>();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < minLength + 2 * (minLength/2))\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; ++i) {\n                    if ((i & 1) == 0)\n                        word1.append(word.charAt(i));\n                    else\n                        word2.append(word.charAt(i));\n                }\n                String oddWord = word1.toString();\n                String evenWord = word2.toString();\n                if (dictionary.contains(oddWord))\n                    oddWords.add(new StringPair(word, oddWord));\n                if (dictionary.contains(evenWord))\n                    evenWords.add(new StringPair(word, evenWord));\n            }\n            System.out.println(\"Odd words:\");\n            printWords(oddWords);\n            System.out.println(\"\\nEven words:\");\n            printWords(evenWords);\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    private static void printWords(List<StringPair> strings) {\n        int n = 1;\n        for (StringPair pair : strings) {\n            System.out.printf(\"%2d:\u00a0%-14s%s\\n\", n++,\n                                    pair.string1, pair.string2);\n        }\n    }\n\n    private static class StringPair {\n        private String string1;\n        private String string2;\n        private StringPair(String s1, String s2) {\n            string1 = s1;\n            string2 = s2;\n        }\n    }\n}\n"}
{"id": 392500, "name": "Deming's funnel", "source": "Translate Swift to Java: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 392501, "name": "Deming's funnel", "source": "Translate Swift to Java: import Foundation\n\nlet dxs = [\n  -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n  1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n  -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n  0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n  -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n  -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n  0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n  -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n  0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n  -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n  0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n  0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n  0.443, -0.521, -0.799,  0.087\n]\n\nlet dys = [\n  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n  0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n  0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n  0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n  -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n  0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n  0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n  1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n  -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n  0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n  -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n  1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n  -0.947, -1.424, -0.542, -1.032\n]\n\nextension Collection where Element: FloatingPoint {\n  @inlinable\n  public func mean() -> Element {\n    return reduce(0, +) / Element(count)\n  }\n\n  @inlinable\n  public func stdDev() -> Element {\n    let m = mean()\n\n    return map({ ($0 - m) * ($0 - m) }).mean().squareRoot()\n  }\n}\n\ntypealias Rule = (Double, Double) -> Double\n\nfunc funnel(_ arr: [Double], rule: Rule) -> [Double] {\n  var x = 0.0\n  var res = [Double](repeating: 0, count: arr.count)\n\n  for (i, d) in arr.enumerated() {\n    res[i] = x + d\n    x = rule(x, d)\n  }\n\n  return res\n}\n\nfunc experiment(label: String, rule: Rule) {\n  let rxs = funnel(dxs, rule: rule)\n  let rys = funnel(dys, rule: rule)\n\n  print(\"\\(label)\\t:    x        y\")\n  print(\"Mean\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.mean(), rys.mean()))\")\n  print(\"Std Dev\\t:\\(String(format: \"%7.4f, %7.4f\", rxs.stdDev(), rys.stdDev()))\")\n  print()\n}\n\nexperiment(label: \"Rule 1\", rule: {_, _ in 0 })\nexperiment(label: \"Rule 2\", rule: {_, dz in -dz })\nexperiment(label: \"Rule 3\", rule: {z, dz in -(z + dz) })\nexperiment(label: \"Rule 4\", rule: {z, dz in z + dz })\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 392502, "name": "MD5_Implementation", "source": "Translate Swift to Java:     import Foundation\n    public class MD5 {\n        \n        private let s: [UInt32] = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                           5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                           4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                           6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]\n        \n        \n        private let K: [UInt32] = (0 ..< 64).map { UInt32(0x100000000 * abs(sin(Double($0 + 1)))) }\n        \n        let a0: UInt32 = 0x67452301\n        let b0: UInt32 = 0xefcdab89\n        let c0: UInt32 = 0x98badcfe\n        let d0: UInt32 = 0x10325476\n        \n        private var message: NSData\n        \n        \n        \n        public init(_ message: NSData) {\n            self.message = message\n        }\n        \n        public func calculate() -> NSData? {\n            var tmpMessage: NSMutableData = NSMutableData(data: message)\n            let wordSize = sizeof(UInt32)\n            \n            var aa = a0\n            var bb = b0\n            var cc = c0\n            var dd = d0\n            \n            \n            tmpMessage.appendBytes([0x80]) \n            \n            \n            while tmpMessage.length % 64 != 56 {\n                tmpMessage.appendBytes([0x00])\n            }\n            \n            \n            var lengthInBits = (message.length * 8)\n            var lengthBytes = lengthInBits.bytes(64 / 8)\n            tmpMessage.appendBytes(reverse(lengthBytes));\n            \n            \n            let chunkSizeBytes = 512 / 8\n            var leftMessageBytes = tmpMessage.length\n            for var i = 0; i < tmpMessage.length; i = i + chunkSizeBytes, leftMessageBytes -= chunkSizeBytes {\n                let chunk = tmpMessage.subdataWithRange(NSRange(location: i, length: min(chunkSizeBytes,leftMessageBytes)))\n                \n                \n                \n                var M:[UInt32] = [UInt32](count: 16, repeatedValue: 0)\n                for x in 0..<M.count {\n                    var range = NSRange(location:x * wordSize, length: wordSize)\n                    chunk.getBytes(&M[x], range:range);\n                }\n                \n                \n                var A:UInt32 = a0\n                var B:UInt32 = b0\n                var C:UInt32 = c0\n                var D:UInt32 = d0\n                \n                var dTemp:UInt32 = 0\n                \n                \n                for j in 0...63 {\n                    var g = 0\n                    var F:UInt32 = 0\n                    \n                    switch (j) {\n                    case 0...15:\n                        F = (B & C) | ((~B) & D)\n                        g = j\n                        break\n                    case 16...31:\n                        F = (D & B) | (~D & C)\n                        g = (5 * j + 1) % 16\n                        break\n                    case 32...47:\n                        F = B ^ C ^ D\n                        g = (3 * j + 5) % 16\n                        break\n                    case 48...63:\n                        F = C ^ (B | (~D))\n                        g = (7 * j) % 16\n                        break\n                    default:\n                        break\n                    }\n                    dTemp = D\n                    D = C\n                    C = B\n                    B = B &+ rotateLeft((A &+ F &+ K[j] &+ M[g]), s[j])\n                    A = dTemp    \n                }\n                \n                aa = aa &+ A\n                bb = bb &+ B\n                cc = cc &+ C\n                dd = dd &+ D\n            }\n\n            var buf: NSMutableData = NSMutableData();\n            buf.appendBytes(&aa, length: wordSize)\n            buf.appendBytes(&bb, length: wordSize)\n            buf.appendBytes(&cc, length: wordSize)\n            buf.appendBytes(&dd, length: wordSize)\n            \n            return buf.copy() as? NSData;\n        }\n\n        \n        class func calculate(message: NSData) -> NSData?\n        {\n            return MD5(message).calculate();\n        }\n        \n        \n        private func rotateLeft(x:UInt32, _ n:UInt32) -> UInt32 {\n            return (x &<< n) | (x &>> (32 - n))\n        }\n    }\n", "target": "class MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n"}
{"id": 392503, "name": "History variables", "source": "Translate Swift to Java: var historyOfHistory = [Int]()\nvar history:Int = 0 {\n    willSet {\n        historyOfHistory.append(history)\n    }\n}\n\nhistory = 2\nhistory = 3\nhistory = 4\nprintln(historyOfHistory)\n", "target": "public class HistoryVariable\n{\n    private Object value;\n\n    public HistoryVariable(Object v)\n    {\n        value = v;\n    }\n\n    public void update(Object v)\n    {\n        value = v;\n    }\n\n    public Object undo()\n    {\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value.toString();\n    }\n\n    public void dispose()\n    {\n    }\n}\n"}
{"id": 392504, "name": "Function definition", "source": "Translate Swift to Java: func multiply(a: Double, b: Double) -> Double {\n   return a * b\n}\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 392505, "name": "Jacobi symbol", "source": "Translate Swift to Java: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 392506, "name": "Jacobi symbol", "source": "Translate Swift to Java: import Foundation\n\nfunc jacobi(a: Int, n: Int) -> Int {\n  var a = a % n\n  var n = n\n  var res = 1\n\n  while a != 0 {\n    while a & 1 == 0 {\n      a >>= 1\n\n      if n % 8 == 3 || n % 8 == 5 {\n        res = -res\n      }\n    }\n\n    (a, n) = (n, a)\n\n    if a % 4 == 3 && n % 4 == 3 {\n      res = -res\n    }\n    \n    a %= n\n  }\n\n  return n == 1 ? res : 0\n}\n\nprint(\"n/a  0  1  2  3  4  5  6  7  8  9\")\nprint(\"---------------------------------\")\n\nfor n in stride(from: 1, through: 17, by: 2) {\n  print(String(format: \"%2d\", n), terminator: \"\")\n\n  for a in 0..<10 {\n    print(String(format: \"\u00a0% d\", jacobi(a: a, n: n)), terminator: \"\")\n  }\n\n  print()\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 392507, "name": "Sattolo cycle", "source": "Translate Swift to Java: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 392508, "name": "Sattolo cycle", "source": "Translate Swift to Java: extension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 392509, "name": "Y combinator", "source": "Translate Swift to Java: struct RecursiveFunc<F> {\n  let o : RecursiveFunc<F> -> F\n}\n\nfunc Y<A, B>(f: (A -> B) -> A -> B) -> A -> B {\n  let r = RecursiveFunc<A -> B> { w in f { w.o(w)($0) } }\n  return r.o(r)\n}\n\nlet fac = Y { (f: Int -> Int) in\n  { $0 <= 1 ? 1 : $0 * f($0-1) }\n}\nlet fib = Y { (f: Int -> Int) in\n  { $0 <= 2 ? 1 : f($0-1)+f($0-2) }\n}\nprintln(\"fac(5) = \\(fac(5))\")\nprintln(\"fib(9) = \\(fib(9))\")\n", "target": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n"}
{"id": 392510, "name": "Factorions", "source": "Translate Swift to Java: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 392511, "name": "Factorions", "source": "Translate Swift to Java: var fact = Array(repeating: 0, count: 12)\n\nfact[0] = 1\n\nfor n in 1..<12 {\n  fact[n] = fact[n - 1] * n\n}\n\nfor b in 9...12 {\n  print(\"The factorions for base \\(b) are:\")\n\n  for i in 1..<1500000 {\n    var sum = 0\n    var j = i\n\n    while j > 0 {\n      sum += fact[j % b]\n      j /= b\n    }\n\n    if sum == i {\n      print(\"\\(i)\", terminator: \" \")\n      fflush(stdout)\n    }\n  }\n\n  print(\"\\n\")\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 392512, "name": "Tau function", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 392513, "name": "Tau function", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"Count of divisors for the first \\(limit) positive integers:\")\nfor n in 1...limit {\n    print(String(format: \"%3d\", divisorCount(number: n)), terminator: \"\")\n    if n % 20 == 0 {\n        print()\n    }\n}\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 392514, "name": "Execute Brain____", "source": "Translate Swift to Java: import Foundation\n\nlet valids = [\">\", \"<\", \"+\", \"-\", \".\", \",\", \"[\", \"]\"] as Set<Character>\nvar ip = 0\nvar dp = 0\nvar data = [UInt8](count: 30_000, repeatedValue: 0)\n\nlet input = Process.arguments\n\nif input.count != 2 {\n    fatalError(\"Need one input file\")\n}\n\nlet infile: String!\n\ndo {\n    infile = try String(contentsOfFile: input[1], encoding: NSUTF8StringEncoding) ?? \"\"\n} catch let err {\n    infile = \"\"\n}\n\nvar program = \"\"\n\n\nfor c in infile.characters {\n    if valids.contains(c) {\n        program += String(c)\n    }\n}\n\nlet numChars = program.characters.count\n\nif numChars == 0 {\n    fatalError(\"Error reading file\")\n}\n\nfunc increaseInstructionPointer() {\n    ip += 1\n}\n\nfunc executeInstruction(ins: Character) {\n    switch ins {\n    case \">\":\n        dp += 1\n        increaseInstructionPointer()\n    case \"<\":\n        dp -= 1\n        increaseInstructionPointer()\n    case \"+\":\n        data[dp] = data[dp] &+ 1\n        increaseInstructionPointer()\n    case \"-\":\n        data[dp] = data[dp] &- 1\n        increaseInstructionPointer()\n    case \".\":\n        print(Character(UnicodeScalar(data[dp])), terminator: \"\")\n        increaseInstructionPointer()\n    case \",\":\n        handleIn()\n        increaseInstructionPointer()\n    case \"[\":\n        handleOpenBracket()\n    case \"]\":\n        handleClosedBracket()\n    default:\n        fatalError(\"What\")\n    }\n}\n\nfunc handleIn() {\n    let input = NSFileHandle.fileHandleWithStandardInput()\n    let bytes = input.availableData.bytes\n    let buf = unsafeBitCast(UnsafeBufferPointer(start: bytes, count: 1),\n        UnsafeBufferPointer<UInt8>.self)\n    \n    data[dp] = buf[0]\n}\n\nfunc handleOpenBracket() {\n    if data[dp] == 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip += 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i += 1\n            } else if ins == \"]\" {\n                i -= 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc handleClosedBracket() {\n    if data[dp] != 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip -= 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i -= 1\n            } else if ins == \"]\" {\n                i += 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc tick() {\n    let ins = program[program.startIndex.advancedBy(ip)]\n    \n    if valids.contains(ins) {\n        executeInstruction(ins)\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nwhile ip != numChars {\n    tick()\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 392515, "name": "Execute Brain____", "source": "Translate Swift to Java: import Foundation\n\nlet valids = [\">\", \"<\", \"+\", \"-\", \".\", \",\", \"[\", \"]\"] as Set<Character>\nvar ip = 0\nvar dp = 0\nvar data = [UInt8](count: 30_000, repeatedValue: 0)\n\nlet input = Process.arguments\n\nif input.count != 2 {\n    fatalError(\"Need one input file\")\n}\n\nlet infile: String!\n\ndo {\n    infile = try String(contentsOfFile: input[1], encoding: NSUTF8StringEncoding) ?? \"\"\n} catch let err {\n    infile = \"\"\n}\n\nvar program = \"\"\n\n\nfor c in infile.characters {\n    if valids.contains(c) {\n        program += String(c)\n    }\n}\n\nlet numChars = program.characters.count\n\nif numChars == 0 {\n    fatalError(\"Error reading file\")\n}\n\nfunc increaseInstructionPointer() {\n    ip += 1\n}\n\nfunc executeInstruction(ins: Character) {\n    switch ins {\n    case \">\":\n        dp += 1\n        increaseInstructionPointer()\n    case \"<\":\n        dp -= 1\n        increaseInstructionPointer()\n    case \"+\":\n        data[dp] = data[dp] &+ 1\n        increaseInstructionPointer()\n    case \"-\":\n        data[dp] = data[dp] &- 1\n        increaseInstructionPointer()\n    case \".\":\n        print(Character(UnicodeScalar(data[dp])), terminator: \"\")\n        increaseInstructionPointer()\n    case \",\":\n        handleIn()\n        increaseInstructionPointer()\n    case \"[\":\n        handleOpenBracket()\n    case \"]\":\n        handleClosedBracket()\n    default:\n        fatalError(\"What\")\n    }\n}\n\nfunc handleIn() {\n    let input = NSFileHandle.fileHandleWithStandardInput()\n    let bytes = input.availableData.bytes\n    let buf = unsafeBitCast(UnsafeBufferPointer(start: bytes, count: 1),\n        UnsafeBufferPointer<UInt8>.self)\n    \n    data[dp] = buf[0]\n}\n\nfunc handleOpenBracket() {\n    if data[dp] == 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip += 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i += 1\n            } else if ins == \"]\" {\n                i -= 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc handleClosedBracket() {\n    if data[dp] != 0 {\n        var i = 1\n        \n        while i > 0 {\n            ip -= 1\n            let ins = program[program.startIndex.advancedBy(ip)]\n            \n            if ins == \"[\" {\n                i -= 1\n            } else if ins == \"]\" {\n                i += 1\n            }\n        }\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nfunc tick() {\n    let ins = program[program.startIndex.advancedBy(ip)]\n    \n    if valids.contains(ins) {\n        executeInstruction(ins)\n    } else {\n        increaseInstructionPointer()\n    }\n}\n\nwhile ip != numChars {\n    tick()\n}\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 392516, "name": "Mertens function", "source": "Translate Swift to Java: import Foundation\n\nfunc mertensNumbers(max: Int) -> [Int] {\n    var mertens = Array(repeating: 1, count: max + 1)\n    for n in 2...max {\n        for k in 2...n {\n            mertens[n] -= mertens[n / k]\n        }\n    }\n    return mertens\n}\n\nlet max = 1000\nlet mertens = mertensNumbers(max: max)\n\nlet count = 200\nlet columns = 20\nprint(\"First \\(count - 1) Mertens numbers:\")\nfor i in 0..<count {\n    if i % columns > 0 {\n        print(\" \", terminator: \"\")\n    }\n    print(i == 0 ? \"  \" : String(format: \"%2d\", mertens[i]), terminator: \"\")\n    if (i + 1) % columns == 0 {\n        print()\n    }\n}\n\nvar zero = 0, cross = 0, previous = 0\nfor i in 1...max {\n    let m = mertens[i]\n    if m == 0 {\n        zero += 1\n        if previous != 0 {\n            cross += 1\n        }\n    }\n    previous = m\n}\nprint(\"M(n) is zero \\(zero) times for 1 <= n <= \\(max).\")\nprint(\"M(n) crosses zero \\(cross) times for 1 <= n <= \\(max).\")\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 392517, "name": "Playing cards", "source": "Translate Swift to Java: struct Card: CustomStringConvertible\n{\n\tenum Suit: String, CaseIterable, CustomStringConvertible\n\t{\n\t\tcase clubs = \"\u2663\ufe0f\"\n\t\tcase diamonds = \"\u2666\ufe0f\"\n\t\tcase hearts = \"\u2665\ufe0f\"\n\t\tcase spades = \"\u2660\ufe0f\"\n\n\t\tvar description: String { rawValue }\n\t}\n\n\tlet suit: Suit\n\tlet value: Int\n\n\tvar description: String\n\t{\n\t\tlet valueAsString: String\n\t\tswitch value\n\t\t{\n\t\tcase 1:\n\t\t\tvalueAsString = \"A\"\n\t\tcase 11:\n\t\t\tvalueAsString = \"J\"\n\t\tcase 12:\n\t\t\tvalueAsString = \"Q\"\n\t\tcase 13:\n\t\t\tvalueAsString = \"K\"\n\t\tdefault:\n\t\t\tvalueAsString = \"\\(value)\"\n\t\t}\n\t\treturn valueAsString + suit.description\n\t}\n}\n\nstruct Deck: CustomStringConvertible\n{\n\tvar cards: [Card] = []\n\n\tinit()\n\t{\n\t\tfor suit in Card.Suit.allCases\n\t\t{\n\t\t\tfor faceValue in 1 ... 13\n\t\t\t{\n\t\t\t\tcards.append(Card(suit: suit, value: faceValue))\n\t\t\t}\n\t\t}\n\t}\n\n\tvar description: String\n\t{\n\t\tString(cards.map{ $0.description }.joined(separator: \", \"))\n\t}\n\n\tmutating func shuffle()\n\t{\n\t\tcards.shuffle()\n\t}\n\n\tmutating func dealCard() -> Card?\n\t{\n\t\tguard !cards.isEmpty else { return nil }\n\t\treturn cards.removeLast()\n\t}\n}\n\nvar deck = Deck()\nprint(\"New deck:\")\nprint(deck)\ndeck.shuffle()\nprint(\"Shuffled deck:\")\nprint(deck)\n\nvar hands: [[Card]] = [[], [], [], []]\n\nvar handIndex = 0\n\nwhile let card = deck.dealCard()\n{\n\thands[handIndex].append(card)\n\thandIndex = (handIndex + 1) % hands.count\n}\n\nprint (\"Hands:\")\nprint(hands.map({ $0.description }).joined(separator: \"\\n\"))\nprint(\"Remaining deck (should be empty):\")\nprint(deck)\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 392518, "name": "Perfect totient numbers", "source": "Translate Swift to Java: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 392519, "name": "Perfect totient numbers", "source": "Translate Swift to Java: public func totient(n: Int) -> Int {\n  var n = n\n  var i = 2\n  var tot = n\n\n  while i * i <= n {\n    if n % i == 0 {\n      while n % i == 0 {\n        n /= i\n      }\n\n      tot -= tot / i\n    }\n\n    if i == 2 {\n      i = 1\n    }\n\n    i += 2\n  }\n\n  if n > 1 {\n    tot -= tot / n\n  }\n\n  return tot\n}\n\npublic struct PerfectTotients: Sequence, IteratorProtocol {\n  private var m = 1\n\n  public init() { }\n\n  public mutating func next() -> Int? {\n    while true {\n      defer {\n        m += 1\n      }\n\n      var tot = m\n      var sum = 0\n\n      while tot != 1 {\n        tot = totient(n: tot)\n        sum += tot\n      }\n\n      if sum == m {\n        return m\n      }\n    }\n  }\n}\n\nprint(\"The first 20 perfect totient numbers are:\")\nprint(Array(PerfectTotients().prefix(20)))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 392520, "name": "Lah numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 392521, "name": "Lah numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\n@inlinable\npublic func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n@inlinable\npublic func lah<T: BinaryInteger>(n: T, k: T) -> T {\n  if k == 1 {\n    return factorial(n)\n  } else if k == n {\n    return 1\n  } else if k > n {\n    return 0\n  } else if k < 1 || n < 1 {\n    return 0\n  } else {\n    let a = (factorial(n) * factorial(n - 1))\n    let b = (factorial(k) * factorial(k - 1))\n    let c = factorial(n - k)\n\n    return a / b / c\n  }\n}\n\nprint(\"Unsigned Lah numbers: L(n, k):\")\nprint(\"n\\\\k\", terminator: \"\")\n\nfor i in 0...12 {\n  print(String(format: \"%10d\", i), terminator: \" \")\n}\n\nprint()\n\nfor row in 0...12 {\n  print(String(format: \"%-2d\", row), terminator: \"\")\n\n  for i in 0...row {\n    lah(n: BigInt(row), k: BigInt(i)).description.withCString {str in\n      print(String(format: \"%11s\", str), terminator: \"\")\n    }\n  }\n\n  print()\n}\n\nlet maxLah = (0...100).map({ lah(n: BigInt(100), k: BigInt($0)) }).max()!\n\nprint(\"Maximum value from the L(100, *) row: \\(maxLah)\")\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 392522, "name": "Sorting algorithms_Cocktail sort with shifting bounds", "source": "Translate Swift to Java: func cocktailShakerSort<T: Comparable>(_ a: inout [T]) {\n    var begin = 0\n    var end = a.count\n    if end == 0 {\n        return\n    }\n    end -= 1\n    while begin < end {\n        var new_begin = end\n        var new_end = begin\n        var i = begin\n        while i < end {\n            if a[i + 1] < a[i] {\n                a.swapAt(i, i + 1)\n                new_end = i\n            }\n            i += 1\n        }\n        end = new_end\n        i = end\n        while i > begin {\n            if a[i] < a[i - 1] {\n                a.swapAt(i, i - 1)\n                new_begin = i\n            }\n            i -= 1\n        }\n        begin = new_begin\n    }\n}\n\nvar array = [5, 1, -6, 12, 3, 13, 2, 4, 0, 15]\nprint(\"before: \\(array)\")\ncocktailShakerSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncocktailShakerSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "import java.util.*;\n\npublic class CocktailSort {\n    public static void main(String[] args) {\n        Integer[] array = new Integer[]{ 5, 1, -6, 12, 3, 13, 2, 4, 0, 15 };\n        System.out.println(\"before: \" + Arrays.toString(array));\n        cocktailSort(array);\n        System.out.println(\"after: \" + Arrays.toString(array));\n    }\n\n    \n    public static void cocktailSort(Object[] array) {\n        int begin = 0;\n        int end = array.length;\n        if (end == 0)\n            return;\n        for (--end; begin < end; ) {\n            int new_begin = end;\n            int new_end = begin;\n            for (int i = begin; i < end; ++i) {\n                Comparable c1 = (Comparable)array[i];\n                Comparable c2 = (Comparable)array[i + 1];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i + 1);\n                    new_end = i;\n                }\n            }\n            end = new_end;\n            for (int i = end; i > begin; --i) {\n                Comparable c1 = (Comparable)array[i - 1];\n                Comparable c2 = (Comparable)array[i];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i - 1);\n                    new_begin = i;\n                }\n            }\n            begin = new_begin;\n        }\n    }\n\n    private static void swap(Object[] array, int i, int j) {\n        Object tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\n"}
{"id": 392523, "name": "Unprimeable numbers", "source": "Translate Swift to Java: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\n\nfunc countDigits(number: Int) -> Int {\n    var digits = 0\n    var n = number\n    while n > 0 {\n        n /= 10\n        digits += 1\n    }\n    return digits\n}\n\n\nfunc changeDigit(number: Int, index: Int, digit: Int) -> Int {\n    var p = 1\n    var changed = 0\n    var n = number\n    var i = index\n    while i > 0 {\n        changed += p * (n % 10)\n        p *= 10\n        n /= 10\n        i -= 1\n    }\n    changed += (10 * (n / 10) + digit) * p\n    return changed\n}\n\nfunc unprimeable(sieve: PrimeSieve, number: Int) -> Bool {\n    if sieve.isPrime(number: number) {\n        return false\n    }\n    for i in 0..<countDigits(number: number) {\n        for j in 0..<10 {\n            let n = changeDigit(number: number, index: i, digit: j)\n            if n != number && sieve.isPrime(number: n) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nvar n = 100\nvar lowest = Array(repeating: 0, count: 10)\nvar found = 0\nlet sieve = PrimeSieve(size: 10000000)\nprint(\"First 35 unprimeable numbers:\")\nwhile count < 600 || found < 10 {\n    if unprimeable(sieve: sieve, number: n) {\n        if count < 35 {\n            if count > 0 {\n                print(\", \", terminator: \"\")\n            }\n            print(n, terminator: \"\")\n        }\n        count += 1\n        if count == 600 {\n            print(\"\\n600th unprimeable number: \\(n)\")\n        }\n        let lastDigit = n % 10\n        if lowest[lastDigit] == 0 {\n            lowest[lastDigit] = n\n            found += 1\n        }\n    }\n    n += 1\n}\nfor i in 0..<10 {\n    let number = NSNumber(value: lowest[i])\n    let str = NumberFormatter.localizedString(from: number, number: .decimal)\n    print(\"Least unprimeable number ending in \\(i): \\(str)\")\n}\n", "target": "public class UnprimeableNumbers {\n\n    private static int MAX = 10_000_000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 35 unprimeable numbers:\");\n        displayUnprimeableNumbers(35);\n        int n = 600;\n        System.out.printf(\"%nThe %dth unprimeable number =\u00a0%,d%n%n\", n, nthUnprimeableNumber(n));\n        int[] lowest = genLowest();\n        System.out.println(\"Least unprimeable number that ends in:\");\n        for ( int i = 0 ; i <= 9 ; i++ ) {\n            System.out.printf(\" %d is\u00a0%,d%n\", i, lowest[i]);\n        }\n    }\n    \n    private static int[] genLowest() {\n        int[] lowest = new int[10];\n        int count = 0;\n        int test = 1;\n        while ( count < 10 ) {\n            test++;\n            if ( unPrimable(test) && lowest[test % 10] == 0 ) {\n                lowest[test % 10] = test;\n                count++;\n            }\n        }\n        return lowest;\n    }\n\n    private static int nthUnprimeableNumber(int maxCount) {\n        int test = 1;\n        int count = 0;\n        int result = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                result = test;\n            }\n        }\n        return result;\n    }\n\n    private static void displayUnprimeableNumbers(int maxCount) {\n        int test = 1;\n        int count = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                System.out.printf(\"%d \", test);\n            }\n        }\n        System.out.println();\n    }\n    \n    private static boolean unPrimable(int test) {\n        if ( primes[test] ) {\n            return false;\n        }\n        String s = test + \"\";\n        for ( int i = 0 ; i < s.length() ; i++ ) {\n            for ( int j = 0 ; j <= 9 ; j++ ) {\n                if ( primes[Integer.parseInt(replace(s, i, j))] ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static String replace(String str, int position, int value) {\n        char[] sChar = str.toCharArray();\n        sChar[position] = (char) value;\n        return str.substring(0, position) + value + str.substring(position + 1);\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 392524, "name": "Tau number", "source": "Translate Swift to Java: import Foundation\n\n\nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while (n & 1) == 0 {\n        total += 1\n        n >>= 1\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 100\nprint(\"The first \\(limit) tau numbers are:\")\nvar count = 0\nvar n = 1\nwhile count < limit {\n    if n % divisorCount(number: n) == 0 {\n        print(String(format: \"%5d\", n), terminator: \"\")\n        count += 1\n        if count % 10 == 0 {\n            print()\n        }\n    }\n    n += 1\n}\n", "target": "public class Tau {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"The first %d tau numbers are:%n\", limit);\n        long count = 0;\n        for (long n = 1; count < limit; ++n) {\n            if (n % divisorCount(n) == 0) {\n                System.out.printf(\"%6d\", n);\n                ++count;\n                if (count % 10 == 0) {\n                    System.out.println();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 392525, "name": "Modulinos", "source": "Translate Swift to Java: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 392526, "name": "Modulinos", "source": "Translate Swift to Java: import Foundation\n\npublic class ScriptedMain {\n  public var meaningOfLife = 42\n\n  public init() {}\n\n  public class func main() {\n    var meaning = ScriptedMain().meaningOfLife\n\n    println(\"Main: The meaning of life is \\(meaning)\")\n  }\n}\n\n#if SCRIPTEDMAIN\n@objc class ScriptedMainAutoload {\n  @objc class func load() {\n    ScriptedMain.main()\n  }\n}\n#endif\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 392527, "name": "Find the last Sunday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 392528, "name": "Find the last Sunday of each month", "source": "Translate Swift to Java: import Foundation\n\nfunc lastSundays(of year: Int) -> [Date] {\n\t\n\tlet calendar = Calendar.current\n\tvar dates = [Date]()\n\t\n\tfor month in 1...12 {\n\t\t\n\t\tvar dateComponents = DateComponents(calendar: calendar,\n\t\t                                    year: year,\n\t\t                                    month: month + 1,\n\t\t                                    day: 0,\n\t\t                                    hour: 12)\n\t\t\n\t\tlet date = calendar.date(from: dateComponents)!\n\t\tlet weekday = calendar.component(.weekday, from: date)\n\n\t\tif weekday != 1 {\n\t\t\tdateComponents.day! -= weekday - 1\n\t\t}\n\t\t\n\t\tdates.append(calendar.date(from: dateComponents)!)\n\t}\n\treturn dates\n}\n\nvar dateFormatter = DateFormatter()\ndateFormatter.dateStyle = .short\n\nprint(lastSundays(of: 2013).map(dateFormatter.string).joined(separator: \"\\n\"))\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 392529, "name": "Teacup rim text", "source": "Translate Swift to Java: import Foundation\n\nfunc loadDictionary(_ path: String) throws -> Set<String> {\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    return Set<String>(contents.components(separatedBy: \"\\n\").filter{!$0.isEmpty})\n}\n\nfunc rotate<T>(_ array: inout [T]) {\n    guard array.count > 1 else {\n        return\n    }\n    let first = array[0]\n    array.replaceSubrange(0..<array.count-1, with: array[1...])\n    array[array.count - 1] = first\n}\n\nfunc findTeacupWords(_ dictionary: Set<String>) {\n    var teacupWords: [String] = []\n    var found = Set<String>()\n    for word in dictionary {\n        if word.count < 3 || found.contains(word) {\n            continue\n        }\n        teacupWords.removeAll()\n        var isTeacupWord = true\n        var chars = Array(word)\n        for _ in 1..<word.count {\n            rotate(&chars)\n            let w = String(chars)\n            if (!dictionary.contains(w)) {\n                isTeacupWord = false\n                break\n            }\n            if w != word && !teacupWords.contains(w) {\n                teacupWords.append(w)\n            }\n        }\n        if !isTeacupWord || teacupWords.isEmpty {\n            continue\n        }\n        print(word, terminator: \"\")\n        found.insert(word)\n        for w in teacupWords {\n            found.insert(w)\n            print(\" \\(w)\", terminator: \"\")\n        }\n        print()\n    }\n}\n\ndo {\n    let dictionary = try loadDictionary(\"unixdict.txt\")\n    findTeacupWords(dictionary)\n} catch {\n    print(error)\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Teacup {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"usage: java Teacup dictionary\");\n            System.exit(1);\n        }\n        try {\n            findTeacupWords(loadDictionary(args[0]));\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n\n    \n    private static Set<String> loadDictionary(String fileName) throws IOException {\n        Set<String> words = new TreeSet<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String word;\n            while ((word = reader.readLine()) != null)\n                words.add(word);\n            return words;\n        }\n    }\n\n    private static void findTeacupWords(Set<String> words) {\n        List<String> teacupWords = new ArrayList<>();\n        Set<String> found = new HashSet<>();\n        for (String word : words) {\n            int len = word.length();\n            if (len < 3 || found.contains(word))\n                continue;\n            teacupWords.clear();\n            teacupWords.add(word);\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < len - 1; ++i) {\n                String rotated = new String(rotate(chars));\n                if (rotated.equals(word) || !words.contains(rotated))\n                    break;\n                teacupWords.add(rotated);\n            }\n            if (teacupWords.size() == len) {\n                found.addAll(teacupWords);\n                System.out.print(word);\n                for (int i = 1; i < len; ++i)\n                    System.out.print(\" \" + teacupWords.get(i));\n                System.out.println();\n            }\n        }\n    }\n\n    private static char[] rotate(char[] ch) {\n        char c = ch[0];\n        System.arraycopy(ch, 1, ch, 0, ch.length - 1);\n        ch[ch.length - 1] = c;\n        return ch;\n    }\n}\n"}
{"id": 392530, "name": "Esthetic numbers", "source": "Translate Swift to Java: extension Sequence {\n  func take(_ n: Int) -> [Element] {\n    var res = [Element]()\n\n    for el in self {\n      guard res.count != n else {\n        return res\n      }\n\n      res.append(el)\n    }\n\n    return res\n  }\n}\n\nextension String {\n  func isEsthetic(base: Int = 10) -> Bool {\n    zip(dropFirst(0), dropFirst())\n      .lazy\n      .allSatisfy({ abs(Int(String($0.0), radix: base)! - Int(String($0.1), radix: base)!) == 1 })\n  }\n}\n\nfunc getEsthetics(from: Int, to: Int, base: Int = 10) -> [String] {\n  guard base >= 2, to >= from else {\n    return []\n  }\n\n  var start = \"\"\n  var end = \"\"\n\n  repeat {\n    if start.count & 1 == 1 {\n      start += \"0\"\n    } else {\n      start += \"1\"\n    }\n  } while Int(start, radix: base)! < from\n\n  let digiMax = String(base - 1, radix: base)\n  let lessThanDigiMax = String(base - 2, radix: base)\n  var count = 0\n\n  repeat {\n    if count != base - 1 {\n      end += String(count + 1, radix: base)\n      count += 1\n    } else {\n      if String(end.last!) == digiMax {\n        end += lessThanDigiMax\n      } else {\n        end += digiMax\n      }\n    }\n  } while Int(end, radix: base)! < to\n\n  if Int(start, radix: base)! >= Int(end, radix: base)! {\n    return []\n  }\n\n  var esthetics = [Int]()\n\n  func shimmer(_ n: Int, _ m: Int, _ i: Int) {\n    if (n...m).contains(i) {\n      esthetics.append(i)\n    } else if i == 0 || i > m {\n      return\n    }\n\n    let d = i % base\n    let i1 = i &* base &+ d &- 1\n    let i2 = i1 &+ 2\n\n    if (i1 < i || i2 < i) {\n      \n      return\n    }\n\n    switch d {\n    case 0: shimmer(n, m, i2)\n    case base-1: shimmer(n, m, i1)\n    case _:\n      shimmer(n, m, i1)\n      shimmer(n, m, i2)\n    }\n  }\n\n  for digit in 0..<base {\n    shimmer(Int(start, radix: base)!, Int(end, radix: base)!, digit)\n  }\n\n  return esthetics.filter({ $0 <= to }).map({ String($0, radix: base) })\n}\n\nfor base in 2...16 {\n  let esthetics = (0...)\n    .lazy\n    .map({ String($0, radix: base) })\n    .filter({ $0.isEsthetic(base: base) })\n    .dropFirst(base * 4)\n    .take((base * 6) - (base * 4) + 1)\n\n  print(\"Base \\(base) esthetics from \\(base * 4) to \\(base * 6)\")\n  print(esthetics)\n  print()\n}\n\nlet base10Esthetics = (1000...9999).filter({ String($0).isEsthetic() })\n\nprint(\"\\(base10Esthetics.count) esthetics between 1000 and 9999:\")\nprint(base10Esthetics)\nprint()\n\nfunc printSlice(of array: [String]) {\n  print(array.take(5))\n  print(\"...\")\n  print(Array(array.lazy.reversed().take(5).reversed()))\n  print(\"\\(array.count) total\\n\")\n}\n\nprint(\"Esthetics between \\(Int(1e8)) and \\(13 * Int(1e7)):\")\nprintSlice(of: getEsthetics(from: Int(1e8), to: 13 * Int(1e7)))\n\nprint(\"Esthetics between \\(Int(1e11)) and \\(13 * Int(1e10))\")\nprintSlice(of: getEsthetics(from: Int(1e11), to: 13 * Int(1e10)))\n\nprint(\"Esthetics between \\(Int(1e14)) and \\(13 * Int(1e13)):\")\nprintSlice(of: getEsthetics(from: Int(1e14), to: 13 * Int(1e13)))\n\nprint(\"Esthetics between \\(Int(1e17)) and \\(13 * Int(1e16)):\")\nprintSlice(of: getEsthetics(from: Int(1e17), to: 13 * Int(1e16)))\n", "target": "import java.util.ArrayList;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\n\npublic class EstheticNumbers {\n    interface RecTriConsumer<A, B, C> {\n        void accept(RecTriConsumer<A, B, C> f, A a, B b, C c);\n    }\n\n    private static boolean isEsthetic(long n, long b) {\n        if (n == 0) {\n            return false;\n        }\n        var i = n % b;\n        var n2 = n / b;\n        while (n2 > 0) {\n            var j = n2 % b;\n            if (Math.abs(i - j) != 1) {\n                return false;\n            }\n            n2 /= b;\n            i = j;\n        }\n        return true;\n    }\n\n    private static void listEsths(long n, long n2, long m, long m2, int perLine, boolean all) {\n        var esths = new ArrayList<Long>();\n        var dfs = new RecTriConsumer<Long, Long, Long>() {\n            public void accept(Long n, Long m, Long i) {\n                accept(this, n, m, i);\n            }\n\n            @Override\n            public void accept(RecTriConsumer<Long, Long, Long> f, Long n, Long m, Long i) {\n                if (n <= i && i <= m) {\n                    esths.add(i);\n                }\n                if (i == 0 || i > m) {\n                    return;\n                }\n                var d = i % 10;\n                var i1 = i * 10 + d - 1;\n                var i2 = i1 + 2;\n                if (d == 0) {\n                    f.accept(f, n, m, i2);\n                } else if (d == 9) {\n                    f.accept(f, n, m, i1);\n                } else {\n                    f.accept(f, n, m, i1);\n                    f.accept(f, n, m, i2);\n                }\n            }\n        };\n\n        LongStream.range(0, 10).forEach(i -> dfs.accept(n2, m2, i));\n\n        var le = esths.size();\n        System.out.printf(\"Base 10: %d esthetic numbers between %d and %d:%n\", le, n, m);\n        if (all) {\n            for (int i = 0; i < esths.size(); i++) {\n                System.out.printf(\"%d \", esths.get(i));\n                if ((i + 1) % perLine == 0) {\n                    System.out.println();\n                }\n            }\n        } else {\n            for (int i = 0; i < perLine; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n            System.out.println();\n            System.out.println(\"............\");\n            for (int i = le - perLine; i < le; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n        }\n        System.out.println();\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(2, 16).forEach(b -> {\n            System.out.printf(\"Base %d: %dth to %dth esthetic numbers:%n\", b, 4 * b, 6 * b);\n            var n = 1L;\n            var c = 0L;\n            while (c < 6 * b) {\n                if (isEsthetic(n, b)) {\n                    c++;\n                    if (c >= 4 * b) {\n                        System.out.printf(\"%s \", Long.toString(n, b));\n                    }\n                }\n                n++;\n            }\n            System.out.println();\n        });\n        System.out.println();\n\n        \n        listEsths(1000, 1010, 9999, 9898, 16, true);\n        listEsths((long) 1e8, 101_010_101, 13 * (long) 1e7, 123_456_789, 9, true);\n        listEsths((long) 1e11, 101_010_101_010L, 13 * (long) 1e10, 123_456_789_898L, 7, false);\n        listEsths((long) 1e14, 101_010_101_010_101L, 13 * (long) 1e13, 123_456_789_898_989L, 5, false);\n        listEsths((long) 1e17, 101_010_101_010_101_010L, 13 * (long) 1e16, 123_456_789_898_989_898L, 4, false);\n    }\n}\n"}
{"id": 392531, "name": "Permutations by swapping", "source": "Translate Swift to Java: \n\nfunc generate<T>(array: inout [T], output: (_: [T], _: Int) -> Void) {\n    let n = array.count\n    var c = Array(repeating: 0, count: n)\n    var i = 1\n    var sign = 1\n    output(array, sign)\n    while i < n {\n        if c[i] < i {\n            if (i & 1) == 0 {\n                array.swapAt(0, i)\n            } else {\n                array.swapAt(c[i], i)\n            }\n            sign = -sign\n            output(array, sign)\n            c[i] += 1\n            i = 1\n        } else {\n            c[i] = 0\n            i += 1\n        }\n    }\n}\n\nfunc printPermutation<T>(array: [T], sign: Int) {\n    print(\"\\(array) \\(sign)\")\n}\n\nprint(\"Permutations and signs for three items:\")\nvar a = [0, 1, 2]\ngenerate(array: &a, output: printPermutation)\n\nprint(\"\\nPermutations and signs for four items:\")\nvar b = [0, 1, 2, 3]\ngenerate(array: &b, output: printPermutation)\n", "target": "package org.rosettacode.java;\n\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class HeapsAlgorithm {\n\n\tpublic static void main(String[] args) {\n\t\tObject[] array = IntStream.range(0, 4)\n\t\t\t\t.boxed()\n\t\t\t\t.toArray();\n\t\tHeapsAlgorithm algorithm = new HeapsAlgorithm();\n\t\talgorithm.recursive(array);\n\t\tSystem.out.println();\n\t\talgorithm.loop(array);\n\t}\n\n\tvoid recursive(Object[] array) {\n\t\trecursive(array, array.length, true);\n\t}\n\n\tvoid recursive(Object[] array, int n, boolean plus) {\n\t\tif (n == 1) {\n\t\t\toutput(array, plus);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trecursive(array, n - 1, i == 0);\n\t\t\t\tswap(array, n % 2 == 0 ? i : 0, n - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid output(Object[] array, boolean plus) {\n\t\tSystem.out.println(Arrays.toString(array) + (plus ? \" +1\" : \" -1\"));\n\t}\n\n\tvoid swap(Object[] array, int a, int b) {\n\t\tObject o = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = o;\n\t}\n\n\tvoid loop(Object[] array) {\n\t\tloop(array, array.length);\n\t}\n\n\tvoid loop(Object[] array, int n) {\n\t\tint[] c = new int[n];\n\t\toutput(array, true);\n\t\tboolean plus = false;\n\t\tfor (int i = 0; i < n; ) {\n\t\t\tif (c[i] < i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tswap(array, 0, i);\n\t\t\t\t} else {\n\t\t\t\t\tswap(array, c[i], i);\n\t\t\t\t}\n\t\t\t\toutput(array, plus);\n\t\t\t\tplus = !plus;\n\t\t\t\tc[i]++;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tc[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 392532, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Swift to Java: \nfunc divisorCount(number: Int) -> Int {\n    var n = number\n    var total = 1\n    \n    while n % 2 == 0 {\n        total += 1\n        n /= 2\n    }\n    \n    var p = 3\n    while p * p <= n {\n        var count = 1\n        while n % p == 0 {\n            count += 1\n            n /= p\n        }\n        total *= count\n        p += 2\n    }\n    \n    if n > 1 {\n        total *= 2\n    }\n    return total\n}\n\nlet limit = 15\nvar sequence = Array(repeating: 0, count: limit)\nvar count = 0\nvar n = 1\nwhile count < limit {\n    let divisors = divisorCount(number: n)\n    if divisors <= limit && sequence[divisors - 1] == 0 {\n        sequence[divisors - 1] = n\n        count += 1\n    }\n    n += 1\n}\nfor n in sequence {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.Arrays;\n\npublic class OEIS_A005179 {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        int[] seq = new int[max];\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, n = 0; n < max; ++i) {\n            int k = count_divisors(i);\n            if (k <= max && seq[k - 1] == 0) {        \n                seq[k- 1] = i;\n                n++;\n            }\n        }\n        System.out.println(Arrays.toString(seq));\n    }\n}\n"}
{"id": 392533, "name": "Longest increasing subsequence", "source": "Translate Swift to Java: import Foundation\n\nextension Array where Element: Comparable {\n  @inlinable\n  public func longestIncreasingSubsequence() -> [Element] {\n    var startI = [Int](repeating: 0, count: count)\n    var endI = [Int](repeating: 0, count: count + 1)\n    var len = 0\n\n    for i in 0..<count {\n      var lo = 1\n      var hi = len\n\n      while lo <= hi {\n        let mid = Int(ceil((Double(lo + hi)) / 2))\n\n        if self[endI[mid]] <= self[i] {\n          lo = mid + 1\n        } else {\n          hi = mid - 1\n        }\n      }\n\n      startI[i] = endI[lo-1]\n      endI[lo] = i\n\n      if lo > len {\n        len = lo\n      }\n    }\n\n    var s = [Element]()\n    var k = endI[len]\n\n    for _ in 0..<len {\n      s.append(self[k])\n      k = startI[k]\n    }\n\n    return s.reversed()\n  }\n}\n\nlet l1 = [3, 2, 6, 4, 5, 1]\nlet l2 = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n\nprint(\"\\(l1) = \\(l1.longestIncreasingSubsequence())\")\nprint(\"\\(l2) = \\(l2.longestIncreasingSubsequence())\")\n", "target": "import java.util.*;\n\npublic class LIS {\n    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {\n        List<Node<E>> pileTops = new ArrayList<Node<E>>();\n        \n        for (E x : n) {\n\t    Node<E> node = new Node<E>();\n\t    node.value = x;\n            int i = Collections.binarySearch(pileTops, node);\n            if (i < 0) i = ~i;\n\t    if (i != 0)\n\t\tnode.pointer = pileTops.get(i-1);\n            if (i != pileTops.size())\n                pileTops.set(i, node);\n            else\n                pileTops.add(node);\n        }\n\t\n\tList<E> result = new ArrayList<E>();\n\tfor (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);\n                node != null; node = node.pointer)\n\t    result.add(node.value);\n\tCollections.reverse(result);\n\treturn result;\n    }\n\n    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {\n\tpublic E value;\n\tpublic Node<E> pointer;\n        public int compareTo(Node<E> y) { return value.compareTo(y.value); }\n    }\n\n    public static void main(String[] args) {\n\tList<Integer> d = Arrays.asList(3,2,6,4,5,1);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n        d = Arrays.asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n    }\n}\n"}
{"id": 392534, "name": "Brilliant numbers", "source": "Translate Swift to Java: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 392535, "name": "Brilliant numbers", "source": "Translate Swift to Java: \n\n\n\n\n\nfunc primeArray(n: Int) -> [Bool] {\n    \n    var primeArr = [Bool](repeating: true, count: n + 1)\n    primeArr[0] = false \n    primeArr[1] = false \n    \n    \n    var p = 2\n    while (p * p) <= n {\n        if primeArr[p] == true {\n            for j in stride(from: p * 2, through: n, by: p) {\n                primeArr[j] = false\n            }\n        }\n        p += 1\n    }\n    \n    return primeArr\n}\n\n\nfunc digitsCount(n: Int) -> Int {\n    \n    \n    var num = n\n    var count = 0;\n    while num != 0 {\n        num = num/10\n        count += 1\n    }\n    \n    return count\n}\n\n\nfunc isBrilliant(n: Int) -> Bool {\n    \n    var isPrime = [Bool]()\n    isPrime = primeArray(n: n)\n    \n    \n    \n    for i in stride(from: 2, through: n, by: 1) { \n        let x = n / i \n        if (isPrime[i] && isPrime[x] && x * i == n) { \n            if (digitsCount(n: i) == digitsCount(n: x)) {\n                return true\n            }\n        }\n    }\n    \n    return false\n}\n\n\nfunc print100Brilliants() {\n    \n    var brilNums = [Int]()\n    var count = 4\n    while brilNums.count != 100 {\n        if isBrilliant(n: count) {\n            brilNums.append(count)\n        }\n        count += 1\n    }\n    \n    print(\"First 100 brilliant numbers:\\n\", brilNums)\n}\n\n\nfunc printBrilliantsOfMagnitude() {\n    \n    \n    var basePower = 10.0\n    var brilNums: [Double] = [0.0]\n    var count = 1.0\n    while basePower != pow(basePower, 6) {\n        if isBrilliant(n: Int(count)) {\n            brilNums.append(count)\n            if count >= basePower {\n                print(\"First brilliant number >= \\(Int(basePower)): \\(Int(count)) at position \\(brilNums.firstIndex(of: count)!)\")\n                basePower *= 10\n            }\n        }\n        count += 1\n    }\n}\n\n\nprint100Brilliants()\nprintBrilliantsOfMagnitude()\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 392536, "name": "Order disjoint list items", "source": "Translate Swift to Java: func disjointOrder<T: Hashable>(m: [T], n: [T]) -> [T] {\n  let replaceCounts = n.reduce(into: [T: Int](), { $0[$1, default: 0] += 1 })\n  let reduced = m.reduce(into: ([T](), n, replaceCounts), {cur, el in\n    cur.0.append(cur.2[el, default: 0] > 0 ? cur.1.removeFirst() : el)\n    cur.2[el]? -= 1\n  })\n\n  return reduced.0\n}\n\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"mat\", \"cat\"]))\nprint(disjointOrder(m: [\"the\", \"cat\", \"sat\", \"on\", \"the\", \"mat\"], n: [\"cat\", \"mat\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"C\", \"A\", \"B\", \"C\"], n: [\"C\", \"A\", \"C\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"C\", \"A\", \"B\", \"D\", \"A\", \"B\", \"E\"], n: [\"E\", \"A\", \"D\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\"]))\nprint(disjointOrder(m: [\"A\", \"B\"], n: [\"B\", \"A\"]))\nprint(disjointOrder(m: [\"A\", \"B\", \"B\", \"A\"], n: [\"B\", \"A\"]))\n", "target": "import java.util.Arrays;\nimport java.util.BitSet;\nimport org.apache.commons.lang3.ArrayUtils;\n\npublic class OrderDisjointItems {\n\n    public static void main(String[] args) {\n        final String[][] MNs = {{\"the cat sat on the mat\", \"mat cat\"},\n        {\"the cat sat on the mat\", \"cat mat\"},\n        {\"A B C A B C A B C\", \"C A C A\"}, {\"A B C A B D A B E\", \"E A D A\"},\n        {\"A B\", \"B\"}, {\"A B\", \"B A\"}, {\"A B B A\", \"B A\"}, {\"X X Y\", \"X\"}};\n\n        for (String[] a : MNs) {\n            String[] r = orderDisjointItems(a[0].split(\" \"), a[1].split(\" \"));\n            System.out.printf(\"%s | %s -> %s%n\", a[0], a[1], Arrays.toString(r));\n        }\n    }\n\n    \n    static String[] orderDisjointItems(String[] m, String[] n) {\n        for (String e : n) {\n            int idx = ArrayUtils.indexOf(m, e);\n            if (idx != -1)\n                m[idx] = null;\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (m[i] == null)\n                m[i] = n[j++];\n        }\n        return m;\n    }\n\n    \n    static String[] orderDisjointItems2(String[] m, String[] n) {\n        BitSet bitSet = new BitSet(m.length);\n        for (String e : n) {\n            int idx = -1;\n            do {\n                idx = ArrayUtils.indexOf(m, e, idx + 1);\n            } while (idx != -1 && bitSet.get(idx));\n            if (idx != -1)\n                bitSet.set(idx);\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (bitSet.get(i))\n                m[i] = n[j++];\n        }\n        return m;\n    }\n}\n"}
{"id": 392537, "name": "Generate random numbers without repeating a value", "source": "Translate Swift to Java: var array = Array(1...20)\narray.shuffle()\nprint(array)\n", "target": "import java.util.*;\n\npublic class RandomShuffle {\n    public static void main(String[] args) {\n        Random rand = new Random();\n        List<Integer> list = new ArrayList<>();\n        for (int j = 1; j <= 20; ++j)\n            list.add(j);\n        Collections.shuffle(list, rand);\n        System.out.println(list);\n    }\n}\n"}
{"id": 392538, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Swift to Java: func circleSort<T: Comparable>(_ array: inout [T]) {\n    func circSort(low: Int, high: Int, swaps: Int) -> Int {\n        if low == high {\n            return swaps\n        }\n        var lo = low\n        var hi = high\n        let mid = (hi - lo) / 2\n        var s = swaps\n        while lo < hi {\n            if array[lo] > array[hi] {\n                array.swapAt(lo, hi)\n                s += 1\n            }\n            lo += 1\n            hi -= 1\n        }\n        if lo == hi {\n            if array[lo] > array[hi + 1] {\n                array.swapAt(lo, hi + 1)\n                s += 1\n            }\n        }\n        s = circSort(low: low, high: low + mid, swaps: s)\n        s = circSort(low: low + mid + 1, high: high, swaps: s)\n        return s\n    }\n    while circSort(low: 0, high: array.count - 1, swaps: 0) != 0 {}\n}\n\nvar array = [10, 8, 4, 3, 1, 9, 0, 2, 7, 5, 6]\nprint(\"before: \\(array)\")\ncircleSort(&array)\nprint(\" after: \\(array)\")\n\nvar array2 = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\"]\nprint(\"before: \\(array2)\")\ncircleSort(&array2)\nprint(\" after: \\(array2)\")\n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 392539, "name": "Circles of given radius through two points", "source": "Translate Swift to Java: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 392540, "name": "Circles of given radius through two points", "source": "Translate Swift to Java: import Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 392541, "name": "Vampire number", "source": "Translate Swift to Java: import Foundation\n\nfunc vampire<T>(n: T) -> [(T, T)] where T: BinaryInteger, T.Stride: SignedInteger {\n  let strN = String(n).sorted()\n  let fangLength = strN.count / 2\n  let start = T(pow(10, Double(fangLength - 1)))\n  let end = T(Double(n).squareRoot())\n\n  var fangs = [(T, T)]()\n\n  for i in start...end where n % i == 0 {\n    let quot = n / i\n\n    guard i % 10 != 0 || quot % 10 != 0 else {\n      continue\n    }\n\n    if \"\\(i)\\(quot)\".sorted() == strN {\n      fangs.append((i, quot))\n    }\n  }\n\n  return fangs\n}\n\nvar count = 0\nvar i = 1.0\n\nwhile count < 25 {\n  let start = Int(pow(10, i))\n  let end = start * 10\n\n  for num in start...end {\n    let fangs = vampire(n: num)\n\n    guard !fangs.isEmpty else { continue }\n\n    count += 1\n\n    print(\"\\(num) is a vampire number with fangs: \\(fangs)\")\n\n    guard count != 25 else { break }\n  }\n\n  i += 2\n}\n\nfor (vamp, fangs) in [16758243290880, 24959017348650, 14593825548650].lazy.map({ ($0, vampire(n: $0)) }) {\n  if fangs.isEmpty {\n    print(\"\\(vamp) is not a vampire number\")\n  } else {\n    print(\"\\(vamp) is a vampire number with fangs: \\(fangs)\")\n  }\n}\n", "target": "import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class VampireNumbers{\n    private static int numDigits(long num){\n        return Long.toString(Math.abs(num)).length();\n    }\n\n    private static boolean fangCheck(long orig, long fang1, long fang2){\n        if(Long.toString(fang1).endsWith(\"0\") && Long.toString(fang2).endsWith(\"0\")) return false;\n\n        int origLen = numDigits(orig);\n        if(numDigits(fang1) != origLen / 2 || numDigits(fang2) != origLen / 2) return false;\n\n        byte[] origBytes = Long.toString(orig).getBytes();\n        byte[] fangBytes = (Long.toString(fang1) + Long.toString(fang2)).getBytes();\n        Arrays.sort(origBytes);\n        Arrays.sort(fangBytes);\n        return Arrays.equals(origBytes, fangBytes);\n    }\n\n    public static void main(String[] args){\n        HashSet<Long> vamps = new HashSet<Long>();\n        for(long i = 10; vamps.size() <= 25; i++ ){\n            if((numDigits(i) % 2) != 0) {i = i * 10 - 1; continue;}\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        vamps.add(i);\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n        Long[] nums = {16758243290880L, 24959017348650L, 14593825548650L};\n        for(Long i : nums){\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 392542, "name": "Nonoblock", "source": "Translate Swift to Java: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 392543, "name": "Nonoblock", "source": "Translate Swift to Java: import Foundation\n\nfunc nonoblock(cells: Int, blocks: [Int]) {\n    print(\"\\(cells) cells and blocks \\(blocks):\")\n    let totalBlockSize = blocks.reduce(0, +)\n    if cells < totalBlockSize + blocks.count - 1 {\n        print(\"no solution\")\n        return\n    }\n\n    func solve(cells: Int, index: Int, totalBlockSize: Int, offset: Int) {\n        if index == blocks.count {\n            count += 1\n            print(\"\\(String(format: \"%2d\", count))  \\(String(output))\")\n            return\n        }\n        let blockSize = blocks[index]\n        let maxPos = cells - (totalBlockSize + blocks.count - index - 1)\n        let t = totalBlockSize - blockSize\n        var c = cells - (blockSize + 1)\n        for pos in 0...maxPos {\n            fill(value: \".\", offset: offset, count: maxPos + blockSize)\n            fill(value: \"#\", offset: offset + pos, count: blockSize)\n            solve(cells: c, index: index + 1, totalBlockSize: t,\n                  offset: offset + blockSize + pos + 1)\n            c -= 1\n        }\n    }\n\n    func fill(value: Character, offset: Int, count: Int) {\n        output.replaceSubrange(offset..<offset+count,\n                               with: repeatElement(value, count: count))\n    }\n    \n    var output: [Character] = Array(repeating: \".\", count: cells)\n    var count = 0\n    solve(cells: cells, index: 0, totalBlockSize: totalBlockSize, offset: 0)\n}\n\nnonoblock(cells: 5, blocks: [2, 1])\nprint()\n\nnonoblock(cells: 5, blocks: [])\nprint()\n\nnonoblock(cells: 10, blocks: [8])\nprint()\n\nnonoblock(cells: 15, blocks: [2, 3, 2, 3])\nprint()\n\nnonoblock(cells: 5, blocks: [2, 3])\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 392544, "name": "Knapsack problem_Bounded", "source": "Translate Swift to Java: public struct KnapsackItem: Hashable {\n  public var name: String\n  public var weight: Int\n  public var value: Int\n\n  public init(name: String, weight: Int, value: Int) {\n    self.name = name\n    self.weight = weight\n    self.value = value\n  }\n}\n\npublic func knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n\n  for j in 1...items.count {\n    let item = items[j-1]\n\n    for w in 1...limit {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n\n  var result = [KnapsackItem]()\n  var w = limit\n\n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n\n    result.append(item)\n\n    w -= item.weight\n  }\n\n  return result\n}\n\ntypealias GroupedItem = (name: String, weight: Int, val: Int, n: Int)\n\nlet groupedItems: [GroupedItem] = [\n  (\"map\", 9, 150, 1),\n  (\"compass\", 13, 35, 1),\n  (\"water\", 153, 200, 3),\n  (\"sandwich\", 50, 60, 2),\n  (\"glucose\", 15, 60, 2),\n  (\"tin\", 68, 45, 3),\n  (\"banana\", 27, 60, 3),\n  (\"apple\", 39, 40, 3),\n  (\"cheese\", 23, 30, 1),\n  (\"beer\", 52, 10, 3),\n  (\"suntan cream\", 11, 70, 1),\n  (\"camera\", 32, 30, 1),\n  (\"t-shirt\", 24, 15, 2),\n  (\"trousers\", 48, 10, 2),\n  (\"umbrella\", 73, 40, 1),\n  (\"waterproof trousers\", 42, 70, 1),\n  (\"waterproof overclothes\", 43, 75, 1),\n  (\"note-case\", 22, 80, 1),\n  (\"sunglasses\", 7, 20, 1),\n  (\"towel\", 18, 12, 2),\n  (\"socks\", 4, 50, 1),\n  (\"book\", 30, 10, 2)\n]\n\nlet items = groupedItems.flatMap({item in\n  (0..<item.n).map({_ in KnapsackItem(name: item.name, weight: item.weight, value: item.val) })\n})\n\nlet bagged = knapsack(items: items, limit: 400)\nlet (totalVal, totalWeight) = bagged.reduce((0, 0), {cur, item in (cur.0 + item.value, cur.1 + item.weight) })\n\nprint(\"Bagged the following \\(bagged.count) items:\")\n\nfor item in bagged {\n  print(\"\\t\\(item.name)\")\n}\n\nprint(\"For a total value of \\(totalVal) and weight of \\(totalWeight)\")\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); \n\n        \n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        \n        List<Item> itemList = bok.calcSolution();\n\n        \n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} \n"}
{"id": 392545, "name": "Angles (geometric), normalization and conversion", "source": "Translate Swift to Java: import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n", "target": "import java.text.DecimalFormat;\n\n\n\npublic class AnglesNormalizationAndConversion {\n\n    public static void main(String[] args) {\n        DecimalFormat formatAngle = new DecimalFormat(\"######0.000000\");\n        DecimalFormat formatConv = new DecimalFormat(\"###0.0000\");\n        System.out.printf(\"                               degrees    gradiens        mils     radians%n\");\n        for ( double angle : new double[] {-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000} ) {\n            for ( String units : new String[] {\"degrees\", \"gradiens\", \"mils\", \"radians\"}) {\n                double d = 0, g = 0, m = 0, r = 0;\n                switch (units) {\n                case \"degrees\":\n                    d = d2d(angle);\n                    g = d2g(d);\n                    m = d2m(d);\n                    r = d2r(d);\n                    break;\n                case \"gradiens\":\n                    g = g2g(angle);\n                    d = g2d(g);\n                    m = g2m(g);\n                    r = g2r(g);\n                    break;\n                case \"mils\":\n                    m = m2m(angle);\n                    d = m2d(m);\n                    g = m2g(m);\n                    r = m2r(m);\n                    break;\n                case \"radians\":\n                    r = r2r(angle);\n                    d = r2d(r);\n                    g = r2g(r);\n                    m = r2m(r);\n                    break;\n                }\n                System.out.printf(\"%15s  %8s = %10s  %10s  %10s  %10s%n\", formatAngle.format(angle), units, formatConv.format(d), formatConv.format(g), formatConv.format(m), formatConv.format(r));\n            }\n        }\n    }\n\n    private static final double DEGREE = 360D;\n    private static final double GRADIAN = 400D;\n    private static final double MIL = 6400D;\n    private static final double RADIAN = (2 * Math.PI);\n    \n    private static double d2d(double a) {\n        return a % DEGREE;\n    }\n    private static double d2g(double a) {\n        return a * (GRADIAN / DEGREE);\n    }\n    private static double d2m(double a) {\n        return a * (MIL / DEGREE);\n    }\n    private static double d2r(double a) {\n        return a * (RADIAN / 360);\n    }\n\n    private static double g2d(double a) {\n        return a * (DEGREE / GRADIAN);\n    }\n    private static double g2g(double a) {\n        return a % GRADIAN;\n    }\n    private static double g2m(double a) {\n        return a * (MIL / GRADIAN);\n    }\n    private static double g2r(double a) {\n        return a * (RADIAN / GRADIAN);\n    }\n    \n    private static double m2d(double a) {\n        return a * (DEGREE / MIL);\n    }\n    private static double m2g(double a) {\n        return a * (GRADIAN / MIL);\n    }\n    private static double m2m(double a) {\n        return a % MIL;\n    }\n    private static double m2r(double a) {\n        return a * (RADIAN / MIL);\n    }\n    \n    private static double r2d(double a) {\n        return a * (DEGREE / RADIAN);\n    }\n    private static double r2g(double a) {\n        return a * (GRADIAN / RADIAN);\n    }\n    private static double r2m(double a) {\n        return a * (MIL / RADIAN);\n    }\n    private static double r2r(double a) {\n        return a % RADIAN;\n    }\n    \n}\n"}
{"id": 392546, "name": "I before E except after C", "source": "Translate Swift to Java: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 392547, "name": "I before E except after C", "source": "Translate Swift to Java: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 392548, "name": "Xiaolin Wu's line algorithm", "source": "Translate Swift to Java: import Darwin\n\npublic func pixel(color: Color, x: Int, y: Int) {\n    let idx = x + y * self.width\n    if idx >= 0 && idx < self.bitmap.count {\n        self.bitmap[idx] = self.blendColors(bot: self.bitmap[idx], top: color)\n    }\n}\n\n\nfunc fpart(_ x: Double) -> Double {\n    return modf(x).1\n}\n\n\nfunc rfpart(_ x: Double) -> Double {\n    return 1 - fpart(x)\n}\n\n\npublic func smoothLine(_ p0: Point, _ p1: Point) {\n    var x0 = p0.x, x1 = p1.x, y0 = p0.y, y1 = p1.y \n    let steep = abs(y1 - y0) > abs(x1 - x0)\n    if steep {\n        swap(&x0, &y0)\n        swap(&x1, &y1)\n    }\n    if x0 > x1 {\n        swap(&x0, &x1)\n        swap(&y0, &y1)\n    }\n    let dX = x1 - x0\n    let dY = y1 - y0\n    \n    var gradient: Double\n    if dX == 0.0 {\n        gradient = 1.0\n    }\n    else {\n        gradient = dY / dX\n    }\n    \n    \n    var xend = round(x0)\n    var yend = y0 + gradient * (xend - x0)\n    var xgap = self.rfpart(x0 + 0.5)\n    let xpxl1 = Int(xend)\n    let ypxl1 = Int(yend)\n    \n    \n    var intery = yend + gradient\n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl1, y: xpxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl1 + 1, y: xpxl1)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl1, y: ypxl1)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl1, y: ypxl1 + 1)\n    }\n    \n    xend = round(x1)\n    yend = y1 + gradient * (xend - x1)\n    xgap = self.fpart(x1 + 0.5)\n    let xpxl2 = Int(xend)\n    let ypxl2 = Int(yend)\n    \n    \n    if steep {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: ypxl2, y: xpxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: ypxl2 + 1, y: xpxl2)\n    }\n    else {\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(yend) * xgap), x: xpxl2, y: ypxl2)\n        self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(yend) * xgap), x: xpxl2, y: ypxl2 + 1)\n    }\n    \n    \n    if steep {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: Int(intery), y: x)\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: Int(intery) + 1, y:x)\n            intery += gradient\n        }\n    }\n    else {\n        for x in xpxl1+1..<xpxl2 {\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.rfpart(intery)), x: x, y: Int(intery))\n            self.pixel(color: self.strokeColor.colorWithAlpha(self.fpart(intery)), x: x, y: Int(intery) + 1)\n            intery += gradient\n        }\n    }\n}\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class XiaolinWu extends JPanel {\n\n    public XiaolinWu() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n    }\n\n    void plot(Graphics2D g, double x, double y, double c) {\n        g.setColor(new Color(0f, 0f, 0f, (float)c));\n        g.fillOval((int) x, (int) y, 2, 2);\n    }\n\n    int ipart(double x) {\n        return (int) x;\n    }\n\n    double fpart(double x) {\n        return x - floor(x);\n    }\n\n    double rfpart(double x) {\n        return 1.0 - fpart(x);\n    }\n\n    void drawLine(Graphics2D g, double x0, double y0, double x1, double y1) {\n\n        boolean steep = abs(y1 - y0) > abs(x1 - x0);\n        if (steep)\n            drawLine(g, y0, x0, y1, x1);\n\n        if (x0 > x1)\n            drawLine(g, x1, y1, x0, y0);\n\n        double dx = x1 - x0;\n        double dy = y1 - y0;\n        double gradient = dy / dx;\n\n        \n        double xend = round(x0);\n        double yend = y0 + gradient * (xend - x0);\n        double xgap = rfpart(x0 + 0.5);\n        double xpxl1 = xend; \n        double ypxl1 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);\n            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);\n            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);\n        }\n\n        \n        double intery = yend + gradient;\n\n        \n        xend = round(x1);\n        yend = y1 + gradient * (xend - x1);\n        xgap = fpart(x1 + 0.5);\n        double xpxl2 = xend; \n        double ypxl2 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);\n            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);\n            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);\n        }\n\n        \n        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {\n            if (steep) {\n                plot(g, ipart(intery), x, rfpart(intery));\n                plot(g, ipart(intery) + 1, x, fpart(intery));\n            } else {\n                plot(g, x, ipart(intery), rfpart(intery));\n                plot(g, x, ipart(intery) + 1, fpart(intery));\n            }\n            intery = intery + gradient;\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        drawLine(g, 550, 170, 50, 435);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Xiaolin Wu's line algorithm\");\n            f.setResizable(false);\n            f.add(new XiaolinWu(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 392549, "name": "Four is magic", "source": "Translate Swift to Java: import Foundation\n\nfunc fourIsMagic(_ number: NSNumber) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .spellOut\n    formatter.locale = Locale(identifier: \"en_EN\")\n\n    var result: [String] = []\n\n    var numberString = formatter.string(from: number)!\n    result.append(numberString.capitalized)\n\n    while numberString != \"four\" {\n        numberString = formatter.string(from: NSNumber(value: numberString.count))!\n        result.append(contentsOf: [\" is \", numberString, \", \", numberString])\n    }\n\n    result.append(\" is magic.\")\n    return result.joined()\n}\n\nfor testInput in [23, 1000000000, 20140, 100, 130, 151, -7] { \n    print(fourIsMagic(testInput as NSNumber))\n}\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 392550, "name": "Zhang-Suen thinning algorithm", "source": "Translate Swift to Java: import UIKit\n\n\nlet beforeTxt = \"\"\"\n1100111\n1100111\n1100111\n1100111\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1100110\n1111110\n0000000\n\"\"\"\n\nlet smallrc01 = \"\"\"\n00000000000000000000000000000000\n01111111110000000111111110000000\n01110001111000001111001111000000\n01110000111000001110000111000000\n01110001111000001110000000000000\n01111111110000001110000000000000\n01110111100000001110000111000000\n01110011110011101111001111011100\n01110001111011100111111110011100\n00000000000000000000000000000000\n\"\"\"\n \nlet rc01 = \"\"\"\n00000000000000000000000000000000000000000000000000000000000\n01111111111111111100000000000000000001111111111111000000000\n01111111111111111110000000000000001111111111111111000000000\n01111111111111111111000000000000111111111111111111000000000\n01111111100000111111100000000001111111111111111111000000000\n00011111100000111111100000000011111110000000111111000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111111111111110000000000111111100000000000000000000000\n00011111111111111111000000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000111111100000000000000000000000\n00011111100000111111100000000011111110000000111111000000000\n01111111100000111111100000000001111111111111111111000000000\n01111111100000111111101111110000111111111111111111011111100\n01111111100000111111101111110000001111111111111111011111100\n01111111100000111111101111110000000001111111111111011111100\n00000000000000000000000000000000000000000000000000000000000\n\"\"\"\n\n\n\nfunc zhangSuen(image: inout [[Int]]) -> [[Int]] {\n    \n    var changing1, changing2: [(Int, Int)]\n    repeat {\n        \n        changing1 = []\n        changing2 = []\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                \n                \n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P6 == 0 &&                     \n                    P4 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing1.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing1 {\n            image[y][x] = 0\n        }\n        \n        \n        for y in 1..<image.count-1 {\n            \n            for x in 1..<image[0].count-1 {\n                \n                var nb = neighbours(x: x, y: y, image: image)\n                \n                let P2 = nb[0], P4 = nb[2], P6 = nb[4], P8 = nb[6]\n                if (image[y][x] == 1 &&                      \n                    (2...6).contains(nb.reduce(0, +)) &&     \n                    transitions(neighbours: &nb) == 1 &&     \n                    P2 * P4 * P8 == 0 &&                     \n                    P2 * P6 * P8 == 0                        \n                ) {\n                    \n                    changing2.append((x,y))\n                }\n            }\n        }\n        \n        for (x, y) in changing2 {\n            image[y][x] = 0\n        }\n        \n    } while !changing1.isEmpty && !changing2.isEmpty\n    \n    return image\n}\n\n\nfunc intarray(binstring: String) -> [[Int]] {\n    \n    \n    return binstring.split(separator: \"\\n\").map {$0.compactMap{$0.wholeNumberValue}}\n}\n\n\nfunc toTxt(intmatrix: [[Int]]) -> String {\n    \n    \n    return intmatrix.map {$0.map { $0 == 1 ? \"#\" : \".\"}.joined(separator: \"\")}.joined(separator: \"\\n\")\n}\n\n\nfunc neighbours(x: Int, y: Int, image: [[Int]]) -> [Int] {\n    let i = image\n    \n    let x1 = x+1, y1 = y-1, x_1 = x-1, y_1 = y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n}\n\n\nfunc transitions(neighbours: inout [Int]) -> Int {\n    \n    let n = neighbours + [neighbours[0]]\n    var result = 0\n    \n    \n    for (n1, n2) in zip(n, n.suffix(n.count - 1)) {\n        \n        if (n1, n2) == (0, 1) { result += 1 }\n    }\n    \n    return result\n}\n\n\n\nlet testCases: [String] = [beforeTxt, smallrc01, rc01]\nfor picture in testCases {\n    \n    var image = intarray(binstring: picture)\n    \n    print(\"\\nFrom:\\n\\(toTxt(intmatrix: image))\")\n    \n    let after = zhangSuen(image: &image)\n    \n    print(\"\\nTo thinned:\\n\\(toTxt(intmatrix: after))\")\n}\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 392551, "name": "Generate Chess960 starting position", "source": "Translate Swift to Java: func isValid960Position(_ firstRank: String) -> Bool {\n  var rooksPlaced = 0\n  var bishopColor = -1\n\n  for (i, piece) in firstRank.enumerated() {\n    switch piece {\n    case \"\u265a\" where rooksPlaced != 1:\n      return false\n    case \"\u265c\":\n      rooksPlaced += 1\n    case \"\u265d\" where bishopColor == -1:\n      bishopColor = i & 1\n    case \"\u265d\" where bishopColor == i & 1:\n      return false\n    case _:\n      continue\n    }\n  }\n\n  return true\n}\n\nstruct Chess960Counts {\n  var king = 0, queen = 0, rook = 0, bishop = 0, knight = 0\n\n  subscript(_ piece: String) -> Int {\n    get {\n      switch piece {\n      case \"\u265a\": return king\n      case \"\u265b\": return queen\n      case \"\u265c\": return rook\n      case \"\u265d\": return bishop\n      case \"\u265e\": return knight\n      case _:   fatalError()\n      }\n    }\n\n    set {\n      switch piece {\n      case \"\u265a\": king = newValue\n      case \"\u265b\": queen = newValue\n      case \"\u265c\": rook = newValue\n      case \"\u265d\": bishop = newValue\n      case \"\u265e\": knight = newValue\n      case _:   fatalError()\n      }\n    }\n  }\n}\n\nfunc get960Position() -> String {\n  var counts = Chess960Counts()\n  var bishopColor = -1 \n  var output = \"\"\n\n  for i in 1...8 {\n    let validPieces = [\n      counts[\"\u265c\"] == 1 && counts[\"\u265a\"] == 0 ? \"\u265a\" : nil, \n      i == 1 || (counts[\"\u265b\"] == 0) ? \"\u265b\" : nil, \n      i == 1 || (counts[\"\u265c\"] == 0 || counts[\"\u265c\"] < 2 && counts[\"\u265a\"] == 1) ? \"\u265c\" : nil, \n      i == 1 || (counts[\"\u265d\"] < 2 && bishopColor == -1 || bishopColor != i & 1) ? \"\u265d\" : nil, \n      i == 1 || (counts[\"\u265e\"] < 2) ? \"\u265e\" : nil \n    ].lazy.compactMap({ $0 })\n\n    guard let chosenPiece = validPieces.randomElement() else {\n      \n      output.insert(\"\u265d\", at: output.index(before: output.endIndex))\n\n      break\n    }\n\n    counts[chosenPiece] += 1\n    output += chosenPiece\n\n    if bishopColor == -1 && chosenPiece == \"\u265d\" {\n      bishopColor = i & 1\n    }\n  }\n\n  assert(isValid960Position(output), \"invalid 960 position \\(output)\")\n\n  return output\n}\n\nvar positions = Set<String>()\n\nwhile positions.count != 960 {\n  positions.insert(get960Position())\n}\n\nprint(positions.count, positions.randomElement()!)\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 392552, "name": "Spelling of ordinal numbers", "source": "Translate Swift to Java: fileprivate class NumberNames {\n    let cardinal: String\n    let ordinal: String\n\n    init(cardinal: String, ordinal: String) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n    \n    class func numberName(number: Int, ordinal: Bool) -> String {\n        guard number < 100 else {\n            return \"\"\n        }\n        if number < 20 {\n            return smallNames[number].getName(ordinal)\n        }\n        if number % 10 == 0 {\n            return tens[number/10 - 2].getName(ordinal)\n        }\n        var result = tens[number/10 - 2].getName(false)\n        result += \"-\"\n        result += smallNames[number % 10].getName(ordinal)\n        return result\n    }\n    \n    static let smallNames = [\n        NumberNames(cardinal: \"zero\", ordinal: \"zeroth\"),\n        NumberNames(cardinal: \"one\", ordinal: \"first\"),\n        NumberNames(cardinal: \"two\", ordinal: \"second\"),\n        NumberNames(cardinal: \"three\", ordinal: \"third\"),\n        NumberNames(cardinal: \"four\", ordinal: \"fourth\"),\n        NumberNames(cardinal: \"five\", ordinal: \"fifth\"),\n        NumberNames(cardinal: \"six\", ordinal: \"sixth\"),\n        NumberNames(cardinal: \"seven\", ordinal: \"seventh\"),\n        NumberNames(cardinal: \"eight\", ordinal: \"eighth\"),\n        NumberNames(cardinal: \"nine\", ordinal: \"ninth\"),\n        NumberNames(cardinal: \"ten\", ordinal: \"tenth\"),\n        NumberNames(cardinal: \"eleven\", ordinal: \"eleventh\"),\n        NumberNames(cardinal: \"twelve\", ordinal: \"twelfth\"),\n        NumberNames(cardinal: \"thirteen\", ordinal: \"thirteenth\"),\n        NumberNames(cardinal: \"fourteen\", ordinal: \"fourteenth\"),\n        NumberNames(cardinal: \"fifteen\", ordinal: \"fifteenth\"),\n        NumberNames(cardinal: \"sixteen\", ordinal: \"sixteenth\"),\n        NumberNames(cardinal: \"seventeen\", ordinal: \"seventeenth\"),\n        NumberNames(cardinal: \"eighteen\", ordinal: \"eighteenth\"),\n        NumberNames(cardinal: \"nineteen\", ordinal: \"nineteenth\")\n    ]\n\n    static let tens = [\n        NumberNames(cardinal: \"twenty\", ordinal: \"twentieth\"),\n        NumberNames(cardinal: \"thirty\", ordinal: \"thirtieth\"),\n        NumberNames(cardinal: \"forty\", ordinal: \"fortieth\"),\n        NumberNames(cardinal: \"fifty\", ordinal: \"fiftieth\"),\n        NumberNames(cardinal: \"sixty\", ordinal: \"sixtieth\"),\n        NumberNames(cardinal: \"seventy\", ordinal: \"seventieth\"),\n        NumberNames(cardinal: \"eighty\", ordinal: \"eightieth\"),\n        NumberNames(cardinal: \"ninety\", ordinal: \"ninetieth\")\n    ]\n}\n\nfileprivate class NamedPower {\n    let cardinal: String\n    let ordinal: String\n    let number: UInt64\n    \n    init(cardinal: String, ordinal: String, number: UInt64) {\n        self.cardinal = cardinal\n        self.ordinal = ordinal\n        self.number = number\n    }\n    \n    func getName(_ ordinal: Bool) -> String {\n        return ordinal ? self.ordinal : self.cardinal\n    }\n\n    class func getNamedPower(_ number: UInt64) -> NamedPower {\n        for i in 1..<namedPowers.count {\n            if number < namedPowers[i].number {\n                return namedPowers[i - 1]\n            }\n        }\n        return namedPowers[namedPowers.count - 1]\n    }\n\n    static let namedPowers = [\n        NamedPower(cardinal: \"hundred\", ordinal: \"hundredth\",\n                   number: 100),\n        NamedPower(cardinal: \"thousand\", ordinal: \"thousandth\",\n                   number: 1000),\n        NamedPower(cardinal: \"million\", ordinal: \"millionth\",\n                   number: 1000000),\n        NamedPower(cardinal: \"billion\", ordinal: \"billionth\",\n                   number: 1000000000),\n        NamedPower(cardinal: \"trillion\", ordinal: \"trillionth\",\n                   number: 1000000000000),\n        NamedPower(cardinal: \"quadrillion\", ordinal: \"quadrillionth\",\n                   number: 1000000000000000),\n        NamedPower(cardinal: \"quintillion\", ordinal: \"quintillionth\",\n                   number: 1000000000000000000)\n    ]\n}\n\npublic func numberName(number: UInt64, ordinal: Bool) -> String {\n    if number < 100 {\n        return NumberNames.numberName(number: Int(truncatingIfNeeded: number),\n                                      ordinal: ordinal)\n    }\n    let p = NamedPower.getNamedPower(number)\n    var result = numberName(number: number/p.number, ordinal: false)\n    result += \" \"\n    if number % p.number == 0 {\n        result += p.getName(ordinal)\n    } else {\n        result += p.getName(false)\n        result += \" \"\n        result += numberName(number: number % p.number, ordinal: ordinal)\n    }\n    return result\n}\n\nfunc printOrdinal(_ number: UInt64) {\n    print(\"\\(number): \\(numberName(number: number, ordinal: true))\")\n}\n\nprintOrdinal(1)\nprintOrdinal(2)\nprintOrdinal(3)\nprintOrdinal(4)\nprintOrdinal(5)\nprintOrdinal(11)\nprintOrdinal(15)\nprintOrdinal(21)\nprintOrdinal(42)\nprintOrdinal(65)\nprintOrdinal(98)\nprintOrdinal(100)\nprintOrdinal(101)\nprintOrdinal(272)\nprintOrdinal(300)\nprintOrdinal(750)\nprintOrdinal(23456)\nprintOrdinal(7891233)\nprintOrdinal(8007006005004003)\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SpellingOfOrdinalNumbers {\n\n    public static void main(String[] args) {\n        for ( long test : new long[] {1,  2,  3,  4,  5,  11,  65,  100,  101,  272,  23456,  8007006005004003L} ) {\n            System.out.printf(\"%d = %s%n\", test, toOrdinal(test));\n        }\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n\n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 392553, "name": "Line circle intersection", "source": "Translate Swift to Java: import Foundation\nimport CoreGraphics\n\nfunc lineCircleIntersection(start: NSPoint, end: NSPoint, center: NSPoint,\n                            radius: CGFloat, segment: Bool) -> [NSPoint] {\n    var result: [NSPoint] = []\n    let angle = atan2(end.y - start.y, end.x - start.x)\n    var at = AffineTransform(rotationByRadians: angle)\n    at.invert()\n    at.translate(x: -center.x, y: -center.y)\n    let p1 = at.transform(start)\n    let p2 = at.transform(end)\n    let minX = min(p1.x, p2.x), maxX = max(p1.x, p2.x)\n    let y = p1.y\n    at.invert()\n    func addPoint(x: CGFloat, y: CGFloat) {\n        if !segment || (x <= maxX && x >= minX) {\n            result.append(at.transform(NSMakePoint(x, y)))\n        }\n    }\n    if y == radius || y == -radius {\n        addPoint(x: 0, y: y)\n    } else if y < radius && y > -radius {\n        let x = (radius * radius - y * y).squareRoot()\n        addPoint(x: -x, y: y)\n        addPoint(x: x, y: y)\n    }\n    return result\n}\n\nfunc toString(points: [NSPoint]) -> String {\n    var result = \"[\"\n    result += points.map{String(format: \"(%.4f,\u00a0%.4f)\", $0.x, $0.y)}.joined(separator: \", \")\n    result += \"]\"\n    return result\n}\n\nvar center = NSMakePoint(3, -5)\nvar radius: CGFloat = 3\n\nprint(\"The intersection points (if any) between:\")\nprint(\"\\n  A circle, center (3, -5) with radius 3, and:\")\nprint(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\")\nvar points = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(10, -9),\n                                    center: center, radius: radius,\n                                    segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\")\npoints = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(-11, 12),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(3, -2), end: NSMakePoint(7, -2),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 0\ncenter.y = 0\nradius = 4\n\nprint(\"\\n  A circle, center (0, 0) with radius 4, and:\")\nprint(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 4\ncenter.y = 2\nradius = 5\n\nprint(\"\\n  A circle, center (4, 2) with radius 5, and:\")\nprint(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(6, 3), end: NSMakePoint(10, 7),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(7, 4), end: NSMakePoint(11, 8),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n", "target": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class LineCircleIntersection {\n    public static void main(String[] args) {\n        try {\n            demo();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void demo() throws NoninvertibleTransformException {\n        Point2D center = makePoint(3, -5);\n        double radius = 3.0;\n        System.out.println(\"The intersection points (if any) between:\");\n        System.out.println(\"\\n  A circle, center (3, -5) with radius 3, and:\");\n        System.out.println(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(10, -9),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(-11, 12),\n                            center, radius, true)));\n        System.out.println(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(3, -2), makePoint(7, -2), center, radius, false)));\n        center.setLocation(0, 0);\n        radius = 4.0;\n        System.out.println(\"\\n  A circle, center (0, 0) with radius 4, and:\");\n        System.out.println(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, false)));\n        System.out.println(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, true)));\n        center.setLocation(4, 2);\n        radius = 5.0;\n        System.out.println(\"\\n  A circle, center (4, 2) with radius 5, and:\");\n        System.out.println(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(6, 3), makePoint(10, 7),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(7, 4), makePoint(11, 8),\n                            center, radius, true)));\n    }\n\n    private static Point2D makePoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static List<Point2D> intersection(Point2D p1, Point2D p2, Point2D center,\n            double radius, boolean isSegment) throws NoninvertibleTransformException {\n        List<Point2D> result = new ArrayList<>();\n        double dx = p2.getX() - p1.getX();\n        double dy = p2.getY() - p1.getY();\n        AffineTransform trans = AffineTransform.getRotateInstance(dx, dy);\n        trans.invert();\n        trans.translate(-center.getX(), -center.getY());\n        Point2D p1a = trans.transform(p1, null);\n        Point2D p2a = trans.transform(p2, null);\n        double y = p1a.getY();\n        double minX = Math.min(p1a.getX(), p2a.getX());\n        double maxX = Math.max(p1a.getX(), p2a.getX());\n        if (y == radius || y == -radius) {\n            if (!isSegment || (0 <= maxX && 0 >= minX)) {\n                p1a.setLocation(0, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n        } else if (y < radius && y > -radius) {\n            double x = Math.sqrt(radius * radius - y * y);\n            if (!isSegment || (-x <= maxX && -x >= minX)) {\n                p1a.setLocation(-x, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n            if (!isSegment || (x <= maxX && x >= minX)) {\n                p2a.setLocation(x, y);\n                trans.inverseTransform(p2a, p2a);\n                result.add(p2a);\n            }\n        }\n        return result;\n    }\n\n    public static String toString(Point2D point) {\n        return String.format(\"(%g, %g)\", point.getX(), point.getY());\n    }\n\n    public static String toString(List<Point2D> points) {\n        StringBuilder str = new StringBuilder(\"[\");\n        for (int i = 0, n = points.size(); i < n; ++i) {\n            if (i > 0)\n                str.append(\", \");\n            str.append(toString(points.get(i)));\n        }\n        str.append(\"]\");\n        return str.toString();\n    }\n}\n"}
{"id": 392554, "name": "Farey sequence", "source": "Translate Swift to Java: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 392555, "name": "Farey sequence", "source": "Translate Swift to Java: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 392556, "name": "Aliquot sequence classifications", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 392557, "name": "Aliquot sequence classifications", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\nstruct SeqClass: CustomStringConvertible {\n  var seq: [Int]\n  var desc: String\n\n  var description: String {\n    return \"\\(desc):    \\(seq)\"\n  }\n}\n\nfunc classifySequence(k: Int, threshold: Int = 1 << 47) -> SeqClass {\n  var last = k\n  var seq = [k]\n\n  while true {\n    last = last.factors().dropLast().reduce(0, +)\n    seq.append(last)\n\n    let n = seq.count\n\n    if last == 0 {\n      return SeqClass(seq: seq, desc: \"Terminating\")\n    } else if n == 2 && last == k {\n      return SeqClass(seq: seq, desc: \"Perfect\")\n    } else if n == 3 && last == k {\n      return SeqClass(seq: seq, desc: \"Amicable\")\n    } else if n >= 4 && last == k {\n      return SeqClass(seq: seq, desc: \"Sociable[\\(n - 1)]\")\n    } else if last == seq[n - 2] {\n      return SeqClass(seq: seq, desc: \"Aspiring\")\n    } else if seq.dropFirst().dropLast(2).contains(last) {\n      return SeqClass(seq: seq, desc: \"Cyclic[\\(n - 1 - seq.firstIndex(of: last)!)]\")\n    } else if n == 16 || last > threshold {\n      return SeqClass(seq: seq, desc: \"Non-terminating\")\n    }\n  }\n\n  fatalError()\n}\n\nfor i in 1...10 {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nfor i in [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488] {\n  print(\"\\(i): \\(classifySequence(k: i))\")\n}\n\nprint()\n\nprint(\"\\(15355717786080): \\(classifySequence(k: 15355717786080))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 392558, "name": "Magnanimous numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isMagnanimous(_ n: Int) -> Bool {\n    var p = 10;\n    while n >= p {\n        if !isPrime(n % p + n / p) {\n            return false\n        }\n        p *= 10\n    }\n    return true\n}\n\nlet m = (0...).lazy.filter{isMagnanimous($0)}.prefix(400);\nprint(\"First 45 magnanimous numbers:\");\nfor (i, n) in m.prefix(45).enumerated() {\n    if i > 0 && i % 15 == 0 {\n        print()\n    }\n    print(String(format: \"%3d\", n), terminator: \" \")\n}\nprint(\"\\n\\n241st through 250th magnanimous numbers:\");\nfor n in m.dropFirst(240).prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\n\\n391st through 400th magnanimous numbers:\");\nfor n in m.dropFirst(390) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MagnanimousNumbers {\n\n    public static void main(String[] args) {\n        runTask(\"Find and display the first 45 magnanimous numbers.\", 1, 45);\n        runTask(\"241st through 250th magnanimous numbers.\", 241, 250);\n        runTask(\"391st through 400th magnanimous numbers.\", 391, 400);\n    }\n    \n    private static void runTask(String message, int startN, int endN) {\n        int count = 0;\n        List<Integer> nums = new ArrayList<>();\n        for ( int n = 0 ; count < endN ; n++ ) {\n            if ( isMagnanimous(n) ) {\n                nums.add(n);\n                count++;\n            }\n        }\n        System.out.printf(\"%s%n\", message);\n        System.out.printf(\"%s%n%n\", nums.subList(startN-1, endN));\n    }\n    \n    private static boolean isMagnanimous(long n) {\n        if ( n >= 0 && n <= 9 ) {\n            return true;\n        }\n        long q = 11;\n        for ( long div = 10 ; q >= 10 ; div *= 10 ) {\n            q = n / div;\n            long r = n % div;\n            if ( ! isPrime(q+r) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 392559, "name": "Taxicab numbers", "source": "Translate Swift to Java: extension Array {\n  func combinations(_ k: Int) -> [[Element]] {\n    return Self._combinations(slice: self[startIndex...], k)\n  }\n\n  static func _combinations(slice: Self.SubSequence, _ k: Int) -> [[Element]] {\n    guard k != 1 else {\n      return slice.map({ [$0] })\n    }\n\n    guard k != slice.count else {\n      return [slice.map({ $0 })]\n    }\n\n    let chopped = slice[slice.index(after: slice.startIndex)...]\n\n    var res = _combinations(slice: chopped, k - 1).map({ [[slice.first!], $0].flatMap({ $0 }) })\n\n    res += _combinations(slice: chopped, k)\n\n    return res\n  }\n}\n\nlet cubes = (1...).lazy.map({ $0 * $0 * $0 })\nlet taxis =\n  Array(cubes.prefix(1201))\n    .combinations(2)\n    .reduce(into: [Int: [[Int]]](), { $0[$1[0] + $1[1], default: []].append($1) })\n\n\nlet res =\n  taxis\n    .lazy\n    .filter({ $0.value.count > 1 })\n    .sorted(by: { $0.key < $1.key })\n    .map({ ($0.key, $0.value) })\n    .prefix(2006)\n\nprint(\"First 25 taxicab numbers:\")\nfor taxi in res[..<25] {\n  print(taxi)\n}\n\nprint(\"\\n2000th through 2006th taxicab numbers:\")\nfor taxi in res[1999..<2006] {\n  print(taxi)\n}\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 392560, "name": "Strong and weak primes", "source": "Translate Swift to Java: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar strongPrimes = PrimeInfo(maxPrint: 36)\nvar weakPrimes = PrimeInfo(maxPrint: 37)\n\nlet sieve = PrimeSieve(size: limit2 + 100)\n\nvar p1 = 2, p2 = 3, p3 = 5\nwhile p2 < limit2 {\n    if sieve.isPrime(number: p3) {\n        let diff = p1 + p3 - 2 * p2\n        if diff < 0 {\n            strongPrimes.addPrime(prime: p2)\n        } else if diff > 0 {\n            weakPrimes.addPrime(prime: p2)\n        }\n        p1 = p2\n        p2 = p3\n    }\n    p3 += 2\n}\n\nstrongPrimes.printInfo(name: \"strong\")\nweakPrimes.printInfo(name: \"weak\")\n", "target": "public class StrongAndWeakPrimes {\n\n    private static int MAX = 10_000_000 + 1000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 36 strong primes:\");        \n        displayStrongPrimes(36);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of strong primes below\u00a0%,d =\u00a0%,d%n\", n, strongPrimesBelow(n));\n        }\n        System.out.println(\"First 37 weak primes:\");        \n        displayWeakPrimes(37);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of weak primes below\u00a0%,d =\u00a0%,d%n\", n, weakPrimesBelow(n));\n        }\n    }\n\n    private static int weakPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n\n    private static void displayWeakPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static int getNextPrime(int currentPrime) {\n        int nextPrime = currentPrime + 2;\n        while ( ! primes[nextPrime] ) {\n            nextPrime += 2;\n        }\n        return nextPrime;\n    }\n    \n    private static int strongPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n    \n    private static void displayStrongPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 392561, "name": "Left factorials", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 392562, "name": "Left factorials", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 392563, "name": "Strange unique prime triplets", "source": "Translate Swift to Java: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 392564, "name": "Strange unique prime triplets", "source": "Translate Swift to Java: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 392565, "name": "Smarandache prime-digital sequence", "source": "Translate Swift to Java: func isPrime(number: Int) -> Bool {\n    if number < 2 {\n        return false\n    }\n    if number % 2 == 0 {\n        return number == 2\n    }\n    if number % 3 == 0 {\n        return number == 3\n    }\n    if number % 5 == 0 {\n        return number == 5\n    }\n    var p = 7\n    let wheel = [4,2,4,2,4,6,2,6]\n    while true {\n        for w in wheel {\n            if p * p > number {\n                return true\n            }\n            if number % p == 0 {\n                return false\n            }\n            p += w\n        }\n    }\n}\n\nfunc nextPrimeDigitNumber(number: Int) -> Int {\n    if number == 0 {\n        return 2\n    }\n    switch number % 10 {\n    case 2:\n        return number + 1\n    case 3, 5:\n        return number + 2\n    default:\n        return 2 + nextPrimeDigitNumber(number: number/10) * 10\n    }\n}\n\nlet limit = 1000000000\nvar n = 0\nvar max = 0\nvar count = 0\nprint(\"First 25 SPDS primes:\")\nwhile n < limit {\n    n = nextPrimeDigitNumber(number: n)\n    if !isPrime(number: n) {\n        continue\n    }\n    if count < 25 {\n        print(n, terminator: \" \")\n    } else if count == 25 {\n        print()\n    }\n    count += 1\n    if (count == 100) {\n        print(\"Hundredth SPDS prime: \\(n)\")\n    } else if (count == 1000) {\n        print(\"Thousandth SPDS prime: \\(n)\")\n    } else if (count == 10000) {\n        print(\"Ten thousandth SPDS prime: \\(n)\")\n    }\n    max = n\n}\nprint(\"Largest SPDS prime less than \\(limit): \\(max)\")\n", "target": "public class SmarandachePrimeDigitalSequence {\n\n    public static void main(String[] args) {\n        long s = getNextSmarandache(7);\n        System.out.printf(\"First 25 Smarandache prime-digital sequence numbers:%n2 3 5 7 \");\n        for ( int count = 1 ; count <= 21 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                System.out.printf(\"%d \", s);\n                count++;\n            }\n        }\n        System.out.printf(\"%n%n\");\n        for (int i = 2 ; i <=5 ; i++ ) {\n            long n = (long) Math.pow(10, i);\n            System.out.printf(\"%,dth Smarandache prime-digital sequence number = %d%n\", n, getSmarandachePrime(n));\n        }\n    }\n    \n    private static final long getSmarandachePrime(long n) {\n        if ( n < 10 ) {\n            switch ((int) n) {\n            case 1:  return 2;\n            case 2:  return 3;\n            case 3:  return 5;\n            case 4:  return 7;\n            }\n        }\n        long s = getNextSmarandache(7);\n        long result = 0;\n        for ( int count = 1 ; count <= n-4 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                count++;\n                result = s;\n            }\n        }\n        return result;\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long getNextSmarandache(long n) {\n        \n        if ( n % 10 == 3 ) {\n            return n+4;\n        }\n        long retVal = n-4;\n        \n        \n        int k = 0;\n        while ( n % 10 == 7 ) {\n            k++;\n            n /= 10;\n        }\n        \n        \n        long digit = n % 10;\n\n        \n        long coeff = (digit == 2 ? 1 : 2);\n        \n        \n        retVal += coeff * Math.pow(10, k);\n        \n        \n        while ( k > 1 ) {\n            retVal -= 5 * Math.pow(10, k-1);\n            k--;\n        }\n        \n        \n        return retVal;\n    }\n\n}\n"}
{"id": 392566, "name": "Pythagorean quadruples", "source": "Translate Swift to Java: func missingD(upTo n: Int) -> [Int] {\n  var a2 = 0, s = 3, s1 = 0, s2 = 0\n  var res = [Int](repeating: 0, count: n + 1)\n  var ab = [Int](repeating: 0, count: n * n * 2 + 1)\n\n  for a in 1...n {\n    a2 = a * a\n\n    for b in a...n {\n      ab[a2 + b * b] = 1\n    }\n  }\n\n  for c in 1..<n {\n    s1 = s\n    s += 2\n    s2 = s\n\n    for d in c+1...n {\n      if ab[s1] != 0 {\n        res[d] = 1\n      }\n\n      s1 += s2\n      s2 += 2\n    }\n  }\n\n  return (1...n).filter({ res[$0] == 0 })\n}\n\nprint(missingD(upTo: 2200))\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PythagoreanQuadruples {\n\n    public static void main(String[] args) {\n        long d = 2200;\n        System.out.printf(\"Values of d < %d where a, b, and c are non-zero and a^2 + b^2 + c^2 = d^2 has no solutions:%n%s%n\", d, getPythagoreanQuadruples(d));\n    }\n\n    \n    private static List<Long> getPythagoreanQuadruples(long max) {\n        List<Long> list = new ArrayList<>();\n        long n = -1;\n        long m = -1;\n        while ( true ) {\n            long nTest = (long) Math.pow(2, n+1);\n            long mTest = (long) (5L * Math.pow(2, m+1));\n            long test = 0;\n            if ( nTest > mTest ) {\n                test = mTest;\n                m++;\n            }\n            else {\n                test = nTest;\n                n++;\n            }\n            if ( test < max ) {\n                list.add(test);\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n\n}\n"}
{"id": 392567, "name": "Safe primes and unsafe primes", "source": "Translate Swift to Java: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar safePrimes = PrimeInfo(maxPrint: 35)\nvar unsafePrimes = PrimeInfo(maxPrint: 40)\n\nlet sieve = PrimeSieve(size: limit2)\n\nfor prime in 2..<limit2 {\n    if sieve.isPrime(number: prime) {\n        if sieve.isPrime(number: (prime - 1)/2) {\n            safePrimes.addPrime(prime: prime)\n        } else {\n            unsafePrimes.addPrime(prime: prime)\n        }\n    }\n}\n\nsafePrimes.printInfo(name: \"safe\")\nunsafePrimes.printInfo(name: \"unsafe\")\n", "target": "public class SafePrimes {\n    public static void main(String... args) {\n        \n        int SIEVE_SIZE = 10_000_000;\n        boolean[] isComposite = new boolean[SIEVE_SIZE];\n        \n        isComposite[0] = true;\n        isComposite[1] = true;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (isComposite[n]) {\n                continue;\n            }\n            for (int i = n * 2; i < SIEVE_SIZE; i += n) {\n                isComposite[i] = true;\n            }\n        }\n        \n        int oldSafePrimeCount = 0;\n        int oldUnsafePrimeCount = 0;\n        int safePrimeCount = 0;\n        int unsafePrimeCount = 0;\n        StringBuilder safePrimes = new StringBuilder();\n        StringBuilder unsafePrimes = new StringBuilder();\n        int safePrimesStrCount = 0;\n        int unsafePrimesStrCount = 0;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (n == 1_000_000) {\n                oldSafePrimeCount = safePrimeCount;\n                oldUnsafePrimeCount = unsafePrimeCount;\n            }\n            if (isComposite[n]) {\n                continue;\n            }\n            boolean isUnsafe = isComposite[(n - 1) >>> 1];\n            if (isUnsafe) {\n                if (unsafePrimeCount < 40) {\n                    if (unsafePrimeCount > 0) {\n                        unsafePrimes.append(\", \");\n                    }\n                    unsafePrimes.append(n);\n                    unsafePrimesStrCount++;\n                }\n                unsafePrimeCount++;\n            }\n            else {\n                if (safePrimeCount < 35) {\n                    if (safePrimeCount > 0) {\n                        safePrimes.append(\", \");\n                    }\n                    safePrimes.append(n);\n                    safePrimesStrCount++;\n                }\n                safePrimeCount++;\n            }\n        }\n        \n        System.out.println(\"First \" + safePrimesStrCount + \" safe primes: \" + safePrimes.toString());\n        System.out.println(\"Number of safe primes below 1,000,000: \" + oldSafePrimeCount);\n        System.out.println(\"Number of safe primes below 10,000,000: \" + safePrimeCount);\n        System.out.println(\"First \" + unsafePrimesStrCount + \" unsafe primes: \" + unsafePrimes.toString());\n        System.out.println(\"Number of unsafe primes below 1,000,000: \" + oldUnsafePrimeCount);\n        System.out.println(\"Number of unsafe primes below 10,000,000: \" + unsafePrimeCount);\n        \n        return;\n    }\n}\n"}
{"id": 392568, "name": "Hash join", "source": "Translate Swift to Java: func hashJoin<A, B, K: Hashable>(_ first: [(K, A)], _ second: [(K, B)]) -> [(A, K, B)] {\n  var map = [K: [B]]()\n\n  for (key, val) in second {\n    map[key, default: []].append(val)\n  }\n\n  var res = [(A, K, B)]()\n\n  for (key, val) in first {\n    guard let vals = map[key] else {\n      continue\n    }\n\n    res += vals.map({ (val, key, $0) })\n  }\n\n  return res\n}\n\nlet t1 = [\n  (\"Jonah\", 27), \n  (\"Alan\", 18), \n  (\"Glory\", 28), \n  (\"Popeye\", 18), \n  (\"Alan\", 28)\n]\n\nlet t2 = [\n  (\"Jonah\", \"Whales\"), \n  (\"Jonah\", \"Spiders\"),\n  (\"Alan\", \"Ghosts\"),\n  (\"Alan\", \"Zombies\"),\n  (\"Glory\", \"Buffy\")\n]\n\nprint(\"Age | Character Name | Nemesis\")\nprint(\"----|----------------|--------\")\n\nfor (age, name, nemesis) in hashJoin(t1, t2) {\n  print(\"\\(age) | \\(name) | \\(nemesis)\")\n}\n", "target": "import java.util.*;\n\npublic class HashJoin {\n\n    public static void main(String[] args) {\n        String[][] table1 = {{\"27\", \"Jonah\"}, {\"18\", \"Alan\"}, {\"28\", \"Glory\"},\n        {\"18\", \"Popeye\"}, {\"28\", \"Alan\"}};\n\n        String[][] table2 = {{\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n        {\"Bob\", \"foo\"}};\n\n        hashJoin(table1, 1, table2, 0).stream()\n                .forEach(r -> System.out.println(Arrays.deepToString(r)));\n    }\n\n    static List<String[][]> hashJoin(String[][] records1, int idx1,\n            String[][] records2, int idx2) {\n\n        List<String[][]> result = new ArrayList<>();\n        Map<String, List<String[]>> map = new HashMap<>();\n\n        for (String[] record : records1) {\n            List<String[]> v = map.getOrDefault(record[idx1], new ArrayList<>());\n            v.add(record);\n            map.put(record[idx1], v);\n        }\n\n        for (String[] record : records2) {\n            List<String[]> lst = map.get(record[idx2]);\n            if (lst != null) {\n                lst.stream().forEach(r -> {\n                    result.add(new String[][]{r, record});\n                });\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"id": 392569, "name": "Terminal control_Preserve screen", "source": "Translate Swift to Java: public let CSI = ESC+\"[\"   \nfunc write(_ text: String...) {\n  for txt in text { write(STDOUT_FILENO, txt, txt.utf8.count) }\n}\nwrite(CSI,\"?1049h\") \nprint(\"Alternate screen buffer\\n\")\nfor n in (1...5).reversed() {\n    print(\"Going back in \\(n)...\")\n    sleep(1)\n}\nwrite(CSI,\"?1049l\") \n", "target": "public class PreserveScreen\n{\n    public static void main(String[] args) throws InterruptedException {\n        System.out.print(\"\\033[?1049h\\033[H\");\n        System.out.println(\"Alternate screen buffer\\n\");\n        for (int i = 5; i > 0; i--) {\n            String s = (i > 1) ? \"s\" : \"\";\n            System.out.printf(\"\\rgoing back in %d second%s...\", i, s);\n            Thread.sleep(1000);\n        }\n        System.out.print(\"\\033[?1049l\");\n    }\n}\n"}
{"id": 392570, "name": "24 game_Solve", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 392571, "name": "24 game_Solve", "source": "Translate Swift to Java: import Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 392572, "name": "Super-d numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 392573, "name": "Super-d numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 392574, "name": "Textonyms", "source": "Translate Swift to Java: import Foundation\n\nfunc textCharacter(_ ch: Character) -> Character? {\n    switch (ch) {\n    case \"a\", \"b\", \"c\":\n        return \"2\"\n    case \"d\", \"e\", \"f\":\n        return \"3\"\n    case \"g\", \"h\", \"i\":\n        return \"4\"\n    case \"j\", \"k\", \"l\":\n        return \"5\"\n    case \"m\", \"n\", \"o\":\n        return \"6\"\n    case \"p\", \"q\", \"r\", \"s\":\n        return \"7\"\n    case \"t\", \"u\", \"v\":\n        return \"8\"\n    case \"w\", \"x\", \"y\", \"z\":\n        return \"9\"\n    default:\n        return nil\n    }\n}\n\nfunc textString(_ string: String) -> String? {\n    var result = String()\n    result.reserveCapacity(string.count)\n    for ch in string {\n        if let tch = textCharacter(ch) {\n            result.append(tch)\n        } else {\n            return nil\n        }\n    }\n    return result\n}\n\nfunc compareByWordCount(pair1: (key: String, value: [String]),\n                        pair2: (key: String, value: [String])) -> Bool {\n    if pair1.value.count == pair2.value.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.value.count > pair2.value.count\n}\n\nfunc compareByTextLength(pair1: (key: String, value: [String]),\n                         pair2: (key: String, value: [String])) -> Bool {\n    if pair1.key.count == pair2.key.count {\n        return pair1.key < pair2.key\n    }\n    return pair1.key.count > pair2.key.count\n}\n\nfunc findTextonyms(_ path: String) throws {\n    var dict = Dictionary<String, [String]>()\n    let contents = try String(contentsOfFile: path, encoding: String.Encoding.ascii)\n    var count = 0\n    for line in contents.components(separatedBy: \"\\n\") {\n        if line.isEmpty {\n            continue\n        }\n        let word = line.lowercased()\n        if let text = textString(word) {\n            dict[text, default: []].append(word)\n            count += 1\n        }\n    }\n    var textonyms = Array(dict.filter{$0.1.count > 1})\n    print(\"There are \\(count) words in '\\(path)' which can be represented by the digit key mapping.\")\n    print(\"They require \\(dict.count) digit combinations to represent them.\")\n    print(\"\\(textonyms.count) digit combinations represent Textonyms.\")\n\n    let top = min(5, textonyms.count)\n    print(\"\\nTop \\(top) by number of words:\")\n    textonyms.sort(by: compareByWordCount)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n\n    print(\"\\nTop \\(top) by length:\")\n    textonyms.sort(by: compareByTextLength)\n    for (text, words) in textonyms.prefix(top) {\n        print(\"\\(text) = \\(words.joined(separator: \", \"))\")\n    }\n}\n\ndo {\n    try findTextonyms(\"unixdict.txt\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read\u00a0%,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are\u00a0%,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require\u00a0%,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to\u00a0%,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n"}
{"id": 392575, "name": "Church numerals", "source": "Translate Swift to Java: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 392576, "name": "Church numerals", "source": "Translate Swift to Java: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 392577, "name": "Send an unknown method call", "source": "Translate Swift to Java: import Foundation\n\nclass MyUglyClass: NSObject {\n  @objc\n  func myUglyFunction() {\n    print(\"called myUglyFunction\")\n  }\n}\n\nlet someObject: NSObject = MyUglyClass()\n\nsomeObject.perform(NSSelectorFromString(\"myUglyFunction\"))\n", "target": "import java.lang.reflect.Method;\n\nclass Example {\n  public int foo(int x) {\n    return 42 + x;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Object example = new Example();\n    String name = \"foo\";\n    Class<?> clazz = example.getClass();\n    Method meth = clazz.getMethod(name, int.class);\n    Object result = meth.invoke(example, 5); \n    System.out.println(result);        \n  }\n}\n"}
{"id": 392578, "name": "Sequence of primorial primes", "source": "Translate Swift to Java: import BigInt \nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nlet limit = 20\nvar primorial = 1\nvar count = 1\nvar p = 3\nvar prod = BigInt(2)\n\nprint(1, terminator: \" \")\n\nwhile true {\n  defer {\n    p += 2\n  }\n\n  guard p.isPrime else {\n    continue\n  }\n\n  prod *= BigInt(p)\n  primorial += 1\n\n  if (prod + 1).isPrime() || (prod - 1).isPrime() {\n    print(primorial, terminator: \" \")\n\n    count += 1\n\n    fflush(stdout)\n\n    if count == limit {\n      break\n    }\n  }\n}\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 392579, "name": "Combinations and permutations", "source": "Translate Swift to Java: import BigInt\n\nfunc permutations(n: Int, k: Int) -> BigInt {\n  let l = n - k + 1\n\n  guard l <= n else {\n    return 1\n  }\n\n  return (l...n).reduce(BigInt(1), { $0 * BigInt($1) })\n}\n\nfunc combinations(n: Int, k: Int) -> BigInt {\n  let fact = {() -> BigInt in\n    guard k > 1 else {\n      return 1\n    }\n\n    return (2...k).map({ BigInt($0) }).reduce(1, *)\n  }()\n\n  return permutations(n: n, k: k) / fact\n}\n\nprint(\"Sample of permutations from 1 to 12\")\n\nfor i in 1...12 {\n  print(\"\\(i) P \\(i / 3) = \\(permutations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of combinations from 10 to 60\")\n\nfor i in stride(from: 10, through: 60, by: 10) {\n  print(\"\\(i) C \\(i / 3) = \\(combinations(n: i, k: i / 3))\")\n}\n\nprint(\"\\nSample of permutations from 5 to 15,000\")\n\nfor i in [5, 50, 500, 1000, 5000, 15000] {\n  let k = i / 3\n  let res = permutations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) P \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n\nprint(\"\\nSample of combinations from 100 to 1000\")\n\nfor i in stride(from: 100, through: 1000, by: 100) {\n  let k = i / 3\n  let res = combinations(n: i, k: k).description\n  let extra = res.count > 40 ? \"... (\\(res.count - 40) more digits)\" : \"\"\n\n  print(\"\\(i) C \\(k) = \\(res.prefix(40))\\(extra)\")\n}\n", "target": "import java.math.BigInteger;\n\npublic class CombinationsAndPermutations {\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n        System.out.println(\"A sample of permutations from 1 to 12 with exact Integer arithmetic:\");\n        for ( int n = 1 ; n <= 12 ; n++ ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, permutation(n, k));\n        }\n\n        System.out.println();\n        System.out.println(\"A sample of combinations from 10 to 60 with exact Integer arithmetic:\");\n        for ( int n = 10 ; n <= 60 ; n += 5 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, combination(n, k));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of permutations from 5 to 15000 displayed in floating point arithmetic:\");\n        System.out.printf(\"%d P %d = %s%n\", 5, 2, display(permutation(5, 2), 50));\n        for ( int n = 1000 ; n <= 15000 ; n += 1000 ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, display(permutation(n, k), 50));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of combinations from 100 to 1000 displayed in floating point arithmetic:\");\n        for ( int n = 100 ; n <= 1000 ; n += 100 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, display(combination(n, k), 50));\n        }\n\n    }\n    \n    private static String display(BigInteger val, int precision) {\n        String s = val.toString();\n        precision = Math.min(precision, s.length());\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.substring(0, 1));\n        sb.append(\".\");\n        sb.append(s.substring(1, precision));\n        sb.append(\" * 10^\");\n        sb.append(s.length()-1);\n        return sb.toString();\n    }\n    \n    public static BigInteger combination(int n, int k) {\n        \n        \n        if ( n-k < k ) {\n            k = n-k;\n        }\n        BigInteger result = permutation(n, k);\n        while ( k > 0 ) {\n            result = result.divide(BigInteger.valueOf(k));\n            k--;\n        }\n        return result;\n    }\n    \n    public static BigInteger permutation(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for ( int i = n ; i >= n-k+1 ; i-- ) {\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 392580, "name": "Long primes", "source": "Translate Swift to Java: public struct Eratosthenes: Sequence, IteratorProtocol {\n  private let n: Int\n  private let limit: Int\n\n  private var i = 2\n  private var sieve: [Int]\n\n  public init(upTo: Int) {\n    if upTo <= 1 {\n      self.n = 0\n      self.limit = -1\n      self.sieve = []\n    } else {\n      self.n = upTo\n      self.limit = Int(Double(n).squareRoot())\n      self.sieve = Array(0...n)\n    }\n  }\n\n  public mutating func next() -> Int? {\n    while i < n {\n      defer { i += 1 }\n\n      if sieve[i] != 0 {\n        if i <= limit {\n          for notPrime in stride(from: i * i, through: n, by: i) {\n            sieve[notPrime] = 0\n          }\n        }\n\n        return i\n      }\n    }\n\n    return nil\n  }\n}\n\nfunc findPeriod(n: Int) -> Int {\n  let r = (1...n+1).reduce(1, {res, _ in (10 * res) % n })\n  var rr = r\n  var period = 0\n\n  repeat {\n    rr = (10 * rr) % n\n    period += 1\n  } while r != rr\n\n  return period\n}\n\nlet longPrimes = Eratosthenes(upTo: 64000).dropFirst().lazy.filter({ findPeriod(n: $0) == $0 - 1 })\n\nprint(\"Long primes less than 500: \\(Array(longPrimes.prefix(while: { $0 <= 500 })))\")\n\nlet counts =\n  longPrimes.reduce(into: [500: 0, 1000: 0, 2000: 0, 4000: 0, 8000: 0, 16000: 0, 32000: 0, 64000: 0], {counts, n in\n    for key in counts.keys where n < key {\n      counts[key]! += 1\n    }\n  })\n\nfor key in counts.keys.sorted() {\n  print(\"There are \\(counts[key]!) long primes less than \\(key)\")\n}\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class LongPrimes\n{\n    private static void sieve(int limit, List<Integer> primes)\n    {\n        boolean[] c = new boolean[limit];\n        for (int i = 0; i < limit; i++)\n            c[i] = false;\n        \n        int p = 3, n = 0;\n        int p2 = p * p;\n        while (p2 <= limit)\n        {\n            for (int i = p2; i <= limit; i += 2 * p)\n                c[i] = true;\n            do\n                p += 2;\n            while (c[p]);\n            p2 = p * p;\n        }\n        for (int i = 3; i <= limit; i += 2)\n            if (!c[i])\n                primes.add(i);\n    }\n\n    \n    private static int findPeriod(int n)\n    {\n        int r = 1, period = 0;\n        for (int i = 1; i < n; i++)\n            r = (10 * r) % n;\n        int rr = r;\n        do\n        {\n            r = (10 * r) % n;\n            ++period;\n        }\n        while (r != rr);\n        return period;\n    }\n    \n    public static void main(String[] args)\n    {\n        int[] numbers = new int[]{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};\n        int[] totals = new int[numbers.length]; \n        List<Integer> primes = new LinkedList<Integer>();\n        List<Integer> longPrimes = new LinkedList<Integer>();\n        sieve(64000, primes);\n        for (int prime : primes)\n            if (findPeriod(prime) == prime - 1)\n                longPrimes.add(prime);\n        int count = 0, index = 0;\n        for (int longPrime : longPrimes)\n        {\n            if (longPrime > numbers[index])\n                totals[index++] = count;\n            ++count;\n        }\n        totals[numbers.length - 1] = count;\n        System.out.println(\"The long primes up to \" + numbers[0] + \" are:\");\n        System.out.println(longPrimes.subList(0, totals[0]));\n        System.out.println();\n        System.out.println(\"The number of long primes up to:\");\n        for (int i = 0; i <= 7; i++)\n            System.out.printf(\"  %5d is %d\\n\", numbers[i], totals[i]);\n    }\n}\n"}
{"id": 392581, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Swift to Java: \nimport Foundation\n\n\nstruct Stack<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tvar top: T? {\n\t\telements.last\n\t}\n\t\n\tmutating func push(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func pop() -> T? {\n\t\tself.isEmpty ? nil : elements.removeLast()\n\t}\n}\n\nstruct Queue<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tmutating func enqueue(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func dequeue() -> T {\n\t\treturn elements.removeFirst()\n\t}\n}\n\nenum Associativity {\n\tcase Left, Right\n}\n\n\nprotocol OperatorType: Comparable, Hashable {\n\tvar name: String { get }\n\tvar precedence: Int { get }\n\tvar associativity: Associativity { get }\n}\n\nstruct Operator: OperatorType {\n\tlet name: String\n\tlet precedence: Int\n\tlet associativity: Associativity\n\t\n\t\n\tfunc hash(into hasher: inout Hasher) {\n\t\thasher.combine(self.name)\n\t}\n\t\n\tinit(_ name: String, _ precedence: Int, _ associativity: Associativity) {\n\t\tself.name = name; self.precedence = precedence; self.associativity = associativity\n\t}\n}\n\nfunc ==(x: Operator, y: Operator) -> Bool {\n\t\n\tx.name == y.name\n}\n\nfunc <(x: Operator, y: Operator) -> Bool {\n\t\n\t(x.associativity == .Left && x.precedence == y.precedence) || x.precedence < y.precedence\n}\n\nextension Set where Element: OperatorType {\n\tfunc contains(_ operatorName: String) -> Bool {\n\t\tcontains { $0.name == operatorName }\n\t}\n\t\n\tsubscript (operatorName: String) -> Element? {\n\t\tget {\n\t\t\tfilter { $0.name == operatorName }.first\n\t\t}\n\t}\n}\n\n\nextension String {\n\tvar isNumber: Bool { return Double(self) != nil }\n}\n\nstruct ShuntingYard {\n\tenum ParseError: Error {\n\t\tcase MismatchedParenthesis(parenthesis: String, expression: String)\n\t\tcase UnrecognizedToken(token: String, expression: String)\n\t\tcase ExtraneousToken(token: String, expression: String)\n\t}\n\t\n\tstatic func parse(_ input: String, operators: Set<Operator>) throws -> String {\n\t\tvar stack = Stack<String>()\n\t\tvar output = Queue<String>()\n\t\tlet tokens = input.components(separatedBy: \" \")\n\t\t\n\t\tfor token in tokens {\n\t\t\t\n\t\t\tif token.isNumber {\n\t\t\t\t\n\t\t\t\toutput.enqueue(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif operators.contains(token) {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top,\n\t\t\t\t\t  operators.contains(top) && Self.hasLowerPrecedence(token, top, operators) {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \"(\" {\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \")\" {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top, top != \"(\" {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tguard let _ = stack.pop() else {\n\t\t\t\t\t\n\t\t\t\t\tthrow ParseError.MismatchedParenthesis(parenthesis: \")\", expression: input)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthrow ParseError.UnrecognizedToken(token: token, expression: token)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\twhile let top = stack.top,\n\t\t\t  operators.contains(top) {\n\t\t\t\n\t\t\toutput.enqueue(stack.pop()!)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif let top = stack.pop() {\n\t\t\tthrow (\n\t\t\t\ttop == \"(\"\n\t\t\t\t? ParseError.MismatchedParenthesis(parenthesis: \"(\", expression: input)\n\t\t\t\t: ParseError.ExtraneousToken(token: top, expression: input)\n\t\t\t)\n\t\t}\n\t\t\n\t\treturn output.elements.joined(separator: \" \")\n\t}\n\t\n\tstatic private func hasLowerPrecedence(_ firstToken: String, _ secondToken: String, _ operators: Set<Operator>) -> Bool {\n\t\tguard let firstOperator = operators[firstToken],\n\t\t\t  let secondOperator = operators[secondToken] else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\treturn firstOperator < secondOperator\n\t}\n}\n\n\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 392582, "name": "Perlin noise", "source": "Translate Swift to Java: import Foundation\n\nstruct Perlin {\n  private static let permutation = [\n    151, 160, 137,  91,  90,  15, 131,  13, 201,  95,  96,  53, 194, 233,   7, 225,\n    140,  36, 103,  30,  69, 142,   8,  99,  37, 240,  21,  10,  23, 190,   6, 148,\n    247, 120, 234,  75,   0,  26, 197,  62,  94, 252, 219, 203, 117,  35,  11,  32,\n    57, 177,  33,  88, 237, 149,  56,  87, 174,  20, 125, 136, 171, 168,  68, 175,\n    74, 165,  71, 134, 139,  48,  27, 166,  77, 146, 158, 231,  83, 111, 229, 122,\n    60, 211, 133, 230, 220, 105,  92,  41,  55,  46, 245,  40, 244, 102, 143,  54,\n    65,  25,  63, 161,   1, 216,  80,  73, 209,  76, 132, 187, 208,  89,  18, 169,\n    200, 196, 135, 130, 116, 188, 159,  86, 164, 100, 109, 198, 173, 186,   3,  64,\n    52, 217, 226, 250, 124, 123,   5, 202,  38, 147, 118, 126, 255,  82,  85, 212,\n    207, 206,  59, 227,  47,  16,  58,  17, 182, 189,  28,  42, 223, 183, 170, 213,\n    119, 248, 152,   2,  44, 154, 163,  70, 221, 153, 101, 155, 167,  43, 172,   9,\n    129,  22,  39, 253,  19,  98, 108, 110,  79, 113, 224, 232, 178, 185, 112, 104,\n    218, 246,  97, 228, 251,  34, 242, 193, 238, 210, 144,  12, 191, 179, 162, 241,\n    81,  51, 145, 235, 249,  14, 239, 107,  49, 192, 214,  31, 181, 199, 106, 157,\n    184,  84, 204, 176, 115, 121,  50,  45, 127,   4, 150, 254, 138, 236, 205,  93,\n    222, 114,  67,  29,  24,  72, 243, 141, 128, 195,  78,  66, 215,  61, 156, 180\n  ]\n\n  private static let p = (0..<512).map({i -> Int in\n    if i < 256 {\n      return permutation[i]\n    } else {\n      return permutation[i - 256]\n    }\n  })\n\n  private static func fade(_ t: Double) -> Double { t * t * t * (t * (t * 6 - 15) + 10) }\n\n  private static func lerp(_ t: Double, _ a: Double, _ b: Double) -> Double { a + t * (b - a) }\n\n  private static func grad(_ hash: Int, _ x: Double, _ y: Double, _ z: Double) -> Double {\n    let h = hash & 15\n    let u = h < 8 ? x : y\n    let v = h < 4 ? y : h == 12 || h == 14 ? x : z\n\n    return (h & 1 == 0 ? u : -u) + (h & 2 == 0 ? v : -v)\n  }\n\n  static func noise(x: Double, y: Double, z: Double) -> Double {\n    let xi = Int(x) & 255\n    let yi = Int(y) & 255\n    let zi = Int(z) & 255\n\n    let xx = x - floor(x)\n    let yy = y - floor(y)\n    let zz = z - floor(z)\n\n    let u = fade(xx)\n    let v = fade(yy)\n    let w = fade(zz)\n\n    let a  = p[xi] + yi\n    let aa = p[a] + zi\n    let b  = p[xi + 1] + yi\n    let ba = p[b] + zi\n    let ab = p[a + 1] + zi\n    let bb = p[b + 1] + zi\n\n    return lerp(w, lerp(v, lerp(u, grad(p[aa], xx, yy, zz),\n      grad(p[ba], xx - 1, yy, zz)),\n      lerp(u, grad(p[ab], xx, yy - 1, zz),\n        grad(p[bb], xx - 1, yy - 1, zz))),\n      lerp(v, lerp(u, grad(p[aa + 1], xx, yy, zz - 1),\n        grad(p[ba + 1], xx - 1, yy, zz - 1)),\n        lerp(u, grad(p[ab + 1], xx, yy - 1, zz - 1),\n          grad(p[bb + 1], xx - 1, yy - 1, zz - 1))))\n  }\n}\n\nprint(Perlin.noise(x: 3.14, y: 42, z: 7))\n", "target": "\n\npublic final class ImprovedNoise {\n   static public double noise(double x, double y, double z) {\n      int X = (int)Math.floor(x) & 255,                  \n          Y = (int)Math.floor(y) & 255,                  \n          Z = (int)Math.floor(z) & 255;\n      x -= Math.floor(x);                                \n      y -= Math.floor(y);                                \n      z -= Math.floor(z);\n      double u = fade(x),                                \n             v = fade(y),                                \n             w = fade(z);\n      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      \n          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      \n\n      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                     grad(p[BA  ], x-1, y  , z   )), \n                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                     grad(p[BB  ], x-1, y-1, z   ))),\n                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                     grad(p[BA+1], x-1, y  , z-1 )), \n                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                     grad(p[BB+1], x-1, y-1, z-1 ))));\n   }\n   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n   static double lerp(double t, double a, double b) { return a + t * (b - a); }\n   static double grad(int hash, double x, double y, double z) {\n      int h = hash & 15;                      \n      double u = h<8 ? x : y,                 \n             v = h<4 ? y : h==12||h==14 ? x : z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n   }\n   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   };\n   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }\n}\n"}
{"id": 392583, "name": "Lychrel numbers", "source": "Translate Swift to Java: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 392584, "name": "Lychrel numbers", "source": "Translate Swift to Java: import BigInt\n\npublic struct Lychrel<T: ReversibleNumeric & CustomStringConvertible>: Sequence, IteratorProtocol {\n  @usableFromInline\n  let seed: T\n\n  @usableFromInline\n  var done = false\n\n  @usableFromInline\n  var n: T\n\n  @usableFromInline\n  var iterations: T\n\n  @inlinable\n  public init(seed: T, iterations: T = 500) {\n    self.seed = seed\n    self.n = seed\n    self.iterations = iterations\n  }\n\n  @inlinable\n  public mutating func next() -> T? {\n    guard !done && iterations != 0 else {\n      return nil\n    }\n\n    guard !isPalindrome(n) || n == seed else {\n      done = true\n\n      return n\n    }\n\n    defer {\n      n += n.reversed()\n      iterations -= 1\n    }\n\n    return n\n  }\n}\n\n@inlinable\npublic func isPalindrome<T: CustomStringConvertible>(_ x: T) -> Bool {\n  let asString = String(describing: x)\n\n  for (c, c1) in zip(asString, asString.reversed()) where c != c1 {\n    return false\n  }\n\n  return true\n}\n\npublic protocol ReversibleNumeric: Numeric {\n  func reversed() -> Self\n}\n\nextension BigInt: ReversibleNumeric {\n  public func reversed() -> BigInt {\n    return BigInt(String(description.reversed()))!\n  }\n}\n\ntypealias LychrelReduce = (seen: Set<BigInt>, seeds: Set<BigInt>, related: Set<BigInt>)\n\nlet (seen, seeds, related): LychrelReduce =\n  (1...10_000)\n    .map({ BigInt($0) })\n    .reduce(into: LychrelReduce(seen: Set(), seeds: Set(), related: Set()), {res, cur in\n      guard !res.seen.contains(cur) else {\n        res.related.insert(cur)\n\n        return\n      }\n\n      var seen = false\n\n      let seq = Lychrel(seed: cur).prefix(while: { seen = res.seen.contains($0); return !seen })\n      let last = seq.last!\n\n      guard !isPalindrome(last) || seen else {\n        return\n      }\n\n      res.seen.formUnion(seq)\n\n      if seq.count == 500 {\n        res.seeds.insert(cur)\n      } else {\n        res.related.insert(cur)\n      }\n  })\n\nprint(\"Found \\(seeds.count + related.count) Lychrel numbers between 1...10_000 when limited to 500 iterations\")\nprint(\"Number of Lychrel seeds found: \\(seeds.count)\")\nprint(\"Lychrel seeds found: \\(seeds.sorted())\")\nprint(\"Number of related Lychrel nums found: \\(related.count)\")\nprint(\"Lychrel palindromes found: \\(seeds.union(related).filter(isPalindrome).sorted())\")\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 392585, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Java: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 392586, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to Java: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 392587, "name": "Pierpont primes", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\npublic func pierpoint(n: Int) -> (first: [BigInt], second: [BigInt]) {\n  var primes = (first: [BigInt](repeating: 0, count: n), second: [BigInt](repeating: 0, count: n))\n\n  primes.first[0] = 2\n\n  var count1 = 1, count2 = 0\n  var s = [BigInt(1)]\n  var i2 = 0, i3 = 0, k = 1\n  var n2 = BigInt(0), n3 = BigInt(0), t = BigInt(0)\n\n  while min(count1, count2) < n {\n    n2 = s[i2] * 2\n    n3 = s[i3] * 3\n\n    if n2 < n3 {\n      t = n2\n      i2 += 1\n    } else {\n      t = n3\n      i3 += 1\n    }\n\n    if t <= s[k - 1] {\n      continue\n    }\n\n    s.append(t)\n    k += 1\n    t += 1\n\n    if count1 < n && t.isPrime(rounds: 10) {\n      primes.first[count1] = t\n      count1 += 1\n    }\n\n    t -= 2\n\n    if count2 < n && t.isPrime(rounds: 10) {\n      primes.second[count2] = t\n      count2 += 1\n    }\n  }\n\n  return primes\n}\n\n\nlet primes = pierpoint(n: 250)\n\nprint(\"First 50 Pierpoint primes of the first kind: \\(Array(primes.first.prefix(50)))\\n\")\nprint(\"First 50 Pierpoint primes of the second kind: \\(Array(primes.second.prefix(50)))\")\nprint()\nprint(\"250th Pierpoint prime of the first kind: \\(primes.first[249])\")\nprint(\"250th Pierpoint prime of the second kind: \\(primes.second[249])\")\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PierpontPrimes {\n\n    public static void main(String[] args) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        display(\"First 50 Pierpont primes of the first kind:\", pierpontPrimes(50, true));\n        display(\"First 50 Pierpont primes of the second kind:\", pierpontPrimes(50, false));\n        System.out.printf(\"250th Pierpont prime of the first kind:     %s%n%n\", nf.format(pierpontPrimes(250, true).get(249)));\n        System.out.printf(\"250th Pierpont prime of the second kind: %s%n%n\", nf.format(pierpontPrimes(250, false).get(249)));\n    }\n    \n    private static void display(String message, List<BigInteger> primes) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        System.out.printf(\"%s%n\", message);\n        for ( int i = 1 ; i <= primes.size() ; i++ ) {\n            System.out.printf(\"%10s  \", nf.format(primes.get(i-1)));\n            if ( i % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        System.out.printf(\"%n\");\n    }\n\n    public static List<BigInteger> pierpontPrimes(int n, boolean first) {\n        List<BigInteger> primes = new ArrayList<BigInteger>();\n        if ( first ) {\n            primes.add(BigInteger.valueOf(2));\n            n -= 1;\n        }\n\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        int twoIndex = 0, threeIndex = 0;\n        List<BigInteger> twoSmooth = new ArrayList<BigInteger>();\n\n        BigInteger one = BigInteger.ONE;\n        BigInteger mOne = BigInteger.valueOf(-1);\n        int count = 0;\n        while ( count < n ) {\n            BigInteger min = twoTest.min(threeTest);\n            twoSmooth.add(min);\n            if ( min.compareTo(twoTest) == 0 ) {\n                twoTest = two.multiply(twoSmooth.get(twoIndex));\n                twoIndex++;\n            }\n            if ( min.compareTo(threeTest) == 0 ) {\n                threeTest = three.multiply(twoSmooth.get(threeIndex));\n                threeIndex++;\n            }\n            BigInteger test = min.add(first ? one : mOne);\n            if ( test.isProbablePrime(10) ) {\n                primes.add(test);\n                count++;\n            }\n        }\n        return primes;\n    }\n    \n}\n"}
{"id": 392588, "name": "N-smooth numbers", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func smoothN<T: BinaryInteger>(n: T, count: Int) -> [T] {\n  let primes = stride(from: 2, to: n + 1, by: 1).filter({ $0.isPrime })\n  var next = primes\n  var indices = [Int](repeating: 0, count: primes.count)\n  var res = [T](repeating: 0, count: count)\n\n  res[0] = 1\n\n  guard count > 1 else {\n    return res\n  }\n\n  for m in 1..<count {\n    res[m] = next.min()!\n\n    for i in 0..<indices.count where res[m] == next[i] {\n      indices[i] += 1\n      next[i] = primes[i] * res[indices[i]]\n    }\n  }\n\n  return res\n}\n\nfor n in 2...29 where n.isPrime {\n  print(\"The first 25 \\(n)-smooth numbers are: \\(smoothN(n: n, count: 25))\")\n}\n\nprint()\n\nfor n in 3...29 where n.isPrime {\n  print(\"The 3000...3002 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 3002).dropFirst(2999).prefix(3))\")\n}\n\nprint()\n\nfor n in 503...521 where n.isPrime {\n  print(\"The 30,000...30,019 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 30_019).dropFirst(29999).prefix(20))\")\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NSmoothNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"show the first 25 n-smooth numbers for n = 2 through n = 29%n\");\n        int max = 25;\n        List<BigInteger> primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The first %d %d-smooth numbers:%n\", max, n);\n                BigInteger[] humble = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = 0 ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", humble[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"show three numbers starting with 3,000 for n-smooth numbers for n = 3 through n = 29%n\");\n        int count = 3;\n        max = 3000 + count - 1;\n        primes = new ArrayList<>();\n        primes.add(BigInteger.valueOf(2));\n        for ( int n = 3 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = max-count ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", nSmooth[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"Show twenty numbers starting with 30,000 n-smooth numbers for n=503 through n=521%n\");\n        count = 20;\n        max = 30000 + count - 1;\n        primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 521 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                if ( n >= 503 && n <= 521 ) {\n                    System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                    BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                    for ( int i = max-count ; i < max ; i++ ) {\n                        System.out.printf(\"%s \", nSmooth[i]);\n                    }\n                    System.out.printf(\"%n%n\");\n                }\n            }\n        }\n\n    }\n\n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BigInteger[] nSmooth(int n, BigInteger[] primes) {\n        int size = primes.length;\n        BigInteger[] test = new BigInteger[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            test[i] = primes[i];\n        }\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        \n        int[] indexes = new int[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            indexes[i] = 0;\n        }\n        \n        for ( int index = 1 ; index < n ; index++ ) {\n            BigInteger min = test[0];\n            for ( int i = 1 ; i < size ; i++ ) {\n                min = min.min(test[i]);\n            }\n            results[index] = min;\n            \n            for ( int i = 0 ; i < size ; i++ ) {\n                if ( results[index].compareTo(test[i]) == 0 ) {\n                    indexes[i] = indexes[i] + 1;\n                    test[i] = primes[i].multiply(results[indexes[i]]);\n                }\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 392589, "name": "Partition an integer x into n primes", "source": "Translate Swift to Java: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc findPrimePartition(sieve: PrimeSieve, number: Int,\n                        count: Int, minPrime: Int,\n                        primes: inout [Int], index: Int) -> Bool {\n    if count == 1 {\n        if number >= minPrime && sieve.isPrime(number: number) {\n            primes[index] = number\n            return true\n        }\n        return false\n    }\n    if minPrime >= number {\n        return false\n    }\n    for p in minPrime..<number {\n        if sieve.isPrime(number: p)\n            && findPrimePartition(sieve: sieve, number: number - p,\n                                  count: count - 1, minPrime: p + 1,\n                                  primes: &primes, index: index + 1) {\n            primes[index] = p\n            return true\n        }\n    }\n    return false\n}\n\nfunc printPrimePartition(sieve: PrimeSieve, number: Int, count: Int) {\n    var primes = Array(repeating: 0, count: count)\n    if !findPrimePartition(sieve: sieve, number: number, count: count,\n                           minPrime: 2, primes: &primes, index: 0) {\n        print(\"\\(number) cannot be partitioned into \\(count) primes.\")\n    } else {\n        print(\"\\(number) = \\(primes[0])\", terminator: \"\")\n        for i in 1..<count {\n            print(\" + \\(primes[i])\", terminator: \"\")\n        }\n        print()\n    }\n}\n\nlet sieve = PrimeSieve(size: 100000)\nprintPrimePartition(sieve: sieve, number: 99809, count: 1)\nprintPrimePartition(sieve: sieve, number: 18, count: 2)\nprintPrimePartition(sieve: sieve, number: 19, count: 3)\nprintPrimePartition(sieve: sieve, number: 20, count: 4)\nprintPrimePartition(sieve: sieve, number: 2017, count: 24)\nprintPrimePartition(sieve: sieve, number: 22699, count: 1)\nprintPrimePartition(sieve: sieve, number: 22699, count: 2)\nprintPrimePartition(sieve: sieve, number: 22699, count: 3)\nprintPrimePartition(sieve: sieve, number: 22699, count: 4)\nprintPrimePartition(sieve: sieve, number: 40355, count: 3)\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PartitionInteger {\n    private static final int[] primes = IntStream.concat(IntStream.of(2), IntStream.iterate(3, n -> n + 2))\n        .filter(PartitionInteger::isPrime)\n        .limit(50_000)\n        .toArray();\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    private static boolean findCombo(int k, int x, int m, int n, int[] combo) {\n        boolean foundCombo = false;\n        if (k >= m) {\n            if (Arrays.stream(combo).map(i -> primes[i]).sum() == x) {\n                String s = m > 1 ? \"s\" : \"\";\n                System.out.printf(\"Partitioned %5d with %2d prime%s: \", x, m, s);\n                for (int i = 0; i < m; ++i) {\n                    System.out.print(primes[combo[i]]);\n                    if (i < m - 1) System.out.print('+');\n                    else System.out.println();\n                }\n                foundCombo = true;\n            }\n        } else {\n            for (int j = 0; j < n; ++j) {\n                if (k == 0 || j > combo[k - 1]) {\n                    combo[k] = j;\n                    if (!foundCombo) {\n                        foundCombo = findCombo(k + 1, x, m, n, combo);\n                    }\n                }\n            }\n        }\n        return foundCombo;\n    }\n\n    private static void partition(int x, int m) {\n        if (x < 2 || m < 1 || m >= x) {\n            throw new IllegalArgumentException();\n        }\n        int[] filteredPrimes = Arrays.stream(primes).filter(it -> it <= x).toArray();\n        int n = filteredPrimes.length;\n        if (n < m) throw new IllegalArgumentException(\"Not enough primes\");\n        int[] combo = new int[m];\n        boolean foundCombo = findCombo(0, x, m, n, combo);\n        if (!foundCombo) {\n            String s = m > 1 ? \"s\" : \" \";\n            System.out.printf(\"Partitioned %5d with %2d prime%s: (not possible)\\n\", x, m, s);\n        }\n    }\n\n    public static void main(String[] args) {\n        partition(99809, 1);\n        partition(18, 2);\n        partition(19, 3);\n        partition(20, 4);\n        partition(2017, 24);\n        partition(22699, 1);\n        partition(22699, 2);\n        partition(22699, 3);\n        partition(22699, 4);\n        partition(40355, 3);\n    }\n}\n"}
{"id": 392590, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Java: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 392591, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to Java: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 392592, "name": "Chebyshev coefficients", "source": "Translate Swift to Java: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 392593, "name": "Chebyshev coefficients", "source": "Translate Swift to Java: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 392594, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Java: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 392595, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to Java: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 392596, "name": "Lucky and even lucky numbers", "source": "Translate Swift to Java: struct LuckyNumbers : Sequence, IteratorProtocol {\n  let even: Bool\n  let through: Int\n  \n  private var drainI = 0\n  private var n = 0\n  private var lst: [Int]\n  \n  init(even: Bool = false, through: Int = 1_000_000) {\n    self.even = even\n    self.through = through\n    self.lst = Array(stride(from: even ? 2 : 1, through: through, by: 2))\n  }\n  \n  mutating func next() -> Int? {\n    guard n != 0 else {\n      defer { n += 1 }\n      \n      return lst[0]\n    }\n    \n    while n < lst.count && lst[n] < lst.count {\n      let retVal = lst[n]\n      \n      lst = lst.enumerated().filter({ ($0.offset + 1) % lst[n] != 0  }).map({ $0.element })\n      n += 1\n      \n      return retVal\n    }\n    \n    if drainI == 0 {\n      lst = Array(lst.dropFirst(n))\n    }\n\n    while drainI < lst.count {\n      defer { drainI += 1 }\n      \n      return lst[drainI]\n    }\n    \n    return nil\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class LuckyNumbers {\n\n    private static int MAX = 200000;\n    private static List<Integer> luckyEven = luckyNumbers(MAX, true);\n    private static List<Integer> luckyOdd = luckyNumbers(MAX, false);\n    \n    public static void main(String[] args) {\n        \n        if ( args.length == 1 || ( args.length == 2 && args[1].compareTo(\"lucky\") == 0 ) ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"LuckyNumber(%d) = %d%n\", n, luckyOdd.get(n-1));\n        }\n        \n        else if ( args.length == 2 && args[1].compareTo(\"evenLucky\") == 0 ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"EvenLuckyNumber(%d) = %d%n\", n, luckyEven.get(n-1));            \n        }\n        \n        else if ( args.length == 2 || args.length == 3 ) {\n            int j = Integer.parseInt(args[0]);\n            int k = Integer.parseInt(args[1]);\n            \n            if ( ( args.length == 2 && k > 0 ) || (args.length == 3 && k > 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                System.out.printf(\"LuckyNumber(%d) through LuckyNumber(%d) = %s%n\", j, k, luckyOdd.subList(j-1, k));\n            }\n            \n            else if ( args.length == 3 && k > 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                System.out.printf(\"EvenLuckyNumber(%d) through EvenLuckyNumber(%d) = %s%n\", j, k, luckyEven.subList(j-1, k));\n            }\n            \n            else if ( ( args.length == 2 && k < 0 ) || (args.length == 3 && k < 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                int n = Collections.binarySearch(luckyOdd, j);\n                int m = Collections.binarySearch(luckyOdd, -k);\n                System.out.printf(\"Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyOdd.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n            \n            else if ( args.length == 3 && k < 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                int n = Collections.binarySearch(luckyEven, j);\n                int m = Collections.binarySearch(luckyEven, -k);\n                System.out.printf(\"Even Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyEven.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n        }\n    }\n    \n    private static List<Integer> luckyNumbers(int max, boolean even) {\n        List<Integer> luckyList = new ArrayList<>();\n        for ( int i = even ? 2 : 1 ; i <= max ; i += 2 ) {\n            luckyList.add(i);\n        }\n        int start = 1;\n        boolean removed = true;\n        while ( removed ) {\n            removed = false;\n            int increment = luckyList.get(start);\n            List<Integer> remove = new ArrayList<>();\n            for ( int i = increment-1 ; i < luckyList.size() ; i += increment ) {\n                remove.add(0, i);\n                removed = true;\n            }\n            for ( int i : remove ) {\n                luckyList.remove(i);\n            }\n            start++;\n        }\n        return luckyList;\n    }\n\n}\n"}
{"id": 392597, "name": "Peaceful chess queen armies", "source": "Translate Swift to Java: enum Piece {\n  case empty, black, white\n}\n\ntypealias Position = (Int, Int)\n\nfunc place(_ m: Int, _ n: Int, pBlackQueens: inout [Position], pWhiteQueens: inout [Position]) -> Bool {\n  guard m != 0 else {\n    return true\n  }\n\n  var placingBlack = true\n\n  for i in 0..<n {\n    inner: for j in 0..<n {\n      let pos = (i, j)\n\n      for queen in pBlackQueens where queen == pos || !placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      for queen in pWhiteQueens where queen == pos || placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      if placingBlack {\n        pBlackQueens.append(pos)\n        placingBlack = false\n      } else {\n        placingBlack = true\n\n        pWhiteQueens.append(pos)\n\n        if place(m - 1, n, pBlackQueens: &pBlackQueens, pWhiteQueens: &pWhiteQueens) {\n          return true\n        } else {\n          pBlackQueens.removeLast()\n          pWhiteQueens.removeLast()\n        }\n      }\n    }\n  }\n\n  if !placingBlack {\n    pBlackQueens.removeLast()\n  }\n\n  return false\n}\n\nfunc isAttacking(_ queen: Position, _ pos: Position) -> Bool {\n  queen.0 == pos.0 || queen.1 == pos.1 || abs(queen.0 - pos.0) == abs(queen.1 - pos.1)\n}\n\nfunc printBoard(n: Int, pBlackQueens: [Position], pWhiteQueens: [Position]) {\n  var board = Array(repeating: Piece.empty, count: n * n)\n\n  for queen in pBlackQueens {\n    board[queen.0 * n + queen.1] = .black\n  }\n\n  for queen in pWhiteQueens {\n    board[queen.0 * n + queen.1] = .white\n  }\n\n  for (i, p) in board.enumerated() {\n    if i != 0 && i % n == 0 {\n      print()\n    }\n\n    switch p {\n    case .black:\n      print(\"B \", terminator: \"\")\n    case .white:\n      print(\"W \", terminator: \"\")\n    case .empty:\n      let j = i / n\n      let k = i - j * n\n\n      if j % 2 == k % 2 {\n        print(\"\u2022 \", terminator: \"\")\n      } else {\n        print(\"\u25e6 \", terminator: \"\")\n      }\n    }\n  }\n\n  print(\"\\n\")\n}\n\nlet nms = [\n  (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),\n  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),\n  (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),\n  (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)\n]\n\nfor (n, m) in nms {\n  print(\"\\(m) black and white queens on \\(n) x \\(n) board\")\n\n  var blackQueens = [Position]()\n  var whiteQueens = [Position]()\n\n  if place(m, n, pBlackQueens: &blackQueens, pWhiteQueens: &whiteQueens) {\n    printBoard(n: n, pBlackQueens: blackQueens, pWhiteQueens: whiteQueens)\n  } else {\n    print(\"No solution\")\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Peaceful {\n    enum Piece {\n        Empty,\n        Black,\n        White,\n    }\n\n    public static class Position {\n        public int x, y;\n\n        public Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Position) {\n                Position pos = (Position) obj;\n                return pos.x == x && pos.y == y;\n            }\n            return false;\n        }\n    }\n\n    private static boolean place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n        if (m == 0) {\n            return true;\n        }\n        boolean placingBlack = true;\n        for (int i = 0; i < n; ++i) {\n            inner:\n            for (int j = 0; j < n; ++j) {\n                Position pos = new Position(i, j);\n                for (Position queen : pBlackQueens) {\n                    if (pos.equals(queen) || !placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                for (Position queen : pWhiteQueens) {\n                    if (pos.equals(queen) || placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                if (placingBlack) {\n                    pBlackQueens.add(pos);\n                    placingBlack = false;\n                } else {\n                    pWhiteQueens.add(pos);\n                    if (place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                        return true;\n                    }\n                    pBlackQueens.remove(pBlackQueens.size() - 1);\n                    pWhiteQueens.remove(pWhiteQueens.size() - 1);\n                    placingBlack = true;\n                }\n            }\n        }\n        if (!placingBlack) {\n            pBlackQueens.remove(pBlackQueens.size() - 1);\n        }\n        return false;\n    }\n\n    private static boolean isAttacking(Position queen, Position pos) {\n        return queen.x == pos.x\n            || queen.y == pos.y\n            || Math.abs(queen.x - pos.x) == Math.abs(queen.y - pos.y);\n    }\n\n    private static void printBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n        Piece[] board = new Piece[n * n];\n        Arrays.fill(board, Piece.Empty);\n\n        for (Position queen : blackQueens) {\n            board[queen.x + n * queen.y] = Piece.Black;\n        }\n        for (Position queen : whiteQueens) {\n            board[queen.x + n * queen.y] = Piece.White;\n        }\n        for (int i = 0; i < board.length; ++i) {\n            if ((i != 0) && i % n == 0) {\n                System.out.println();\n            }\n\n            Piece b = board[i];\n            if (b == Piece.Black) {\n                System.out.print(\"B \");\n            } else if (b == Piece.White) {\n                System.out.print(\"W \");\n            } else {\n                int j = i / n;\n                int k = i - j * n;\n                if (j % 2 == k % 2) {\n                    System.out.print(\"\u2022 \");\n                } else {\n                    System.out.print(\"\u25e6 \");\n                }\n            }\n        }\n        System.out.println('\\n');\n    }\n\n    public static void main(String[] args) {\n        List<Position> nms = List.of(\n            new Position(2, 1),\n            new Position(3, 1),\n            new Position(3, 2),\n            new Position(4, 1),\n            new Position(4, 2),\n            new Position(4, 3),\n            new Position(5, 1),\n            new Position(5, 2),\n            new Position(5, 3),\n            new Position(5, 4),\n            new Position(5, 5),\n            new Position(6, 1),\n            new Position(6, 2),\n            new Position(6, 3),\n            new Position(6, 4),\n            new Position(6, 5),\n            new Position(6, 6),\n            new Position(7, 1),\n            new Position(7, 2),\n            new Position(7, 3),\n            new Position(7, 4),\n            new Position(7, 5),\n            new Position(7, 6),\n            new Position(7, 7)\n        );\n        for (Position nm : nms) {\n            int m = nm.y;\n            int n = nm.x;\n            System.out.printf(\"%d black and %d white queens on a %d x %d board:\\n\", m, m, n, n);\n            List<Position> blackQueens = new ArrayList<>();\n            List<Position> whiteQueens = new ArrayList<>();\n            if (place(m, n, blackQueens, whiteQueens)) {\n                printBoard(n, blackQueens, whiteQueens);\n            } else {\n                System.out.println(\"No solution exists.\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 392598, "name": "N-body problem", "source": "Translate Swift to Java: import Foundation\n\npublic struct Vector {\n  public var px = 0.0\n  public var py = 0.0\n  public var pz = 0.0\n\n  public init(px: Double, py: Double, pz: Double) {\n    (self.px, self.py, self.pz) = (px, py, pz)\n  }\n\n  public init?(array: [Double]) {\n    guard array.count == 3 else {\n      return nil\n    }\n\n    (self.px, self.py, self.pz) = (array[0], array[1], array[2])\n  }\n\n  public func mod() -> Double {\n    (px * px + py * py + pz * pz).squareRoot()\n  }\n\n  static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px + rhs.px,\n      py: lhs.py + rhs.py,\n      pz: lhs.pz + rhs.pz\n    )\n  }\n\n  static func - (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px - rhs.px,\n      py: lhs.py - rhs.py,\n      pz: lhs.pz - rhs.pz\n    )\n  }\n\n  static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      px: lhs.px * rhs,\n      py: lhs.py * rhs,\n      pz: lhs.pz * rhs\n    )\n  }\n}\n\nextension Vector {\n  public static let origin = Vector(px: 0, py: 0, pz: 0)\n}\n\nextension Vector: Equatable {\n  public static func == (lhs: Vector, rhs: Vector) -> Bool {\n    return lhs.px == rhs.px && lhs.py == rhs.py && lhs.pz == rhs.pz\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", px, py, pz)\n  }\n}\n\npublic class NBody {\n  public let gravitationalConstant: Double\n  public let numBodies: Int\n  public let timeSteps: Int\n\n  public private(set) var masses: [Double]\n  public private(set) var positions: [Vector]\n  public private(set) var velocities: [Vector]\n  public private(set) var accelerations: [Vector]\n\n  public init?(file: String) {\n    guard let data = try? String(contentsOfFile: file) else {\n      return nil\n    }\n\n    print(\"Input file:\\n\\(data)\")\n\n    let lines = data.components(separatedBy: \"\\n\").map({ $0.components(separatedBy: \" \") })\n\n    let worldData = lines.first!\n\n    guard worldData.count == 3,\n          let gc = Double(worldData[0]),\n          let bodies = Int(worldData[1]),\n          let timeSteps = Int(worldData[2]) else {\n      return nil\n    }\n\n    let defaultState = Array(repeating: Vector.origin, count: bodies)\n\n    self.gravitationalConstant = gc\n    self.numBodies = bodies\n    self.timeSteps = timeSteps\n    self.masses = Array(repeating: 0, count: bodies)\n    self.positions = defaultState\n    self.accelerations = defaultState\n    self.velocities = defaultState\n\n    let bodyData = lines.dropFirst().map({ $0.compactMap(Double.init) })\n\n    guard bodyData.count == bodies * 3 else {\n      return nil\n    }\n\n    for n in 0..<bodies {\n      masses[n] = bodyData[0 + n * 3][0]\n\n      guard let position = Vector(array: bodyData[1 + n * 3]),\n            let velocity = Vector(array: bodyData[2 + n * 3]) else {\n        return nil\n      }\n\n      positions[n] = position\n      velocities[n] = velocity\n    }\n  }\n\n  private func computeAccelerations() {\n    for i in 0..<numBodies {\n      accelerations[i] = .origin\n\n      for j in 0..<numBodies where i != j {\n        let t = gravitationalConstant * masses[j] / pow((positions[i] - positions[j]).mod(), 3)\n        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * t\n      }\n    }\n  }\n\n  private func resolveCollisions() {\n    for i in 0..<numBodies {\n      for j in 0..<numBodies where positions[i] == positions[j] {\n        velocities.swapAt(i, j)\n      }\n    }\n  }\n\n  private func computeVelocities() {\n    for i in 0..<numBodies {\n      velocities[i] = velocities[i] + accelerations[i]\n    }\n  }\n\n  private func computePositions() {\n    for i in 0..<numBodies {\n      positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5\n    }\n  }\n\n  public func printState() {\n    for i in 0..<numBodies {\n      print(\"Body \\(i + 1): \\(positions[i])  |  \\(velocities[i])\")\n    }\n  }\n\n  public func simulate() {\n    computeAccelerations()\n    computePositions()\n    computeVelocities()\n    resolveCollisions()\n  }\n}\n\nguard let sim = NBody(file: \"input.txt\") else {\n  fatalError()\n}\n\nprint()\nprint(\"Body  \u00a0:      x          y          z    |     vx         vy         vz\")\n\nfor i in 0..<sim.timeSteps {\n  print(\"Step \\(i + 1)\")\n  sim.simulate()\n  sim.printState()\n  print()\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class NBodySim {\n    private static class Vector3D {\n        double x, y, z;\n\n        public Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public Vector3D plus(Vector3D rhs) {\n            return new Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);\n        }\n\n        public Vector3D minus(Vector3D rhs) {\n            return new Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);\n        }\n\n        public Vector3D times(double s) {\n            return new Vector3D(s * x, s * y, s * z);\n        }\n\n        public double mod() {\n            return Math.sqrt(x * x + y * y + z * z);\n        }\n    }\n\n    private static final Vector3D origin = new Vector3D(0, 0, 0);\n\n    private static class NBody {\n        private double gc;\n        private int bodies;\n        public final int timeSteps;\n        private double[] masses;\n        private Vector3D[] positions;\n        private Vector3D[] velocities;\n        private Vector3D[] accelerations;\n\n        public NBody(String fileName) throws IOException {\n            Path path = Paths.get(fileName);\n            List<String> lines = Files.readAllLines(path);\n\n            String[] gbt = lines.get(0).split(\" \");\n            gc = Double.parseDouble(gbt[0]);\n            bodies = Integer.parseInt(gbt[1]);\n            timeSteps = Integer.parseInt(gbt[2]);\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            Arrays.fill(positions, origin);\n            velocities = new Vector3D[bodies];\n            Arrays.fill(velocities, origin);\n            accelerations = new Vector3D[bodies];\n            Arrays.fill(accelerations, origin);\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = Double.parseDouble(lines.get(i * 3 + 1));\n                positions[i] = decompose(lines.get(i * 3 + 2));\n                velocities[i] = decompose(lines.get(i * 3 + 3));\n            }\n            System.out.printf(\"Contents of %s\\n\", fileName);\n            for (String line : lines) {\n                System.out.println(line);\n            }\n            System.out.println();\n            System.out.print(\"Body  \u00a0:      x          y          z    |\");\n            System.out.println(\"     vx         vy         vz\");\n        }\n\n        private Vector3D decompose(String line) {\n            String[] xyz = line.split(\" \");\n            double x = Double.parseDouble(xyz[0]);\n            double y = Double.parseDouble(xyz[1]);\n            double z = Double.parseDouble(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void resolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].x == positions[j].x\n                        && positions[i].y == positions[j].y\n                        && positions[i].z == positions[j].z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        private void computeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = origin;\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.pow((positions[i].minus(positions[j])).mod(), 3);\n                        accelerations[i] = accelerations[i].plus(positions[j].minus(positions[i]).times(temp));\n                    }\n                }\n            }\n        }\n\n        private void computeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i].plus(accelerations[i]);\n            }\n        }\n\n        private void computePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i].plus(velocities[i]).plus(accelerations[i].times(0.5));\n            }\n        }\n\n        public void simulate() {\n            computeAccelerations();\n            computePositions();\n            computeVelocities();\n            resolveCollisions();\n        }\n\n        public void printResults() {\n            String fmt = \"Body %d\u00a0:\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f |\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f\\n\";\n            for (int i = 0; i < bodies; ++i) {\n                System.out.printf(\n                    fmt,\n                    i + 1,\n                    positions[i].x, positions[i].y, positions[i].z,\n                    velocities[i].x, velocities[i].y, velocities[i].z\n                );\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        String filename = \"nbody.txt\";\n        NBody nb = new NBody(filename);\n        for (int i = 0; i < nb.timeSteps; ++i) {\n            System.out.printf(\"\\nCycle %s\\n\", i + 1);\n            nb.simulate();\n            nb.printResults();\n        }\n    }\n}\n"}
{"id": 392599, "name": "Zumkeller numbers", "source": "Translate Swift to Java: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isZumkeller: Bool {\n    let divs = factors(sorted: false)\n    let sum = divs.reduce(0, +)\n\n    guard sum & 1 != 1 else {\n      return false\n    }\n\n    guard self & 1 != 1 else {\n      let abundance = sum - 2*self\n\n      return abundance > 0 && abundance & 1 == 0\n    }\n\n    return isPartSum(divs: divs[...], sum: sum / 2)\n  }\n\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@usableFromInline\nfunc isPartSum<T: BinaryInteger>(divs: ArraySlice<T>, sum: T) -> Bool {\n  guard sum != 0 else {\n    return true\n  }\n\n  guard !divs.isEmpty else {\n    return false\n  }\n\n  let last = divs.last!\n\n  if last > sum {\n    return isPartSum(divs: divs.dropLast(), sum: sum)\n  }\n\n  return isPartSum(divs: divs.dropLast(), sum: sum) || isPartSum(divs: divs.dropLast(), sum: sum - last)\n}\n\nlet zums = (2...).lazy.filter({ $0.isZumkeller })\nlet oddZums = zums.filter({ $0 & 1 == 1 })\nlet oddZumsWithout5 = oddZums.filter({ String($0).last! != \"5\" })\n\nprint(\"First 220 zumkeller numbers are \\(Array(zums.prefix(220)))\")\nprint(\"First 40 odd zumkeller numbers are \\(Array(oddZums.prefix(40)))\")\nprint(\"First 40 odd zumkeller numbers that don't end in a 5 are: \\(Array(oddZumsWithout5.prefix(40)))\")\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ZumkellerNumbers {\n\n    public static void main(String[] args) {\n        int n = 1;\n        System.out.printf(\"First 220 Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 220 ; n += 1 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%3d  \", n);\n                if ( count % 20 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%6d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers that do not end in a 5:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( n % 5 != 0 && isZumkeller(n) ) {\n                System.out.printf(\"%8d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n\n    }\n    \n    private static boolean isZumkeller(int n) {\n        \n        if ( n % 18 == 6 || n % 18 == 12 ) {\n            return true;\n        }\n        \n        List<Integer> divisors = getDivisors(n);        \n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        \n        \n        if ( divisorSum % 2 == 1 ) {\n            return false;\n        }\n        \n        \n        int abundance = divisorSum - 2 * n;\n        if ( n % 2 == 1 && abundance > 0 && abundance % 2 == 0 ) {\n            return true;\n        }\n        \n        Collections.sort(divisors);\n        int j = divisors.size() - 1;\n        int sum = divisorSum/2;\n        \n        \n        if ( divisors.get(j) > sum ) {\n            return false;\n        }\n        \n        return canPartition(j, divisors, sum, new int[2]);\n    }\n    \n    private static boolean canPartition(int j, List<Integer> divisors, int sum, int[] buckets) {\n        if ( j < 0 ) {\n            return true;\n        }\n        for ( int i = 0 ; i < 2 ; i++ ) {\n            if ( buckets[i] + divisors.get(j) <= sum ) {\n                buckets[i] += divisors.get(j);\n                if ( canPartition(j-1, divisors, sum, buckets) ) {\n                    return true;\n                }\n                buckets[i] -= divisors.get(j);\n            }\n            if( buckets[i] == 0 ) {\n                break;\n            }\n        }\n        return false;\n    }\n    \n    private static final List<Integer> getDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 392600, "name": "Commatizing numbers", "source": "Translate Swift to Java: import Foundation\n\nextension String {\n  private static let commaReg = try! NSRegularExpression(pattern: \"(\\\\.[0-9]+|[1-9]([0-9]+)?(\\\\.[0-9]+)?)\")\n\n  public func commatize(start: Int = 0, period: Int = 3, separator: String = \",\") -> String {\n    guard separator != \"\" else {\n      return self\n    }\n\n    let sep = Array(separator)\n    let startIdx = index(startIndex, offsetBy: start)\n    let matches = String.commaReg.matches(in: self, range: NSRange(startIdx..., in: self))\n\n    guard !matches.isEmpty else {\n      return self\n    }\n\n    let fullMatch = String(self[Range(matches.first!.range(at: 0), in: self)!])\n    let splits = fullMatch.components(separatedBy: \".\")\n    var ip = splits[0]\n\n    if ip.count > period {\n      var builder = Array(ip.reversed())\n\n      for i in stride(from: (ip.count - 1) / period * period, through: period, by: -period) {\n        builder.insert(contentsOf: sep, at: i)\n      }\n\n      ip = String(builder.reversed())\n    }\n\n    if fullMatch.contains(\".\") {\n      var dp = splits[1]\n\n      if dp.count > period {\n        var builder = Array(dp)\n\n        for i in stride(from: (dp.count - 1) / period * period, through: period, by: -period) {\n          builder.insert(contentsOf: sep, at: i)\n        }\n\n        dp = String(builder)\n      }\n\n      ip += \".\" + dp\n    }\n\n    return String(prefix(start)) + String(dropFirst(start)).replacingOccurrences(of: fullMatch, with: ip)\n  }\n}\n\nlet tests = [\n  \"123456789.123456789\",\n  \".123456789\",\n  \"57256.1D-4\",\n  \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n  \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n  \"-in Aus$+1411.8millions\",\n  \"===US$0017440 millions=== (in 2000 dollars)\",\n  \"123.e8000 is pretty big.\",\n  \"The land area of the earth is 57268900(29% of the surface) square miles.\",\n  \"Ain't no numbers in this here words, nohow, no way, Jose.\",\n  \"James was never known as 0000000007\",\n  \"Arthur Eddington wrote: I believe there are \" +\n      \"15747724136275002577605653961181555468044717914527116709366231425076185631031296\" +\n      \" protons in the universe.\",\n  \"   $-140000\u00b1100 millions.\",\n  \"6/9/1946 was a good year for some.\"\n]\n\nprint(tests[0].commatize(period: 2, separator: \"*\"))\nprint(tests[1].commatize(period: 3, separator: \"-\"))\nprint(tests[2].commatize(period: 4, separator: \"__\"))\nprint(tests[3].commatize(period: 5, separator: \" \"))\nprint(tests[4].commatize(separator: \".\"))\n\nfor testCase in tests.dropFirst(5) {\n  print(testCase.commatize())\n}\n", "target": "import java.io.File;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class CommatizingNumbers {\n\n    public static void main(String[] args) throws Exception {\n        commatize(\"pi=3.14159265358979323846264338327950288419716939937510582\"\n                + \"097494459231\", 6, 5, \" \");\n\n        commatize(\"The author has two Z$100000000000000 Zimbabwe notes (100 \"\n                + \"trillion).\", 0, 3, \".\");\n\n        try (Scanner sc = new Scanner(new File(\"input.txt\"))) {\n            while(sc.hasNext())\n                commatize(sc.nextLine());\n        }\n    }\n\n    static void commatize(String s) {\n        commatize(s, 0, 3, \",\");\n    }\n\n    static void commatize(String s, int start, int step, String ins) {\n        if (start < 0 || start > s.length() || step < 1 || step > s.length())\n            return;\n\n        Matcher m = Pattern.compile(\"([1-9][0-9]*)\").matcher(s.substring(start));\n        StringBuffer result = new StringBuffer(s.substring(0, start));\n\n        if (m.find()) {\n            StringBuilder sb = new StringBuilder(m.group(1)).reverse();\n            for (int i = step; i < sb.length(); i += step)\n                sb.insert(i++, ins);\n            m.appendReplacement(result, sb.reverse().toString());\n        }\n\n        System.out.println(m.appendTail(result));\n    }\n}\n"}
{"id": 392601, "name": "Kosaraju", "source": "Translate Swift to Java: func kosaraju(graph: [[Int]]) -> [Int] {\n  let size = graph.count\n  var x = size\n  var vis = [Bool](repeating: false, count: size)\n  var l = [Int](repeating: 0, count: size)\n  var c = [Int](repeating: 0, count: size)\n  var t = [[Int]](repeating: [], count: size)\n\n  func visit(_ u: Int) {\n    guard !vis[u] else {\n      return\n    }\n\n    vis[u] = true\n\n    for v in graph[u] {\n      visit(v)\n      t[v].append(u)\n    }\n\n    x -= 1\n    l[x] = u\n  }\n\n  for u in 0..<graph.count {\n    visit(u)\n  }\n\n  func assign(_ u: Int, root: Int) {\n    guard vis[u] else {\n      return\n    }\n\n    vis[u] = false\n    c[u] = root\n\n    for v in t[u] {\n      assign(v, root: root)\n    }\n  }\n\n  for u in l {\n    assign(u, root: u)\n  }\n\n  return c\n}\n\nlet graph = [\n  [1],\n  [2],\n  [0],\n  [1, 2, 4],\n  [3, 5],\n  [2, 6],\n  [5],\n  [4, 6, 7]\n]\n\nprint(kosaraju(graph: graph))\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.IntConsumer;\nimport java.util.stream.Collectors;\n\npublic class Kosaraju {\n    static class Recursive<I> {\n        I func;\n    }\n\n    private static List<Integer> kosaraju(List<List<Integer>> g) {\n        \n        int size = g.size();\n        boolean[] vis = new boolean[size];\n        int[] l = new int[size];\n        AtomicInteger x = new AtomicInteger(size);\n\n        List<List<Integer>> t = new ArrayList<>();\n        for (int i = 0; i < size; ++i) {\n            t.add(new ArrayList<>());\n        }\n\n        Recursive<IntConsumer> visit = new Recursive<>();\n        visit.func = (int u) -> {\n            if (!vis[u]) {\n                vis[u] = true;\n                for (Integer v : g.get(u)) {\n                    visit.func.accept(v);\n                    t.get(v).add(u);\n                }\n                int xval = x.decrementAndGet();\n                l[xval] = u;\n            }\n        };\n\n        \n        for (int i = 0; i < size; ++i) {\n            visit.func.accept(i);\n        }\n        int[] c = new int[size];\n\n        Recursive<BiConsumer<Integer, Integer>> assign = new Recursive<>();\n        assign.func = (Integer u, Integer root) -> {\n            if (vis[u]) {  \n                vis[u] = false;\n                c[u] = root;\n                for (Integer v : t.get(u)) {\n                    assign.func.accept(v, root);\n                }\n            }\n        };\n\n        \n        for (int u : l) {\n            assign.func.accept(u, u);\n        }\n\n        return Arrays.stream(c).boxed().collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < 8; ++i) {\n            g.add(new ArrayList<>());\n        }\n        g.get(0).add(1);\n        g.get(1).add(2);\n        g.get(2).add(0);\n        g.get(3).add(1);\n        g.get(3).add(2);\n        g.get(3).add(4);\n        g.get(4).add(3);\n        g.get(4).add(5);\n        g.get(5).add(2);\n        g.get(5).add(6);\n        g.get(6).add(5);\n        g.get(7).add(4);\n        g.get(7).add(6);\n        g.get(7).add(7);\n\n        List<Integer> output = kosaraju(g);\n        System.out.println(output);\n    }\n}\n"}
{"id": 392602, "name": "Markov chain text generator", "source": "Translate Swift to Java: import Foundation\n\nfunc makeRule(input: String, keyLength: Int) -> [String: [String]] {\n  let words = input.components(separatedBy: \" \")\n  var rules = [String: [String]]()\n  var i = keyLength\n  \n  for word in words[i...] {\n    let key = words[i-keyLength..<i].joined(separator: \" \")\n    \n    rules[key, default: []].append(word)\n    \n    i += 1\n  }\n  \n  return rules\n}\n\nfunc makeString(rule: [String: [String]], length: Int) -> String {\n  var oldWords = rule.keys.randomElement()!.components(separatedBy: \" \")\n  var string = oldWords.joined(separator: \" \") + \" \"\n  \n  for _ in 0..<length {\n    let key = oldWords.joined(separator: \" \")\n    guard let newWord = rule[key]?.randomElement() else { return string }\n    \n    string += newWord + \" \"\n    \n    for ii in 0..<oldWords.count {\n      oldWords[ii] = oldWords[(ii + 1) % oldWords.count]\n    }\n    \n    oldWords[oldWords.index(before: oldWords.endIndex)] = newWord\n  }\n  \n  return string\n}\n\nlet inputLoc = CommandLine.arguments.dropFirst().first!\nlet input = FileManager.default.contents(atPath: inputLoc)!\nlet inputStr = String(data: input, encoding: .utf8)!\nlet rule = makeRule(input: inputStr, keyLength: 3)\nlet str = makeString(rule: rule, length: 300)\n\nprint(str)\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Random;\n\npublic class MarkovChain {\n    private static Random r = new Random();\n\n    private static String markov(String filePath, int keySize, int outputSize) throws IOException {\n        if (keySize < 1) throw new IllegalArgumentException(\"Key size can't be less than 1\");\n        Path path = Paths.get(filePath);\n        byte[] bytes = Files.readAllBytes(path);\n        String[] words = new String(bytes).trim().split(\" \");\n        if (outputSize < keySize || outputSize >= words.length) {\n            throw new IllegalArgumentException(\"Output size is out of range\");\n        }\n        Map<String, List<String>> dict = new HashMap<>();\n\n        for (int i = 0; i < (words.length - keySize); ++i) {\n            StringBuilder key = new StringBuilder(words[i]);\n            for (int j = i + 1; j < i + keySize; ++j) {\n                key.append(' ').append(words[j]);\n            }\n            String value = (i + keySize < words.length) ? words[i + keySize] : \"\";\n            if (!dict.containsKey(key.toString())) {\n                ArrayList<String> list = new ArrayList<>();\n                list.add(value);\n                dict.put(key.toString(), list);\n            } else {\n                dict.get(key.toString()).add(value);\n            }\n        }\n\n        int n = 0;\n        int rn = r.nextInt(dict.size());\n        String prefix = (String) dict.keySet().toArray()[rn];\n        List<String> output = new ArrayList<>(Arrays.asList(prefix.split(\" \")));\n\n        while (true) {\n            List<String> suffix = dict.get(prefix);\n            if (suffix.size() == 1) {\n                if (Objects.equals(suffix.get(0), \"\")) return output.stream().reduce(\"\", (a, b) -> a + \" \" + b);\n                output.add(suffix.get(0));\n            } else {\n                rn = r.nextInt(suffix.size());\n                output.add(suffix.get(rn));\n            }\n            if (output.size() >= outputSize) return output.stream().limit(outputSize).reduce(\"\", (a, b) -> a + \" \" + b);\n            n++;\n            prefix = output.stream().skip(n).limit(keySize).reduce(\"\", (a, b) -> a + \" \" + b).trim();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(markov(\"alice_oz.txt\", 3, 200));\n    }\n}\n"}
{"id": 392603, "name": "Word break problem", "source": "Translate Swift to Java: infix operator ??= : AssignmentPrecedence\n\n@inlinable\npublic func ??= <T>(lhs: inout T?, rhs: T?) {\n  lhs = lhs ?? rhs\n}\n\nprivate func createString(_ from: String, _ v: [Int?]) -> String {\n  var idx = from.count\n  var sliceVec = [Substring]()\n\n  while let prev = v[idx] {\n    let s = from.index(from.startIndex, offsetBy: prev)\n    let e = from.index(from.startIndex, offsetBy: idx)\n    \n    sliceVec.append(from[s..<e])\n    idx = prev\n  }\n\n  return sliceVec.reversed().joined(separator: \" \")\n}\n\npublic func wordBreak(str: String, dict: Set<String>) -> String? {\n  let size = str.count + 1\n  var possible = [Int?](repeating: nil, count: size)\n\n  func checkWord(i: Int, j: Int) -> Int? {\n    let s = str.index(str.startIndex, offsetBy: i)\n    let e = str.index(str.startIndex, offsetBy: j)\n\n    return dict.contains(String(str[s..<e])) ? i : nil\n  }\n\n  for i in 1..<size {\n    possible[i] ??= checkWord(i: 0, j: i)\n\n    guard possible[i] != nil else {\n      continue\n    }\n\n    for j in i+1..<size {\n      possible[j] ??= checkWord(i: i, j: j)\n    }\n\n    if possible[str.count] != nil {\n      return createString(str, possible)\n    }\n  }\n\n  return nil\n}\n\nlet words = [\n  \"a\",\n  \"bc\",\n  \"abc\",\n  \"cd\",\n  \"b\"\n] as Set\n\nlet testCases = [\n  \"abcd\",\n  \"abbc\",\n  \"abcbcd\",\n  \"acdbc\",\n  \"abcdd\"\n]\n\nfor test in testCases {\n  print(\"\\(test):\")\n  print(\"  \\(wordBreak(str: test, dict: words) ?? \"did not parse with given words\")\")\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class WordBreak {\n\n    public static void main(String[] args) {\n        List<String> dict = Arrays.asList(\"a\", \"aa\", \"b\", \"ab\", \"aab\");\n        for ( String testString : Arrays.asList(\"aab\", \"aa b\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n        dict = Arrays.asList(\"abc\", \"a\", \"ac\", \"b\", \"c\", \"cb\", \"d\");\n        for ( String testString : Arrays.asList(\"abcd\", \"abbc\", \"abcbcd\", \"acdbc\", \"abcdd\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static List<List<String>> wordBreak(String s, List<String> dictionary) {\n        List<List<String>> matches = new ArrayList<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(new Node(s));\n        while ( ! queue.isEmpty() ) {\n            Node node = queue.remove();\n            \n            if ( node.val.length() == 0 ) {\n                matches.add(node.parsed);\n            }\n            else {\n                for ( String word : dictionary ) {\n                    \n                    if ( node.val.startsWith(word) ) {\n                        String valNew = node.val.substring(word.length(), node.val.length());\n                        List<String> parsedNew = new ArrayList<>();\n                        parsedNew.addAll(node.parsed);\n                        parsedNew.add(word);\n                        queue.add(new Node(valNew, parsedNew));\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    \n    private static class Node {\n        private String val;  \n        private List<String> parsed;  \n        public Node(String initial) {\n            val = initial;\n            parsed = new ArrayList<>();\n        }\n        public Node(String s, List<String> p) {\n            val = s;\n            parsed = p;\n        }\n    }\n\n}\n"}
{"id": 392604, "name": "Partition function P", "source": "Translate Swift to Java: import BigInt \n\nfunc partitions(n: Int) -> BigInt {\n  var p = [BigInt(1)]\n\n  for i in 1...n {\n    var num = BigInt(0)\n    var k = 1\n\n    while true {\n      var j = (k * (3 * k - 1)) / 2\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      j += k\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      k += 1\n    }\n\n    p.append(num)\n  }\n\n  return p[n]\n}\n\nprint(\"partitions(6666) = \\(partitions(n: 6666))\")\n", "target": "import java.math.BigInteger;\n\npublic class PartitionFunction {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        BigInteger result = partitions(6666);\n        long end = System.currentTimeMillis();\n        System.out.println(\"P(6666) = \" + result);\n        System.out.printf(\"elapsed time: %d milliseconds\\n\", end - start);\n    }\n\n    private static BigInteger partitions(int n) {\n        BigInteger[] p = new BigInteger[n + 1];\n        p[0] = BigInteger.ONE;\n        for (int i = 1; i <= n; ++i) {\n            p[i] = BigInteger.ZERO;\n            for (int k = 1; ; ++k) {\n                int j = (k * (3 * k - 1))/2;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n                j += k;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n            }\n        }\n        return p[n];\n    }\n}\n"}
{"id": 392605, "name": "Legendre prime counting function", "source": "Translate Swift to Java: import Foundation\n\nextension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nfunc eratosthenes(limit: Int) -> [Int] {\n  guard limit >= 3 else {\n    return limit < 2 ? [] : [2]\n  }\n\n  let ndxLimit = (limit - 3) / 2 + 1\n  let bufSize = ((limit - 3) / 2) / 32 + 1\n  let sqrtNdxLimit = (Int(Double(limit).squareRoot()) - 3) / 2 + 1\n  var cmpsts = Array(repeating: 0, count: bufSize)\n\n  for ndx in 0..<sqrtNdxLimit where (cmpsts[ndx >> 5] & (1 << (ndx & 31))) == 0 {\n    let p = ndx + ndx + 3\n    var cullPos = (p * p - 3) / 2\n\n    while cullPos < ndxLimit {\n      cmpsts[cullPos >> 5] |= 1 << (cullPos & 31)\n\n      cullPos += p\n    }\n  }\n\n  return (-1..<ndxLimit).compactMap({i -> Int? in\n    if i < 0 {\n      return 2\n    } else {\n      if cmpsts[i >> 5] & (1 << (i & 31)) == 0 {\n        return .some(i + i + 3)\n      } else {\n        return nil\n      }\n    }\n  })\n}\n\nlet primes = eratosthenes(limit: 1_000_000_000)\n\nfunc \u03c6(_ x: Int, _ a: Int) -> Int {\n  struct Cache {\n    static var cache = [String: Int]()\n  }\n\n  guard a != 0 else {\n    return x\n  }\n\n  guard Cache.cache[\"\\(x),\\(a)\"] == nil else {\n    return Cache.cache[\"\\(x),\\(a)\"]!\n  }\n\n  Cache.cache[\"\\(x),\\(a)\"] = \u03c6(x, a - 1) - \u03c6(x / primes[a - 1], a - 1)\n\n  return Cache.cache[\"\\(x),\\(a)\"]!\n}\n\nfunc \u03c0(n: Int) -> Int {\n  guard n > 2 else {\n    return 0\n  }\n\n  let a = \u03c0(n: Int(Double(n).squareRoot()))\n\n  return \u03c6(n, a) + a - 1\n}\n\nfor i in 0..<10 {\n  let n = 10.power(i)\n\n  print(\"\u03c0(10^\\(i)) = \\(\u03c0(n: n))\")\n}\n", "target": "import java.util.*;\n\npublic class LegendrePrimeCounter {\n    public static void main(String[] args) {\n        LegendrePrimeCounter counter = new LegendrePrimeCounter(1000000000);\n        for (int i = 0, n = 1; i < 10; ++i, n *= 10)\n            System.out.printf(\"10^%d\\t%d\\n\", i, counter.primeCount((n)));\n    }\n\n    private List<Integer> primes;\n\n    public LegendrePrimeCounter(int limit) {\n        primes = generatePrimes((int)Math.sqrt((double)limit));\n    }\n\n    public int primeCount(int n) {\n        if (n < 2)\n            return 0;\n        int a = primeCount((int)Math.sqrt((double)n));\n        return phi(n, a) + a - 1;\n    }\n\n    private int phi(int x, int a) {\n        if (a == 0)\n            return x;\n        if (a == 1)\n            return x - (x >> 1);\n        int pa = primes.get(a - 1);\n        if (x <= pa)\n            return 1;\n        return phi(x, a - 1) - phi(x / pa, a - 1);\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 392606, "name": "Permuted multiples", "source": "Translate Swift to Java: func getDigits(_ num: Int) -> Array<Int> {\n    var n = num\n    var digits = Array(repeating: 0, count: 10)\n    while true {\n        digits[n % 10] += 1\n        n /= 10\n        if n == 0 {\n            break\n        }\n    }\n    return digits\n}\n\n\nfunc sameDigits(_ n: Int) -> Bool {\n    let digits = getDigits(n)\n    for i in 2...6 {\n        if digits != getDigits(i * n) {\n            return false\n        }\n    }\n    return true\n}\n\nvar p = 100\nloop: while true {\n    for n in stride(from: p + 2, through: (p * 10) / 6, by: 3) {\n        if sameDigits(n) {\n            print(\" n = \\(n)\")\n            for i in 2...6 {\n                print(\"\\(i)n = \\(i * n)\")\n            }\n            break loop\n        }\n    }\n    p *= 10\n}\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 392607, "name": "Permuted multiples", "source": "Translate Swift to Java: func getDigits(_ num: Int) -> Array<Int> {\n    var n = num\n    var digits = Array(repeating: 0, count: 10)\n    while true {\n        digits[n % 10] += 1\n        n /= 10\n        if n == 0 {\n            break\n        }\n    }\n    return digits\n}\n\n\nfunc sameDigits(_ n: Int) -> Bool {\n    let digits = getDigits(n)\n    for i in 2...6 {\n        if digits != getDigits(i * n) {\n            return false\n        }\n    }\n    return true\n}\n\nvar p = 100\nloop: while true {\n    for n in stride(from: p + 2, through: (p * 10) / 6, by: 3) {\n        if sameDigits(n) {\n            print(\" n = \\(n)\")\n            for i in 2...6 {\n                print(\"\\(i)n = \\(i * n)\")\n            }\n            break loop\n        }\n    }\n    p *= 10\n}\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 392608, "name": "Prime triangle", "source": "Translate Swift to Java: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    guard n > 0 && n < 64 else {\n        return false\n    }\n    return ((UInt64(1) << n) & 0x28208a20a08a28ac) != 0\n}\n\nfunc primeTriangleRow(_ a: inout [Int], start: Int, length: Int) -> Bool {\n    if length == 2 {\n        return isPrime(a[start] + a[start + 1])\n    }\n    for i in stride(from: 1, to: length - 1, by: 2) {\n        let index = start + i\n        if isPrime(a[start] + a[index]) {\n            a.swapAt(index, start + 1)\n            if primeTriangleRow(&a, start: start + 1, length: length - 1) {\n                return true\n            }\n            a.swapAt(index, start + 1)\n        }\n    }\n    return false\n}\n\nfunc primeTriangleCount(_ a: inout [Int], start: Int, length: Int) -> Int {\n    var count = 0\n    if length == 2 {\n        if isPrime(a[start] + a[start + 1]) {\n            count += 1\n        }\n    } else {\n        for i in stride(from: 1, to: length - 1, by: 2) {\n            let index = start + i\n            if isPrime(a[start] + a[index]) {\n                a.swapAt(index, start + 1)\n                count += primeTriangleCount(&a, start: start + 1, length: length - 1)\n                a.swapAt(index, start + 1)\n            }\n        }\n    }\n    return count\n}\n\nfunc printRow(_ a: [Int]) {\n    if a.count == 0 {\n        return\n    }\n    print(String(format: \"%2d\", a[0]), terminator: \"\")\n    for x in a[1...] {\n        print(String(format: \" %2d\", x), terminator: \"\")\n    }\n    print()\n}\n\nlet startTime = CFAbsoluteTimeGetCurrent()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if primeTriangleRow(&a, start: 0, length: n) {\n        printRow(a)\n    }\n}\nprint()\n\nfor n in 2...20 {\n    var a = Array(1...n)\n    if n > 2 {\n        print(\" \", terminator: \"\")\n    }\n    print(\"\\(primeTriangleCount(&a, start: 0, length: n))\", terminator: \"\")\n}\nprint()\n\nlet endTime = CFAbsoluteTimeGetCurrent()\nprint(\"\\nElapsed time: \\(endTime - startTime) seconds\")\n", "target": "public class PrimeTriangle {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (findRow(a, 0, i))\n                printRow(a);                \n        }\n        System.out.println();\n        StringBuilder s = new StringBuilder();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (i > 2)\n                s.append(\" \");\n            s.append(countRows(a, 0, i));\n        }\n        System.out.println(s);\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"\\nElapsed time: %d milliseconds\\n\", finish - start);\n    }\n\n    private static void printRow(int[] a) {\n        for (int i = 0; i < a.length; ++i) {\n            if (i != 0)\n                System.out.print(\" \");\n            System.out.printf(\"%2d\", a[i]);\n        }\n        System.out.println();\n    }\n\n    private static boolean findRow(int[] a, int start, int length) {\n        if (length == 2)\n            return isPrime(a[start] + a[start + 1]);\n        for (int i = 1; i + 1 < length; i += 2) {\n            if (isPrime(a[start] + a[start + i])) {\n                swap(a, start + i, start + 1);\n                if (findRow(a, start + 1, length - 1))\n                    return true;\n                swap(a, start + i, start + 1);\n            }\n        }\n        return false;\n    }\n\n    private static int countRows(int[] a, int start, int length) {\n        int count = 0;\n        if (length == 2) {\n            if (isPrime(a[start] + a[start + 1]))\n                ++count;\n        } else {\n            for (int i = 1; i + 1 < length; i += 2) {\n                if (isPrime(a[start] + a[start + i])) {\n                    swap(a, start + i, start + 1);\n                    count += countRows(a, start + 1, length - 1);\n                    swap(a, start + i, start + 1);\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private static boolean isPrime(int n) {\n        return ((1L << n) & 0x28208a20a08a28acL) != 0;\n    }\n}\n"}
{"id": 392609, "name": "Word ladder", "source": "Translate Swift to Java: import Foundation\n\nfunc oneAway(string1: [Character], string2: [Character]) -> Bool {\n    if string1.count != string2.count {\n        return false\n    }\n    var result = false\n    var i = 0\n    while i < string1.count {\n        if string1[i] != string2[i] {\n            if result {\n                return false\n            }\n            result = true\n        }\n        i += 1\n    }\n    return result\n}\n\nfunc wordLadder(words: [[Character]], from: String, to: String) {\n    let fromCh = Array(from)\n    let toCh = Array(to)\n    var poss = words.filter{$0.count == fromCh.count}\n    var queue: [[[Character]]] = [[fromCh]]\n    while !queue.isEmpty {\n        var curr = queue[0]\n        let last = curr[curr.count - 1]\n        queue.removeFirst()\n        let next = poss.filter{oneAway(string1: $0, string2: last)}\n        if next.contains(toCh) {\n            curr.append(toCh)\n            print(curr.map{String($0)}.joined(separator: \" -> \"))\n            return\n        }\n        poss.removeAll(where: {next.contains($0)})\n        for str in next {\n            var temp = curr\n            temp.append(str)\n            queue.append(temp)\n        }\n    }\n    print(\"\\(from) into \\(to) cannot be done.\")\n}\n\ndo {\n    let words = try String(contentsOfFile: \"unixdict.txt\", encoding: String.Encoding.ascii)\n        .components(separatedBy: \"\\n\")\n        .filter{!$0.isEmpty}\n        .map{Array($0)}\n    wordLadder(words: words, from: \"man\", to: \"boy\")\n    wordLadder(words: words, from: \"girl\", to: \"lady\")\n    wordLadder(words: words, from: \"john\", to: \"jane\")\n    wordLadder(words: words, from: \"child\", to: \"adult\")\n    wordLadder(words: words, from: \"cat\", to: \"dog\")\n    wordLadder(words: words, from: \"lead\", to: \"gold\")\n    wordLadder(words: words, from: \"white\", to: \"black\")\n    wordLadder(words: words, from: \"bubble\", to: \"tickle\")\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class WordLadder {\n    private static int distance(String s1, String s2) {\n        assert s1.length() == s2.length();\n        return (int) IntStream.range(0, s1.length())\n            .filter(i -> s1.charAt(i) != s2.charAt(i))\n            .count();\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw) {\n        wordLadder(words, fw, tw, 8);\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw, int limit) {\n        if (fw.length() != tw.length()) {\n            throw new IllegalArgumentException(\"From word and to word must have the same length\");\n        }\n\n        Set<String> ws = words.get(fw.length());\n        if (ws.contains(fw)) {\n            List<String> primeList = new ArrayList<>();\n            primeList.add(fw);\n\n            PriorityQueue<List<String>> queue = new PriorityQueue<>((chain1, chain2) -> {\n                int cmp1 = Integer.compare(chain1.size(), chain2.size());\n                if (cmp1 == 0) {\n                    String last1 = chain1.get(chain1.size() - 1);\n                    int d1 = distance(last1, tw);\n\n                    String last2 = chain2.get(chain2.size() - 1);\n                    int d2 = distance(last2, tw);\n\n                    return Integer.compare(d1, d2);\n                }\n                return cmp1;\n            });\n            queue.add(primeList);\n\n            while (queue.size() > 0) {\n                List<String> curr = queue.remove();\n                if (curr.size() > limit) {\n                    continue;\n                }\n\n                String last = curr.get(curr.size() - 1);\n                for (String word : ws) {\n                    if (distance(last, word) == 1) {\n                        if (word.equals(tw)) {\n                            curr.add(word);\n                            System.out.println(String.join(\" -> \", curr));\n                            return;\n                        }\n\n                        if (!curr.contains(word)) {\n                            List<String> cp = new ArrayList<>(curr);\n                            cp.add(word);\n                            queue.add(cp);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.err.printf(\"Cannot turn `%s` into `%s`%n\", fw, tw);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<Integer, Set<String>> words = new HashMap<>();\n        for (String line : Files.readAllLines(Path.of(\"unixdict.txt\"))) {\n            Set<String> wl = words.computeIfAbsent(line.length(), HashSet::new);\n            wl.add(line);\n        }\n\n        wordLadder(words, \"boy\", \"man\");\n        wordLadder(words, \"girl\", \"lady\");\n        wordLadder(words, \"john\", \"jane\");\n        wordLadder(words, \"child\", \"adult\");\n        wordLadder(words, \"cat\", \"dog\");\n        wordLadder(words, \"lead\", \"gold\");\n        wordLadder(words, \"white\", \"black\");\n        wordLadder(words, \"bubble\", \"tickle\", 12);\n    }\n}\n"}
{"id": 392610, "name": "Rhonda numbers", "source": "Translate Swift to Java: func digitProduct(base: Int, num: Int) -> Int {\n    var product = 1\n    var n = num\n    while n != 0 {\n        product *= n % base\n        n /= base\n    }\n    return product\n}\n\nfunc primeFactorSum(_ num: Int) -> Int {\n    var sum = 0\n    var n = num\n    while (n & 1) == 0 {\n        sum += 2\n        n >>= 1\n    }\n    var p = 3\n    while p * p <= n {\n        while n % p == 0 {\n            sum += p\n            n /= p\n        }\n        p += 2\n    }\n    if n > 1 {\n        sum += n\n    }\n    return sum\n}\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isRhonda(base: Int, num: Int) -> Bool {\n    return digitProduct(base: base, num: num) == base * primeFactorSum(num)\n}\n\nlet limit = 15\nfor base in 2...36 {\n    if isPrime(base) {\n        continue\n    }\n    print(\"First \\(limit) Rhonda numbers to base \\(base):\")\n    let numbers = Array((1...).lazy.filter{ isRhonda(base: base, num: $0) }.prefix(limit))\n    print(\"In base 10:\", terminator: \"\")\n    for n in numbers {\n        print(\" \\(n)\", terminator: \"\")\n    }\n    print(\"\\nIn base \\(base):\", terminator: \"\")\n    for n in numbers {\n        print(\" \\(String(n, radix: base))\", terminator: \"\")\n    }\n    print(\"\\n\")\n}\n", "target": "public class RhondaNumbers {\n    public static void main(String[] args) {\n        final int limit = 15;\n        for (int base = 2; base <= 36; ++base) {\n            if (isPrime(base))\n                continue;\n            System.out.printf(\"First %d Rhonda numbers to base %d:\\n\", limit, base);\n            int numbers[] = new int[limit];\n            for (int n = 1, count = 0; count < limit; ++n) {\n                if (isRhonda(base, n))\n                    numbers[count++] = n;\n            }\n            System.out.printf(\"In base 10:\");\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %d\", numbers[i]);\n            System.out.printf(\"\\nIn base %d:\", base);\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %s\", Integer.toString(numbers[i], base));\n            System.out.printf(\"\\n\\n\");\n        }\n    }\n    \n    private static int digitProduct(int base, int n) {\n        int product = 1;\n        for (; n != 0; n /= base)\n            product *= n % base;\n        return product;\n    }\n     \n    private static int primeFactorSum(int n) {\n        int sum = 0;\n        for (; (n & 1) == 0; n >>= 1)\n            sum += 2;\n        for (int p = 3; p * p <= n; p += 2)\n            for (; n % p == 0; n /= p)\n                sum += p;\n        if (n > 1)\n            sum += n;\n        return sum;\n    }\n     \n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n     \n    private static boolean isRhonda(int base, int n) {\n        return digitProduct(base, n) == base * primeFactorSum(n);\n    }\n}\n"}
{"id": 392611, "name": "Minimal steps down to 1", "source": "Translate Swift to Java: func minToOne(divs: [Int], subs: [Int], upTo n: Int) -> ([Int], [[String]]) {\n  var table = Array(repeating: n + 2, count: n + 1)\n  var how = Array(repeating: [\"\"], count: n + 2)\n\n  table[1] = 0\n  how[1] = [\"=\"]\n\n  for t in 1..<n {\n    let thisPlus1 = table[t] + 1\n\n    for div in divs {\n      let dt = div * t\n\n      if dt <= n && thisPlus1 < table[dt] {\n        table[dt] = thisPlus1\n        how[dt] = how[t] + [\"/\\(div)=>  \\(t)\"]\n      }\n    }\n\n    for sub in subs {\n      let st = sub + t\n\n      if st <= n && thisPlus1 < table[st] {\n        table[st] = thisPlus1\n        how[st] = how[t] + [\"-\\(sub)=> \\(t)\"]\n      }\n    }\n  }\n\n  return (table, how.map({ $0.reversed().dropLast() }))\n}\n\nfor (divs, subs) in [([2, 3], [1]), ([2, 3], [2])] {\n  print(\"\\nMINIMUM STEPS TO 1:\")\n  print(\"  Possible divisors:  \\(divs)\")\n  print(\"  Possible decrements: \\(subs)\")\n\n  let (table, hows) = minToOne(divs: divs, subs: subs, upTo: 10)\n\n  for n in 1...10 {\n    print(\"    mintab(  \\(n)) in {  \\(table[n])} by: \", hows[n].joined(separator: \", \"))\n  }\n\n  for upTo in [2_000, 50_000] {\n    print(\"\\n    Those numbers up to \\(upTo) that take the maximum, \\\"minimal steps down to 1\\\":\")\n    let (table, _) = minToOne(divs: divs, subs: subs, upTo: upTo)\n    let max = table.dropFirst().max()!\n    let maxNs = table.enumerated().filter({ $0.element == max })\n\n    print(\n      \"      Taking\", max, \"steps are the \\(maxNs.count) numbers:\",\n      maxNs.map({ String($0.offset) }).joined(separator: \", \")\n    )\n  }\n}\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class MinimalStepsDownToOne {\n\n    public static void main(String[] args) {\n        runTasks(getFunctions1());\n        runTasks(getFunctions2());\n        runTasks(getFunctions3());\n    }\n    \n    private static void runTasks(List<Function> functions) {\n        Map<Integer,List<String>> minPath = getInitialMap(functions, 5);\n\n        \n        int max = 10;\n        populateMap(minPath, functions, max);\n        System.out.printf(\"%nWith functions:  %s%n\", functions);\n        System.out.printf(\"  Minimum steps to 1:%n\");\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int steps = minPath.get(n).size();\n            System.out.printf(\"    %2d: %d step%1s: %s%n\", n, steps, steps == 1 ? \"\" : \"s\", minPath.get(n));\n        }\n        \n        \n        displayMaxMin(minPath, functions, 2000);\n\n        \n        displayMaxMin(minPath, functions, 20000);\n\n        \n        displayMaxMin(minPath, functions, 100000);\n    }\n    \n    private static void displayMaxMin(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        populateMap(minPath, functions, max);\n        List<Integer> maxIntegers = getMaxMin(minPath, max);\n        int maxSteps = maxIntegers.remove(0);\n        int numCount = maxIntegers.size();\n        System.out.printf(\"  There %s %d number%s in the range 1-%d that have maximum 'minimal steps' of %d:%n    %s%n\", numCount == 1 ? \"is\" : \"are\", numCount, numCount == 1 ? \"\" : \"s\", max, maxSteps, maxIntegers);\n        \n    }\n    \n    private static List<Integer> getMaxMin(Map<Integer,List<String>> minPath, int max) {\n        int maxSteps = Integer.MIN_VALUE;\n        List<Integer> maxIntegers = new ArrayList<Integer>();\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int len = minPath.get(n).size();\n            if ( len > maxSteps ) {\n                maxSteps = len;\n                maxIntegers.clear();\n                maxIntegers.add(n);\n            }\n            else if ( len == maxSteps ) {\n                maxIntegers.add(n);\n            }\n        }\n        maxIntegers.add(0, maxSteps);\n        return maxIntegers;\n    }\n\n    private static void populateMap(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        for ( int n = 2 ; n <= max ; n++ ) {\n            if ( minPath.containsKey(n) ) {\n                continue;\n            }\n            Function minFunction = null;\n            int minSteps = Integer.MAX_VALUE;\n            for ( Function f : functions ) {\n                if ( f.actionOk(n) ) {\n                    int result = f.action(n);\n                    int steps = 1 + minPath.get(result).size();\n                    if ( steps < minSteps ) {\n                        minFunction = f;\n                        minSteps = steps;\n                    }\n                }\n            }\n            int result = minFunction.action(n);\n            List<String> path = new ArrayList<String>();\n            path.add(minFunction.toString(n));\n            path.addAll(minPath.get(result));\n            minPath.put(n, path);\n        }\n        \n    }\n\n    private static Map<Integer,List<String>> getInitialMap(List<Function> functions, int max) {\n        Map<Integer,List<String>> minPath = new HashMap<>();\n        for ( int i = 2 ; i <= max ; i++ ) {\n            for ( Function f : functions ) {\n                if ( f.actionOk(i) ) {\n                    int result = f.action(i);\n                    if ( result == 1 ) {\n                        List<String> path = new ArrayList<String>();\n                        path.add(f.toString(i));\n                        minPath.put(i, path);\n                    }\n                }\n            }\n        }\n        return minPath;\n    }\n\n    private static List<Function> getFunctions3() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide2Function());\n        functions.add(new Divide3Function());\n        functions.add(new Subtract2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions2() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract2Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions1() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n    \n    public abstract static class Function {\n        abstract public int action(int n);\n        abstract public boolean actionOk(int n);\n        abstract public String toString(int n);\n    }\n    \n    public static class Divide2Function extends Function {\n        @Override public int action(int n) {\n            return n/2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 2 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/2 -> \" + n/2;\n        }\n        \n        @Override public String toString() {\n            return \"Divisor 2\";\n        }\n        \n    }\n\n    public static class Divide3Function extends Function {\n        @Override public int action(int n) {\n            return n/3;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 3 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/3 -> \" + n/3;\n        }\n\n        @Override public String toString() {\n            return \"Divisor 3\";\n        }\n\n    }\n\n    public static class Subtract1Function extends Function {\n        @Override public int action(int n) {\n            return n-1;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return true;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-1 -> \" + (n-1);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 1\";\n        }\n\n    }\n\n    public static class Subtract2Function extends Function {\n        @Override public int action(int n) {\n            return n-2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n > 2;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-2 -> \" + (n-2);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 2\";\n        }\n\n    }\n\n}\n"}
{"id": 392612, "name": "Railway circuit", "source": "Translate Swift to Java: enum Track: Int, Hashable {\n  case left = -1, straight, right\n}\n\nextension Track: Comparable {\n  static func < (lhs: Track, rhs: Track) -> Bool {\n    return lhs.rawValue < rhs.rawValue\n  }\n}\n\nfunc < (lhs: [Track], rhs: [Track]) -> Bool {\n  for (l, r) in zip(lhs, rhs) where l != r {\n    return l < r\n  }\n\n  return false\n}\n\nfunc normalize(_ tracks: [Track]) -> [Track] {\n  let count = tracks.count\n  var workingTracks = tracks\n  var norm = tracks\n\n  for _ in 0..<count {\n    if workingTracks < norm {\n      norm = workingTracks\n    }\n\n    let temp = workingTracks[0]\n\n    for j in 1..<count {\n      workingTracks[j - 1] = workingTracks[j]\n    }\n\n    workingTracks[count - 1] = temp\n  }\n\n  return norm\n}\n\nfunc fullCircleStraight(tracks: [Track], nStraight: Int) -> Bool {\n  guard nStraight != 0 else {\n    return true\n  }\n\n  guard tracks.filter({ $0 == .straight }).count == nStraight else {\n    return false\n  }\n\n  var straight = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .straight {\n      straight[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { straight[$0] != straight[$0 + 6] }) &&\n    (0...7).contains(where: { straight[$0] != straight[$0 + 4] })\n  )\n}\n\nfunc fullCircleRight(tracks: [Track]) -> Bool {\n  guard tracks.map({ $0.rawValue * 30 }).reduce(0, +) % 360 == 0 else {\n    return false\n  }\n\n  var rightTurns = [Int](repeating: 0, count: 12)\n  var i = 0\n  var idx = 0\n\n  while i < tracks.count && idx >= 0 {\n    if tracks[i] == .right {\n      rightTurns[idx % 12] += 1\n    }\n\n    idx += tracks[i].rawValue\n    i += 1\n  }\n\n  return !((0...5).contains(where: { rightTurns[$0] != rightTurns[$0 + 6] }) &&\n    (0...7).contains(where: { rightTurns[$0] != rightTurns[$0 + 4] })\n  )\n}\n\nfunc circuits(nCurved: Int, nStraight: Int) {\n  var solutions = Set<[Track]>()\n\n  for tracks in getPermutationsGen(nCurved: nCurved, nStraight: nStraight)\n      where fullCircleStraight(tracks: tracks, nStraight: nStraight) && fullCircleRight(tracks: tracks)  {\n    solutions.insert(normalize(tracks))\n  }\n\n  report(solutions: solutions, nCurved: nCurved, nStraight: nStraight)\n}\n\nfunc getPermutationsGen(nCurved: Int, nStraight: Int) -> PermutationsGen {\n  precondition((nCurved + nStraight - 12) % 4 == 0, \"input must be 12 + k * 4\")\n\n  let trackTypes: [Track]\n\n  if nStraight == 0 {\n    trackTypes = [.right, .left]\n  } else if nCurved == 12 {\n    trackTypes = [.right, .straight]\n  } else {\n    trackTypes = [.right, .left, .straight]\n  }\n\n  return PermutationsGen(numPositions: nCurved + nStraight, choices: trackTypes)\n}\n\nfunc report(solutions: Set<[Track]>, nCurved: Int, nStraight: Int) {\n  print(\"\\(solutions.count) solutions for C\\(nCurved),\\(nStraight)\")\n\n  if nCurved <= 20 {\n    for tracks in solutions {\n      for track in tracks {\n        print(track.rawValue, terminator: \" \")\n      }\n\n      print()\n    }\n  }\n}\n\nstruct PermutationsGen: Sequence, IteratorProtocol {\n  private let choices: [Track]\n  private var indices: [Int]\n  private var sequence: [Track]\n  private var carry = 0\n\n  init(numPositions: Int, choices: [Track]) {\n    self.choices = choices\n    self.indices = .init(repeating: 0, count: numPositions)\n    self.sequence = .init(repeating: choices.first!, count: numPositions)\n  }\n\n  mutating func next() -> [Track]? {\n    guard carry != 1 else {\n      return nil\n    }\n\n    carry = 1\n    var i = 1\n\n    while i < indices.count && carry > 0 {\n      indices[i] += carry\n      carry = 0\n\n      if indices[i] == choices.count {\n        carry = 1\n        indices[i] = 0\n      }\n\n      i += 1\n    }\n\n    for j in 0..<indices.count {\n      sequence[j] = choices[indices[j]]\n    }\n\n    return sequence\n  }\n}\n\nfor n in stride(from: 12, through: 32, by: 4) {\n  circuits(nCurved: n, nStraight: 0)\n}\n\ncircuits(nCurved: 12, nStraight: 4)\n", "target": "package railwaycircuit;\n\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.IntStream.range;\n\npublic class RailwayCircuit {\n    final static int RIGHT = 1, LEFT = -1, STRAIGHT = 0;\n\n    static String normalize(int[] tracks) {\n        char[] a = new char[tracks.length];\n        for (int i = 0; i < a.length; i++)\n            a[i] = \"abc\".charAt(tracks[i] + 1);\n\n        \n        String norm = new String(a);\n        for (int i = 0, len = a.length; i < len; i++) {\n\n            String s = new String(a);\n            if (s.compareTo(norm) < 0)\n                norm = s;\n\n            char tmp = a[0];\n            for (int j = 1; j < a.length; j++)\n                a[j - 1] = a[j];\n            a[len - 1] = tmp;\n        }\n        return norm;\n    }\n\n    static boolean fullCircleStraight(int[] tracks, int nStraight) {\n        if (nStraight == 0)\n            return true;\n\n        \n        if (stream(tracks).filter(i -> i == STRAIGHT).count() != nStraight)\n            return false;\n\n        \n        int[] straight = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == STRAIGHT)\n                straight[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> straight[i] != straight[i + 6])\n                && range(0, 8).anyMatch(i -> straight[i] != straight[i + 4]));\n    }\n\n    static boolean fullCircleRight(int[] tracks) {\n\n        \n        if (stream(tracks).map(i -> i * 30).sum() % 360 != 0)\n            return false;\n\n        \n        int[] rTurns = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == RIGHT)\n                rTurns[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> rTurns[i] != rTurns[i + 6])\n                && range(0, 8).anyMatch(i -> rTurns[i] != rTurns[i + 4]));\n    }\n\n    static void circuits(int nCurved, int nStraight) {\n        Map<String, int[]> solutions = new HashMap<>();\n\n        PermutationsGen gen = getPermutationsGen(nCurved, nStraight);\n        while (gen.hasNext()) {\n\n            int[] tracks = gen.next();\n\n            if (!fullCircleStraight(tracks, nStraight))\n                continue;\n\n            if (!fullCircleRight(tracks))\n                continue;\n\n            solutions.put(normalize(tracks), tracks.clone());\n        }\n        report(solutions, nCurved, nStraight);\n    }\n\n    static PermutationsGen getPermutationsGen(int nCurved, int nStraight) {\n        assert (nCurved + nStraight - 12) % 4 == 0 : \"input must be 12 + k * 4\";\n\n        int[] trackTypes = new int[]{RIGHT, LEFT};\n\n        if (nStraight != 0) {\n            if (nCurved == 12)\n                trackTypes = new int[]{RIGHT, STRAIGHT};\n            else\n                trackTypes = new int[]{RIGHT, LEFT, STRAIGHT};\n        }\n\n        return new PermutationsGen(nCurved + nStraight, trackTypes);\n    }\n\n    static void report(Map<String, int[]> sol, int numC, int numS) {\n\n        int size = sol.size();\n        System.out.printf(\"%n%d solution(s) for C%d,%d %n\", size, numC, numS);\n\n        if (size < 10)\n            sol.values().stream().forEach(tracks -> {\n                stream(tracks).forEach(i -> System.out.printf(\"%2d \", i));\n                System.out.println();\n            });\n    }\n\n    public static void main(String[] args) {\n        circuits(12, 0);\n        circuits(16, 0);\n        circuits(20, 0);\n        circuits(24, 0);\n        circuits(12, 4);\n    }\n}\n\nclass PermutationsGen {\n    \n    private int[] indices;\n    private int[] choices;\n    private int[] sequence;\n    private int carry;\n\n    PermutationsGen(int numPositions, int[] choices) {\n        indices = new int[numPositions];\n        sequence = new int[numPositions];\n        this.choices = choices;\n    }\n\n    int[] next() {\n        carry = 1;\n        \n        for (int i = 1; i < indices.length && carry > 0; i++) {\n            indices[i] += carry;\n            carry = 0;\n\n            if (indices[i] == choices.length) {\n                carry = 1;\n                indices[i] = 0;\n            }\n        }\n\n        for (int i = 0; i < indices.length; i++)\n            sequence[i] = choices[indices[i]];\n\n        return sequence;\n    }\n\n    boolean hasNext() {\n        return carry != 1;\n    }\n}\n"}
{"id": 399632, "name": "Angles (geometric), normalization and conversion", "source": "Translate Swift to C#: import Foundation\n\nfunc normalize(_ f: Double, N: Double) -> Double {\n  var a = f\n\n  while a < -N { a += N }\n  while a >= N { a -= N }\n\n  return a\n}\n\nfunc normalizeToDeg(_ f: Double) -> Double {\n  return normalize(f, N: 360)\n}\n\nfunc normalizeToGrad(_ f: Double) -> Double {\n  return normalize(f, N: 400)\n}\n\nfunc normalizeToMil(_ f: Double) -> Double {\n  return normalize(f, N: 6400)\n}\n\nfunc normalizeToRad(_ f: Double) -> Double {\n  return normalize(f, N: 2 * .pi)\n}\n\nfunc d2g(_ f: Double) -> Double { f * 10 / 9 }\nfunc d2m(_ f: Double) -> Double { f * 160 / 9 }\nfunc d2r(_ f: Double) -> Double { f * .pi / 180 }\n\nfunc g2d(_ f: Double) -> Double { f * 9 / 10 }\nfunc g2m(_ f: Double) -> Double { f * 16 }\nfunc g2r(_ f: Double) -> Double { f * .pi / 200 }\n\nfunc m2d(_ f: Double) -> Double { f * 9 / 160 }\nfunc m2g(_ f: Double) -> Double { f / 16 }\nfunc m2r(_ f: Double) -> Double { f * .pi / 3200 }\n\nfunc r2d(_ f: Double) -> Double { f * 180 / .pi }\nfunc r2g(_ f: Double) -> Double { f * 200 / .pi }\nfunc r2m(_ f: Double) -> Double { f * 3200 / .pi }\n\nlet angles = [-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000]\nlet names = [\"Degrees\", \"Gradians\", \"Mils\", \"Radians\"]\nlet fmt = { String(format: \"%.4f\", $0) }\n\nlet normal = [normalizeToDeg, normalizeToGrad, normalizeToMil, normalizeToRad]\nlet convert = [\n  [{ $0 }, d2g, d2m, d2r],\n  [g2d, { $0 }, g2m, g2r],\n  [m2d, m2g, { $0 }, m2r],\n  [r2d, r2g, r2m, { $0 }]\n]\n\nlet ans =\n  angles.map({ angle in\n    (0..<4).map({ ($0, normal[$0](angle)) }).map({\n      (fmt(angle),\n        fmt($0.1),\n        names[$0.0],\n        fmt(convert[$0.0][0]($0.1)),\n        fmt(convert[$0.0][1]($0.1)),\n        fmt(convert[$0.0][2]($0.1)),\n        fmt(convert[$0.0][3]($0.1))\n      )\n    })\n  })\n\nprint(\"angle\", \"normalized\", \"unit\", \"degrees\", \"grads\", \"mils\", \"radians\")\n\nfor res in ans {\n  for unit in res {\n    print(unit)\n  }\n\n  print()\n}\n", "target": "using System;\n\npublic static class Angles\n{\n    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);\n\n    public static void Print(params double[] angles) {\n        string[] names = { \"Degrees\", \"Gradians\", \"Mils\", \"Radians\" };\n        Func<double, double> rnd = a => Math.Round(a, 4);\n        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };\n\n        Func<double, double>[,] convert = {\n            { a => a, DegToGrad, DegToMil, DegToRad },\n            { GradToDeg, a => a, GradToMil, GradToRad },\n            { MilToDeg, MilToGrad, a => a, MilToRad },\n            { RadToDeg, RadToGrad, RadToMil, a => a }\n        };\n\n        Console.WriteLine($@\"{\"Angle\",-12}{\"Normalized\",-12}{\"Unit\",-12}{\n            \"Degrees\",-12}{\"Gradians\",-12}{\"Mils\",-12}{\"Radians\",-12}\");\n\n        foreach (double angle in angles) {\n            for (int i = 0; i < 4; i++) {\n                double nAngle = normal[i](angle);\n\n                Console.WriteLine($@\"{\n                    rnd(angle),-12}{\n                    rnd(nAngle),-12}{\n                    names[i],-12}{\n                    rnd(convert[i, 0](nAngle)),-12}{\n                    rnd(convert[i, 1](nAngle)),-12}{\n                    rnd(convert[i, 2](nAngle)),-12}{\n                    rnd(convert[i, 3](nAngle)),-12}\");\n            }\n        }\n    }\n\n    public static double NormalizeDeg(double angle) => Normalize(angle, 360);\n    public static double NormalizeGrad(double angle) => Normalize(angle, 400);\n    public static double NormalizeMil(double angle) => Normalize(angle, 6400);\n    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);\n\n    private static double Normalize(double angle, double N) {\n        while (angle <= -N) angle += N;\n        while (angle >= N) angle -= N;\n        return angle;\n    }\n\n    public static double DegToGrad(double angle) => angle * 10 / 9;\n    public static double DegToMil(double angle) => angle * 160 / 9;\n    public static double DegToRad(double angle) => angle * Math.PI / 180;\n    \n    public static double GradToDeg(double angle) => angle * 9 / 10;\n    public static double GradToMil(double angle) => angle * 16;\n    public static double GradToRad(double angle) => angle * Math.PI / 200;\n    \n    public static double MilToDeg(double angle) => angle * 9 / 160;\n    public static double MilToGrad(double angle) => angle / 16;\n    public static double MilToRad(double angle) => angle * Math.PI / 3200;\n    \n    public static double RadToDeg(double angle) => angle * 180 / Math.PI;\n    public static double RadToGrad(double angle) => angle * 200 / Math.PI;\n    public static double RadToMil(double angle) => angle * 3200 / Math.PI;\n}\n"}
{"id": 399633, "name": "I before E except after C", "source": "Translate Swift to C#: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 399634, "name": "I before E except after C", "source": "Translate Swift to C#: import Foundation\n\nlet request = NSURLRequest(URL: NSURL(string: \"http:\n\nNSURLConnection.sendAsynchronousRequest(request, queue: NSOperationQueue()) {res, data, err in\n    if (data != nil) {\n        if let fileAsString = NSString(data: data, encoding: NSUTF8StringEncoding) {\n            var firstCase = false\n            var secondCase = false\n            var cie = 0\n            var cei = 0\n            var not_c_ie = 0\n            var not_c_ei = 0\n            let words = fileAsString.componentsSeparatedByString(\"\\n\")\n            for word in words {\n                var wordRegex = RegexMutable(word as String)\n                if (wordRegex[\"cie\"]) {\n                    cie++\n                }\n                if (wordRegex[\"cei\"]) {\n                    cei++\n                }\n                if (wordRegex[\"(^ie|[^c]ie)\"].matches().count != 0) {\n                    not_c_ie++\n                }\n                if (wordRegex[\"(^ei|[^c]ei)\"].matches().count != 0) {\n                    not_c_ei++\n                }\n            }\n            \n            \n            if (not_c_ie > not_c_ei * 2) {\n                println(\"I before E when not preceded by C is plausable\")\n                firstCase = true\n            } else {\n                println(\"I before E when not preceded by C is not plausable\")\n            }\n            \n            if (cei > cie * 2) {\n                secondCase = true\n                println(\"E before I when preceded by C is plausable\")\n            } else {\n                println(\"E before I when preceded by C is not plausable\")\n            }\n            \n            if (firstCase && secondCase) {\n                println(\"I before E except after C is plausible\")\n            } else {\n                println(\"I before E except after C is not plausible\")\n            }\n        }\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 399635, "name": "Line circle intersection", "source": "Translate Swift to C#: import Foundation\nimport CoreGraphics\n\nfunc lineCircleIntersection(start: NSPoint, end: NSPoint, center: NSPoint,\n                            radius: CGFloat, segment: Bool) -> [NSPoint] {\n    var result: [NSPoint] = []\n    let angle = atan2(end.y - start.y, end.x - start.x)\n    var at = AffineTransform(rotationByRadians: angle)\n    at.invert()\n    at.translate(x: -center.x, y: -center.y)\n    let p1 = at.transform(start)\n    let p2 = at.transform(end)\n    let minX = min(p1.x, p2.x), maxX = max(p1.x, p2.x)\n    let y = p1.y\n    at.invert()\n    func addPoint(x: CGFloat, y: CGFloat) {\n        if !segment || (x <= maxX && x >= minX) {\n            result.append(at.transform(NSMakePoint(x, y)))\n        }\n    }\n    if y == radius || y == -radius {\n        addPoint(x: 0, y: y)\n    } else if y < radius && y > -radius {\n        let x = (radius * radius - y * y).squareRoot()\n        addPoint(x: -x, y: y)\n        addPoint(x: x, y: y)\n    }\n    return result\n}\n\nfunc toString(points: [NSPoint]) -> String {\n    var result = \"[\"\n    result += points.map{String(format: \"(%.4f,\u00a0%.4f)\", $0.x, $0.y)}.joined(separator: \", \")\n    result += \"]\"\n    return result\n}\n\nvar center = NSMakePoint(3, -5)\nvar radius: CGFloat = 3\n\nprint(\"The intersection points (if any) between:\")\nprint(\"\\n  A circle, center (3, -5) with radius 3, and:\")\nprint(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\")\nvar points = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(10, -9),\n                                    center: center, radius: radius,\n                                    segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\")\npoints = lineCircleIntersection(start: NSMakePoint(-10, 11), end: NSMakePoint(-11, 12),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(3, -2), end: NSMakePoint(7, -2),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 0\ncenter.y = 0\nradius = 4\n\nprint(\"\\n  A circle, center (0, 0) with radius 4, and:\")\nprint(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(0, -3), end: NSMakePoint(0, 6),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n\ncenter.x = 4\ncenter.y = 2\nradius = 5\n\nprint(\"\\n  A circle, center (4, 2) with radius 5, and:\")\nprint(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(6, 3), end: NSMakePoint(10, 7),\n                                center: center, radius: radius,\n                                segment: false)\nprint(\"     \\(toString(points: points))\")\nprint(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\")\npoints = lineCircleIntersection(start: NSMakePoint(7, 4), end: NSMakePoint(11, 8),\n                                center: center, radius: radius,\n                                segment: true)\nprint(\"     \\(toString(points: points))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Circle circle = ((3, -5), 3);\n        Line[] lines = {\n            ((-10, 11), (10, -9)),\n            ((-10, 11), (-11, 12), true),\n            ((3, -2), (7, -2))\n        };\n        Print(circle, lines);\n        \n        circle = ((0, 0), 4);\n        lines = new Line[] {\n            ((0, -3), (0, 6)),\n            ((0, -3), (0, 6), true)\n        };\n        Print(circle, lines);\n        \n        circle = ((4, 2), 5);\n        lines = new Line[] {\n            ((6, 3), (10, 7)),\n            ((7, 4), (11, 8), true)\n        };\n        Print(circle, lines);\n    }\n    \n    static void Print(Circle circle, Line[] lines)\n    {\n        Console.WriteLine($\"Circle: {circle}\");\n        foreach (var line in lines) {\n            Console.WriteLine($\"\\t{(line.IsSegment\u00a0? \"Segment:\"\u00a0: \"Line:\")} {line}\");\n            var points = Intersection(circle, line).ToList();\n            Console.WriteLine(points.Count == 0 ? \"\\t\\tdo not intersect\" : \"\\t\\tintersect at \" + string.Join(\" and \", points));\n        }\n        Console.WriteLine();\n    }\n    \n    static IEnumerable<Point> Intersection(Circle circle, Line line)\n    {\n        var intersection = LineIntersection(circle, line);\n        return line.IsSegment\n            ? intersection.Where(p => p.CompareTo(line.P1) >= 0 && p.CompareTo(line.P2) <= 0)\n            : intersection;\n\n        static IEnumerable<Point> LineIntersection(Circle circle, Line line)\n        {\n            double x, y, A, B, C, D;\n            var (m, c) = (line.Slope, line.YIntercept);\n            var (p, q, r) = (circle.X, circle.Y, circle.Radius);\n\n            if (line.IsVertical) {\n                x = line.P1.X;\n                B = -2 * q;\n                C = p * p + q * q - r * r + x * x - 2 * p * x;\n                D = B * B - 4 * C;\n                if (D == 0) yield return (x, -q);\n                else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    yield return (x, (-B - D) / 2);\n                    yield return (x, (-B + D) / 2);\n                }\n            } else {\n                A = m * m + 1;\n                B = 2 * (m * c - m * q - p);\n                C = p * p + q * q - r * r + c * c - 2 * c * q;\n                D = B * B - 4 * A * C;\n                if (D == 0) {\n                    x = -B / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                } else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    x = (-B - D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                    x = (-B + D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                }\n            }\n        }\n\n    }\n    \n    readonly struct Point : IComparable<Point>\n    {\n        public Point(double x, double y) => (X, Y) = (x, y);\n        \n        public static implicit operator Point((double x, double y) p) => new Point(p.x, p.y);\n        \n        public double X { get; }\n        public double Y { get; }\n        \n        public int CompareTo(Point other)\n        {\n            int c = X.CompareTo(other.X);\n            if (c != 0) return c;\n            return Y.CompareTo(other.Y);\n        }\n        \n        public override string ToString() => $\"({X}, {Y})\";\n    }\n    \n    readonly struct Line\n    {\n        public Line(Point p1, Point p2, bool isSegment = false)\n        {\n            (P1, P2) = p2.CompareTo(p1) < 0 ? (p2, p1) : (p1, p2);\n            IsSegment = isSegment;\n            if (p1.X == p2.X) (Slope, YIntercept) = (double.PositiveInfinity, double.NaN);\n            else {\n                Slope = (P2.Y - P1.Y) / (P2.X - P1.X);\n                YIntercept = P2.Y - Slope * P2.X;\n            }\n        }\n        \n        public static implicit operator Line((Point p1, Point p2) l) => new Line(l.p1, l.p2);\n        public static implicit operator Line((Point p1, Point p2, bool isSegment) l) => new Line(l.p1, l.p2, l.isSegment);\n        \n        public Point P1 { get; }\n        public Point P2 { get; }\n        public double Slope { get; }\n        public double YIntercept { get; }\n        public bool IsSegment { get; }\n        public bool IsVertical => P1.X == P2.X;\n        \n        public override string ToString() => $\"[{P1}, {P2}]\";\n    }\n    \n    readonly struct Circle\n    {\n        public Circle(Point center, double radius) => (Center, Radius) = (center, radius);\n        \n        public static implicit operator Circle((Point center, double radius) c) => new Circle(c.center, c.radius);\n        \n        public Point Center { get; }\n        public double Radius { get; }\n        public double X => Center.X;\n        public double Y => Center.Y;\n        \n        public override string ToString() => $\"{{ C:{Center}, R:{Radius} }}\";\n    }   \n}\n"}
{"id": 399636, "name": "Farey sequence", "source": "Translate Swift to C#: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 399637, "name": "Farey sequence", "source": "Translate Swift to C#: class Farey {\n    let n: Int\n\n    init(_ x: Int) {\n        n = x\n    }\n\n    \n    var sequence: [(Int,Int)] {\n        var a = 0\n        var b = 1\n        var c = 1\n        var d = n\n        var results = [(a, b)]\n        while c <= n {\n            let k = (n + b) / d\n            let oldA = a\n            let oldB = b\n            a = c\n            b = d\n            c = k * c - oldA\n            d = k * d - oldB\n            results += [(a, b)]\n        }\n        return results\n    }\n\n    var formattedSequence: String {\n        var s = \"\\(n):\"\n        for pair in sequence {\n            s += \" \\(pair.0)/\\(pair.1)\"\n        }\n        return s\n    }\n\n}\n\nprint(\"Sequences\\n\")\n\nfor n in 1...11 {\n    print(Farey(n).formattedSequence)\n}\n\nprint(\"\\nSequence Lengths\\n\")\n\nfor n in 1...10 {\n    let m = n * 100\n    print(\"\\(m): \\(Farey(m).sequence.count)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 399638, "name": "Magnanimous numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isMagnanimous(_ n: Int) -> Bool {\n    var p = 10;\n    while n >= p {\n        if !isPrime(n % p + n / p) {\n            return false\n        }\n        p *= 10\n    }\n    return true\n}\n\nlet m = (0...).lazy.filter{isMagnanimous($0)}.prefix(400);\nprint(\"First 45 magnanimous numbers:\");\nfor (i, n) in m.prefix(45).enumerated() {\n    if i > 0 && i % 15 == 0 {\n        print()\n    }\n    print(String(format: \"%3d\", n), terminator: \" \")\n}\nprint(\"\\n\\n241st through 250th magnanimous numbers:\");\nfor n in m.dropFirst(240).prefix(10) {\n    print(n, terminator: \" \")\n}\nprint(\"\\n\\n391st through 400th magnanimous numbers:\");\nfor n in m.dropFirst(390) {\n    print(n, terminator: \" \")\n}\nprint()\n", "target": "using System; using static System.Console;\n\nclass Program {\n\n  static bool[] np; \n\n  static void ms(long lmt) { \n    np = new bool[lmt]; np[0] = np[1] = true;\n    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])\n        for (long k = n * n; k < lmt; k += n) np[k] = true; }\n\n  static bool is_Mag(long n) { long res, rem;\n    for (long p = 10; n >= p; p *= 10) {\n      res = Math.DivRem (n, p, out rem);\n      if (np[res + rem]) return false; } return true; }\n\n  static void Main(string[] args) { ms(100_009); string mn;\n    WriteLine(\"First 45{0}\", mn = \" magnanimous numbers:\");\n    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {\n      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)\n        Write(c <= 45 ? \"{0,4} \" : \"{0,8:n0} \", l);\n      if (c < 45 && c % 15 == 0) WriteLine();\n      if (c == 240) WriteLine (\"\\n\\n241st through 250th{0}\", mn);\n      if (c == 390) WriteLine (\"\\n\\n391st through 400th{0}\", mn); } }\n}\n"}
{"id": 399639, "name": "Taxicab numbers", "source": "Translate Swift to C#: extension Array {\n  func combinations(_ k: Int) -> [[Element]] {\n    return Self._combinations(slice: self[startIndex...], k)\n  }\n\n  static func _combinations(slice: Self.SubSequence, _ k: Int) -> [[Element]] {\n    guard k != 1 else {\n      return slice.map({ [$0] })\n    }\n\n    guard k != slice.count else {\n      return [slice.map({ $0 })]\n    }\n\n    let chopped = slice[slice.index(after: slice.startIndex)...]\n\n    var res = _combinations(slice: chopped, k - 1).map({ [[slice.first!], $0].flatMap({ $0 }) })\n\n    res += _combinations(slice: chopped, k)\n\n    return res\n  }\n}\n\nlet cubes = (1...).lazy.map({ $0 * $0 * $0 })\nlet taxis =\n  Array(cubes.prefix(1201))\n    .combinations(2)\n    .reduce(into: [Int: [[Int]]](), { $0[$1[0] + $1[1], default: []].append($1) })\n\n\nlet res =\n  taxis\n    .lazy\n    .filter({ $0.value.count > 1 })\n    .sorted(by: { $0.key < $1.key })\n    .map({ ($0.key, $0.value) })\n    .prefix(2006)\n\nprint(\"First 25 taxicab numbers:\")\nfor taxi in res[..<25] {\n  print(taxi)\n}\n\nprint(\"\\n2000th through 2006th taxicab numbers:\")\nfor taxi in res[1999..<2006] {\n  print(taxi)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace TaxicabNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);\n            PrintTaxicabNumbers(taxicabNumbers);\n            Console.ReadKey();\n        }\n\n        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)\n        {\n            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();\n\n            for (int i = 1; i < int.MaxValue; i++)\n            {\n                for (int j = 1; j < int.MaxValue; j++)\n                {\n                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));\n\n                    if (!sumsOfTwoCubes.ContainsKey(sum))\n                    {\n                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());\n                    }\n\n                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));\n\n                    if (j >= i)\n                    {\n                        break;\n                    }\n                }\n\n                \n                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)\n                {\n                    break;\n                }\n            }\n\n            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)\n                .Take(2006)\n                .ToDictionary(u => u.Key, u => u.Value);\n\n            return values;\n        }\n\n        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)\n        {\n            int i = 1;\n\n            foreach (long taxicabNumber in values.Keys)\n            {\n                StringBuilder output = new StringBuilder().AppendFormat(\"{0,10}\\t{1,4}\", i, taxicabNumber);\n\n                foreach (Tuple<int, int> numbers in values[taxicabNumber])\n                {\n                    output.AppendFormat(\"\\t= {0}^3 + {1}^3\", numbers.Item1, numbers.Item2);\n                }\n\n                if (i <= 25 || (i >= 2000 && i <= 2006))\n                {\n                    Console.WriteLine(output.ToString());\n                }\n\n                i++;\n            }\n        }\n    }\n}\n"}
{"id": 399640, "name": "Strong and weak primes", "source": "Translate Swift to C#: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar strongPrimes = PrimeInfo(maxPrint: 36)\nvar weakPrimes = PrimeInfo(maxPrint: 37)\n\nlet sieve = PrimeSieve(size: limit2 + 100)\n\nvar p1 = 2, p2 = 3, p3 = 5\nwhile p2 < limit2 {\n    if sieve.isPrime(number: p3) {\n        let diff = p1 + p3 - 2 * p2\n        if diff < 0 {\n            strongPrimes.addPrime(prime: p2)\n        } else if diff > 0 {\n            weakPrimes.addPrime(prime: p2)\n        }\n        p1 = p2\n        p2 = p3\n    }\n    p3 += 2\n}\n\nstrongPrimes.printInfo(name: \"strong\")\nweakPrimes.printInfo(name: \"weak\")\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\nusing System;\n\npublic static class StrongAndWeakPrimes\n{\n    public static void Main() {\n        var primes = PrimeGenerator(10_000_100).ToList();\n        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];\n        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];\n        WriteLine($\"First 36 strong primes: {string.Join(\", \", strongPrimes.Take(36))}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}\");\n        WriteLine($\"First 37 weak primes: {string.Join(\", \", weakPrimes.Take(37))}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n    }\n   \n}\n"}
{"id": 399641, "name": "Left factorials", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 399642, "name": "Left factorials", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nprefix func ! <T: BinaryInteger>(n: T) -> T {\n  guard n != 0 else {\n    return 0\n  }\n\n  return stride(from: 0, to: n, by: 1).lazy.map(factorial).reduce(0, +)\n}\n\nfor i in 0...10 {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nfor i in stride(from: BigInt(20), through: 110, by: 10) {\n  print(\"!\\(i) = \\(!i)\")\n}\n\nprint()\n\nprint(\"!1000 = \\((!BigInt(1000)).description.count) digit number\")\n\nprint()\n\nfor i in stride(from: BigInt(2000), through: 10_000, by: 1000) {\n  print(\"!\\(i) = \\((!i).description.count) digit number\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 399643, "name": "Strange unique prime triplets", "source": "Translate Swift to C#: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 399644, "name": "Strange unique prime triplets", "source": "Translate Swift to C#: import Foundation\n\nfunc primeSieve(limit: Int) -> [Bool] {\n    guard limit > 0 else {\n        return []\n    }\n    var sieve = Array(repeating: true, count: limit)\n    sieve[0] = false\n    if limit > 1 {\n        sieve[1] = false\n    }\n    if limit > 4 {\n        for i in stride(from: 4, to: limit, by: 2) {\n            sieve[i] = false\n        }\n    }\n    var p = 3\n    while true {\n        var q = p * p\n        if q >= limit {\n            break\n        }\n        if sieve[p] {\n            let inc = 2 * p\n            while q < limit {\n                sieve[q] = false\n                q += inc\n            }\n        }\n        p += 2\n    }\n    return sieve\n}\n\nfunc strangeUniquePrimeTriplets(limit: Int, verbose: Bool) {\n    guard limit > 5 else {\n        return;\n    }\n    let sieve = primeSieve(limit: 3 * limit)\n    var primes: [Int] = []\n    for p in stride(from: 3, to: limit, by: 2) {\n        if sieve[p] {\n            primes.append(p)\n        }\n    }\n    let n = primes.count\n    var count = 0\n    if verbose {\n        print(\"Strange unique prime triplets < \\(limit):\")\n    }\n    for i in (0..<n - 2) {\n        for j in (i + 1..<n - 1) {\n            for k in (j + 1..<n) {\n                let sum = primes[i] + primes[j] + primes[k]\n                if sieve[sum] {\n                    count += 1\n                    if verbose {\n                        print(String(format: \"%2d + %2d + %2d = %2d\",\n                                     primes[i], primes[j], primes[k], sum))\n                    }\n                }\n            }\n        }\n    }\n    print(\"\\nCount of strange unique prime triplets < \\(limit) is \\(count).\")\n}\n\nstrangeUniquePrimeTriplets(limit: 30, verbose: true)\nstrangeUniquePrimeTriplets(limit: 1000, verbose: false)\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 399645, "name": "Motzkin numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n}\n\nfunc motzkin(_ n: Int) -> [Int] {\n  var m = Array(repeating: 0, count: n)\n\n  m[0] = 1\n  m[1] = 1\n\n  for i in 2..<n {\n    m[i] = (m[i - 1] * (2 * i + 1) + m[i - 2] * (3 * i - 3)) / (i + 2)\n  }\n\n  return m\n}\n\nlet m = motzkin(42)\n\nfor (i, n) in m.enumerated() {\n  print(\"\\(i): \\(n) \\(n.isPrime ? \"prime\" : \"\")\")\n}\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n  \n  static bool hmf(BI x) {\n    if (x < 4) return x == 1;\n    if ((x & 1) == 0 || x % 3 == 0) return true;\n    int l = (int)Math.Sqrt((double)x); \n    for (int j = 5, d = 4; j <= l; j += d = 6 - d)\n      if (x % j == 0) return x > j;\n    return false;\n  }\n \n  static void Main(string[] args) {\n    BI a = 0, b = 1, t;\n    int n = 1, s = 0, d = 1, c = 0, f = 1;\n    while (n <= 80)\n      Console.WriteLine(\"{0,46:n0} {1}\",\n        t = b / n++,\n        hmf(t) ? \"\" : \"is prime.\",\n        t = b,\n        b = ((c += d * 3 + 3) * a +\n             (f += d * 2 + 3) * b) /\n             (s += d += 2),\n        a = t);\n  }\n}\n"}
{"id": 399646, "name": "Pythagorean quadruples", "source": "Translate Swift to C#: func missingD(upTo n: Int) -> [Int] {\n  var a2 = 0, s = 3, s1 = 0, s2 = 0\n  var res = [Int](repeating: 0, count: n + 1)\n  var ab = [Int](repeating: 0, count: n * n * 2 + 1)\n\n  for a in 1...n {\n    a2 = a * a\n\n    for b in a...n {\n      ab[a2 + b * b] = 1\n    }\n  }\n\n  for c in 1..<n {\n    s1 = s\n    s += 2\n    s2 = s\n\n    for d in c+1...n {\n      if ab[s1] != 0 {\n        res[d] = 1\n      }\n\n      s1 += s2\n      s2 += 2\n    }\n  }\n\n  return (1...n).filter({ res[$0] == 0 })\n}\n\nprint(missingD(upTo: 2200))\n", "target": "using System;\n\nnamespace PythagoreanQuadruples {\n    class Program {\n        const int MAX = 2200;\n        const int MAX2 = MAX * MAX * 2;\n\n        static void Main(string[] args) {\n            bool[] found = new bool[MAX + 1]; \n            bool[] a2b2 = new bool[MAX2 + 1]; \n            int s = 3;\n\n            for(int a = 1; a <= MAX; a++) {\n                int a2 = a * a;\n                for (int b=a; b<=MAX; b++) {\n                    a2b2[a2 + b * b] = true;\n                }\n            }\n\n            for (int c = 1; c <= MAX; c++) {\n                int s1 = s;\n                s += 2;\n                int s2 = s;\n                for (int d = c + 1; d <= MAX; d++) {\n                    if (a2b2[s1]) found[d] = true;\n                    s1 += s2;\n                    s2 += 2;\n                }\n            }\n\n            Console.WriteLine(\"The values of d <= {0} which can't be represented:\", MAX);\n            for (int d = 1; d < MAX; d++) {\n                if (!found[d]) Console.Write(\"{0}  \", d);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 399647, "name": "Safe primes and unsafe primes", "source": "Translate Swift to C#: import Foundation\n\nclass PrimeSieve {\n    var composite: [Bool]\n    \n    init(size: Int) {\n        composite = Array(repeating: false, count: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite[p/2 - 1] {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite[q/2 - 1] = true\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite[number/2 - 1]\n    }\n}\n\nfunc commatize(_ number: Int) -> String {\n    let n = NSNumber(value: number)\n    return NumberFormatter.localizedString(from: n, number: .decimal)\n}\n\nlet limit1 = 1000000\nlet limit2 = 10000000\n\nclass PrimeInfo {\n    let maxPrint: Int\n    var count1: Int\n    var count2: Int\n    var primes: [Int]\n    \n    init(maxPrint: Int) {\n        self.maxPrint = maxPrint\n        count1 = 0\n        count2 = 0\n        primes = []\n    }\n    \n    func addPrime(prime: Int) {\n        count2 += 1\n        if prime < limit1 {\n            count1 += 1\n        }\n        if count2 <= maxPrint {\n            primes.append(prime)\n        }\n    }\n    \n    func printInfo(name: String) {\n        print(\"First \\(maxPrint) \\(name) primes: \\(primes)\")\n        print(\"Number of \\(name) primes below \\(commatize(limit1)): \\(commatize(count1))\")\n        print(\"Number of \\(name) primes below \\(commatize(limit2)): \\(commatize(count2))\")\n    }\n}\n\nvar safePrimes = PrimeInfo(maxPrint: 35)\nvar unsafePrimes = PrimeInfo(maxPrint: 40)\n\nlet sieve = PrimeSieve(size: limit2)\n\nfor prime in 2..<limit2 {\n    if sieve.isPrime(number: prime) {\n        if sieve.isPrime(number: (prime - 1)/2) {\n            safePrimes.addPrime(prime: prime)\n        } else {\n            unsafePrimes.addPrime(prime: prime)\n        }\n    }\n}\n\nsafePrimes.printInfo(name: \"safe\")\nunsafePrimes.printInfo(name: \"unsafe\")\n", "target": "using static System.Console;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class SafePrimes\n{\n    public static void Main() {\n        HashSet<int> primes = Primes(10_000_000).ToHashSet();\n        WriteLine(\"First 35 safe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsSafe).Take(35)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}\");\n        WriteLine(\"First 40 unsafe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsUnsafe).Take(40)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}\");\n\n        bool IsSafe(int prime) => primes.Contains(prime / 2);\n        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);\n    }\n\n    \n    static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n}\n"}
{"id": 399648, "name": "Hash join", "source": "Translate Swift to C#: func hashJoin<A, B, K: Hashable>(_ first: [(K, A)], _ second: [(K, B)]) -> [(A, K, B)] {\n  var map = [K: [B]]()\n\n  for (key, val) in second {\n    map[key, default: []].append(val)\n  }\n\n  var res = [(A, K, B)]()\n\n  for (key, val) in first {\n    guard let vals = map[key] else {\n      continue\n    }\n\n    res += vals.map({ (val, key, $0) })\n  }\n\n  return res\n}\n\nlet t1 = [\n  (\"Jonah\", 27), \n  (\"Alan\", 18), \n  (\"Glory\", 28), \n  (\"Popeye\", 18), \n  (\"Alan\", 28)\n]\n\nlet t2 = [\n  (\"Jonah\", \"Whales\"), \n  (\"Jonah\", \"Spiders\"),\n  (\"Alan\", \"Ghosts\"),\n  (\"Alan\", \"Zombies\"),\n  (\"Glory\", \"Buffy\")\n]\n\nprint(\"Age | Character Name | Nemesis\")\nprint(\"----|----------------|--------\")\n\nfor (age, name, nemesis) in hashJoin(t1, t2) {\n  print(\"\\(age) | \\(name) | \\(nemesis)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"id": 399649, "name": "Speech synthesis", "source": "Translate Swift to C#: import Foundation\n\nlet task = NSTask()\ntask.launchPath = \"/usr/bin/say\"\ntask.arguments = [\"This is an example of speech synthesis.\"]\ntask.launch()\n", "target": "using SpeechLib;\n\nnamespace Speaking_Computer\n{\n  public class Program\n  {\n    private static void Main()\n    {\n      var voice = new SpVoice();\n      voice.Speak(\"This is an example of speech synthesis.\");\n    }\n  }\n}\n"}
{"id": 399650, "name": "Super-d numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 399651, "name": "Super-d numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nlet rd = [\"22\", \"333\", \"4444\", \"55555\", \"666666\", \"7777777\", \"88888888\", \"999999999\"]\n\nfor d in 2...9 {\n  print(\"First 10 super-\\(d) numbers:\")\n\n  var count = 0\n  var n = BigInt(3)\n  var k = BigInt(0)\n\n  while true {\n    k = n.power(d)\n    k *= BigInt(d)\n\n    if let _ = String(k).range(of: rd[d - 2]) {\n      count += 1\n\n      print(n, terminator: \" \")\n      fflush(stdout)\n\n      guard count < 10 else {\n        break\n      }\n    }\n\n    n += 1\n  }\n\n  print()\n  print()\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 399652, "name": "Monads_Maybe monad", "source": "Translate Swift to C#: precedencegroup MonadPrecedence {\n\thigherThan: BitwiseShiftPrecedence\n\tassociativity: left\n}\n\ninfix operator >>-: MonadPrecedence\t\n\ntypealias Maybe = Optional\n\nextension Maybe\n{\n\tstatic func unit(_ x: Wrapped) -> Maybe<Wrapped>\n\t{\n\t\treturn Maybe(x)\n\t}\n\n\tfunc bind<T>(_ f: (Wrapped) -> Maybe<T>) -> Maybe<T>\n\t{\n\t\treturn self.flatMap(f)\n\t}\n\n\tstatic func >>- <U>(_ m: Optional<Wrapped>, _ f: (Wrapped) -> Maybe<U>) -> Maybe<U>\n\t{\n\t\treturn m.flatMap(f)\n\t}\n}\n\nfunc dividedBy2IfEven(_ x: Int) -> Maybe<Int>\n{\n\tx.isMultiple(of: 2) ? x / 2 : nil\n}\n\nfunc lineOfAs(_ x: Int) -> Maybe<String>\n{\n\tguard x >= 0 else { return nil }\n\tlet chars = Array<Character>(repeating: \"A\", count: x)\n\treturn String(chars)\n}\n\nprint(\"\\(Maybe.unit(6).bind(dividedBy2IfEven).bind(lineOfAs) ?? \"nil\")\")\nprint(\"\\(Maybe.unit(4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(3) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\nprint(\"\\(Maybe.unit(-4) >>- dividedBy2IfEven >>- lineOfAs ?? \"nil\")\")\n", "target": "using System;\n\nnamespace RosettaMaybe\n{\n    \n    public abstract class Maybe<T>\n    {\n        public sealed class Some : Maybe<T>\n        {\n            public Some(T value) => Value = value;\n            public T Value { get; }\n        }\n        public sealed class None : Maybe<T> { }\n    }\n\n    class Program\n    {\n        static Maybe<double> MonadicSquareRoot(double x)\n        {\n            if (x >= 0)\n            {\n                return new Maybe<double>.Some(Math.Sqrt(x));\n            }\n            else\n            {\n                return new Maybe<double>.None();\n            }\n        }\n        static void Main(string[] args)\n        {\n            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })\n            {\n                Maybe<double> maybe = MonadicSquareRoot(x);\n                if (maybe is Maybe<double>.Some some)\n                {\n                    Console.WriteLine($\"The square root of {x} is \" + some.Value);\n                }\n                else\n                {\n                    Console.WriteLine($\"Square root of {x} is undefined.\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399653, "name": "Church numerals", "source": "Translate Swift to C#: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 399654, "name": "Church numerals", "source": "Translate Swift to C#: func succ<A, B, C>(_ n: @escaping (@escaping (A) -> B) -> (C) -> A) -> (@escaping (A) -> B) -> (C) -> B {\n  return {f in\n    return {x in\n      return f(n(f)(x))\n    }\n  }\n}\n\nfunc zero<A, B>(_ a: A) -> (B) -> B {\n  return {b in\n    return b\n  }\n}\n\nfunc three<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(zero)))(f)(x)\n  }\n}\n\nfunc four<A>(_ f: @escaping (A) -> A) -> (A) -> A {\n  return {x in\n    return succ(succ(succ(succ(zero))))(f)(x)\n  }\n}\n\nfunc add<A, B, C>(_ m: @escaping (B) -> (A) -> C) -> (@escaping (B) -> (C) -> A) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return m(f)(n(f)(x))\n      }\n    }\n  }\n}\n\nfunc mult<A, B, C>(_ m: @escaping (A) -> B) -> (@escaping (C) -> A) -> (C) -> B {\n  return {n in\n    return {f in\n      return m(n(f))\n    }\n  }\n}\n\nfunc exp<A, B, C>(_ m: A) -> (@escaping (A) -> (B) -> (C) -> C) -> (B) -> (C) -> C {\n  return {n in\n    return {f in\n      return {x in\n        return n(m)(f)(x)\n      }\n    }\n  }\n}\n\nfunc church<A>(_ x: Int) -> (@escaping (A) -> A) -> (A) -> A {\n  guard x != 0 else { return zero }\n\n  return {f in\n    return {a in\n      return f(church(x - 1)(f)(a))\n    }\n  }\n}\n\nfunc unchurch<A>(_ f: (@escaping (Int) -> Int) -> (Int) -> A) -> A {\n  return f({i in\n    return i + 1\n  })(0)\n}\n\nlet a = unchurch(add(three)(four))\nlet b = unchurch(mult(three)(four))\n\nlet c = unchurch(exp(mult(four)(church(1)))(three))\nlet d = unchurch(exp(mult(three)(church(1)))(four))\n\nprint(a, b, c, d)\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 399655, "name": "Send an unknown method call", "source": "Translate Swift to C#: import Foundation\n\nclass MyUglyClass: NSObject {\n  @objc\n  func myUglyFunction() {\n    print(\"called myUglyFunction\")\n  }\n}\n\nlet someObject: NSObject = MyUglyClass()\n\nsomeObject.perform(NSSelectorFromString(\"myUglyFunction\"))\n", "target": "using System;\n\nclass Example\n{\n    public int foo(int x)\n    {\n        return 42 + x;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var example = new Example();\n        var method = \"foo\";\n        \n        var result = (int)example.GetType().GetMethod(method).Invoke(example, new object[]{ 5 });\n        Console.WriteLine(\"{0}(5) = {1}\", method, result);\n    }\n}\n"}
{"id": 399656, "name": "Long primes", "source": "Translate Swift to C#: public struct Eratosthenes: Sequence, IteratorProtocol {\n  private let n: Int\n  private let limit: Int\n\n  private var i = 2\n  private var sieve: [Int]\n\n  public init(upTo: Int) {\n    if upTo <= 1 {\n      self.n = 0\n      self.limit = -1\n      self.sieve = []\n    } else {\n      self.n = upTo\n      self.limit = Int(Double(n).squareRoot())\n      self.sieve = Array(0...n)\n    }\n  }\n\n  public mutating func next() -> Int? {\n    while i < n {\n      defer { i += 1 }\n\n      if sieve[i] != 0 {\n        if i <= limit {\n          for notPrime in stride(from: i * i, through: n, by: i) {\n            sieve[notPrime] = 0\n          }\n        }\n\n        return i\n      }\n    }\n\n    return nil\n  }\n}\n\nfunc findPeriod(n: Int) -> Int {\n  let r = (1...n+1).reduce(1, {res, _ in (10 * res) % n })\n  var rr = r\n  var period = 0\n\n  repeat {\n    rr = (10 * rr) % n\n    period += 1\n  } while r != rr\n\n  return period\n}\n\nlet longPrimes = Eratosthenes(upTo: 64000).dropFirst().lazy.filter({ findPeriod(n: $0) == $0 - 1 })\n\nprint(\"Long primes less than 500: \\(Array(longPrimes.prefix(while: { $0 <= 500 })))\")\n\nlet counts =\n  longPrimes.reduce(into: [500: 0, 1000: 0, 2000: 0, 4000: 0, 8000: 0, 16000: 0, 32000: 0, 64000: 0], {counts, n in\n    for key in counts.keys where n < key {\n      counts[key]! += 1\n    }\n  })\n\nfor key in counts.keys.sorted() {\n  print(\"There are \\(counts[key]!) long primes less than \\(key)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LongPrimes\n{\n    public static void Main() {\n        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);\n        Console.WriteLine(string.Join(\" \", primes.TakeWhile(p => p <= 500)));\n        int count = 0, limit = 500;\n        foreach (int prime in primes) {\n            if (prime > limit) {\n                Console.WriteLine($\"There are {count} long primes below {limit}\");\n                limit *= 2;\n            }\n            count++;\n        }\n\n        int Period(int n) {\n            int r = 1, rr;\n            for (int i = 0; i <= n; i++) r = 10 * r % n;\n            rr = r;\n            for (int period = 1;; period++) {\n                r = (10 * r) % n;\n                if (r == rr) return period;\n            }\n        }\n    }\n\n}\n\nstatic class SomePrimeGenerator {\n\n    public static IEnumerable<int> Primes(int lim) {\n        bool [] flags = new bool[lim + 1]; int j = 2;\n        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n            if (!flags[j]) {\n                yield return j; for (int k = sq; k <= lim; k += j)\n                    flags[k] = true;\n            }\n        for (; j<= lim; j++) if (!flags[j]) yield return j;\n    }\n}\n"}
{"id": 399657, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Swift to C#: \nimport Foundation\n\n\nstruct Stack<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tvar top: T? {\n\t\telements.last\n\t}\n\t\n\tmutating func push(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func pop() -> T? {\n\t\tself.isEmpty ? nil : elements.removeLast()\n\t}\n}\n\nstruct Queue<T> {\n\tprivate(set) var elements = [T]()\n\t\n\tvar isEmpty: Bool {\n\t\telements.isEmpty\n\t}\n\t\n\tmutating func enqueue(_ newElement: T) {\n\t\telements.append(newElement)\n\t}\n\t\n\tmutating func dequeue() -> T {\n\t\treturn elements.removeFirst()\n\t}\n}\n\nenum Associativity {\n\tcase Left, Right\n}\n\n\nprotocol OperatorType: Comparable, Hashable {\n\tvar name: String { get }\n\tvar precedence: Int { get }\n\tvar associativity: Associativity { get }\n}\n\nstruct Operator: OperatorType {\n\tlet name: String\n\tlet precedence: Int\n\tlet associativity: Associativity\n\t\n\t\n\tfunc hash(into hasher: inout Hasher) {\n\t\thasher.combine(self.name)\n\t}\n\t\n\tinit(_ name: String, _ precedence: Int, _ associativity: Associativity) {\n\t\tself.name = name; self.precedence = precedence; self.associativity = associativity\n\t}\n}\n\nfunc ==(x: Operator, y: Operator) -> Bool {\n\t\n\tx.name == y.name\n}\n\nfunc <(x: Operator, y: Operator) -> Bool {\n\t\n\t(x.associativity == .Left && x.precedence == y.precedence) || x.precedence < y.precedence\n}\n\nextension Set where Element: OperatorType {\n\tfunc contains(_ operatorName: String) -> Bool {\n\t\tcontains { $0.name == operatorName }\n\t}\n\t\n\tsubscript (operatorName: String) -> Element? {\n\t\tget {\n\t\t\tfilter { $0.name == operatorName }.first\n\t\t}\n\t}\n}\n\n\nextension String {\n\tvar isNumber: Bool { return Double(self) != nil }\n}\n\nstruct ShuntingYard {\n\tenum ParseError: Error {\n\t\tcase MismatchedParenthesis(parenthesis: String, expression: String)\n\t\tcase UnrecognizedToken(token: String, expression: String)\n\t\tcase ExtraneousToken(token: String, expression: String)\n\t}\n\t\n\tstatic func parse(_ input: String, operators: Set<Operator>) throws -> String {\n\t\tvar stack = Stack<String>()\n\t\tvar output = Queue<String>()\n\t\tlet tokens = input.components(separatedBy: \" \")\n\t\t\n\t\tfor token in tokens {\n\t\t\t\n\t\t\tif token.isNumber {\n\t\t\t\t\n\t\t\t\toutput.enqueue(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif operators.contains(token) {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top,\n\t\t\t\t\t  operators.contains(top) && Self.hasLowerPrecedence(token, top, operators) {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \"(\" {\n\t\t\t\t\n\t\t\t\tstack.push(token)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif token == \")\" {\n\t\t\t\t\n\t\t\t\twhile let top = stack.top, top != \"(\" {\n\t\t\t\t\t\n\t\t\t\t\toutput.enqueue(stack.pop()!)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tguard let _ = stack.pop() else {\n\t\t\t\t\t\n\t\t\t\t\tthrow ParseError.MismatchedParenthesis(parenthesis: \")\", expression: input)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tthrow ParseError.UnrecognizedToken(token: token, expression: token)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\twhile let top = stack.top,\n\t\t\t  operators.contains(top) {\n\t\t\t\n\t\t\toutput.enqueue(stack.pop()!)\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif let top = stack.pop() {\n\t\t\tthrow (\n\t\t\t\ttop == \"(\"\n\t\t\t\t? ParseError.MismatchedParenthesis(parenthesis: \"(\", expression: input)\n\t\t\t\t: ParseError.ExtraneousToken(token: top, expression: input)\n\t\t\t)\n\t\t}\n\t\t\n\t\treturn output.elements.joined(separator: \" \")\n\t}\n\t\n\tstatic private func hasLowerPrecedence(_ firstToken: String, _ secondToken: String, _ operators: Set<Operator>) -> Bool {\n\t\tguard let firstOperator = operators[firstToken],\n\t\t\t  let secondOperator = operators[secondToken] else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\treturn firstOperator < secondOperator\n\t}\n}\n\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 399658, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to C#: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 399659, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Swift to C#: let ld10 = log(2.0) / log(10.0)\n\nfunc p(L: Int, n: Int) -> Int {\n  var l = L\n  var digits = 1\n\n  while l >= 10 {\n    digits *= 10\n    l /= 10\n  }\n\n  var count = 0\n  var i = 0\n\n  while count < n {\n    let rhs = (Double(i) * ld10).truncatingRemainder(dividingBy: 1)\n    let e = exp(log(10.0) * rhs)\n\n    if Int(e * Double(digits)) == L {\n      count += 1\n    }\n\n    i += 1\n  }\n\n  return i - 1\n}\n\nlet cases = [\n  (12, 1),\n  (12, 2),\n  (123, 45),\n  (123, 12345),\n  (123, 678910)\n]\n\nfor (l, n) in cases {\n  print(\"p(\\(l), \\(n)) = \\(p(L: l, n: n))\")\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 399660, "name": "Pierpont primes", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\npublic func pierpoint(n: Int) -> (first: [BigInt], second: [BigInt]) {\n  var primes = (first: [BigInt](repeating: 0, count: n), second: [BigInt](repeating: 0, count: n))\n\n  primes.first[0] = 2\n\n  var count1 = 1, count2 = 0\n  var s = [BigInt(1)]\n  var i2 = 0, i3 = 0, k = 1\n  var n2 = BigInt(0), n3 = BigInt(0), t = BigInt(0)\n\n  while min(count1, count2) < n {\n    n2 = s[i2] * 2\n    n3 = s[i3] * 3\n\n    if n2 < n3 {\n      t = n2\n      i2 += 1\n    } else {\n      t = n3\n      i3 += 1\n    }\n\n    if t <= s[k - 1] {\n      continue\n    }\n\n    s.append(t)\n    k += 1\n    t += 1\n\n    if count1 < n && t.isPrime(rounds: 10) {\n      primes.first[count1] = t\n      count1 += 1\n    }\n\n    t -= 2\n\n    if count2 < n && t.isPrime(rounds: 10) {\n      primes.second[count2] = t\n      count2 += 1\n    }\n  }\n\n  return primes\n}\n\n\nlet primes = pierpoint(n: 250)\n\nprint(\"First 50 Pierpoint primes of the first kind: \\(Array(primes.first.prefix(50)))\\n\")\nprint(\"First 50 Pierpoint primes of the second kind: \\(Array(primes.second.prefix(50)))\")\nprint()\nprint(\"250th Pierpoint prime of the first kind: \\(primes.first[249])\")\nprint(\"250th Pierpoint prime of the second kind: \\(primes.second[249])\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace PierpontPrimes {\n    public static class Helper {\n        private static readonly Random rand = new Random();\n        private static readonly List<int> primeList = new List<int>() {\n              2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43, 47,\n             53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\n            199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\n            383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\n            577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\n            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\n        };\n\n        public static BigInteger GetRandom(BigInteger min, BigInteger max) {\n            var bytes = max.ToByteArray();\n            BigInteger r;\n\n            do {\n                rand.NextBytes(bytes);\n                bytes[bytes.Length - 1] &= (byte)0x7F; \n                r = new BigInteger(bytes);\n            } while (r < min || r >= max);\n\n            return r;\n        }\n\n        \n        public static bool IsProbablePrime(this BigInteger n) {\n            if (n == 0 || n == 1) {\n                return false;\n            }\n\n            bool Check(BigInteger num) {\n                foreach (var prime in primeList) {\n                    if (num == prime) {\n                        return true;\n                    }\n                    if (num % prime == 0) {\n                        return false;\n                    }\n                    if (prime * prime > num) {\n                        return true;\n                    }\n                }\n\n                return true;\n            }\n\n            if (Check(n)) {\n                var large = primeList[primeList.Count - 1];\n                if (n <= large) {\n                    return true;\n                }\n            }\n\n            var s = 0;\n            var d = n - 1;\n            while (d.IsEven) {\n                d >>= 1;\n                s++;\n            }\n\n            bool TrialComposite(BigInteger a) {\n                if (BigInteger.ModPow(a, d, n) == 1) {\n                    return false;\n                }\n                for (int i = 0; i < s; i++) {\n                    var t = BigInteger.Pow(2, i);\n                    if (BigInteger.ModPow(a, t * d, n) == n - 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            for (int i = 0; i < 8; i++) {\n                var a = GetRandom(2, n);\n                if (TrialComposite(a)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program {\n        static List<List<BigInteger>> Pierpont(int n) {\n            var p = new List<List<BigInteger>> {\n                new List<BigInteger>(),\n                new List<BigInteger>()\n            };\n            for (int i = 0; i < n; i++) {\n                p[0].Add(0);\n                p[1].Add(0);\n            }\n            p[0][0] = 2;\n\n            var count = 0;\n            var count1 = 1;\n            var count2 = 0;\n            List<BigInteger> s = new List<BigInteger> { 1 };\n            var i2 = 0;\n            var i3 = 0;\n            var k = 1;\n            BigInteger n2;\n            BigInteger n3;\n            BigInteger t;\n\n            while (count < n) {\n                n2 = s[i2] * 2;\n                n3 = s[i3] * 3;\n                if (n2 < n3) {\n                    t = n2;\n                    i2++;\n                } else {\n                    t = n3;\n                    i3++;\n                }\n                if (t > s[k - 1]) {\n                    s.Add(t);\n                    k++;\n                    t += 1;\n                    if (count1 < n && t.IsProbablePrime()) {\n                        p[0][count1] = t;\n                        count1++;\n                    }\n                    t -= 2;\n                    if (count2 < n && t.IsProbablePrime()) {\n                        p[1][count2] = t;\n                        count2++;\n                    }\n                    count = Math.Min(count1, count2);\n                }\n            }\n\n            return p;\n        }\n\n        static void Main() {\n            var p = Pierpont(250);\n\n            Console.WriteLine(\"First 50 Pierpont primes of the first kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[0][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"First 50 Pierpont primes of the second kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[1][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"250th Pierpont prime of the first kind: {0}\", p[0][249]);\n            Console.WriteLine(\"250th Pierpont prime of the second kind: {0}\", p[1][249]);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 399661, "name": "N-smooth numbers", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) {\n      if self % i == 0 {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n@inlinable\npublic func smoothN<T: BinaryInteger>(n: T, count: Int) -> [T] {\n  let primes = stride(from: 2, to: n + 1, by: 1).filter({ $0.isPrime })\n  var next = primes\n  var indices = [Int](repeating: 0, count: primes.count)\n  var res = [T](repeating: 0, count: count)\n\n  res[0] = 1\n\n  guard count > 1 else {\n    return res\n  }\n\n  for m in 1..<count {\n    res[m] = next.min()!\n\n    for i in 0..<indices.count where res[m] == next[i] {\n      indices[i] += 1\n      next[i] = primes[i] * res[indices[i]]\n    }\n  }\n\n  return res\n}\n\nfor n in 2...29 where n.isPrime {\n  print(\"The first 25 \\(n)-smooth numbers are: \\(smoothN(n: n, count: 25))\")\n}\n\nprint()\n\nfor n in 3...29 where n.isPrime {\n  print(\"The 3000...3002 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 3002).dropFirst(2999).prefix(3))\")\n}\n\nprint()\n\nfor n in 503...521 where n.isPrime {\n  print(\"The 30,000...30,019 \\(n)-smooth numbers are: \\(smoothN(n: BigInt(n), count: 30_019).dropFirst(29999).prefix(20))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NSmooth {\n    class Program {\n        static readonly List<BigInteger> primes = new List<BigInteger>();\n        static readonly List<int> smallPrimes = new List<int>();\n\n        static Program() {\n            primes.Add(2);\n            smallPrimes.Add(2);\n\n            BigInteger i = 3;\n            while (i <= 521) {\n                if (IsPrime(i)) {\n                    primes.Add(i);\n                    if (i <= 29) {\n                        smallPrimes.Add((int)i);\n                    }\n                }\n                i += 2;\n            }\n        }\n\n        static bool IsPrime(BigInteger value) {\n            if (value < 2) return false;\n\n            if (value % 2 == 0) return value == 2;\n            if (value % 3 == 0) return value == 3;\n\n            if (value % 5 == 0) return value == 5;\n            if (value % 7 == 0) return value == 7;\n\n            if (value % 11 == 0) return value == 11;\n            if (value % 13 == 0) return value == 13;\n\n            if (value % 17 == 0) return value == 17;\n            if (value % 19 == 0) return value == 19;\n\n            if (value % 23 == 0) return value == 23;\n\n            BigInteger t = 29;\n            while (t * t < value) {\n                if (value % t == 0) return false;\n                value += 2;\n\n                if (value % t == 0) return false;\n                value += 4;\n            }\n\n            return true;\n        }\n\n        static List<BigInteger> NSmooth(int n, int size) {\n            if (n < 2 || n > 521) {\n                throw new ArgumentOutOfRangeException(\"n\");\n            }\n            if (size < 1) {\n                throw new ArgumentOutOfRangeException(\"size\");\n            }\n\n            BigInteger bn = n;\n            bool ok = false;\n            foreach (var prime in primes) {\n                if (bn == prime) {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                throw new ArgumentException(\"must be a prime number\", \"n\");\n            }\n\n            BigInteger[] ns = new BigInteger[size];\n            ns[0] = 1;\n            for (int i = 1; i < size; i++) {\n                ns[i] = 0;\n            }\n\n            List<BigInteger> next = new List<BigInteger>();\n            foreach (var prime in primes) {\n                if (prime > bn) {\n                    break;\n                }\n                next.Add(prime);\n            }\n\n            int[] indices = new int[next.Count];\n            for (int i = 0; i < indices.Length; i++) {\n                indices[i] = 0;\n            }\n            for (int m = 1; m < size; m++) {\n                ns[m] = next.Min();\n                for (int i = 0; i < indices.Length; i++) {\n                    if (ns[m] == next[i]) {\n                        indices[i]++;\n                        next[i] = primes[i] * ns[indices[i]];\n                    }\n                }\n            }\n\n            return ns.ToList();\n        }\n\n        static void Println<T>(IEnumerable<T> nums) {\n            Console.Write('[');\n\n            var it = nums.GetEnumerator();\n            if (it.MoveNext()) {\n                Console.Write(it.Current);\n            }\n            while (it.MoveNext()) {\n                Console.Write(\", \");\n                Console.Write(it.Current);\n            }\n\n            Console.WriteLine(']');\n        }\n\n        static void Main() {\n            foreach (var i in smallPrimes) {\n                Console.WriteLine(\"The first {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 25));\n                Console.WriteLine();\n            }\n            foreach (var i in smallPrimes.Skip(1)) {\n                Console.WriteLine(\"The 3,000 to 3,202 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 3_002).Skip(2_999));\n                Console.WriteLine();\n            }\n            foreach (var i in new int[] { 503, 509, 521 }) {\n                Console.WriteLine(\"The 30,000 to 3,019 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 30_019).Skip(29_999));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399662, "name": "Partition an integer x into n primes", "source": "Translate Swift to C#: import Foundation\n\nclass BitArray {\n    var array: [UInt32]\n\n    init(size: Int) {\n        array = Array(repeating: 0, count: (size + 31)/32)\n    }\n    \n    func get(index: Int) -> Bool {\n        let bit = UInt32(1) << (index & 31)\n        return (array[index >> 5] & bit) != 0\n    }\n    \n    func set(index: Int, value: Bool) {\n        let bit = UInt32(1) << (index & 31)\n        if value {\n            array[index >> 5] |= bit\n        } else {\n            array[index >> 5] &= ~bit\n        }\n    }\n}\n\nclass PrimeSieve {\n    let composite: BitArray\n    \n    init(size: Int) {\n        composite = BitArray(size: size/2)\n        var p = 3\n        while p * p <= size {\n            if !composite.get(index: p/2 - 1) {\n                let inc = p * 2\n                var q = p * p\n                while q <= size {\n                    composite.set(index: q/2 - 1, value: true)\n                    q += inc\n                }\n            }\n            p += 2\n        }\n    }\n    \n    func isPrime(number: Int) -> Bool {\n        if number < 2 {\n            return false\n        }\n        if (number & 1) == 0 {\n            return number == 2\n        }\n        return !composite.get(index: number/2 - 1)\n    }\n}\n\nfunc findPrimePartition(sieve: PrimeSieve, number: Int,\n                        count: Int, minPrime: Int,\n                        primes: inout [Int], index: Int) -> Bool {\n    if count == 1 {\n        if number >= minPrime && sieve.isPrime(number: number) {\n            primes[index] = number\n            return true\n        }\n        return false\n    }\n    if minPrime >= number {\n        return false\n    }\n    for p in minPrime..<number {\n        if sieve.isPrime(number: p)\n            && findPrimePartition(sieve: sieve, number: number - p,\n                                  count: count - 1, minPrime: p + 1,\n                                  primes: &primes, index: index + 1) {\n            primes[index] = p\n            return true\n        }\n    }\n    return false\n}\n\nfunc printPrimePartition(sieve: PrimeSieve, number: Int, count: Int) {\n    var primes = Array(repeating: 0, count: count)\n    if !findPrimePartition(sieve: sieve, number: number, count: count,\n                           minPrime: 2, primes: &primes, index: 0) {\n        print(\"\\(number) cannot be partitioned into \\(count) primes.\")\n    } else {\n        print(\"\\(number) = \\(primes[0])\", terminator: \"\")\n        for i in 1..<count {\n            print(\" + \\(primes[i])\", terminator: \"\")\n        }\n        print()\n    }\n}\n\nlet sieve = PrimeSieve(size: 100000)\nprintPrimePartition(sieve: sieve, number: 99809, count: 1)\nprintPrimePartition(sieve: sieve, number: 18, count: 2)\nprintPrimePartition(sieve: sieve, number: 19, count: 3)\nprintPrimePartition(sieve: sieve, number: 20, count: 4)\nprintPrimePartition(sieve: sieve, number: 2017, count: 24)\nprintPrimePartition(sieve: sieve, number: 22699, count: 1)\nprintPrimePartition(sieve: sieve, number: 22699, count: 2)\nprintPrimePartition(sieve: sieve, number: 22699, count: 3)\nprintPrimePartition(sieve: sieve, number: 22699, count: 4)\nprintPrimePartition(sieve: sieve, number: 40355, count: 3)\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Rosetta\n{\n    static void Main()\n    {\n        foreach ((int x, int n) in new [] {\n            (99809, 1),\n            (18, 2),\n            (19, 3),\n            (20, 4),\n            (2017, 24),\n            (22699, 1),\n            (22699, 2),\n            (22699, 3),\n            (22699, 4),\n            (40355, 3)\n        }) {\n            Console.WriteLine(Partition(x, n));\n        }\n    }\n\n    public static string Partition(int x, int n) {\n        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(\"Parameters must be positive.\");\n        string header = $\"{x} with {n} {(n == 1\u00a0? \"prime\"\u00a0: \"primes\")}: \";\n        int[] primes = SievePrimes(x).ToArray();\n        if (primes.Length < n) return header + \"not enough primes\";\n        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);\n        return header + (solution == null ? \"not possible\" : string.Join(\"+\", solution);\n    }\n\n    static IEnumerable<int> SievePrimes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {\n        T[] result = new T[count];\n        foreach (int[] indices in Combinations(input.Length, count)) {\n            for (int i = 0; i < count; i++) result[i] = input[indices[i]];\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int[]> Combinations(int n, int k) {\n        var result = new int[k];\n        var stack = new Stack<int>();\n        stack.Push(0);\n        while (stack.Count > 0) {\n            int index = stack.Count - 1;\n            int value = stack.Pop();\n            while (value < n) {\n                result[index++] = value++;\n                stack.Push(value);\n                if (index == k) {\n                    yield return result;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 399663, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to C#: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 399664, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Swift to C#: struct Point: CustomStringConvertible {\n    let x: Double, y: Double\n\n    var description: String {\n        return \"(\\(x), \\(y))\"\n    }\n}\n\n\nfunc perpendicularDistance(p: Point, p1: Point, p2: Point) -> Double {\n    let dx = p2.x - p1.x\n    let dy = p2.y - p1.y\n    let d = (p.x * dy - p.y * dx + p2.x * p1.y - p2.y * p1.x)\n    return abs(d)/(dx * dx + dy * dy).squareRoot()\n}\n\nfunc ramerDouglasPeucker(points: [Point], epsilon: Double) -> [Point] {\n    var result : [Point] = []\n    func rdp(begin: Int, end: Int) {\n        guard end > begin else {\n            return\n        }\n        var maxDist = 0.0\n        var index = 0\n        for i in begin+1..<end {\n            let dist = perpendicularDistance(p: points[i], p1: points[begin],\n                                             p2: points[end])\n            if dist > maxDist {\n                maxDist = dist\n                index = i\n            }\n        }\n        if maxDist > epsilon {\n            rdp(begin: begin, end: index)\n            rdp(begin: index, end: end)\n        } else {\n            result.append(points[end])\n        }\n    }\n    if points.count > 0 && epsilon >= 0.0 {\n        result.append(points[0])\n        rdp(begin: 0, end: points.count - 1)\n    }\n    return result\n}\n\nlet points = [\n    Point(x: 0.0, y: 0.0),\n    Point(x: 1.0, y: 0.1),\n    Point(x: 2.0, y: -0.1),\n    Point(x: 3.0, y: 5.0),\n    Point(x: 4.0, y: 6.0),\n    Point(x: 5.0, y: 7.0),\n    Point(x: 6.0, y: 8.1),\n    Point(x: 7.0, y: 9.0),\n    Point(x: 8.0, y: 9.0),\n    Point(x: 9.0, y: 9.0)\n]\nprint(\"\\(ramerDouglasPeucker(points: points, epsilon: 1.0))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 399665, "name": "Chebyshev coefficients", "source": "Translate Swift to C#: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 399666, "name": "Chebyshev coefficients", "source": "Translate Swift to C#: import Foundation\n\ntypealias DFunc = (Double) -> Double\n\nfunc mapRange(x: Double, min: Double, max: Double, minTo: Double, maxTo: Double) -> Double {\n  return (x - min) / (max - min) * (maxTo - minTo) + minTo\n}\n\nfunc chebCoeffs(fun: DFunc, n: Int, min: Double, max: Double) -> [Double] {\n  var res = [Double](repeating: 0, count: n)\n\n  for i in 0..<n {\n    let dI = Double(i)\n    let dN = Double(n)\n    let f = fun(mapRange(x: cos(.pi * (dI + 0.5) / dN), min: -1, max: 1, minTo: min, maxTo: max)) * 2.0 / dN\n\n    for j in 0..<n {\n      res[j] += f * cos(.pi * Double(j) * (dI + 0.5) / dN)\n    }\n  }\n\n  return res\n}\n\nfunc chebApprox(x: Double, n: Int, min: Double, max: Double, coeffs: [Double]) -> Double {\n  var a = 1.0\n  var b = mapRange(x: x, min: min, max: max, minTo: -1, maxTo: 1)\n  var res = coeffs[0] / 2.0 + coeffs[1] * b\n  let xx = 2 * b\n  var i = 2\n\n  while i < n {\n    let c = xx * b - a\n    res += coeffs[i] * c\n    (a, b) = (b, c)\n    i += 1\n  }\n\n  return res\n}\n\nlet coeffs = chebCoeffs(fun: cos, n: 10, min: 0, max: 1)\n\nprint(\"Coefficients\")\n\nfor coeff in coeffs {\n  print(String(format: \"%+1.15g\", coeff))\n}\n\nprint(\"\\nApproximations:\\n  x      func(x)     approx       diff\")\n\nfor i in stride(from: 0.0, through: 20, by: 1) {\n  let x = mapRange(x: i, min: 0, max: 20, minTo: 0, maxTo: 1)\n  let f = cos(x)\n  let approx = chebApprox(x: x, n: 10, min: 0, max: 1, coeffs: coeffs)\n\n  print(String(format: \"%1.3f  %1.8f  %1.8f \u00a0% 4.1e\", x, f, approx, approx - f))\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 399667, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to C#: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399668, "name": "Burrows\u2013Wheeler transform", "source": "Translate Swift to C#: import Foundation\n\nprivate let stx = \"\\u{2}\"\nprivate let etx = \"\\u{3}\"\n\nfunc bwt(_ str: String) -> String? {\n  guard !str.contains(stx), !str.contains(etx) else {\n    return nil\n  }\n\n  let ss = stx + str + etx\n  let table = ss.indices.map({i in ss[i...] + ss[ss.startIndex..<i] }).sorted()\n\n  return String(table.map({str in str.last!}))\n}\n\nfunc ibwt(_ str: String) -> String? {\n  let len = str.count\n  var table = Array(repeating: \"\", count: len)\n\n  for _ in 0..<len {\n    for i in 0..<len {\n      table[i] = String(str[str.index(str.startIndex, offsetBy: i)]) + table[i]\n    }\n\n    table.sort()\n  }\n\n  for row in table where row.hasSuffix(etx) {\n    return String(row.dropFirst().dropLast())\n  }\n\n  return nil\n}\n\n\nfunc readableBwt(_ str: String) -> String {\n  return str.replacingOccurrences(of: \"\\u{2}\", with: \"^\").replacingOccurrences(of: \"\\u{3}\", with: \"|\")\n}\n\nlet testCases = [\n  \"banana\",\n  \"appellee\",\n  \"dogwood\",\n  \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n  \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n  \"\\u{2}ABC\\u{3}\"\n]\n\nfor test in testCases {\n  let b = bwt(test) ?? \"error\"\n  let c = ibwt(b) ?? \"error\"\n\n  print(\"\\(readableBwt(test)) -> \\(readableBwt(b)) -> \\(readableBwt(c))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 399669, "name": "Peaceful chess queen armies", "source": "Translate Swift to C#: enum Piece {\n  case empty, black, white\n}\n\ntypealias Position = (Int, Int)\n\nfunc place(_ m: Int, _ n: Int, pBlackQueens: inout [Position], pWhiteQueens: inout [Position]) -> Bool {\n  guard m != 0 else {\n    return true\n  }\n\n  var placingBlack = true\n\n  for i in 0..<n {\n    inner: for j in 0..<n {\n      let pos = (i, j)\n\n      for queen in pBlackQueens where queen == pos || !placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      for queen in pWhiteQueens where queen == pos || placingBlack && isAttacking(queen, pos) {\n        continue inner\n      }\n\n      if placingBlack {\n        pBlackQueens.append(pos)\n        placingBlack = false\n      } else {\n        placingBlack = true\n\n        pWhiteQueens.append(pos)\n\n        if place(m - 1, n, pBlackQueens: &pBlackQueens, pWhiteQueens: &pWhiteQueens) {\n          return true\n        } else {\n          pBlackQueens.removeLast()\n          pWhiteQueens.removeLast()\n        }\n      }\n    }\n  }\n\n  if !placingBlack {\n    pBlackQueens.removeLast()\n  }\n\n  return false\n}\n\nfunc isAttacking(_ queen: Position, _ pos: Position) -> Bool {\n  queen.0 == pos.0 || queen.1 == pos.1 || abs(queen.0 - pos.0) == abs(queen.1 - pos.1)\n}\n\nfunc printBoard(n: Int, pBlackQueens: [Position], pWhiteQueens: [Position]) {\n  var board = Array(repeating: Piece.empty, count: n * n)\n\n  for queen in pBlackQueens {\n    board[queen.0 * n + queen.1] = .black\n  }\n\n  for queen in pWhiteQueens {\n    board[queen.0 * n + queen.1] = .white\n  }\n\n  for (i, p) in board.enumerated() {\n    if i != 0 && i % n == 0 {\n      print()\n    }\n\n    switch p {\n    case .black:\n      print(\"B \", terminator: \"\")\n    case .white:\n      print(\"W \", terminator: \"\")\n    case .empty:\n      let j = i / n\n      let k = i - j * n\n\n      if j % 2 == k % 2 {\n        print(\"\u2022 \", terminator: \"\")\n      } else {\n        print(\"\u25e6 \", terminator: \"\")\n      }\n    }\n  }\n\n  print(\"\\n\")\n}\n\nlet nms = [\n  (2, 1), (3, 1), (3, 2), (4, 1), (4, 2), (4, 3),\n  (5, 1), (5, 2), (5, 3), (5, 4), (5, 5),\n  (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6),\n  (7, 1), (7, 2), (7, 3), (7, 4), (7, 5), (7, 6), (7, 7)\n]\n\nfor (n, m) in nms {\n  print(\"\\(m) black and white queens on \\(n) x \\(n) board\")\n\n  var blackQueens = [Position]()\n  var whiteQueens = [Position]()\n\n  if place(m, n, pBlackQueens: &blackQueens, pWhiteQueens: &whiteQueens) {\n    printBoard(n: n, pBlackQueens: blackQueens, pWhiteQueens: whiteQueens)\n  } else {\n    print(\"No solution\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PeacefulChessQueenArmies {\n    using Position = Tuple<int, int>;\n\n    enum Piece {\n        Empty,\n        Black,\n        White\n    }\n\n    class Program {\n        static bool IsAttacking(Position queen, Position pos) {\n            return queen.Item1 == pos.Item1\n                || queen.Item2 == pos.Item2\n                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);\n        }\n\n        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n            if (m == 0) {\n                return true;\n            }\n            bool placingBlack = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    var pos = new Position(i, j);\n                    foreach (var queen in pBlackQueens) {\n                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    foreach (var queen in pWhiteQueens) {\n                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    if (placingBlack) {\n                        pBlackQueens.Add(pos);\n                        placingBlack = false;\n                    } else {\n                        pWhiteQueens.Add(pos);\n                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                            return true;\n                        }\n                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);\n                        placingBlack = true;\n                    }\n                inner: { }\n                }\n            }\n            if (!placingBlack) {\n                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n            }\n            return false;\n        }\n\n        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n            var board = new Piece[n * n];\n\n            foreach (var queen in blackQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.Black;\n            }\n            foreach (var queen in whiteQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.White;\n            }\n\n            for (int i = 0; i < board.Length; i++) {\n                if (i != 0 && i % n == 0) {\n                    Console.WriteLine();\n                }\n                switch (board[i]) {\n                    case Piece.Black:\n                        Console.Write(\"B \");\n                        break;\n                    case Piece.White:\n                        Console.Write(\"W \");\n                        break;\n                    case Piece.Empty:\n                        int j = i / n;\n                        int k = i - j * n;\n                        if (j % 2 == k % 2) {\n                            Console.Write(\"  \");\n                        } else {\n                            Console.Write(\"# \");\n                        }\n                        break;\n                }\n            }\n\n            Console.WriteLine(\"\\n\");\n        }\n\n        static void Main() {\n            var nms = new int[,] {\n                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n            };\n            for (int i = 0; i < nms.GetLength(0); i++) {\n                Console.WriteLine(\"{0} black and {0} white queens on a {1} x {1} board:\", nms[i, 1], nms[i, 0]);\n                List<Position> blackQueens = new List<Position>();\n                List<Position> whiteQueens = new List<Position>();\n                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {\n                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);\n                } else {\n                    Console.WriteLine(\"No solution exists.\\n\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399670, "name": "N-body problem", "source": "Translate Swift to C#: import Foundation\n\npublic struct Vector {\n  public var px = 0.0\n  public var py = 0.0\n  public var pz = 0.0\n\n  public init(px: Double, py: Double, pz: Double) {\n    (self.px, self.py, self.pz) = (px, py, pz)\n  }\n\n  public init?(array: [Double]) {\n    guard array.count == 3 else {\n      return nil\n    }\n\n    (self.px, self.py, self.pz) = (array[0], array[1], array[2])\n  }\n\n  public func mod() -> Double {\n    (px * px + py * py + pz * pz).squareRoot()\n  }\n\n  static func + (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px + rhs.px,\n      py: lhs.py + rhs.py,\n      pz: lhs.pz + rhs.pz\n    )\n  }\n\n  static func - (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      px: lhs.px - rhs.px,\n      py: lhs.py - rhs.py,\n      pz: lhs.pz - rhs.pz\n    )\n  }\n\n  static func * (lhs: Vector, rhs: Double) -> Vector {\n    return Vector(\n      px: lhs.px * rhs,\n      py: lhs.py * rhs,\n      pz: lhs.pz * rhs\n    )\n  }\n}\n\nextension Vector {\n  public static let origin = Vector(px: 0, py: 0, pz: 0)\n}\n\nextension Vector: Equatable {\n  public static func == (lhs: Vector, rhs: Vector) -> Bool {\n    return lhs.px == rhs.px && lhs.py == rhs.py && lhs.pz == rhs.pz\n  }\n}\n\nextension Vector: CustomStringConvertible {\n  public var description: String {\n    return String(format: \"%.6f\\t%.6f\\t%.6f\", px, py, pz)\n  }\n}\n\npublic class NBody {\n  public let gravitationalConstant: Double\n  public let numBodies: Int\n  public let timeSteps: Int\n\n  public private(set) var masses: [Double]\n  public private(set) var positions: [Vector]\n  public private(set) var velocities: [Vector]\n  public private(set) var accelerations: [Vector]\n\n  public init?(file: String) {\n    guard let data = try? String(contentsOfFile: file) else {\n      return nil\n    }\n\n    print(\"Input file:\\n\\(data)\")\n\n    let lines = data.components(separatedBy: \"\\n\").map({ $0.components(separatedBy: \" \") })\n\n    let worldData = lines.first!\n\n    guard worldData.count == 3,\n          let gc = Double(worldData[0]),\n          let bodies = Int(worldData[1]),\n          let timeSteps = Int(worldData[2]) else {\n      return nil\n    }\n\n    let defaultState = Array(repeating: Vector.origin, count: bodies)\n\n    self.gravitationalConstant = gc\n    self.numBodies = bodies\n    self.timeSteps = timeSteps\n    self.masses = Array(repeating: 0, count: bodies)\n    self.positions = defaultState\n    self.accelerations = defaultState\n    self.velocities = defaultState\n\n    let bodyData = lines.dropFirst().map({ $0.compactMap(Double.init) })\n\n    guard bodyData.count == bodies * 3 else {\n      return nil\n    }\n\n    for n in 0..<bodies {\n      masses[n] = bodyData[0 + n * 3][0]\n\n      guard let position = Vector(array: bodyData[1 + n * 3]),\n            let velocity = Vector(array: bodyData[2 + n * 3]) else {\n        return nil\n      }\n\n      positions[n] = position\n      velocities[n] = velocity\n    }\n  }\n\n  private func computeAccelerations() {\n    for i in 0..<numBodies {\n      accelerations[i] = .origin\n\n      for j in 0..<numBodies where i != j {\n        let t = gravitationalConstant * masses[j] / pow((positions[i] - positions[j]).mod(), 3)\n        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * t\n      }\n    }\n  }\n\n  private func resolveCollisions() {\n    for i in 0..<numBodies {\n      for j in 0..<numBodies where positions[i] == positions[j] {\n        velocities.swapAt(i, j)\n      }\n    }\n  }\n\n  private func computeVelocities() {\n    for i in 0..<numBodies {\n      velocities[i] = velocities[i] + accelerations[i]\n    }\n  }\n\n  private func computePositions() {\n    for i in 0..<numBodies {\n      positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5\n    }\n  }\n\n  public func printState() {\n    for i in 0..<numBodies {\n      print(\"Body \\(i + 1): \\(positions[i])  |  \\(velocities[i])\")\n    }\n  }\n\n  public func simulate() {\n    computeAccelerations()\n    computePositions()\n    computeVelocities()\n    resolveCollisions()\n  }\n}\n\nguard let sim = NBody(file: \"input.txt\") else {\n  fatalError()\n}\n\nprint()\nprint(\"Body  \u00a0:      x          y          z    |     vx         vy         vz\")\n\nfor i in 0..<sim.timeSteps {\n  print(\"Step \\(i + 1)\")\n  sim.simulate()\n  sim.printState()\n  print()\n}\n", "target": "using System;\nusing System.IO;\n\nnamespace NBodyProblem {\n    class Vector3D {\n        public Vector3D(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; }\n        public double Y { get; }\n        public double Z { get; }\n\n        public double Mod() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z);\n        }\n\n        public static Vector3D operator *(Vector3D lhs, double rhs) {\n            return new Vector3D(lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs);\n        }\n    }\n\n    class NBody {\n        private readonly double gc;\n        private readonly int bodies;\n        private readonly int timeSteps;\n        private readonly double[] masses;\n        private readonly Vector3D[] positions;\n        private readonly Vector3D[] velocities;\n        private readonly Vector3D[] accelerations;\n\n        public NBody(string fileName) {\n            string[] lines = File.ReadAllLines(fileName);\n\n            string[] gbt = lines[0].Split();\n            gc = double.Parse(gbt[0]);\n            bodies = int.Parse(gbt[1]);\n            timeSteps = int.Parse(gbt[2]);\n\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            velocities = new Vector3D[bodies];\n            accelerations = new Vector3D[bodies];\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = double.Parse(lines[i * 3 + 1]);\n                positions[i] = Decompose(lines[i * 3 + 2]);\n                velocities[i] = Decompose(lines[i * 3 + 3]);\n            }\n\n            Console.WriteLine(\"Contents of {0}\", fileName);\n            foreach (string line in lines) {\n                Console.WriteLine(line);\n            }\n            Console.WriteLine();\n            Console.Write(\"Body  \u00a0:      x          y          z    |\");\n            Console.WriteLine(\"     vx         vy         vz\");\n        }\n\n        public int GetTimeSteps() {\n            return timeSteps;\n        }\n\n        private Vector3D Decompose(string line) {\n            string[] xyz = line.Split();\n            double x = double.Parse(xyz[0]);\n            double y = double.Parse(xyz[1]);\n            double z = double.Parse(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void ComputeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = new Vector3D(0, 0, 0);\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.Pow((positions[i] - positions[j]).Mod(), 3);\n                        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * temp;\n                    }\n                }\n            }\n        }\n\n        private void ComputeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i] + accelerations[i];\n            }\n        }\n\n        private void ComputePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5;\n            }\n        }\n\n        private void ResolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].X == positions[j].X\n                     && positions[i].Y == positions[j].Y\n                     && positions[i].Z == positions[j].Z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        public void Simulate() {\n            ComputeAccelerations();\n            ComputePositions();\n            ComputeVelocities();\n            ResolveCollisions();\n        }\n\n        public void PrintResults() {\n            for (int i = 0; i < bodies; ++i) {\n                Console.WriteLine(\n                    \"Body {0}\u00a0: {1,9:F6}  {2,9:F6}  {3,9:F6} | {4,9:F6}  {5,9:F6}  {6,9:F6}\",\n                    i + 1,\n                    positions[i].X, positions[i].Y, positions[i].Z,\n                    velocities[i].X, velocities[i].Y, velocities[i].Z\n                );\n            }\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            NBody nb = new NBody(\"nbody.txt\");\n\n            for (int i = 0; i < nb.GetTimeSteps(); ++i) {\n                Console.WriteLine();\n                Console.WriteLine(\"Cycle {0}\", i + 1);\n                nb.Simulate();\n                nb.PrintResults();\n            }\n        }\n    }\n}\n"}
{"id": 399671, "name": "Zumkeller numbers", "source": "Translate Swift to C#: import Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public var isZumkeller: Bool {\n    let divs = factors(sorted: false)\n    let sum = divs.reduce(0, +)\n\n    guard sum & 1 != 1 else {\n      return false\n    }\n\n    guard self & 1 != 1 else {\n      let abundance = sum - 2*self\n\n      return abundance > 0 && abundance & 1 == 0\n    }\n\n    return isPartSum(divs: divs[...], sum: sum / 2)\n  }\n\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@usableFromInline\nfunc isPartSum<T: BinaryInteger>(divs: ArraySlice<T>, sum: T) -> Bool {\n  guard sum != 0 else {\n    return true\n  }\n\n  guard !divs.isEmpty else {\n    return false\n  }\n\n  let last = divs.last!\n\n  if last > sum {\n    return isPartSum(divs: divs.dropLast(), sum: sum)\n  }\n\n  return isPartSum(divs: divs.dropLast(), sum: sum) || isPartSum(divs: divs.dropLast(), sum: sum - last)\n}\n\nlet zums = (2...).lazy.filter({ $0.isZumkeller })\nlet oddZums = zums.filter({ $0 & 1 == 1 })\nlet oddZumsWithout5 = oddZums.filter({ String($0).last! != \"5\" })\n\nprint(\"First 220 zumkeller numbers are \\(Array(zums.prefix(220)))\")\nprint(\"First 40 odd zumkeller numbers are \\(Array(oddZums.prefix(40)))\")\nprint(\"First 40 odd zumkeller numbers that don't end in a 5 are: \\(Array(oddZumsWithout5.prefix(40)))\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 399672, "name": "Commatizing numbers", "source": "Translate Swift to C#: import Foundation\n\nextension String {\n  private static let commaReg = try! NSRegularExpression(pattern: \"(\\\\.[0-9]+|[1-9]([0-9]+)?(\\\\.[0-9]+)?)\")\n\n  public func commatize(start: Int = 0, period: Int = 3, separator: String = \",\") -> String {\n    guard separator != \"\" else {\n      return self\n    }\n\n    let sep = Array(separator)\n    let startIdx = index(startIndex, offsetBy: start)\n    let matches = String.commaReg.matches(in: self, range: NSRange(startIdx..., in: self))\n\n    guard !matches.isEmpty else {\n      return self\n    }\n\n    let fullMatch = String(self[Range(matches.first!.range(at: 0), in: self)!])\n    let splits = fullMatch.components(separatedBy: \".\")\n    var ip = splits[0]\n\n    if ip.count > period {\n      var builder = Array(ip.reversed())\n\n      for i in stride(from: (ip.count - 1) / period * period, through: period, by: -period) {\n        builder.insert(contentsOf: sep, at: i)\n      }\n\n      ip = String(builder.reversed())\n    }\n\n    if fullMatch.contains(\".\") {\n      var dp = splits[1]\n\n      if dp.count > period {\n        var builder = Array(dp)\n\n        for i in stride(from: (dp.count - 1) / period * period, through: period, by: -period) {\n          builder.insert(contentsOf: sep, at: i)\n        }\n\n        dp = String(builder)\n      }\n\n      ip += \".\" + dp\n    }\n\n    return String(prefix(start)) + String(dropFirst(start)).replacingOccurrences(of: fullMatch, with: ip)\n  }\n}\n\nlet tests = [\n  \"123456789.123456789\",\n  \".123456789\",\n  \"57256.1D-4\",\n  \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n  \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n  \"-in Aus$+1411.8millions\",\n  \"===US$0017440 millions=== (in 2000 dollars)\",\n  \"123.e8000 is pretty big.\",\n  \"The land area of the earth is 57268900(29% of the surface) square miles.\",\n  \"Ain't no numbers in this here words, nohow, no way, Jose.\",\n  \"James was never known as 0000000007\",\n  \"Arthur Eddington wrote: I believe there are \" +\n      \"15747724136275002577605653961181555468044717914527116709366231425076185631031296\" +\n      \" protons in the universe.\",\n  \"   $-140000\u00b1100 millions.\",\n  \"6/9/1946 was a good year for some.\"\n]\n\nprint(tests[0].commatize(period: 2, separator: \"*\"))\nprint(tests[1].commatize(period: 3, separator: \"-\"))\nprint(tests[2].commatize(period: 4, separator: \"__\"))\nprint(tests[3].commatize(period: 5, separator: \" \"))\nprint(tests[4].commatize(separator: \".\"))\n\nfor testCase in tests.dropFirst(5) {\n  print(testCase.commatize())\n}\n", "target": "static string[] inputs = {\n\t\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n\t\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n\t\"\\\"-in Aus$+1411.8millions\\\"\",\n\t\"===US$0017440 millions=== (in 2000 dollars)\"\n};\n\nvoid Main()\n{\n\tinputs.Select(s => Commatize(s, 0, 3, \",\"))\n              .ToList()\n              .ForEach(Console.WriteLine);\n}\n\nstring Commatize(string text, int startPosition, int interval, string separator)\n{\n\tvar matches = Regex.Matches(text.Substring(startPosition), \"[0-9]*\");\n\tvar x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();\n\treturn string.Join(\"\", x);\n}\n\n\nstring Commatize(Match match, int interval, string separator, string original)\n{\n\tif (match.Length <= interval)\n\t\treturn original.Substring(match.Index, \n                match.Index == original.Length ? 0 : Math.Max(match.Length, 1));\n\t\n\treturn string.Join(separator, match.Value.Split(interval));\n}\n\npublic static class Extension\n{\n\tpublic static string[] Split(this string source, int interval)\n\t{\n\t\treturn SplitImpl(source, interval).ToArray();\n\t}\n\t\n\tstatic IEnumerable<string>SplitImpl(string source, int interval)\n\t{\n\t\tfor\t(int i = 1; i < source.Length; i++)\n\t\t{\n\t\t\tif (i % interval != 0) continue;\n\t\t\t\n\t\t\tyield return source.Substring(i - interval, interval);\n\t\t}\n\t}\n}\n"}
{"id": 399673, "name": "Kosaraju", "source": "Translate Swift to C#: func kosaraju(graph: [[Int]]) -> [Int] {\n  let size = graph.count\n  var x = size\n  var vis = [Bool](repeating: false, count: size)\n  var l = [Int](repeating: 0, count: size)\n  var c = [Int](repeating: 0, count: size)\n  var t = [[Int]](repeating: [], count: size)\n\n  func visit(_ u: Int) {\n    guard !vis[u] else {\n      return\n    }\n\n    vis[u] = true\n\n    for v in graph[u] {\n      visit(v)\n      t[v].append(u)\n    }\n\n    x -= 1\n    l[x] = u\n  }\n\n  for u in 0..<graph.count {\n    visit(u)\n  }\n\n  func assign(_ u: Int, root: Int) {\n    guard vis[u] else {\n      return\n    }\n\n    vis[u] = false\n    c[u] = root\n\n    for v in t[u] {\n      assign(v, root: root)\n    }\n  }\n\n  for u in l {\n    assign(u, root: u)\n  }\n\n  return c\n}\n\nlet graph = [\n  [1],\n  [2],\n  [0],\n  [1, 2, 4],\n  [3, 5],\n  [2, 6],\n  [5],\n  [4, 6, 7]\n]\n\nprint(kosaraju(graph: graph))\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n\tpublic enum Colors\n\t{\n\t\tBlack, White, Gray\n\t}\n\n\tpublic Colors color { get; set; }\n\tpublic int N { get; }\n\t\n\tpublic Node(int n)\n\t{\n\t\tN = n;\n\t\tcolor = Colors.White;\n\t}\n}\n\nclass Graph\n{\n\tpublic HashSet<Node> V { get; }\n\tpublic Dictionary<Node, HashSet<Node>> Adj { get; }\n\n\t\n\t\n\t\n\tpublic void Kosaraju()\n\t{\n\t\tvar L = new HashSet<Node>();\n\n\t\tAction<Node> Visit = null;\n\t\tVisit = (u) =>\n\t\t{\n\t\t\tif (u.color == Node.Colors.White)\n\t\t\t{\n\t\t\t\tu.color = Node.Colors.Gray;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tVisit(v);\n\n\t\t\t\tL.Add(u);\n\t\t\t}\n\t\t};\n\n\t\tAction<Node, Node> Assign = null;\n\t\tAssign = (u, root) =>\n\t\t{\n\t\t\tif (u.color != Node.Colors.Black)\n\t\t\t{\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.Write(\"SCC: \");\n\n\t\t\t\tConsole.Write(u.N + \" \");\n\t\t\t\tu.color = Node.Colors.Black;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tAssign(v, root);\n\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t};\n\n\t\tforeach (var u in V)\n\t\t\tVisit(u);\n\n\t\tforeach (var u in L)\n\t\t\tAssign(u, u);\n\t}\n}\n"}
{"id": 399674, "name": "Markov chain text generator", "source": "Translate Swift to C#: import Foundation\n\nfunc makeRule(input: String, keyLength: Int) -> [String: [String]] {\n  let words = input.components(separatedBy: \" \")\n  var rules = [String: [String]]()\n  var i = keyLength\n  \n  for word in words[i...] {\n    let key = words[i-keyLength..<i].joined(separator: \" \")\n    \n    rules[key, default: []].append(word)\n    \n    i += 1\n  }\n  \n  return rules\n}\n\nfunc makeString(rule: [String: [String]], length: Int) -> String {\n  var oldWords = rule.keys.randomElement()!.components(separatedBy: \" \")\n  var string = oldWords.joined(separator: \" \") + \" \"\n  \n  for _ in 0..<length {\n    let key = oldWords.joined(separator: \" \")\n    guard let newWord = rule[key]?.randomElement() else { return string }\n    \n    string += newWord + \" \"\n    \n    for ii in 0..<oldWords.count {\n      oldWords[ii] = oldWords[(ii + 1) % oldWords.count]\n    }\n    \n    oldWords[oldWords.index(before: oldWords.endIndex)] = newWord\n  }\n  \n  return string\n}\n\nlet inputLoc = CommandLine.arguments.dropFirst().first!\nlet input = FileManager.default.contents(atPath: inputLoc)!\nlet inputStr = String(data: input, encoding: .utf8)!\nlet rule = makeRule(input: inputStr, keyLength: 3)\nlet str = makeString(rule: rule, length: 300)\n\nprint(str)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace MarkovChainTextGenerator {\n    class Program {\n        static string Join(string a, string b) {\n            return a + \" \" + b;\n        }\n\n        static string Markov(string filePath, int keySize, int outputSize) {\n            if (keySize < 1) throw new ArgumentException(\"Key size can't be less than 1\");\n\n            string body;\n            using (StreamReader sr = new StreamReader(filePath)) {\n                body = sr.ReadToEnd();\n            }\n            var words = body.Split();\n            if (outputSize < keySize || words.Length < outputSize) {\n                throw new ArgumentException(\"Output size is out of range\");\n            }\n\n            Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\n            for (int i = 0; i < words.Length - keySize; i++) {\n                var key = words.Skip(i).Take(keySize).Aggregate(Join);\n                string value;\n                if (i + keySize < words.Length) {\n                    value = words[i + keySize];\n                } else {\n                    value = \"\";\n                }\n\n                if (dict.ContainsKey(key)) {\n                    dict[key].Add(value);\n                } else {\n                    dict.Add(key, new List<string>() { value });\n                }\n            }\n\n            Random rand = new Random();\n            List<string> output = new List<string>();\n            int n = 0;\n            int rn = rand.Next(dict.Count);\n            string prefix = dict.Keys.Skip(rn).Take(1).Single();\n            output.AddRange(prefix.Split());\n\n            while (true) {\n                var suffix = dict[prefix];\n                if (suffix.Count == 1) {\n                    if (suffix[0] == \"\") {\n                        return output.Aggregate(Join);\n                    }\n                    output.Add(suffix[0]);\n                } else {\n                    rn = rand.Next(suffix.Count);\n                    output.Add(suffix[rn]);\n                }\n                if (output.Count >= outputSize) {\n                    return output.Take(outputSize).Aggregate(Join);\n                }\n                n++;\n                prefix = output.Skip(n).Take(keySize).Aggregate(Join);\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(Markov(\"alice_oz.txt\", 3, 200));\n        }\n    }\n}\n"}
{"id": 399675, "name": "Partition function P", "source": "Translate Swift to C#: import BigInt \n\nfunc partitions(n: Int) -> BigInt {\n  var p = [BigInt(1)]\n\n  for i in 1...n {\n    var num = BigInt(0)\n    var k = 1\n\n    while true {\n      var j = (k * (3 * k - 1)) / 2\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      j += k\n\n      if j > i {\n        break\n      }\n\n      if k & 1 == 1 {\n        num += p[i - j]\n      } else {\n        num -= p[i - j]\n      }\n\n      k += 1\n    }\n\n    p.append(num)\n  }\n\n  return p[n]\n}\n\nprint(\"partitions(6666) = \\(partitions(n: 6666))\")\n", "target": "using System;\n\nclass Program {\n\n    const long Lm = (long)1e18;\n    const string Fm = \"D18\";\n\n    \n    struct LI { public long lo, ml, mh, hi, tp; }\n\n    static void inc(ref LI d, LI s) { \n        if ((d.lo += s.lo) >= Lm) { d.ml++; d.lo -= Lm; }\n        if ((d.ml += s.ml) >= Lm) { d.mh++; d.ml -= Lm; }\n        if ((d.mh += s.mh) >= Lm) { d.hi++; d.mh -= Lm; }\n        if ((d.hi += s.hi) >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n \n    static void dec(ref LI d, LI s) { \n        if ((d.lo -= s.lo) < 0) { d.ml--; d.lo += Lm; }\n        if ((d.ml -= s.ml) < 0) { d.mh--; d.ml += Lm; }\n        if ((d.mh -= s.mh) < 0) { d.hi--; d.mh += Lm; }\n        if ((d.hi -= s.hi) < 0) { d.tp--; d.hi += Lm; }\n        d.tp -= s.tp;\n    }\n\n    static LI set(long s) { LI d;\n      d.lo = s; d.ml = d.mh = d.hi = d.tp = 0; return d; }\n\n  static string fmt(LI x) { \n    if (x.tp > 0) return x.tp.ToString() + x.hi.ToString(Fm) + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.hi > 0) return x.hi.ToString() + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.mh > 0) return x.mh.ToString() + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.ml > 0) return x.ml.ToString() + x.lo.ToString(Fm);\n    return x.lo.ToString();\n  }\n\n  static LI partcount(int n) {\n    var P = new LI[n + 1]; P[0] = set(1);\n    for (int i = 1; i <= n; i++) {\n      int k = 0, d = -2, j = i;\n      LI x = set(0);\n      while (true) {\n        if ((j -= (d += 3) -k) >= 0) inc(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) inc(ref x, P[j]); else break;\n        if ((j -= (d += 3) -k) >= 0) dec(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) dec(ref x, P[j]); else break;\n      }\n      P[i] = x;\n    }\n    return P[n];\n  }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew ();\n    var res = partcount(6666); sw.Stop();\n    Console.Write(\"{0}  {1} ms\", fmt(res), sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 399676, "name": "Special divisors", "source": "Translate Swift to C#: import Foundation\n\nfunc reverse(_ number: Int) -> Int {\n    var rev = 0\n    var n = number\n    while n > 0 {\n        rev = rev * 10 + n % 10\n        n /= 10\n    }\n    return rev\n}\n\nfunc special(_ number: Int) -> Bool {\n    var n = 2\n    let rev = reverse(number)\n    while n * n <= number {\n        if number % n == 0 {\n            if rev % reverse(n) != 0 {\n                return false\n            }\n            let m = number / n\n            if m != n && rev % reverse(m) != 0 {\n                return false\n            }\n        }\n        n += 1\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<200 {\n    if special(n) {\n        count += 1\n        print(String(format: \"%3d\", n),\n              terminator: count % 10 == 0 ? \"\\n\" : \" \")\n    }\n}\nprint(\"\\n\\(count) numbers found.\")\n", "target": "using System;\n\nnamespace SpecialDivisors {\n    class Program {\n        static int Reverse(int n) {\n            int result = 0;\n            while (n > 0) {\n                result = 10 * result + n % 10;\n                n /= 10;\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int LIMIT = 200;\n\n            int row = 0;\n            int num = 0;\n\n            for (int n = 1; n < LIMIT; n++) {\n                bool flag = true;\n                int revNum = Reverse(n);\n\n                for (int m = 1; m < n / 2; m++) {\n                    int revDiv = Reverse(m);\n                    if (n % m == 0) {\n                        if (revNum % revDiv == 0) {\n                            flag = true;\n                        } else {\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (flag) {\n                    num++;\n                    row++;\n                    Console.Write(\"{0,4}\", n);\n                    if (row % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine();\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} special divisors N that reverse(D) divides reverse(N) for all divisors D of N, where N < 200\", num);\n        }\n    }\n}\n"}
{"id": 399677, "name": "Minimal steps down to 1", "source": "Translate Swift to C#: func minToOne(divs: [Int], subs: [Int], upTo n: Int) -> ([Int], [[String]]) {\n  var table = Array(repeating: n + 2, count: n + 1)\n  var how = Array(repeating: [\"\"], count: n + 2)\n\n  table[1] = 0\n  how[1] = [\"=\"]\n\n  for t in 1..<n {\n    let thisPlus1 = table[t] + 1\n\n    for div in divs {\n      let dt = div * t\n\n      if dt <= n && thisPlus1 < table[dt] {\n        table[dt] = thisPlus1\n        how[dt] = how[t] + [\"/\\(div)=>  \\(t)\"]\n      }\n    }\n\n    for sub in subs {\n      let st = sub + t\n\n      if st <= n && thisPlus1 < table[st] {\n        table[st] = thisPlus1\n        how[st] = how[t] + [\"-\\(sub)=> \\(t)\"]\n      }\n    }\n  }\n\n  return (table, how.map({ $0.reversed().dropLast() }))\n}\n\nfor (divs, subs) in [([2, 3], [1]), ([2, 3], [2])] {\n  print(\"\\nMINIMUM STEPS TO 1:\")\n  print(\"  Possible divisors:  \\(divs)\")\n  print(\"  Possible decrements: \\(subs)\")\n\n  let (table, hows) = minToOne(divs: divs, subs: subs, upTo: 10)\n\n  for n in 1...10 {\n    print(\"    mintab(  \\(n)) in {  \\(table[n])} by: \", hows[n].joined(separator: \", \"))\n  }\n\n  for upTo in [2_000, 50_000] {\n    print(\"\\n    Those numbers up to \\(upTo) that take the maximum, \\\"minimal steps down to 1\\\":\")\n    let (table, _) = minToOne(divs: divs, subs: subs, upTo: upTo)\n    let max = table.dropFirst().max()!\n    let maxNs = table.enumerated().filter({ $0.element == max })\n\n    print(\n      \"      Taking\", max, \"steps are the \\(maxNs.count) numbers:\",\n      maxNs.map({ String($0.offset) }).joined(separator: \", \")\n    )\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MinimalSteps\n{\n    public static void Main() {\n        var (divisors, subtractors) = (new int[] { 2, 3 }, new [] { 1 });\n        var lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n        Console.WriteLine();\n\n        subtractors = new [] { 2 };\n        lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n    }\n\n    private static void PrintRange((char op, int param, int steps)[] lookup, int limit) {\n        for (int goal = 1; goal <= limit; goal++) {\n            var x = lookup[goal];\n            if (x.param == 0) {\n                Console.WriteLine($\"{goal} cannot be reached with these numbers.\");\n                continue;\n            }\n            Console.Write($\"{goal} takes {x.steps} {(x.steps == 1\u00a0? \"step\"\u00a0: \"steps\")}: \");\n            for (int n = goal; n > 1; ) {\n                Console.Write($\"{n},{x.op}{x.param}=> \");\n                n = x.op == '/' ? n / x.param : n - x.param;\n                x = lookup[n];\n            }\n            Console.WriteLine(\"1\");\n        }\n    }\n\n    private static void PrintMaxMins((char op, int param, int steps)[] lookup) {\n        var maxSteps = lookup.Max(x => x.steps);\n        var items = lookup.Select((x, i) => (i, x)).Where(t => t.x.steps == maxSteps).ToList();\n        Console.WriteLine(items.Count == 1\n            ? $\"There is one number below {lookup.Length-1} that requires {maxSteps} steps: {items[0].i}\"\n            : $\"There are {items.Count} numbers below {lookup.Length-1} that require {maxSteps} steps: {items.Select(t => t.i).Delimit()}\"\n        );\n    }\n\n    private static (char op, int param, int steps)[] CreateLookup(int goal, int[] divisors, int[] subtractors)\n    {\n        var lookup = new (char op, int param, int steps)[goal+1];\n        lookup[1] = ('/', 1, 0);\n        for (int n = 1; n < lookup.Length; n++) {\n            var ln = lookup[n];\n            if (ln.param == 0) continue;\n            for (int d = 0; d < divisors.Length; d++) {\n                int target = n * divisors[d];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('/', divisors[d], ln.steps + 1);\n            }\n            for (int s = 0; s < subtractors.Length; s++) {\n                int target = n + subtractors[s];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('-', subtractors[s], ln.steps + 1);\n            }\n        }\n        return lookup;\n    }\n\n    private static string Delimit<T>(this IEnumerable<T> source) => string.Join(\", \", source);\n}\n"}
{"id": 399678, "name": "Idoneal numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isIdoneal(_ n: Int) -> Bool {\n    for a in 1..<n {\n        for b in a + 1..<n {\n            if a * b + a + b > n {\n                break\n            }\n            for c in b + 1..<n {\n                let sum = a * b + b * c + a * c\n                if sum == n {\n                    return false\n                }\n                if sum > n {\n                    break\n                }\n            }\n        }\n    }\n    return true\n}\n\nvar count = 0\nfor n in 1..<1850 {\n    if isIdoneal(n) {\n        count += 1\n        print(String(format: \"%4d\", n), terminator: count % 13 == 0 ? \"\\n\" : \" \")\n    }\n}\n", "target": "using System;\n\nclass Program {\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    int a, b, c, i, n, s3, ab; var res = new int[65];\n    for (n = 1, i = 0; n < 1850; n++) {\n      bool found = true;\n      for (a = 1; a < n; a++)\n         for (b = a + 1, ab = a * b + a + b; b < n; b++, ab += a + 1) {\n            if (ab > n) break;\n            for (c = b + 1, s3 = ab + (b + a) * b; c < n; c++, s3 += b + a) {\n                if (s3 == n) found = false;\n                if (s3 >= n) break;\n            }\n         }\n      if (found) res[i++] = n;\n    }\n    sw.Stop();\n    Console.WriteLine(\"The 65 known Idoneal numbers:\");\n    for (i = 0; i < res.Length; i++)\n      Console.Write(\"{0,5}{1}\", res[i], i % 13 == 12 ? \"\\n\" : \"\");\n    Console.Write(\"Calculations took {0} ms\", sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}

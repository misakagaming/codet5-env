{"id": 234, "name": "Arithmetic_Integer", "source": "Translate Swift to C#: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 236, "name": "Arithmetic_Integer", "source": "Translate Swift to Java: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 237, "name": "Arithmetic_Integer", "source": "Translate Swift to Python: let a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 475, "name": "Null object", "source": "Translate Swift to Java: let maybeInt: Int? = nil\n", "target": "module NullObject\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print($\"Null value={Null}, Null.toString()={Null.toString()}\");\n\n     \n        String? s = Null;       \n        String s2 = \"test\";\n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n\n     \n        Int len = s?.size : 0;\n        console.print($\"len={len}\");\n\n        if (String test ?= s)\n            {\n            \n            }\n        else\n            {\n            s = \"a non-null value\";\n            }\n\n     \n        s2 = s;                 \n        console.print($\"s={s}, s2={s2}, (s==s2)={s==s2}\");\n        }\n    }\n"}
{"id": 476, "name": "Null object", "source": "Translate Swift to Python: let maybeInt: Int? = nil\n", "target": "x = None\nif x is None:\n  print \"x is None\"\nelse:\n  print \"x is not None\"\n"}
{"id": 726, "name": "Percentage difference between images", "source": "Translate Swift to C#: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "using System;\nusing System.Drawing;\n\nclass Program\n{\n    static void Main()\n    {\n        Bitmap img1 = new Bitmap(\"Lenna50.jpg\");\n        Bitmap img2 = new Bitmap(\"Lenna100.jpg\");\n\n        if (img1.Size != img2.Size)\n        {\n            Console.Error.WriteLine(\"Images are of different sizes\");\n            return;\n        }\n\n        float diff = 0;\n\n        for (int y = 0; y < img1.Height; y++)\n        {\n            for (int x = 0; x < img1.Width; x++)\n            {\n                Color pixel1 = img1.GetPixel(x, y);\n                Color pixel2 = img2.GetPixel(x, y);\n\n                diff += Math.Abs(pixel1.R - pixel2.R);\n                diff += Math.Abs(pixel1.G - pixel2.G);\n                diff += Math.Abs(pixel1.B - pixel2.B);\n            }\n        }\n\n        Console.WriteLine(\"diff: {0}\u00a0%\", 100 * (diff / 255) / (img1.Width * img1.Height * 3));\n    }\n}\n"}
{"id": 728, "name": "Percentage difference between images", "source": "Translate Swift to Java: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImgDiffPercent {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        \n        \n        BufferedImage img1 = ImageIO.read(new File(\"Lenna50.jpg\"));\n        BufferedImage img2 = ImageIO.read(new File(\"Lenna100.jpg\"));\n\n        double p = getDifferencePercent(img1, img2);\n        System.out.println(\"diff percent: \" + p);\n    }\n\n    private static double getDifferencePercent(BufferedImage img1, BufferedImage img2) {\n        int width = img1.getWidth();\n        int height = img1.getHeight();\n        int width2 = img2.getWidth();\n        int height2 = img2.getHeight();\n        if (width != width2 || height != height2) {\n            throw new IllegalArgumentException(String.format(\"Images must have the same dimensions: (%d,%d) vs. (%d,%d)\", width, height, width2, height2));\n        }\n\n        long diff = 0;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                diff += pixelDiff(img1.getRGB(x, y), img2.getRGB(x, y));\n            }\n        }\n        long maxDiff = 3L * 255 * width * height;\n\n        return 100.0 * diff / maxDiff;\n    }\n\n    private static int pixelDiff(int rgb1, int rgb2) {\n        int r1 = (rgb1 >> 16) & 0xff;\n        int g1 = (rgb1 >>  8) & 0xff;\n        int b1 =  rgb1        & 0xff;\n        int r2 = (rgb2 >> 16) & 0xff;\n        int g2 = (rgb2 >>  8) & 0xff;\n        int b2 =  rgb2        & 0xff;\n        return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);\n    }\n}\n"}
{"id": 729, "name": "Percentage difference between images", "source": "Translate Swift to Python: func pixelValues(fromCGImage imageRef: CGImage?) -> [UInt8]?\n{\n    var width = 0\n    var height = 0\n    var pixelValues: [UInt8]?\n    \n    if let imageRef = imageRef {\n        width = imageRef.width\n        height = imageRef.height\n        let bitsPerComponent = imageRef.bitsPerComponent\n        let bytesPerRow = imageRef.bytesPerRow\n        let totalBytes = height * bytesPerRow\n        let bitmapInfo = imageRef.bitmapInfo\n        \n        let colorSpace = CGColorSpaceCreateDeviceRGB()\n        var intensities = [UInt8](repeating: 0, count: totalBytes)\n        \n        let contextRef = CGContext(data: &intensities,\n                                  width: width,\n                                 height: height,\n                       bitsPerComponent: bitsPerComponent,\n                            bytesPerRow: bytesPerRow,\n                                  space: colorSpace,\n                             bitmapInfo: bitmapInfo.rawValue)\n        contextRef?.draw(imageRef, in: CGRect(x: 0.0, y: 0.0, width: CGFloat(width), height: CGFloat(height)))\n        \n        pixelValues = intensities\n    }\n    \n    return pixelValues\n}\n\nfunc compareImages(image1: UIImage, image2: UIImage) -> Double? {\n    guard let data1 = pixelValues(fromCGImage: image1.cgImage),\n        let data2 = pixelValues(fromCGImage: image2.cgImage),\n        data1.count == data2.count else {\n            return nil\n    }\n    \n    let width = Double(image1.size.width)\n    let height = Double(image1.size.height)\n    \n    return zip(data1, data2)\n        .enumerated()\n        .reduce(0.0) {\n            $1.offset % 4 == 3 ? $0 : $0 + abs(Double($1.element.0) - Double($1.element.1))\n        }\n        * 100 / (width * height * 3.0) / 255.0\n}\n\nlet image1 = UIImage(named: \"Lenna50\")\nlet image2 = UIImage(named: \"Lenna100\")\n\ncompareImages(image1: image1, image2: image2)\n", "target": "from PIL import Image\n\ni1 = Image.open(\"image1.jpg\")\ni2 = Image.open(\"image2.jpg\")\nassert i1.mode == i2.mode, \"Different kinds of images.\"\nassert i1.size == i2.size, \"Different sizes.\"\n\npairs = zip(i1.getdata(), i2.getdata())\nif len(i1.getbands()) == 1:\n    \n    dif = sum(abs(p1-p2) for p1,p2 in pairs)\nelse:\n    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2))\n\nncomponents = i1.size[0] * i1.size[1] * 3\nprint (\"Difference (percentage):\", (dif / 255.0 * 100) / ncomponents)\n"}
{"id": 966, "name": "Bitwise operations", "source": "Translate Swift to C#: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 968, "name": "Bitwise operations", "source": "Translate Swift to Java: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 969, "name": "Bitwise operations", "source": "Translate Swift to Python: func bitwise(a: Int, b: Int) {\n  \n  \n  println(\"a AND b: \\(a & b)\")\n  println(\"a OR b: \\(a | b)\")\n  println(\"a XOR b: \\(a ^ b)\")\n  println(\"NOT a: \\(~a)\")\n  println(\"a << b: \\(a << b)\") \n  \n  \n  println(\"a >> b: \\(a >> b)\") \n  println(\"a lsr b: \\(Int(bitPattern: UInt(bitPattern: a) >> UInt(bitPattern: b)))\") \n}\n\nbitwise(-15,3)\n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1564, "name": "Flatten a list", "source": "Translate Swift to C#: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1565, "name": "Flatten a list", "source": "Translate Swift to C#: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1568, "name": "Flatten a list", "source": "Translate Swift to Java: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1569, "name": "Flatten a list", "source": "Translate Swift to Java: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1570, "name": "Flatten a list", "source": "Translate Swift to Python: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1571, "name": "Flatten a list", "source": "Translate Swift to Python: func list(s: Any...) -> [Any] {\n  return s\n}\n\nfunc flatten<T>(s: [Any]) -> [T] {\n  var r = [T]()\n  for e in s {\n    switch e {\n    case let a as [Any]:\n      r += flatten(a)\n    case let x as T:\n      r.append(x)\n    default:\n      assert(false, \"value of wrong type\")\n    }\n  }\n  return r\n}\n\nlet s = list(list(1),\n  2,\n  list(list(3, 4), 5),\n  list(list(list())),\n  list(list(list(6))),\n  7,\n  8,\n  list()\n)\nprintln(s)\nlet result : [Int] = flatten(s)\nprintln(result)\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1842, "name": "Calendar", "source": "Translate Swift to C#: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": "using System;\nusing System.Collections.Generic; \nusing System.Linq;\nusing System.Text;\n\nnamespace CalendarStuff\n{\n \n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WindowHeight = 46;\n            Console.Write(buildMonths(new DateTime(1969, 1, 1)));\n            Console.Read(); \n        }\n        private static string buildMonths(DateTime date)\n        {\n            StringBuilder sb = new StringBuilder();\n            sb.AppendLine(center(\"[Snoop]\", 24 * 3));\n            sb.AppendLine();\n            sb.AppendLine(center(date.Year.ToString(), 24 * 3));\n\n            List<DateTime> dts = new List<DateTime>();\n            while (true)\n            {\n                dts.Add(date);\n                if (date.Year != ((date = date.AddMonths(1)).Year))\n                {\n                    break;\n                }\n            }\n            var jd = dts.Select(a => buildMonth(a).GetEnumerator()).ToArray();\n            \n            int sCur=0;\n            while (sCur<dts.Count)\n            {\n                sb.AppendLine();\n                int curMonth=0; \n                var j = jd.Where(a => curMonth++ >= sCur && curMonth - 1 < sCur + 3).ToArray(); \n                sCur += j.Length; \n                bool breakOut = false;\n                while (!breakOut)\n                {\n                    int inj = 1;\n                    foreach (var cd in j)\n                    {\n                        if (cd.MoveNext())\n                        {\n                            sb.Append((cd.Current.Length == 21 ? cd.Current : cd.Current.PadRight(21, ' ')) + \"     \");\n                        }\n                        else\n                        {\n                            sb.Append(\"\".PadRight(21, ' ') + \"     \");\n                            breakOut = true;\n                        }\n                        if (inj++ % 3 == 0) sb.AppendLine();\n                    }\n                }\n\n            }\n            return sb.ToString();\n        }\n\n\n        private static IEnumerable<string> buildMonth(DateTime date)\n        {\n            yield return center(date.ToString(\"MMMM\"),7*3);\n            var j = DateTime.DaysInMonth(date.Year, date.Month);\n            yield return Enum.GetNames(typeof(DayOfWeek)).Aggregate(\"\", (current, result) => current + (result.Substring(0, 2).ToUpper() + \" \"));\n            string cur = \"\";\n            int total = 0;\n\n            foreach (var day in Enumerable.Range(-((int)date.DayOfWeek),j + (int)date.DayOfWeek))\n            {\n                cur += (day < 0 ? \"  \" : ((day < 9 ? \" \" : \"\") + (day + 1))) +\" \";\n                if (total++ > 0 && (total ) % 7 == 0)\n                {\n                    yield return cur;\n                    cur = \"\";\n                }\n            }\n            yield return cur;\n        }\n        private static string center(string s, int len)\n        {\n            return (s.PadLeft((len - s.Length) / 2 + s.Length, ' ').PadRight((len), ' '));\n        } \n    }\n}\n"}
{"id": 1844, "name": "Calendar", "source": "Translate Swift to Java: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": "import java.text.*;\nimport java.util.*;\n\npublic class CalendarTask {\n\n    public static void main(String[] args) {\n        printCalendar(1969, 3);\n    }\n\n    static void printCalendar(int year, int nCols) {\n        if (nCols < 1 || nCols > 12)\n            throw new IllegalArgumentException(\"Illegal column width.\");\n\n        Calendar date = new GregorianCalendar(year, 0, 1);\n\n        int nRows = (int) Math.ceil(12.0 / nCols);\n        int offs = date.get(Calendar.DAY_OF_WEEK) - 1;\n        int w = nCols * 24;\n\n        String[] monthNames = new DateFormatSymbols(Locale.US).getMonths();\n\n        String[][] mons = new String[12][8];\n        for (int m = 0; m < 12; m++) {\n\n            String name = monthNames[m];\n            int len = 11 + name.length() / 2;\n            String format = MessageFormat.format(\"%{0}s%{1}s\", len, 21 - len);\n\n            mons[m][0] = String.format(format, name, \"\");\n            mons[m][1] = \" Su Mo Tu We Th Fr Sa\";\n            int dim = date.getActualMaximum(Calendar.DAY_OF_MONTH);\n\n            for (int d = 1; d < 43; d++) {\n                boolean isDay = d > offs && d <= offs + dim;\n                String entry = isDay ? String.format(\" %2s\", d - offs) : \"   \";\n                if (d % 7 == 1)\n                    mons[m][2 + (d - 1) / 7] = entry;\n                else\n                    mons[m][2 + (d - 1) / 7] += entry;\n            }\n            offs = (offs + dim) % 7;\n            date.add(Calendar.MONTH, 1);\n        }\n\n        System.out.printf(\"%\" + (w / 2 + 10) + \"s%n\", \"[Snoopy Picture]\");\n        System.out.printf(\"%\" + (w / 2 + 4) + \"s%n%n\", year);\n\n        for (int r = 0; r < nRows; r++) {\n            for (int i = 0; i < 8; i++) {\n                for (int c = r * nCols; c < (r + 1) * nCols && c < 12; c++)\n                    System.out.printf(\"   %s\", mons[c][i]);\n                System.out.println();\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 1845, "name": "Calendar", "source": "Translate Swift to Python: import Foundation\n\nlet monthWidth = 20\nlet monthGap = 2\nlet dayNames = \"Su Mo Tu We Th Fr Sa\"\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"MMMM\"\n\nfunc rpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc lpad(string: String, width: Int) -> String {\n    return string.count >= width ? string\n        : string + String(repeating: \" \", count: width - string.count)\n}\n\nfunc centre(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    let c = (width - string.count)/2\n    return String(repeating: \" \", count: c) + string\n        + String(repeating: \" \", count: width - string.count - c)\n}\n\nfunc formatMonth(year: Int, month: Int) -> [String] {\n    let calendar = Calendar.current\n    let dc = DateComponents(year: year, month: month, day: 1)\n    let date = calendar.date(from: dc)!\n    let firstDay = calendar.component(.weekday, from: date) - 1\n    let range = calendar.range(of: .day, in: .month, for: date)!\n    let daysInMonth = range.count\n    var lines: [String] = []\n    lines.append(centre(string: dateFormatter.string(from: date), width: monthWidth))\n    lines.append(dayNames)\n    var padWidth = 2\n    var line = String(repeating: \" \", count: 3 * firstDay)\n    for day in 1...daysInMonth {\n        line += rpad(string: String(day), width: padWidth)\n        padWidth = 3\n        if (firstDay + day) % 7 == 0 {\n            lines.append(line)\n            line = \"\"\n            padWidth = 2\n        }\n    }\n    if line.count > 0 {\n        lines.append(lpad(string: line, width: monthWidth))\n    }\n    return lines\n}\n\nfunc printCentred(string: String, width: Int) {\n    print(rpad(string: string, width: (width + string.count)/2))\n}\n\npublic func printCalendar(year: Int, width: Int) {\n    let months = min(12, max(1, (width + monthGap)/(monthWidth + monthGap)))\n    let lineWidth = monthWidth * months + monthGap * (months - 1)\n    printCentred(string: \"[Snoopy]\", width: lineWidth)\n    printCentred(string: String(year), width: lineWidth)\n    var firstMonth = 1\n    while firstMonth <= 12 {\n        if firstMonth > 1 {\n            print()\n        }\n        let lastMonth = min(12, firstMonth + months - 1)\n        let monthCount = lastMonth - firstMonth + 1\n        var lines: [[String]] = []\n        var lineCount = 0\n        for month in firstMonth...lastMonth {\n            let monthLines = formatMonth(year: year, month: month)\n            lineCount = max(lineCount, monthLines.count)\n            lines.append(monthLines)\n        }\n        for i in 0..<lineCount {\n            var line = \"\"\n            for month in 0..<monthCount {\n                if month > 0 {\n                    line.append(String(repeating: \" \", count: monthGap))\n                }\n                line.append(i < lines[month].count ? lines[month][i]\n                            : String(repeating: \" \", count: monthWidth))\n            }\n            print(line)\n        }\n        firstMonth = lastMonth + 1\n    }\n}\n\nprintCalendar(year: 1969, width: 80)\n", "target": ">>> import calendar\n>>> help(calendar.prcal)\nHelp on method pryear in module calendar:\n\npryear(self, theyear, w=0, l=0, c=6, m=3) method of calendar.TextCalendar instance\n    Print a years calendar.\n\n>>> calendar.prcal(1969)\n                                  1969\n\n      January                   February                   March\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2                      1  2\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       3  4  5  6  7  8  9\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      10 11 12 13 14 15 16\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      17 18 19 20 21 22 23\n27 28 29 30 31            24 25 26 27 28            24 25 26 27 28 29 30\n                                                    31\n\n       April                      May                       June\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                1  2  3  4                         1\n 7  8  9 10 11 12 13       5  6  7  8  9 10 11       2  3  4  5  6  7  8\n14 15 16 17 18 19 20      12 13 14 15 16 17 18       9 10 11 12 13 14 15\n21 22 23 24 25 26 27      19 20 21 22 23 24 25      16 17 18 19 20 21 22\n28 29 30                  26 27 28 29 30 31         23 24 25 26 27 28 29\n                                                    30\n\n        July                     August                  September\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n    1  2  3  4  5  6                   1  2  3       1  2  3  4  5  6  7\n 7  8  9 10 11 12 13       4  5  6  7  8  9 10       8  9 10 11 12 13 14\n14 15 16 17 18 19 20      11 12 13 14 15 16 17      15 16 17 18 19 20 21\n21 22 23 24 25 26 27      18 19 20 21 22 23 24      22 23 24 25 26 27 28\n28 29 30 31               25 26 27 28 29 30 31      29 30\n\n      October                   November                  December\nMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su\n       1  2  3  4  5                      1  2       1  2  3  4  5  6  7\n 6  7  8  9 10 11 12       3  4  5  6  7  8  9       8  9 10 11 12 13 14\n13 14 15 16 17 18 19      10 11 12 13 14 15 16      15 16 17 18 19 20 21\n20 21 22 23 24 25 26      17 18 19 20 21 22 23      22 23 24 25 26 27 28\n27 28 29 30 31            24 25 26 27 28 29 30      29 30 31\n"}
{"id": 2268, "name": "String interpolation (included)", "source": "Translate Swift to C#: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2270, "name": "String interpolation (included)", "source": "Translate Swift to Java: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2271, "name": "String interpolation (included)", "source": "Translate Swift to Python: let extra = \"little\"\nprintln(\"Mary had a \\(extra) lamb.\")\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2739, "name": "Babbage problem", "source": "Translate Swift to C#: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2742, "name": "Babbage problem", "source": "Translate Swift to Java: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2743, "name": "Babbage problem", "source": "Translate Swift to Java: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2744, "name": "Babbage problem", "source": "Translate Swift to Python: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2745, "name": "Babbage problem", "source": "Translate Swift to Python: import Swift\n\nfor i in 2...Int.max {\n\tif i * i % 1000000 == 269696 {\n\t\tprint(i, \"is the smallest number that ends with 269696\")\n\t\tbreak\n\t}\n}\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 3442, "name": "Find limit of recursion", "source": "Translate Swift to C#: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3443, "name": "Find limit of recursion", "source": "Translate Swift to C#: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3446, "name": "Find limit of recursion", "source": "Translate Swift to Java: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3447, "name": "Find limit of recursion", "source": "Translate Swift to Java: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3448, "name": "Find limit of recursion", "source": "Translate Swift to Python: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3449, "name": "Find limit of recursion", "source": "Translate Swift to Python: var n = 1\n\nfunc recurse() {\n    print(n)\n    n += 1\n    recurse()\n}\n\nrecurse()\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 5061, "name": "Read entire file", "source": "Translate Swift to C#: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");  \n        \n    }\n}\n"}
{"id": 5063, "name": "Read entire file", "source": "Translate Swift to Java: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "static Byte[] contentsOf(File file)\n    {\n    return file.contents;\n    }\n"}
{"id": 5064, "name": "Read entire file", "source": "Translate Swift to Python: import Foundation\n\nlet path = \"~/input.txt\".stringByExpandingTildeInPath\nif let string = String(contentsOfFile: path, encoding: NSUTF8StringEncoding) {\n  println(string) \n}\n", "target": "open(filename).read()\n"}
{"id": 6185, "name": "Man or boy test", "source": "Translate Swift to C#: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "using System;\n \ndelegate T Func<T>();\n \nclass ManOrBoy\n{\n    static void Main()\n    {\n        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));\n    }\n \n    static Func<int> C(int i)\n    {\n        return delegate { return i; };\n    }\n \n    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)\n    {\n        Func<int> b = null;\n        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };\n        return k <= 0 ? x4() + x5() : b();\n    }\n}\n"}
{"id": 6187, "name": "Man or boy test", "source": "Translate Swift to Java: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "import java.util.function.DoubleSupplier;\n\npublic class ManOrBoy {\n    \n    static double A(int k, DoubleSupplier x1, DoubleSupplier x2,\n                 DoubleSupplier x3, DoubleSupplier x4, DoubleSupplier x5) {\n        \n        DoubleSupplier B = new DoubleSupplier() {\n            int m = k;\n            public double getAsDouble() {\n                return A(--m, this, x1, x2, x3, x4);\n            }\n        };\n                \n        return k <= 0 ? x4.getAsDouble() + x5.getAsDouble() : B.getAsDouble();\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(A(10, () -> 1.0, () -> -1.0, () -> -1.0, () -> 1.0, () -> 0.0));\n    }\n}\n"}
{"id": 6188, "name": "Man or boy test", "source": "Translate Swift to Python: func A(_ k: Int,                          \n       _ x1: @escaping () -> Int,         \n       _ x2: @escaping () -> Int,         \n       _ x3: @escaping () -> Int,         \n       _ x4: @escaping () -> Int,         \n       _ x5: @escaping () -> Int) -> Int {\n    var k1 = k                            \n                                          \n    func B() -> Int {                     \n        k1 -= 1                           \n        return A(k1, B, x1, x2, x3, x4)   \n    }                                     \n                                          \n    if k1 <= 0 {                          \n        return x4() + x5()                \n    } else {                              \n        return B()                        \n    }                                     \n}                                         \n                                          \nprint(A(10, {1}, {-1}, {-1}, {1}, {0}))\n", "target": "\nimport sys\nsys.setrecursionlimit(1025)\n\ndef a(in_k, x1, x2, x3, x4, x5):\n    k = [in_k]\n    def b():\n        k[0] -= 1\n        return a(k[0], b, x1, x2, x3, x4)\n    return x4() + x5() if k[0] <= 0 else b()\n\nx = lambda i: lambda: i\nprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))\n"}
{"id": 6423, "name": "Assertions", "source": "Translate Swift to C#: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "using System.Diagnostics; \n\nstatic class Program\n{\n    static void Main()\n    {\n        int a = 0;\n\n        Console.WriteLine(\"Before\");\n\n        \n        Trace.Assert(a == 42, \"Trace assertion failed\");\n\n        Console.WriteLine(\"After Trace.Assert\");\n\n        \n        Debug.Assert(a == 42, \"Debug assertion failed\");\n\n        Console.WriteLine(\"After Debug.Assert\");\n    }\n}\n"}
{"id": 6425, "name": "Assertions", "source": "Translate Swift to Java: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "public class Assertions {\n\n    public static void main(String[] args) {\n        int a = 13;\n\n        \n\n        assert a == 42;\n        \n\n        assert a == 42 : \"Error message\";\n        \n        \n        \n    }\n}\n"}
{"id": 6426, "name": "Assertions", "source": "Translate Swift to Python: var a = 5\n\nassert(a == 42) \nassert(a == 42, \"Error message\") \n       \n       \n", "target": "a = 5\n\nassert a == 42 \nassert a == 42, \"Error message\" \n       \n       \n"}
{"id": 7054, "name": "Tree traversal", "source": "Translate Swift to C#: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"id": 7056, "name": "Tree traversal", "source": "Translate Swift to Java: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "import java.util.*;\n\npublic class TreeTraversal {\n\n        static class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\n\t\tNode(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tvoid visit() {\n\t\t\tSystem.out.print(this.value + \" \");\n\t\t}\n\t}\n\n\tstatic enum ORDER {\n\t\tPREORDER, INORDER, POSTORDER, LEVEL\n\t}\n        \n        static <T> void traverse(Node<T> node, ORDER order) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (order) {\n\t\tcase PREORDER:\n\t\t\tnode.visit();\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase INORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\tnode.visit();\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase POSTORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tnode.visit();\n\t\t\tbreak;\n\t\tcase LEVEL:\n\t\t\tQueue<Node<T>> queue = new LinkedList<>();\n\t\t\tqueue.add(node);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode<T> next = queue.remove();\n\t\t\t\tnext.visit();\n\t\t\t\tif(next.left!=null)\n\t\t\t\t\tqueue.add(next.left);\n\t\t\t\tif(next.right!=null)\n\t\t\t\t\tqueue.add(next.right);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tpublic static void main(String[] args) {\n\n\t\tNode<Integer> one = new Node<Integer>(1);\n\t\tNode<Integer> two = new Node<Integer>(2);\n\t\tNode<Integer> three = new Node<Integer>(3);\n\t\tNode<Integer> four = new Node<Integer>(4);\n\t\tNode<Integer> five = new Node<Integer>(5);\n\t\tNode<Integer> six = new Node<Integer>(6);\n\t\tNode<Integer> seven = new Node<Integer>(7);\n\t\tNode<Integer> eight = new Node<Integer>(8);\n\t\tNode<Integer> nine = new Node<Integer>(9);\n\t\t\n\t\tone.left = two;\n\t\tone.right = three;\n\t\ttwo.left = four;\n\t\ttwo.right = five;\n\t\tthree.left = six;\n\t\tfour.left = seven;\n\t\tsix.left = eight;\n\t\tsix.right = nine;\n\n\t\ttraverse(one, ORDER.PREORDER);\n\t\tSystem.out.println(); \n\t\ttraverse(one, ORDER.INORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.POSTORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.LEVEL);\n\t\t\n\t}\n}\n"}
{"id": 7057, "name": "Tree traversal", "source": "Translate Swift to Python: class TreeNode<T> {\n    let value: T\n    let left: TreeNode?\n    let right: TreeNode?\n    \n    init(value: T, left: TreeNode? = nil, right: TreeNode? = nil) {\n        self.value = value\n        self.left = left\n        self.right = right\n    }\n\n    func preOrder(function: (T) -> Void) {\n        function(value)\n        if left != nil {\n            left!.preOrder(function: function)\n        }\n        if right != nil {\n            right!.preOrder(function: function)\n        }\n    }\n    \n    func inOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.inOrder(function: function)\n        }\n        function(value)\n        if right != nil {\n            right!.inOrder(function: function)\n        }\n    }\n    \n    func postOrder(function: (T) -> Void) {\n        if left != nil {\n            left!.postOrder(function: function)\n        }\n        if right != nil {\n            right!.postOrder(function: function)\n        }\n        function(value)\n    }\n    \n    func levelOrder(function: (T) -> Void) {\n        var queue: [TreeNode] = []\n        queue.append(self)\n        while queue.count > 0 {\n            let node = queue.removeFirst()\n            function(node.value)\n            if node.left != nil {\n                queue.append(node.left!)\n            }\n            if node.right != nil {\n                queue.append(node.right!)\n            }\n        }\n    }\n}\n\ntypealias Node = TreeNode<Int>\n\nlet n = Node(value: 1,\n             left: Node(value: 2,\n                        left: Node(value: 4,\n                                   left: Node(value: 7)),\n                        right: Node(value: 5)),\n             right: Node(value: 3,\n                         left: Node(value: 6,\n                                    left: Node(value: 8),\n                                    right: Node(value: 9))))\n\nlet fn = { print($0, terminator: \" \") }\n\nprint(\"pre-order:   \", terminator: \"\")\nn.preOrder(function: fn)\nprint()\n\nprint(\"in-order:    \", terminator: \"\")\nn.inOrder(function: fn)\nprint()\n\nprint(\"post-order:  \", terminator: \"\")\nn.postOrder(function: fn)\nprint()\n\nprint(\"level-order: \", terminator: \"\")\nn.levelOrder(function: fn)\nprint()\n", "target": "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()\n"}
{"id": 7272, "name": "List comprehensions", "source": "Translate Swift to C#: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "using System.Linq;\n\nstatic class Program\n{\n  static void Main()\n  {\n    var ts =\n      from a in Enumerable.Range(1, 20)\n      from b in Enumerable.Range(a, 21 - a)\n      from c in Enumerable.Range(b, 21 - b)\n      where a * a + b * b == c * c\n      select new { a, b, c };\n\n      foreach (var t in ts)\n        System.Console.WriteLine(\"{0}, {1}, {2}\", t.a, t.b, t.c);\n  }\n}\n"}
{"id": 7274, "name": "List comprehensions", "source": "Translate Swift to Java: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "\nimport java.util.Arrays;\nimport java.util.List;\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\npublic interface PythagComp{\n    static void main(String... args){\n        System.out.println(run(20));\n    }\n\n    static List<List<Integer>> run(int n){\n        return\n            \n            \n            range(1, n).mapToObj(\n                x -> range(x, n).mapToObj(\n                    y -> range(y, n).mapToObj(\n                        z -> new Integer[]{x, y, z}\n                    )\n                )\n            )\n                .flatMap(identity())\n                .flatMap(identity())\n                \n                .filter(a -> a[0]*a[0] + a[1]*a[1] == a[2]*a[2])\n                \n                .map(Arrays::asList)\n                \n                .collect(toList())\n        ;\n    }\n}\n"}
{"id": 7275, "name": "List comprehensions", "source": "Translate Swift to Python: typealias F1 = (Int) -> [(Int, Int, Int)]\ntypealias F2 = (Int) -> Bool\n\nfunc pythagoreanTriples(n: Int) -> [(Int, Int, Int)] {\n  (1...n).flatMap({x in\n    (x...n).flatMap({y in\n      (y...n).filter({z in\n        x * x + y * y == z * z\n      } as F2).map({ (x, y, $0) })\n    } as F1)\n  } as F1)\n}\n\nprint(pythagoreanTriples(n: 20))\n", "target": "[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]\n"}
{"id": 7392, "name": "Literals_Floating point", "source": "Translate Swift to C#: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "double d = 1;\nd = 1d;\nd = 1D;\nd = 1.2; \nd = 1.2d; \nd = .2;\nd = 12e-12;\nd = 12E-12;\nd = 1_234e-1_2; \nfloat f = 1;\nf = 1f;\nf = 1F;\nf = 1.2f;\nf = .2f;\nf = 12e-12f;\nf = 12E-12f;\nf = 1_234e-1_2f;\ndecimal m = 1;\nm = 1m;\nm = 1m;\nm = 1.2m;\nm = .2m;\nm = 12e-12m;\nm = 12E-12m;\nm = 1_234e-1_2m;\n"}
{"id": 7394, "name": "Literals_Floating point", "source": "Translate Swift to Java: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "1. \n1.0 \n2432311.7567374 \n1.234E-10 \n1.234e-10 \n758832d \n728832f \n1.0f \n758832D \n728832F \n1.0F \n1 / 2. \n1 / 2 \n"}
{"id": 7395, "name": "Literals_Floating point", "source": "Translate Swift to Python: let double = 1.0 as Double  \nlet float = 1.0 as Float \nlet scientific = 1.0E-12\n\n\nlet sum = double + float \n\nlet div = 1.1 / 2 \nlet div1 = 1 / 2 \n", "target": "2.3    \n.3     \n.3e4   \n.3e+34 \n.3e-34 \n2.e34  \n"}
{"id": 7743, "name": "Abundant odd numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7744, "name": "Abundant odd numbers", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7747, "name": "Abundant odd numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7748, "name": "Abundant odd numbers", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7749, "name": "Abundant odd numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7750, "name": "Abundant odd numbers", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func factors(sorted: Bool = true) -> [Self] {\n    let maxN = Self(Double(self).squareRoot())\n    var res = Set<Self>()\n\n    for factor in stride(from: 1, through: maxN, by: 1) where self % factor == 0 {\n      res.insert(factor)\n      res.insert(self / factor)\n    }\n\n    return sorted ? res.sorted() : Array(res)\n  }\n}\n\n@inlinable\npublic func isAbundant<T: BinaryInteger>(n: T) -> (Bool, [T]) {\n  let divs = n.factors().dropLast()\n\n  return (divs.reduce(0, +) > n, Array(divs))\n}\n\nlet oddAbundant = (0...).lazy.filter({ $0 & 1 == 1 }).map({ ($0, isAbundant(n: $0)) }).filter({ $1.0 })\n\nfor (n, (_, factors)) in oddAbundant.prefix(25) {\n  print(\"n: \\(n); sigma: \\(factors.reduce(0, +))\")\n}\n\nlet (bigA, (_, bigFactors)) =\n  (1_000_000_000...)\n    .lazy\n    .filter({ $0 & 1 == 1 })\n    .map({ ($0, isAbundant(n: $0)) })\n    .first(where: { $1.0 })!\n\nprint(\"first odd abundant number over 1 billion: \\(bigA), sigma: \\(bigFactors.reduce(0, +))\")\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 8215, "name": "Combinations", "source": "Translate Swift to C#: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int[]> Combinations(int m, int n)\n    {\n            int[] result = new int[m];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(0);\n\n            while (stack.Count > 0)\n           {\n                int index = stack.Count - 1;\n                int value = stack.Pop();\n\n                while (value < n) \n               {\n                    result[index++] = ++value;\n                    stack.Push(value);\n\n                    if (index == m) \n                    {\n                        yield return result;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void Main()\n    {\n        foreach (int[] c in Combinations(3, 5))\n        {\n            Console.WriteLine(string.Join(\",\", c));\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 8217, "name": "Combinations", "source": "Translate Swift to Java: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Comb{\n\n        public static void main(String[] args){\n                System.out.println(comb(3,5));\n        }\n\n        public static String bitprint(int u){\n                String s= \"\";\n                for(int n= 0;u > 0;++n, u>>= 1)\n                        if((u & 1) > 0) s+= n + \" \";\n                return s;\n        }\n\n        public static int bitcount(int u){\n                int n;\n                for(n= 0;u > 0;++n, u&= (u - 1));\n                return n;\n        }\n\n        public static LinkedList<String> comb(int c, int n){\n                LinkedList<String> s= new LinkedList<String>();\n                for(int u= 0;u < 1 << n;u++)\n                        if(bitcount(u) == c) s.push(bitprint(u));\n                Collections.sort(s);\n                return s;\n        }\n}\n"}
{"id": 8218, "name": "Combinations", "source": "Translate Swift to Python: func addCombo(prevCombo: [Int], var pivotList: [Int]) -> [([Int], [Int])] {\n\n  return (0..<pivotList.count)\n    .map {\n      _ -> ([Int], [Int]) in\n      (prevCombo + [pivotList.removeAtIndex(0)], pivotList)\n    }\n}\nfunc combosOfLength(n: Int, m: Int) -> [[Int]] {\n\n  return [Int](1...m)\n    .reduce([([Int](), [Int](0..<n))]) {\n      (accum, _) in\n      accum.flatMap(addCombo)\n    }.map {\n      $0.0\n    }\n}\n\nprintln(combosOfLength(5, 3))\n", "target": ">>> from itertools import combinations\n>>> list(combinations(range(5),3))\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n"}
{"id": 8838, "name": "Department numbers", "source": "Translate Swift to C#: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8839, "name": "Department numbers", "source": "Translate Swift to C#: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8842, "name": "Department numbers", "source": "Translate Swift to Java: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8843, "name": "Department numbers", "source": "Translate Swift to Java: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8844, "name": "Department numbers", "source": "Translate Swift to Python: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8845, "name": "Department numbers", "source": "Translate Swift to Python: let res = [2, 4, 6].map({x in\n  return (1...7)\n      .filter({ $0 != x })\n      .map({y -> (Int, Int, Int)? in\n        let z = 12 - (x + y)\n\n        guard y != z && 1 <= z && z <= 7 else {\n          return nil\n        }\n\n        return (x, y, z)\n      }).compactMap({ $0 })\n}).flatMap({ $0 })\n\nfor result in res {\n  print(result)\n}\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 9250, "name": "Fusc sequence", "source": "Translate Swift to C#: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9251, "name": "Fusc sequence", "source": "Translate Swift to C#: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nstatic class program\n{\n    static int n = 61;\n    static List<int> l = new List<int>() { 0, 1 };\n\n    static int fusc(int n)\n    {\n        if (n < l.Count) return l[n];\n        int f = (n & 1) == 0 ? l[n >> 1] : l[(n - 1) >> 1] + l[(n + 1) >> 1];\n        l.Add(f); return f;\n    }\n\n    static void Main(string[] args)\n    {\n        bool lst = true; int w = -1, c = 0, t;\n        string fs = \"{0,11:n0}  {1,-9:n0}\", res = \"\";\n        Console.WriteLine(\"First {0} numbers in the fusc sequence:\", n);\n        for (int i = 0; i < int.MaxValue; i++)\n        {\n            int f = fusc(i); if (lst)\n            {\n                if (i < 61) Console.Write(\"{0} \", f);\n                else\n                {\n                    lst = false;\n                    Console.WriteLine();\n                    Console.WriteLine(\"Points in the sequence where an item has more digits than any previous items:\");\n                    Console.WriteLine(fs, \"Index\\\\\", \"/Value\"); Console.WriteLine(res); res = \"\";\n                }\n            }\n            if ((t = f.ToString().Length) > w)\n            {\n                w = t; res += (res == \"\" ? \"\" : \"\\n\") + string.Format(fs, i, f);\n                if (!lst) { Console.WriteLine(res); res = \"\"; } if (++c > 5) break;\n            }\n        }\n        l.Clear();\n    }\n}\n"}
{"id": 9254, "name": "Fusc sequence", "source": "Translate Swift to Java: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9255, "name": "Fusc sequence", "source": "Translate Swift to Java: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "public class FuscSequence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the first 61 fusc numbers (starting at zero) in a horizontal format\");\n        for ( int n = 0 ; n < 61 ; n++ ) {\n            System.out.printf(\"%,d \", fusc[n]);\n        }\n        \n        System.out.printf(\"%n%nShow the fusc number (and its index) whose length is greater than any previous fusc number length.%n\");\n        int start = 0;\n        for (int i = 0 ; i <= 5 ; i++ ) {\n            int val = i != 0 ? (int) Math.pow(10, i) : -1;\n            for ( int j = start ; j < FUSC_MAX ; j++ ) {\n                if ( fusc[j] > val ) {\n                    System.out.printf(\"fusc[%,d] =\u00a0%,d%n\", j, fusc[j] );\n                    start = j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    private static final int FUSC_MAX = 30000000;\n    private static int[] fusc = new int[FUSC_MAX];\n\n    static {\n        fusc[0] = 0;\n        fusc[1] = 1;\n        for ( int n = 2 ; n < FUSC_MAX ; n++ ) {\n            fusc[n] = (n % 2 == 0 ? fusc[n/2] : fusc[(n-1)/2] + fusc[(n+1)/2]);\n        }\n    }\n}\n"}
{"id": 9256, "name": "Fusc sequence", "source": "Translate Swift to Python: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9257, "name": "Fusc sequence", "source": "Translate Swift to Python: struct FuscSeq: Sequence, IteratorProtocol {\n  private var arr = [0, 1]\n  private var i = 0\n\n  mutating func next() -> Int? {\n    defer {\n      i += 1\n    }\n\n    guard i > 1 else {\n      return arr[i]\n    }\n\n    switch i & 1 {\n    case 0:\n      arr.append(arr[i / 2])\n    case 1:\n      arr.append(arr[(i - 1) / 2] + arr[(i + 1) / 2])\n    case _:\n      fatalError()\n    }\n\n    return arr.last!\n  }\n}\n\nlet first = FuscSeq().prefix(61)\n\nprint(\"First 61: \\(Array(first))\")\n\nvar max = -1\n\nfor (i, n) in FuscSeq().prefix(20_000_000).enumerated() {\n  let f = String(n).count\n\n  if f > max {\n    max = f\n\n    print(\"New max: \\(i): \\(n)\")\n  }\n}\n", "target": "from collections import deque\nfrom itertools import islice, count\n\n\ndef fusc():\n    q = deque([1])\n    yield 0\n    yield 1\n\n    while True:\n        x = q.popleft()\n        q.append(x)\n        yield x\n\n        x += q[0]\n        q.append(x)\n        yield x\n\n\ndef longest_fusc():\n    sofar = 0\n    for i, f in zip(count(), fusc()):\n        if f >= sofar:\n            yield(i, f)\n            sofar = 10 * sofar or 10\n\n\nprint('First 61:')\nprint(list(islice(fusc(), 61)))\n\nprint('\\nLength records:')\nfor i, f in islice(longest_fusc(), 6):\n    print(f'fusc({i}) = {f}')\n"}
{"id": 9914, "name": "Haversine formula", "source": "Translate Swift to C#: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9915, "name": "Haversine formula", "source": "Translate Swift to C#: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9918, "name": "Haversine formula", "source": "Translate Swift to Java: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9919, "name": "Haversine formula", "source": "Translate Swift to Java: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9920, "name": "Haversine formula", "source": "Translate Swift to Python: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 9921, "name": "Haversine formula", "source": "Translate Swift to Python: import Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 10551, "name": "Nth root", "source": "Translate Swift to C#: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10553, "name": "Nth root", "source": "Translate Swift to Java: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10554, "name": "Nth root", "source": "Translate Swift to Python: extension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 10986, "name": "Priority queue", "source": "Translate Swift to C#: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10987, "name": "Priority queue", "source": "Translate Swift to C#: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10990, "name": "Priority queue", "source": "Translate Swift to Java: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10991, "name": "Priority queue", "source": "Translate Swift to Java: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10992, "name": "Priority queue", "source": "Translate Swift to Python: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 10993, "name": "Priority queue", "source": "Translate Swift to Python: class Task : Comparable, CustomStringConvertible {\n  var priority : Int\n  var name: String\n  init(priority: Int, name: String) {\n    self.priority = priority\n    self.name = name\n  }\n  var description: String {\n    return \"\\(priority), \\(name)\"\n  }\n}\nfunc ==(t1: Task, t2: Task) -> Bool {\n  return t1.priority == t2.priority\n}\nfunc <(t1: Task, t2: Task) -> Bool {\n  return t1.priority < t2.priority\n}\n\nstruct TaskPriorityQueue {\n  let heap : CFBinaryHeapRef = {\n    var callBacks = CFBinaryHeapCallBacks(version: 0, retain: {\n      UnsafePointer(Unmanaged<Task>.fromOpaque(COpaquePointer($1)).retain().toOpaque())\n      }, release: {\n        Unmanaged<Task>.fromOpaque(COpaquePointer($1)).release()\n      }, copyDescription: nil, compare: { (ptr1, ptr2, _) in\n        let t1 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr1)).takeUnretainedValue()\n        let t2 : Task = Unmanaged<Task>.fromOpaque(COpaquePointer(ptr2)).takeUnretainedValue()\n        return t1 == t2 ? CFComparisonResult.CompareEqualTo : t1 < t2 ? CFComparisonResult.CompareLessThan : CFComparisonResult.CompareGreaterThan\n    })\n    return CFBinaryHeapCreate(nil, 0, &callBacks, nil)\n  }()\n  var count : Int { return CFBinaryHeapGetCount(heap) }\n  mutating func push(t: Task) {\n    CFBinaryHeapAddValue(heap, UnsafePointer(Unmanaged.passUnretained(t).toOpaque()))\n  }\n  func peek() -> Task {\n    return Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n  }\n  mutating func pop() -> Task {\n    let result = Unmanaged<Task>.fromOpaque(COpaquePointer(CFBinaryHeapGetMinimum(heap))).takeUnretainedValue()\n    CFBinaryHeapRemoveMinimumValue(heap)\n    return result\n  }\n}\n\nvar pq = TaskPriorityQueue()\n\npq.push(Task(priority: 3, name: \"Clear drains\"))\npq.push(Task(priority: 4, name: \"Feed cat\"))\npq.push(Task(priority: 5, name: \"Make tea\"))\npq.push(Task(priority: 1, name: \"Solve RC tasks\"))\npq.push(Task(priority: 2, name: \"Tax return\"))\n\nwhile pq.count != 0 {\n  print(pq.pop())\n}\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 11550, "name": "Hailstone sequence", "source": "Translate Swift to C#: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11553, "name": "Hailstone sequence", "source": "Translate Swift to Java: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11554, "name": "Hailstone sequence", "source": "Translate Swift to Java: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11555, "name": "Hailstone sequence", "source": "Translate Swift to Python: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11556, "name": "Hailstone sequence", "source": "Translate Swift to Python: func hailstone(var n:Int) -> [Int] {\n\n    var arr = [n]\n    \n    while n != 1 {\n\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n            n = (3 * n) + 1\n        }    \n\n        arr.append(n)\n    }\n    \n    return arr\n}\n\nlet n = hailstone(27)\n\nprintln(\"hailstone(27): \\(n[0...3]) ... \\(n[n.count-4...n.count-1]) for a count of \\(n.count).\")\n\nvar longest = (n: 1, len: 1)\n\nfor i in 1...100_000 {\n\n    let new = hailstone(i)\n    \n    if new.count > longest.len {\n        longest = (i, new.count)\n    }\n}\n\nprintln(\"Longest sequence for numbers under 100,000 is with \\(longest.n). Which has \\(longest.len) items.\")\n", "target": "def hailstone(n):\n    seq = [n]\n    while n > 1:\n        n = 3 * n + 1 if n & 1 else n // 2\n        seq.append(n)\n    return seq\n\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert (len(h) == 112\n            and h[:4] == [27, 82, 41, 124]\n            and h[-4:] == [8, 4, 2, 1])\n    max_length, n = max((len(hailstone(i)), i) for i in range(1, 100_000))\n    print(f\"Maximum length {max_length} was found for hailstone({n}) \"\n          f\"for numbers <100,000\")\n"}
{"id": 11996, "name": "Multifactorial", "source": "Translate Swift to C#: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11997, "name": "Multifactorial", "source": "Translate Swift to C#: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 12000, "name": "Multifactorial", "source": "Translate Swift to Java: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 12001, "name": "Multifactorial", "source": "Translate Swift to Java: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 12002, "name": "Multifactorial", "source": "Translate Swift to Python: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12003, "name": "Multifactorial", "source": "Translate Swift to Python: func multiFactorial(_ n: Int, k: Int) -> Int {\n  return stride(from: n, to: 0, by: -k).reduce(1, *)\n}\n\nlet multis = (1...5).map({degree in\n  (1...10).map({member in\n    multiFactorial(member, k: degree)\n  })\n})\n\nfor (i, degree) in multis.enumerated() {\n  print(\"Degree \\(i + 1): \\(degree)\")\n}\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12373, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12374, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12377, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12378, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12379, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12380, "name": "Shoelace formula for polygonal area", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nextension Point: CustomStringConvertible {\n  var description: String {\n    return \"Point(x: \\(x), y: \\(y))\"\n  }\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  var area: Double {\n    let xx = points.map({ $0.x })\n    let yy = points.map({ $0.y })\n    let overlace = zip(xx, yy.dropFirst() + yy.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n    let underlace = zip(yy, xx.dropFirst() + xx.prefix(1)).map({ $0.0 * $0.1 }).reduce(0, +)\n\n    return abs(overlace - underlace) / 2\n  }\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nlet poly = Polygon(points: [\n  (3,4),\n  (5,11),\n  (12,8),\n  (9,5),\n  (5,6)\n])\n\nprint(\"\\(poly) area = \\(poly.area)\")\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12746, "name": "Sudoku", "source": "Translate Swift to C#: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "using System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n"}
{"id": 12748, "name": "Sudoku", "source": "Translate Swift to Java: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "public class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n"}
{"id": 12749, "name": "Sudoku", "source": "Translate Swift to Python: import Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n", "target": "def initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n"}
{"id": 12990, "name": "Hello world_Newline omission", "source": "Translate Swift to C#: print(\"Goodbye, World!\", terminator: \"\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12992, "name": "Hello world_Newline omission", "source": "Translate Swift to Java: print(\"Goodbye, World!\", terminator: \"\")\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 13446, "name": "Vector products", "source": "Translate Swift to C#: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13447, "name": "Vector products", "source": "Translate Swift to C#: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13450, "name": "Vector products", "source": "Translate Swift to Java: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13451, "name": "Vector products", "source": "Translate Swift to Java: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13452, "name": "Vector products", "source": "Translate Swift to Python: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13453, "name": "Vector products", "source": "Translate Swift to Python: import Foundation\n\ninfix operator \u2022 : MultiplicationPrecedence\ninfix operator \u00d7 : MultiplicationPrecedence\n\npublic struct Vector {\n  public var x = 0.0\n  public var y = 0.0\n  public var z = 0.0\n\n  public init(x: Double, y: Double, z: Double) {\n    (self.x, self.y, self.z) = (x, y, z)\n  }\n\n  public static func \u2022 (lhs: Vector, rhs: Vector) -> Double {\n    return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z\n  }\n\n  public static func \u00d7 (lhs: Vector, rhs: Vector) -> Vector {\n    return Vector(\n      x: lhs.y * rhs.z - lhs.z * rhs.y,\n      y: lhs.z * rhs.x - lhs.x * rhs.z,\n      z: lhs.x * rhs.y - lhs.y * rhs.x\n    )\n  }\n}\n\nlet a = Vector(x: 3, y: 4, z: 5)\nlet b = Vector(x: 4, y: 3, z: 5)\nlet c = Vector(x: -5, y: -12, z: -13)\n\nprint(\"a: \\(a)\")\nprint(\"b: \\(b)\")\nprint(\"c: \\(c)\")\nprint()\nprint(\"a \u2022 b = \\(a \u2022 b)\")\nprint(\"a \u00d7 b = \\(a \u00d7 b)\")\nprint(\"a \u2022 (b \u00d7 c) = \\(a \u2022 (b \u00d7 c))\")\nprint(\"a \u00d7 (b \u00d7 c) = \\(a \u00d7 (b \u00d7 c))\")\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13724, "name": "Hello world_Standard error", "source": "Translate Swift to C#: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13726, "name": "Hello world_Standard error", "source": "Translate Swift to Java: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13727, "name": "Hello world_Standard error", "source": "Translate Swift to Python: import Foundation\n\nlet out = NSOutputStream(toFileAtPath: \"/dev/stderr\", append: true)\nlet err = \"Goodbye, World!\".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)\nout?.open()\nlet success = out?.write(UnsafePointer<UInt8>(err!.bytes), maxLength: err!.length)\nout?.close()\n\nif let bytes = success {\n    println(\"\\nWrote \\(bytes) bytes\")\n}\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 14822, "name": "Cholesky decomposition", "source": "Translate Swift to C#: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Cholesky\n{\n    class Program\n    {\n        \n        \n        \n        \n        static void Main(string[] args)\n        {\n            double[,] test1 = new double[,]\n            {\n                {25, 15, -5},\n                {15, 18, 0},\n                {-5, 0, 11},\n            };\n\n            double[,] test2 = new double[,]\n            {\n                {18, 22, 54, 42},\n                {22, 70, 86, 62},\n                {54, 86, 174, 134},\n                {42, 62, 134, 106},\n            };\n\n            double[,] chol1 = Cholesky(test1);\n            double[,] chol2 = Cholesky(test2);\n\n            Console.WriteLine(\"Test 1: \");\n            Print(test1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 1: \");\n            Print(chol1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Test 2: \");\n            Print(test2);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 2: \");\n            Print(chol2);\n\n        }\n\n        public static void Print(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            StringBuilder sb = new StringBuilder();\n            for (int r = 0; r < n; r++)\n            {\n                string s = \"\";\n                for (int c = 0; c < n; c++)\n                {\n                    s += a[r, c].ToString(\"f5\").PadLeft(9) + \",\";\n                }\n                sb.AppendLine(s);\n            }\n\n            Console.WriteLine(sb.ToString());\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public static double[,] Cholesky(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            double[,] ret = new double[n, n];\n            for (int r = 0; r < n; r++)\n                for (int c = 0; c <= r; c++)\n                {\n                    if (c == r)\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                        {\n                            sum += ret[c, j] * ret[c, j];\n                        }\n                        ret[c, c] = Math.Sqrt(a[c, c] - sum);\n                    }\n                    else\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                            sum += ret[r, j] * ret[c, j];\n                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);\n                    }\n                }\n\n            return ret;\n        }\n    }\n}\n"}
{"id": 14824, "name": "Cholesky decomposition", "source": "Translate Swift to Java: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "import java.util.Arrays;\n\npublic class Cholesky {\n\tpublic static double[][] chol(double[][] a){\n\t\tint m = a.length;\n\t\tdouble[][] l = new double[m][m]; \n\t\tfor(int i = 0; i< m;i++){\n\t\t\tfor(int k = 0; k < (i+1); k++){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tsum += l[i][j] * l[k][j];\n\t\t\t\t}\n\t\t\t\tl[i][k] = (i == k) ? Math.sqrt(a[i][i] - sum) :\n\t\t\t\t\t(1.0 / l[k][k] * (a[i][k] - sum));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tdouble[][] test1 = {{25, 15, -5},\n\t\t\t\t\t\t\t{15, 18, 0},\n\t\t\t\t\t\t\t{-5, 0, 11}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test1)));\n\t\tdouble[][] test2 = {{18, 22, 54, 42},\n\t\t\t\t\t\t\t{22, 70, 86, 62},\n\t\t\t\t\t\t\t{54, 86, 174, 134},\n\t\t\t\t\t\t\t{42, 62, 134, 106}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test2)));\n\t}\n}\n"}
{"id": 14825, "name": "Cholesky decomposition", "source": "Translate Swift to Python: func cholesky(matrix: [Double], n: Int) -> [Double] {\n  var res = [Double](repeating: 0, count: matrix.count)\n\n  for i in 0..<n {\n    for j in 0..<i+1 {\n      var s = 0.0\n\n      for k in 0..<j {\n        s += res[i * n + k] * res[j * n + k]\n      }\n\n      if i == j {\n        res[i * n + j] = (matrix[i * n + i] - s).squareRoot()\n      } else {\n        res[i * n + j] = (1.0 / res[j * n + j] * (matrix[i * n + j] - s))\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix(_ matrix: [Double], n: Int) {\n  for i in 0..<n {\n    for j in 0..<n {\n      print(matrix[i * n + j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\nlet res1 = cholesky(\n  matrix: [25.0, 15.0, -5.0,\n           15.0, 18.0,  0.0,\n           -5.0,  0.0, 11.0],\n  n: 3\n)\n\nlet res2 = cholesky(\n  matrix: [18.0, 22.0,  54.0,  42.0,\n           22.0, 70.0,  86.0,  62.0,\n           54.0, 86.0, 174.0, 134.0,\n           42.0, 62.0, 134.0, 106.0],\n  n: 4\n)\n\nprintMatrix(res1, n: 3)\nprint()\nprintMatrix(res2, n: 4)\n", "target": "from __future__ import print_function\n\nfrom pprint import pprint\nfrom math import sqrt\n\n\ndef cholesky(A):\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\n    for i in xrange(len(A)):\n        for j in xrange(i+1):\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\n                      (1.0 / L[j][j] * (A[i][j] - s))\n    return L\n\nif __name__ == \"__main__\":\n    m1 = [[25, 15, -5],\n          [15, 18,  0],\n          [-5,  0, 11]]\n    pprint(cholesky(m1))\n    print()\n    \n    m2 = [[18, 22,  54,  42],\n          [22, 70,  86,  62],\n          [54, 86, 174, 134],\n          [42, 62, 134, 106]]\n    pprint(cholesky(m2), width=120)\n"}
{"id": 15031, "name": "Almost prime", "source": "Translate Swift to C#: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 15033, "name": "Almost prime", "source": "Translate Swift to Java: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 15034, "name": "Almost prime", "source": "Translate Swift to Python: struct KPrimeGen: Sequence, IteratorProtocol {\n  let k: Int\n  private(set) var n: Int\n\n  private func isKPrime() -> Bool {\n    var primes = 0\n    var f = 2\n    var rem = n\n\n    while primes < k && rem > 1 {\n      while rem % f == 0 && rem > 1 {\n        rem /= f\n        primes += 1\n      }\n\n      f += 1\n    }\n\n    return rem == 1 && primes == k\n  }\n\n  mutating func next() -> Int? {\n    n += 1\n\n    while !isKPrime() {\n      n += 1\n    }\n\n    return n\n  }\n}\n\nfor k in 1..<6 {\n  print(\"\\(k): \\(Array(KPrimeGen(k: k, n: 1).lazy.prefix(10)))\")\n}\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15311, "name": "Integer comparison", "source": "Translate Swift to C#: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15313, "name": "Integer comparison", "source": "Translate Swift to Java: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15314, "name": "Integer comparison", "source": "Translate Swift to Python: import Cocoa\n\nvar input = NSFileHandle.fileHandleWithStandardInput()\n\nprintln(\"Enter two integers separated by a space: \")\n\nlet data = input.availableData\nlet stringArray = NSString(data: data, encoding: NSUTF8StringEncoding)?.componentsSeparatedByString(\" \")\nvar a:Int!\nvar b:Int!\nif (stringArray?.count == 2) {\n    a = stringArray![0].integerValue\n    b = stringArray![1].integerValue\n}\nif (a==b)  {println(\"\\(a) equals \\(b)\")}\nif (a < b) {println(\"\\(a) is less than \\(b)\")}\nif (a > b) {println(\"\\(a) is greater than \\(b)\")}\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15524, "name": "Environment variables", "source": "Translate Swift to C#: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15526, "name": "Environment variables", "source": "Translate Swift to Java: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15527, "name": "Environment variables", "source": "Translate Swift to Python: print(\"USER: \\(ProcessInfo.processInfo.environment[\"USER\"] ?? \"Not set\")\")\nprint(\"PATH: \\(ProcessInfo.processInfo.environment[\"PATH\"] ?? \"Not set\")\")\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15774, "name": "Substring", "source": "Translate Swift to C#: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15776, "name": "Substring", "source": "Translate Swift to Java: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15777, "name": "Substring", "source": "Translate Swift to Python: let string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  \n  _ = string[start..<end]\n  \n  string.substringWithRange(start..<end)\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  \n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n\ndo {\n  \n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  \n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n\ndo {\n  \n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n\ndo {\n  \n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 16054, "name": "Evaluate binomial coefficients", "source": "Translate Swift to C#: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "using System;\n\nnamespace BinomialCoefficients\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ulong n = 1000000, k = 3;\n            ulong result = biCoefficient(n, k);\n            Console.WriteLine(\"The Binomial Coefficient of {0}, and {1}, is equal to: {2}\", n, k, result);\n            Console.ReadLine();\n        }\n\n        static int fact(int n)\n        {\n            if (n == 0) return 1;\n            else return n * fact(n - 1);\n        }\n\n        static ulong biCoefficient(ulong n, ulong k)\n        {\n            if (k > n - k)\n            {\n                k = n - k;\n            }\n\n            ulong c = 1;\n            for (uint i = 0; i < k; i++)\n            {\n                c = c * (n - i);\n                c = c / (i + 1);\n            }\n            return c;\n        }\n    }\n}\n"}
{"id": 16056, "name": "Evaluate binomial coefficients", "source": "Translate Swift to Java: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "public class Binomial {\n\n    \n    private static long binomialInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static Object binomialIntReliable(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++) {\n            try {\n                binom = Math.multiplyExact(binom, n + 1 - i) / i;\n            } catch (ArithmeticException e) {\n                return \"overflow\";\n            }\n        }\n        return binom;\n    }\n\n    \n    \n    private static double binomialFloat(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        double binom = 1.0;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static BigInteger binomialBigInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        BigInteger binom = BigInteger.ONE;\n        for (int i = 1; i <= k; i++) {\n            binom = binom.multiply(BigInteger.valueOf(n + 1 - i));\n            binom = binom.divide(BigInteger.valueOf(i));\n        }\n        return binom;\n    }\n\n    private static void demo(int n, int k) {\n        List<Object> data = Arrays.asList(\n                n,\n                k,\n                binomialInt(n, k),\n                binomialIntReliable(n, k),\n                binomialFloat(n, k),\n                binomialBigInt(n, k));\n\n        System.out.println(data.stream().map(Object::toString).collect(Collectors.joining(\"\\t\")));\n    }\n\n    public static void main(String[] args) {\n        demo(5, 3);\n        demo(1000, 300);\n    }\n}\n"}
{"id": 16057, "name": "Evaluate binomial coefficients", "source": "Translate Swift to Python: func factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\nfunc binomial<T: BinaryInteger>(_ x: (n: T, k: T)) -> T {\n  let nFac = factorial(x.n)\n  let kFac = factorial(x.k)\n\n  return nFac / (factorial(x.n - x.k) * kFac)\n}\n\nprint(\"binomial(\\(5), \\(3)) = \\(binomial((5, 3)))\")\nprint(\"binomial(\\(20), \\(11)) = \\(binomial((20, 11)))\")\n", "target": "def binomialCoeff(n, k):\n    result = 1\n    for i in range(1, k+1):\n        result = result * (n-i+1) / i\n    return result\n\nif __name__ == \"__main__\":\n    print(binomialCoeff(5, 3))\n"}
{"id": 16662, "name": "Perfect numbers", "source": "Translate Swift to C#: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16664, "name": "Perfect numbers", "source": "Translate Swift to Java: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16665, "name": "Perfect numbers", "source": "Translate Swift to Python: func perfect(n:Int) -> Bool {\n    var sum = 0\n    for i in 1..<n {\n        if n % i == 0 {\n            sum += i\n        }\n    }\n    return sum == n\n}\n\nfor i in 1..<10000 {\n    if perfect(i) {\n        println(i)\n    }\n}\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 18153, "name": "Munchausen numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18154, "name": "Munchausen numbers", "source": "Translate Swift to C#: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 18157, "name": "Munchausen numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18158, "name": "Munchausen numbers", "source": "Translate Swift to Java: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 18159, "name": "Munchausen numbers", "source": "Translate Swift to Python: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18160, "name": "Munchausen numbers", "source": "Translate Swift to Python: import Foundation\n\nfunc isM\u00fcnchhausen(_ n: Int) -> Bool {\n  let nums = String(n).map(String.init).compactMap(Int.init)\n\n  return Int(nums.map({ pow(Double($0), Double($0)) }).reduce(0, +)) == n\n}\n\nfor i in 1...5000 where isM\u00fcnchhausen(i) {\n  print(i)\n}\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18402, "name": "Strip block comments", "source": "Translate Swift to C#: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "using System;\n\n    class Program\n    {\n        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)\n        {\n            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)\n            {\n                int start = sampleText.IndexOf(commentStart);\n                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);\n                sampleText = sampleText.Remove(\n                    start,\n                    (end + commentEnd.Length) - start\n                    );\n            }\n            return sampleText;\n        }\n    }\n"}
{"id": 18404, "name": "Strip block comments", "source": "Translate Swift to Java: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "import java.io.*;\n\npublic class StripBlockComments{\n    public static String readFile(String filename) {\n\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\ttry {\n\t    StringBuilder fileContents = new StringBuilder();\n\t    char[] buffer = new char[4096];\n\t    while (reader.read(buffer, 0, 4096) > 0) {\n\t\tfileContents.append(buffer);\n\t    }\n\t    return fileContents.toString();\n\t} finally {\n\t    reader.close();\n\t}\n    }\n\n    public static String stripComments(String beginToken, String endToken,\n\t\t\t\t       String input) {\n\tStringBuilder output = new StringBuilder();\n\twhile (true) {\n\t    int begin = input.indexOf(beginToken);\n\t    int end = input.indexOf(endToken, begin+beginToken.length());\n\t    if (begin == -1 || end == -1) {\n\t\toutput.append(input);\n\t\treturn output.toString();\n\t    }\n\t    output.append(input.substring(0, begin));\n\t    input = input.substring(end + endToken.length());\n\t}\n    }\n\n    public static void main(String[] args) {\n\tif (args.length < 3) {\n\t    System.out.println(\"Usage: BeginToken EndToken FileToProcess\");\n\t    System.exit(1);\n\t}\n\n\tString begin = args[0];\n\tString end = args[1];\n\tString input = args[2];\n\n\ttry {\n\t    System.out.println(stripComments(begin, end, readFile(input)));\n\t} catch (Exception e) {\n\t    e.printStackTrace();\n\t    System.exit(1);\n\t}\n    }\n}\n"}
{"id": 18405, "name": "Strip block comments", "source": "Translate Swift to Python: import Foundation\n\nfunc stripBlocks(from str: String, open: String = \"\") -> String {\n  guard !open.isEmpty && !close.isEmpty else {\n    return str\n  }\n\n  var ret = str\n\n  while let begin = ret.range(of: open), let end = ret[begin.upperBound...].range(of: close) {\n    ret.replaceSubrange(Range(uncheckedBounds: (begin.lowerBound, end.upperBound)), with: \"\")\n  }\n\n  return ret\n}\n\nlet test = \"\"\"\n             \n           function subroutine() {\n            a =  b + c\u00a0;\n           }\n           \n\n           \n            function something() {\n            }\n           \"\"\"\n\nprint(stripBlocks(from: test))\n", "target": "def _commentstripper(txt, delim):\n    'Strips first nest of block comments'\n    \n    deliml, delimr = delim\n    out = ''\n    if deliml in txt:\n        indx = txt.index(deliml)\n        out += txt[:indx]\n        txt = txt[indx+len(deliml):]\n        txt = _commentstripper(txt, delim)\n        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt\n        indx = txt.index(delimr)\n        out += txt[(indx+len(delimr)):]\n    else:\n        out = txt\n    return out\n\ndef commentstripper(txt, delim=('/*', '*/')):\n    'Strips nests of block comments'\n    \n    deliml, delimr = delim\n    while deliml in txt:\n        txt = _commentstripper(txt, delim)\n    return txt\n"}
{"id": 18729, "name": "Arithmetic_Complex", "source": "Translate Swift to C#: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18731, "name": "Arithmetic_Complex", "source": "Translate Swift to Java: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18732, "name": "Arithmetic_Complex", "source": "Translate Swift to Python: public struct Complex {\n    \n    public let real : Double\n    public let imaginary : Double\n    \n    public init(real inReal:Double, imaginary inImaginary:Double) {\n        real = inReal\n        imaginary = inImaginary\n    }\n    \n    public static var i : Complex = Complex(real:0, imaginary: 1)\n    public static var zero : Complex = Complex(real: 0, imaginary: 0)\n    \n    public var negate : Complex {\n        return Complex(real: -real, imaginary: -imaginary)\n    }\n    \n    public var invert : Complex {\n        let d = (real*real + imaginary*imaginary)\n        return Complex(real: real/d, imaginary: -imaginary/d)\n    }\n    \n    public var conjugate : Complex {\n        return Complex(real: real, imaginary: -imaginary)\n    }\n    \n}\npublic func + (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real+right.real, imaginary: left.imaginary+right.imaginary)\n}\npublic func * (left: Complex, right: Complex) -> Complex {\n    \n    return Complex(real: left.real*right.real - left.imaginary*right.imaginary,\n        imaginary: left.real*right.imaginary+left.imaginary*right.real)\n}\npublic prefix func - (right:Complex) -> Complex {\n    return right.negate\n}\n\n\nextension Complex : Equatable {}\npublic func == (left:Complex, right:Complex) -> Bool {\n    return left.real == right.real && left.imaginary == right.imaginary\n}\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 18949, "name": "Walk a directory_Recursively", "source": "Translate Swift to C#: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace RosettaRecursiveDirectory\n{\n    class Program\n    {\n        static IEnumerable<FileInfo> TraverseDirectory(string rootPath, Func<FileInfo, bool> Pattern)\n        {\n            var directoryStack = new Stack<DirectoryInfo>();\n            directoryStack.Push(new DirectoryInfo(rootPath));\n            while (directoryStack.Count > 0)\n            {\n                var dir = directoryStack.Pop();\n                try\n                {\n                    foreach (var i in dir.GetDirectories())\n                        directoryStack.Push(i);\n                }\n                catch (UnauthorizedAccessException) {\n                    continue; \n                }\n                foreach (var f in dir.GetFiles().Where(Pattern)) \n                    yield return f;\n            }\n        }\n        static void Main(string[] args)\n        {\n            \n            foreach (var file in TraverseDirectory(@\"C:\\Windows\", f => f.Extension == \".wmv\"))\n                Console.WriteLine(file.FullName);\n            Console.WriteLine(\"Done.\");\n        }\n    }\n}\n"}
{"id": 18951, "name": "Walk a directory_Recursively", "source": "Translate Swift to Java: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "import java.io.File;\n\npublic class MainEntry {\n    public static void main(String[] args) {\n        walkin(new File(\"/home/user\")); \n    }\n    \n    \n    public static void walkin(File dir) {\n        String pattern = \".mp3\";\n        \n        File listFile[] = dir.listFiles();\n        if (listFile != null) {\n            for (int i=0; i<listFile.length; i++) {\n                if (listFile[i].isDirectory()) {\n                    walkin(listFile[i]);\n                } else {\n                    if (listFile[i].getName().endsWith(pattern)) {\n                        System.out.println(listFile[i].getPath());\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 18952, "name": "Walk a directory_Recursively", "source": "Translate Swift to Python: import Foundation\n\nlet fileSystem = FileManager.default\nlet rootPath = \"/\"\n\n\n\nif let fsTree = fileSystem.enumerator(atPath: rootPath) {\n\t\n    while let fsNodeName = fsTree.nextObject() as? NSString {\n\t\t\t\t\n        let fullPath = \"\\(rootPath)/\\(fsNodeName)\"\n\t\t\t\t\n        var isDir: ObjCBool = false\n        fileSystem.fileExists(atPath: fullPath, isDirectory: &isDir)\n\t\t\t\t\n        if !isDir.boolValue && fsNodeName.pathExtension == \"txt\" {\n            print(fsNodeName)\n        }\n    }\n}\n", "target": "from pathlib import Path\n\nfor path in Path('.').rglob('*.*'):\n    print(path)\n"}
{"id": 19274, "name": "Deal cards for FreeCell", "source": "Translate Swift to C#: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class RNG\n    {\n        private int _state;\n\n        public RNG()\n        {\n            _state = (int)DateTime.Now.Ticks;\n        }\n\n        public RNG(int n)\n        {\n            _state = n;\n        }\n        public int Next()\n        {\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n    }\n\n    public enum Rank\n    {\n        Ace,\n        One,\n        Two,\n        Three,\n        Four,\n        Five,\n        Six,\n        Seven,\n        Eight,\n        Nine,\n        Ten,\n        Jack,\n        Queen,\n        King\n    }\n\n    public enum Suit\n    {\n        Clubs,\n        Diamonds,\n        Hearts,\n        Spades\n    }\n\n    public class Card\n    {\n        private const string Ranks = \"A23456789TJQK\";\n        private const string Suits = \"CDHS\";\n\n        private Rank _rank;\n        public Rank Rank\n        {\n            get\n            {\n                return _rank;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 12)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _rank = value;\n            }\n        }\n\n        private Suit _suit;\n        public Suit Suit\n        {\n            get\n            {\n                return _suit;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 3)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _suit = value;\n            }\n        }\n\n        public Card(Rank rank, Suit suit)\n        {\n            Rank = rank;\n            Suit = suit;\n        }\n\n        public int NRank()\n        {\n            return (int) Rank;\n        }\n\n        public int NSuit()\n        {\n            return (int) Suit;\n        }\n\n        public override string ToString()\n        {\n            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});\n        }\n    }\n\n    public class FreeCellDeal\n    {\n        public List<Card> Deck { get; private set; }\n\n        public FreeCellDeal(int iDeal)\n        {\n            RNG rng = new RNG(iDeal);\n\n            List<Card> rDeck = new List<Card>();\n            Deck = new List<Card>();\n\n            for (int rank = 0; rank < 13; rank++)\n            {\n                for (int suit = 0; suit < 4; suit++)\n                {\n                    rDeck.Add(new Card((Rank)rank, (Suit)suit));\n                }\n            }\n\n            \n            \n            for (int iCard = 51; iCard >= 0; iCard--)\n            {\n                int iSwap = rng.Next() % (iCard + 1);\n                Deck.Add(rDeck[iSwap]);\n                rDeck[iSwap] = rDeck[iCard];\n            }\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int iRow = 0; iRow < 6; iRow++ )\n            {\n                for (int iCol = 0; iCol < 8; iCol++)\n                {\n                    sb.AppendFormat(\"{0} \", Deck[iRow * 8 + iCol]);\n                }\n                sb.Append(\"\\n\");\n            }\n            for (int iCard = 48; iCard < 52; iCard++)\n            {\n                sb.AppendFormat(\"{0} \", Deck[iCard]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            Console.WriteLine(new FreeCellDeal(1));\n            Console.WriteLine();\n            Console.WriteLine(new FreeCellDeal(617));\n        }\n    }\n}\n"}
{"id": 19276, "name": "Deal cards for FreeCell", "source": "Translate Swift to Java: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "import java.util.Arrays;\n\npublic class Shuffler {\n\t\n\tprivate int seed;\n\t\n\tprivate String[] deck = {\n\t\t\t\"AC\", \"AD\", \"AH\", \"AS\",\n\t\t\t\"2C\", \"2D\", \"2H\", \"2S\",\n\t\t\t\"3C\", \"3D\", \"3H\", \"3S\",\n\t\t\t\"4C\", \"4D\", \"4H\", \"4S\",\n\t\t\t\"5C\", \"5D\", \"5H\", \"5S\",\n\t\t\t\"6C\", \"6D\", \"6H\", \"6S\",\n\t\t\t\"7C\", \"7D\", \"7H\", \"7S\",\n\t\t\t\"8C\", \"8D\", \"8H\", \"8S\",\n\t\t\t\"9C\", \"9D\", \"9H\", \"9S\",\n\t\t\t\"TC\", \"TD\", \"TH\", \"TS\",\n\t\t\t\"JC\", \"JD\", \"JH\", \"JS\",\n\t\t\t\"QC\", \"QD\", \"QH\", \"QS\",\n\t\t\t\"KC\", \"KD\", \"KH\", \"KS\",\n\t};\n\t\n\tprivate int random() {\n\t\tseed = (214013 * seed + 2531011) & Integer.MAX_VALUE;\n\t\treturn seed >> 16;\n\t}\n\t\n\t\n\tprivate String[] getShuffledDeck() {\n\t\tString[] deck = Arrays.copyOf(this.deck, this.deck.length);\n\t\tfor(int i = deck.length - 1; i > 0; i--) {\n\t\t\tint r = random() % (i + 1);\n\t\t\tString card = deck[r];\n\t\t\tdeck[r] = deck[i];\n\t\t\tdeck[i] = card;\n\t\t}\n\t\treturn deck;\n\t}\n\t\n\t\n\tpublic void dealGame(int seed) {\n\t\tthis.seed = seed;\n\t\tString[] shuffledDeck = getShuffledDeck();\n\t\tfor(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {\n\t\t\tSystem.out.print(shuffledDeck[i]);\n\t\t\tif(count % 8 == 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tShuffler s = new Shuffler();\n\t\ts.dealGame(1);\n\t\tSystem.out.println();\n\t\ts.dealGame(617);\n\t}\n\t\n}\n"}
{"id": 19277, "name": "Deal cards for FreeCell", "source": "Translate Swift to Python: enum Suit : String, CustomStringConvertible, CaseIterable {\n    case clubs = \"C\", diamonds = \"D\", hearts = \"H\", spades = \"S\"\n    var description: String {\n        return self.rawValue\n    }\n}\nenum Rank : Int, CustomStringConvertible, CaseIterable {\n    case ace=1, two, three, four, five, six, seven\n    case eight, nine, ten, jack, queen, king\n    var description: String {\n        let d : [Rank:String] = [.ace:\"A\", .king:\"K\", .queen:\"Q\", .jack:\"J\", .ten:\"T\"]\n        return d[self] ?? String(self.rawValue)\n    }\n}\nstruct Card : CustomStringConvertible {\n    let rank : Rank, suit : Suit\n    var description : String {\n        return String(describing:self.rank) + String(describing:self.suit)\n    }\n    init(rank:Rank, suit:Suit) {\n        self.rank = rank; self.suit = suit\n    }\n    init(sequence n:Int) {\n        self.init(rank:Rank.allCases[n/4], suit:Suit.allCases[n%4])\n    }\n}\nstruct Deck : CustomStringConvertible {\n    var cards = [Card]()\n    init(seed:Int) {\n        for i in (0..<52).reversed() {\n            self.cards.append(Card(sequence:i))\n        }\n        struct MicrosoftLinearCongruentialGenerator {\n            var seed : Int\n            mutating func next() -> Int {\n                self.seed = (self.seed * 214013 + 2531011) % (Int(Int32.max)+1)\n                return self.seed >> 16\n            }\n        }\n        var r = MicrosoftLinearCongruentialGenerator(seed: seed)\n        for i in 0..<51 {\n            self.cards.swapAt(i, 51-r.next()%(52-i))\n        }\n    }\n    var description : String {\n        var s = \"\"\n        for (ix,c) in self.cards.enumerated() {\n            s.write(String(describing:c))\n            s.write(ix % 8 == 7 ? \"\\n\" : \" \")\n        }\n        return s\n    }\n}\nlet d1 = Deck(seed: 1)\nprint(d1)\nlet d617 = Deck(seed: 617)\nprint(d617)\n", "target": "def randomGenerator(seed=1):\n    max_int32 = (1 << 31) - 1\n    seed = seed & max_int32\n\n    while True:\n        seed = (seed * 214013 + 2531011) & max_int32\n        yield seed >> 16\n\ndef deal(seed):\n    nc = 52\n    cards = list(range(nc - 1, -1, -1))\n    rnd = randomGenerator(seed)\n    for i, r in zip(range(nc), rnd):\n        j = (nc - 1) - r % (nc - i)\n        cards[i], cards[j] = cards[j], cards[i]\n    return cards\n\ndef show(cards):\n    l = [\"A23456789TJQK\"[int(c/4)] + \"CDHS\"[c%4] for c in cards]\n    for i in range(0, len(cards), 8):\n        print(\" \".join(l[i : i+8]))\n\nif __name__ == '__main__':\n    from sys import argv\n    seed = int(argv[1]) if len(argv) == 2 else 11982\n    print(\"Hand {}\".format(seed))\n    deck = deal(seed)\n    show(deck)\n"}
{"id": 19474, "name": "Handle a signal", "source": "Translate Swift to C#: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19476, "name": "Handle a signal", "source": "Translate Swift to Java: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19477, "name": "Handle a signal", "source": "Translate Swift to Python: import Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 20034, "name": "Huffman coding", "source": "Translate Swift to C#: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 20036, "name": "Huffman coding", "source": "Translate Swift to Java: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "import java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; \n    public HuffmanTree(int freq) { frequency = freq; }\n\n    \n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; \n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; \n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    \n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        \n        \n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        \n        while (trees.size() > 1) {\n            \n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            \n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            \n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            \n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            \n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        \n        \n        int[] charFreqs = new int[256];\n        \n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        \n        HuffmanTree tree = buildTree(charFreqs);\n\n        \n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n"}
{"id": 20037, "name": "Huffman coding", "source": "Translate Swift to Python: enum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  \n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  \n  var nodes = [(Int, HuffmanTree<T>)]()\n  \n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    \n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    \n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    \n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    \n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n", "target": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n\n\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n"}
{"id": 20192, "name": "Primality by Wilson's theorem", "source": "Translate Swift to C#: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "using System;\nusing System.Linq;\nusing System.Collections;\nusing static System.Console;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n  \n    const int fst = 120, skp = 1000, max = 1015; static double et1, et2; static DateTime st;\n    static string ms1 = \"Wilson's theorem method\", ms2 = \"Sieve of Eratosthenes method\", \n       fmt = \"--- {0} ---\\n\\nThe first {1} primes are:\", fm2 = \"{0} prime thru the {1} prime:\";\n    static List<int> lst = new List<int>();\n\n  \n    static void Dump(int s, int t, string f) {\n        foreach (var item in lst.Skip(s).Take(t)) Write(f, item); WriteLine(\"\\n\"); }\n\n  \n    static string Ord(int x, string fmt = \"{0:n0}\") {\n      var y = x % 10; if ((x % 100) / 10 == 10 || y > 3) y = 0;\n      return string.Format(fmt, x) + \"thstndrd\".Substring(y << 1, 2); }\n\n  \n    static void ShowOne(string title, ref double et) {\n        WriteLine(fmt, title, fst); Dump(0, fst, \"{0,-3} \");\n        WriteLine(fm2, Ord(skp), Ord(max)); Dump(skp - 1, max - skp + 1, \"{0,4} \");\n        WriteLine(\"Time taken: {0}ms\\n\", et = (DateTime.Now - st).TotalMilliseconds); }\n\n  \n    static BI factorial(int n) { BI res = 1; if (n < 2) return res;\n        while (n > 0) res *= n--; return res; }\n\n    static bool WTisPrimeSA(int n) { return ((factorial(n - 1) + 1) % n) == 0; }\n\n    static BI[] facts;\n\n    static void initFacts(int n) {\n        facts = new BI[n]; facts[0] = facts[1] = 1;\n        for (int i = 1, j = 2; j < n; i = j++)\n            facts[j] = facts[i] * j; }\n\n    static bool WTisPrime(int n) { return ((facts[n - 1] + 1) % n) == 0; }\n  \n\n    static void Main(string[] args) { st = DateTime.Now;\n        BI f = 1; for (int n = 2; lst.Count < max; f *= n++) if ((f + 1) % n == 0) lst.Add(n);\n        ShowOne(ms1, ref et1);\n        st = DateTime.Now; int lmt = lst.Last(); lst.Clear(); BitArray flags = new BitArray(lmt + 1);\n        for (int n = 2; n <= lmt; n+=n==2?1:2) if (!flags[n]) {\n                lst.Add(n); for (int k = n * n, n2=n<<1; k <= lmt; k += n2) flags[k] = true; }\n        ShowOne(ms2, ref et2);\n        WriteLine(\"{0} was {1:0.0} times slower than the {2}.\", ms1, et1 / et2, ms2);\n\n      \n        WriteLine(\"\\n\" + ms1 + \" stand-alone computation:\");\n        WriteLine(\"factorial computed for each item\");\n        st = DateTime.Now;\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrimeSA(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n\n        WriteLine(\"factorials precomputed up to highest item\");\n        st = DateTime.Now; initFacts(lst[max - 1]);\n        for (int x = lst[skp - 1]; x <= lst[max - 1]; x++) if (WTisPrime(x)) Write(\"{0,4} \", x);\n        WriteLine(); WriteLine(\"\\nTime taken: {0}ms\\n\", (DateTime.Now - st).TotalMilliseconds);\n    }\n}\n"}
{"id": 20194, "name": "Primality by Wilson's theorem", "source": "Translate Swift to Java: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "import java.math.BigInteger;\n\npublic class PrimaltyByWilsonsTheorem {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Primes less than 100 testing by Wilson's Theorem%n\");\n        for ( int i = 0 ; i <= 100 ; i++ ) {\n            if ( isPrime(i) ) {\n                System.out.printf(\"%d \", i);\n            }\n        }\n    }\n    \n    \n    private static boolean isPrime(long p) {\n        if ( p <= 1) {\n            return false;\n        }\n        return fact(p-1).add(BigInteger.ONE).mod(BigInteger.valueOf(p)).compareTo(BigInteger.ZERO) == 0;\n    }\n    \n    private static BigInteger fact(long n) {\n        BigInteger fact = BigInteger.ONE;\n        for ( int i = 2 ; i <= n ; i++ ) {\n            fact = fact.multiply(BigInteger.valueOf(i));\n        }\n        return fact;\n    }\n\n}\n"}
{"id": 20195, "name": "Primality by Wilson's theorem", "source": "Translate Swift to Python: import BigInt\n\nfunc factorial<T: BinaryInteger>(_ n: T) -> T {\n  guard n != 0 else {\n    return 1\n  }\n\n  return stride(from: n, to: 0, by: -1).reduce(1, *)\n}\n\n\nfunc isWilsonPrime<T: BinaryInteger>(_ n: T) -> Bool {\n  guard n >= 2 else {\n    return false\n  }\n\n  return (factorial(n - 1) + 1) % n == 0\n}\n\nprint((1...100).map({ BigInt($0) }).filter(isWilsonPrime))\n", "target": "from math import factorial\n\ndef is_wprime(n):\n    return n == 2 or (\n        n > 1\n        and n % 2 != 0\n        and (factorial(n - 1) + 1) % n == 0\n    )\n\nif __name__ == '__main__':\n    c = int(input('Enter upper limit: '))\n    print(f'Primes under {c}:')\n    print([n for n in range(c) if is_wprime(n)])\n"}
{"id": 20565, "name": "Parallel calculations", "source": "Translate Swift to C#: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static List<int> PrimeFactors(int number)\n    {\n        var primes = new List<int>();\n        for (int div = 2; div <= number; div++)\n        {\n            while (number % div == 0)\n            {\n                primes.Add(div);\n                number = number / div;\n            }\n        }\n        return primes;\n    }\n\n    static void Main(string[] args)\n    {\n        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };\n        \n        var factors = n.AsParallel().Select(PrimeFactors).ToList();\n        \n        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();\n        \n        int biggestFactor = smallestFactors.Max();\n        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);\n        Console.WriteLine(\"{0} has the largest minimum prime factor: {1}\", n[whatIndexIsThat], biggestFactor);\n        Console.WriteLine(string.Join(\" \", factors[whatIndexIsThat]));\n    }\n}\n"}
{"id": 20567, "name": "Parallel calculations", "source": "Translate Swift to Java: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "import static java.lang.System.out; \nimport static java.util.Arrays.stream;\nimport static java.util.Comparator.comparing;\n \npublic interface ParallelCalculations {\n    public static final long[] NUMBERS = {\n      12757923,\n      12878611,\n      12878893,\n      12757923,\n      15808973,\n      15780709,\n      197622519\n    };\n \n    public static void main(String... arguments) {\n      stream(NUMBERS)\n        .unordered()\n        .parallel()\n        .mapToObj(ParallelCalculations::minimalPrimeFactor)\n        .max(comparing(a -> a[0]))\n        .ifPresent(res -> out.printf(\n          \"%d has the largest minimum prime factor: %d%n\",\n          res[1],\n          res[0]\n        ));\n    }\n \n    public static long[] minimalPrimeFactor(long n) {\n      for (long i = 2; n >= i * i; i++) {\n        if (n % i == 0) {\n          return new long[]{i, n};\n        }\n      }\n      return new long[]{n, n};\n    }\n}\n"}
{"id": 20568, "name": "Parallel calculations", "source": "Translate Swift to Python: import BigInt\nimport Foundation\n\nextension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nlet numbers = [\n  112272537195293,\n  112582718962171,\n  112272537095293,\n  115280098190773,\n  115797840077099,\n  1099726829285419,\n  1275792312878611,\n  BigInt(\"64921987050997300559\")\n]\n\nfunc findLargestMinFactor<T: BinaryInteger>(for nums: [T], then: @escaping ((n: T, factors: [T])) -> ()) {\n  let waiter = DispatchSemaphore(value: 0)\n  let lock = DispatchSemaphore(value: 1)\n  var factors = [(n: T, factors: [T])]()\n\n  DispatchQueue.concurrentPerform(iterations: nums.count) {i in\n    let n = nums[i]\n\n    print(\"Factoring \\(n)\")\n\n    let nFacs = n.primeDecomposition().sorted()\n\n    print(\"Factored \\(n)\")\n\n    lock.wait()\n    factors.append((n, nFacs))\n\n    if factors.count == nums.count {\n      waiter.signal()\n    }\n\n    lock.signal()\n  }\n\n  waiter.wait()\n\n  then(factors.sorted(by: { $0.factors.first! > $1.factors.first! }).first!)\n}\n\nfindLargestMinFactor(for: numbers) {res in\n  let (n, factors) = res\n\n  print(\"Number with largest min prime factor: \\(n); factors: \\(factors)\")\n\n  exit(0)\n}\n\ndispatchMain()\n", "target": "from concurrent import futures\nfrom math import floor, sqrt\n \nNUMBERS = [\n    112272537195293,\n    112582718962171,\n    112272537095293,\n    115280098190773,\n    115797840077099,\n    1099726829285419]\n\n \ndef lowest_factor(n, _start=3):\n    if n % 2 == 0:\n        return 2\n    search_max = int(floor(sqrt(n))) + 1\n    for i in range(_start, search_max, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef prime_factors(n, lowest):\n    pf = []\n    while n > 1:\n        pf.append(lowest)\n        n //= lowest\n        lowest = lowest_factor(n, max(lowest, 3))\n    return pf\n\ndef prime_factors_of_number_with_lowest_prime_factor(NUMBERS):\n    with futures.ProcessPoolExecutor() as executor:\n        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )\n        all_factors = prime_factors(number, low_factor)\n        return number, all_factors\n\n \ndef main():\n    print('For these numbers:')\n    print('\\n  '.join(str(p) for p in NUMBERS))\n    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)\n    print('    The one with the largest minimum prime factor is {}:'.format(number))\n    print('      All its prime factors in order are: {}'.format(all_factors))\n \nif __name__ == '__main__':\n    main()\n"}
{"id": 20865, "name": "Reduced row echelon form", "source": "Translate Swift to C#:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "using System;\n\nnamespace rref\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 4]{\n                {  1, 2, -1,  -4 },\n                {  2, 3, -1, -11 },\n                { -2, 0, -3,  22 }\n            };\n            matrix = rref(matrix);   \n        }\n\n        private static int[,] rref(int[,] matrix)\n        {            \n            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);\n            for (int r = 0; r < rowCount; r++)\n            {\n                if (columnCount <= lead) break;\n                int i = r;\n                while (matrix[i, lead] == 0)\n                {\n                    i++;\n                    if (i == rowCount)\n                    {\n                        i = r;\n                        lead++;\n                        if (columnCount == lead)\n                        {\n                        lead--;\n                        break;\n                        }\n                    }\n                }\n                for (int j = 0; j < columnCount; j++)\n                {\n                    int temp = matrix[r, j];\n                    matrix[r, j] = matrix[i, j];\n                    matrix[i, j] = temp;\n                }\n                int div = matrix[r, lead];\n                if(div != 0)\n                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                \n                for (int j = 0; j < rowCount; j++)\n                {\n                    if (j != r)\n                    {\n                        int sub = matrix[j, lead];\n                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);\n                    }\n                }\n                lead++;\n            }\n            return matrix;\n        }\n    }\n}\n"}
{"id": 20867, "name": "Reduced row echelon form", "source": "Translate Swift to Java:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "import java.util.*;\nimport java.lang.Math;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.fraction.FractionConversionException;\n\n\nclass Matrix {\n\tLinkedList<LinkedList<Fraction>> matrix;\n\tint numRows;\n\tint numCols;\t\n\t\n\tstatic class Coordinate {\n\t\tint row;\n\t\tint col;\n\n\t\tCoordinate(int r, int c) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + row + \", \" + col + \")\";\n\t\t}\n\t}\n\n\tMatrix(double [][] m) {\n\t\tnumRows = m.length;\t\n\t\tnumCols = m[0].length;\n\n\t\tmatrix = new LinkedList<LinkedList<Fraction>>();\n\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tmatrix.add(new LinkedList<Fraction>());\n\t\t\tfor (int j = 0; j < numCols; j++) {\n\t\t\t\ttry {\n\t\t\t\t\tmatrix.get(i).add(new Fraction(m[i][j]));\n\t\t\t\t} catch (FractionConversionException e) {\n\t\t\t\t\tSystem.err.println(\"Fraction could not be converted from double by apache commons . . .\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void Interchange(Coordinate a, Coordinate b) {\n\t\tLinkedList<Fraction> temp = matrix.get(a.row);\n\t\tmatrix.set(a.row, matrix.get(b.row));\t\t\n\t\tmatrix.set(b.row, temp);\n\n\t\tint t = a.row;\n\t\ta.row = b.row;\n\t\tb.row = t;\n\t} \n\n\tpublic void Scale(Coordinate x, Fraction d) {\n\t\tLinkedList<Fraction> row = matrix.get(x.row);\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).multiply(d));\n\t\t}\n\t}\n\n\tpublic void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {\n\t\tLinkedList<Fraction> row = matrix.get(to.row);\n\t\tLinkedList<Fraction> rowMultiplied = matrix.get(from.row);\n\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));\n\t\t}\n\t}\n\n\tpublic void RREF() {\n\t\tCoordinate pivot = new Coordinate(0,0);\n\n\t\tint submatrix = 0;\n\t\tfor (int x = 0; x < numCols; x++) {\n\t\t\tpivot = new Coordinate(pivot.row, x);\n\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = x; i < numCols; i++) {\n\t\t\t\t\tif (isColumnZeroes(pivot) == false) {\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpivot.col = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\tpivot = findPivot(pivot);\n\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() == 0.0) {\n\t\t\t\t\tpivot.row++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pivot.row != submatrix) {\n\t\t\t\t\tInterchange(new Coordinate(submatrix, pivot.col), pivot);\n\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1) {\n\t\t\t\t\t\n\t\t\t\t\tFraction scalar = getCoordinate(pivot).reciprocal();\n\t\t\t\t\tScale(pivot, scalar);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i < numRows; i++) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCoordinate belowPivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(belowPivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i >= 0; i--) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1.0) {\n\t\t\t\t\t\t\tScale(pivot, getCoordinate(pivot).reciprocal());\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tCoordinate abovePivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(abovePivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsubmatrix++;\n\t\t\t\tpivot.row++;\n\t\t}\n\t}\n\t\n\tpublic boolean isColumnZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tif (matrix.get(i).get(a.col).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic boolean isRowZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\tif (matrix.get(a.row).get(i).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic Coordinate findPivot(Coordinate a) {\n\t\tint first_row = a.row;\n\t\tCoordinate pivot = new Coordinate(a.row, a.col);\n\t\tCoordinate current = new Coordinate(a.row, a.col);\t\n\n\t\tfor (int i = a.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() == 1.0) {\n\t\t\t\tInterchange(current, a);\n\t\t\t}\n\t\t}\n\n\t\tcurrent.row = a.row;\n\t\tfor (int i = current.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() != 0) {\n\t\t\t\tpivot.row = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\treturn pivot;\t\n\t}\t\n\n\tpublic Fraction getCoordinate(Coordinate a) {\n\t\treturn matrix.get(a.row).get(a.col);\n\t}\n\n\tpublic String toString() {\n\t\treturn matrix.toString().replace(\"], \", \"]\\n\");\n\t}\n\n\tpublic static void main (String[] args) {\n        \tdouble[][] matrix_1 = {\n\t\t\t{1, 2, -1, -4},\n\t\t\t{2, 3, -1, -11},\n\t\t\t{-2, 0, -3, 22}\n\t\t};\n\n\t\tMatrix x = new Matrix(matrix_1);\n\t\tSystem.out.println(\"before\\n\" + x.toString() + \"\\n\");\n\t\tx.RREF();\n\t\tSystem.out.println(\"after\\n\" + x.toString() + \"\\n\");\n\n\t\tdouble matrix_2 [][] = {\n\t\t\t{2, 0, -1, 0, 0},\n\t\t\t{1, 0, 0, -1, 0},\n\t\t\t{3, 0, 0, -2, -1},\n\t\t\t{0, 1, 0, 0, -2},\n\t\t\t{0, 1, -1, 0, 0}\n\t\t};\n\t\n\t\tMatrix y = new Matrix(matrix_2);\n\t\tSystem.out.println(\"before\\n\" + y.toString() + \"\\n\");\n\t\ty.RREF();\n\t\tSystem.out.println(\"after\\n\" + y.toString() + \"\\n\");\n\n\t\tdouble matrix_3 [][] = {\n\t\t\t{1, 2, 3, 4, 3, 1},\n\t\t\t{2, 4, 6, 2, 6, 2},\n\t\t\t{3, 6, 18, 9, 9, -6},\n\t\t\t{4, 8, 12, 10, 12, 4},\n\t\t\t{5, 10, 24, 11, 15, -4}\n\t\t};\n\n\t\tMatrix z = new Matrix(matrix_3);\n\t\tSystem.out.println(\"before\\n\" + z.toString() + \"\\n\");\n\t\tz.RREF();\n\t\tSystem.out.println(\"after\\n\" + z.toString() + \"\\n\");\n\n\t\tdouble matrix_4 [][] = {\n\t\t\t{0, 1},\n\t\t\t{1, 2},\n\t\t\t{0,5}\n\t\t};\n\n\t\tMatrix a = new Matrix(matrix_4);\n\t\tSystem.out.println(\"before\\n\" + a.toString() + \"\\n\");\n\t\ta.RREF();\n\t\tSystem.out.println(\"after\\n\" + a.toString() + \"\\n\");\n\t}\t\n}\n"}
{"id": 20868, "name": "Reduced row echelon form", "source": "Translate Swift to Python:         var lead = 0\n        for r in 0..<rows {\n            if (cols <= lead) { break }\n            var i = r\n            while (m[i][lead] == 0) {\n                i += 1\n                if (i == rows) {\n                    i = r\n                    lead += 1\n                    if (cols == lead) {\n                        lead -= 1\n                        break\n                    }\n                }\n            }\n            for j in 0..<cols {\n                let temp = m[r][j]\n                m[r][j] = m[i][j]\n                m[i][j] = temp\n            }\n            let div = m[r][lead]\n            if (div != 0) {\n                for j in 0..<cols {\n                    m[r][j] /= div\n                }\n            }\n            for j in 0..<rows {\n                if (j != r) {\n                    let sub = m[j][lead]\n                    for k in 0..<cols {\n                        m[j][k] -= (sub * m[r][k])\n                    }\n                }\n            }\n            lead += 1\n        }\n", "target": "def ToReducedRowEchelonForm( M):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / float(lv) for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n\n\nmtx = [\n   [ 1, 2, -1, -4],\n   [ 2, 3, -1, -11],\n   [-2, 0, -3, 22],]\n\nToReducedRowEchelonForm( mtx )\n\nfor rw in mtx:\n  print ', '.join( (str(rv) for rv in rw) )\n"}
{"id": 21124, "name": "Power set", "source": "Translate Swift to C#: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "public IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list)\n{\n    return from m in Enumerable.Range(0, 1 << list.Count)\n                  select\n                      from i in Enumerable.Range(0, list.Count)\n                      where (m & (1 << i)) != 0\n                      select list[i];\n}\n\npublic void PowerSetofColors()\n{\n    var colors = new List<KnownColor> { KnownColor.Red, KnownColor.Green, \n        KnownColor.Blue, KnownColor.Yellow };\n    \n    var result = GetPowerSet(colors);\n    \n    Console.Write( string.Join( Environment.NewLine, \n        result.Select(subset => \n            string.Join(\",\", subset.Select(clr => clr.ToString()).ToArray())).ToArray()));\n}\n"}
{"id": 21126, "name": "Power set", "source": "Translate Swift to Java: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "public static ArrayList<String> getpowerset(int a[],int n,ArrayList<String> ps)\n    {\n        if(n<0)\n        {\n            return null;\n        }\n        if(n==0)\n        {\n            if(ps==null)\n                ps=new ArrayList<String>();\n            ps.add(\" \");\n            return ps;\n        }\n        ps=getpowerset(a, n-1, ps);\n        ArrayList<String> tmp=new ArrayList<String>();\n        for(String s:ps)\n        {\n            if(s.equals(\" \"))\n                tmp.add(\"\"+a[n-1]);\n            else\n                tmp.add(s+a[n-1]);\n        }\n        ps.addAll(tmp);\n        return ps;\n    }\n"}
{"id": 21127, "name": "Power set", "source": "Translate Swift to Python: func powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n\npowersetFrom([1, 2, 4])\n", "target": "def list_powerset(lst):\n    \n    result = [[]]\n    for x in lst:\n        \n        \n        \n        \n        \n        \n        result.extend([subset + [x] for subset in result])\n    return result\n\n\ndef list_powerset2(lst):\n    return reduce(lambda result, x: result + [subset + [x] for subset in result],\n                  lst, [[]])\n\ndef powerset(s):\n    return frozenset(map(frozenset, list_powerset(list(s))))\n"}
{"id": 21552, "name": "Topological sort", "source": "Translate Swift to C#: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    \n                new Task{ Message = \"B - depends on none\" },       \n                new Task{ Message = \"C - depends on D and E\" },    \n                new Task{ Message = \"D - depends on none\" },       \n                new Task{ Message = \"E - depends on F, G and H\" }, \n                new Task{ Message = \"F - depends on I\" },          \n                new Task{ Message = \"G - depends on none\" },       \n                new Task{ Message = \"H - depends on none\" },       \n                new Task{ Message = \"I - depends on none\" },       \n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            \n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            \n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            \n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            \n            \n\n            \n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"id": 21554, "name": "Topological sort", "source": "Translate Swift to Java: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "import java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         \n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 21555, "name": "Topological sort", "source": "Translate Swift to Python: let libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) \n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n"}
{"id": 21970, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to C#: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "class Link\n{\n    public int Item { get; set; }\n    public Link Prev { get; set; }\n    public Link Next { get; set; }\n\n    \n    public Link(int item, Link prev = null, Link next = null) {\n        Item = item;\n        Prev = prev;\n        Next = next;\n    }\n}\n"}
{"id": 21972, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to Java: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "public class Node<T> {\n   private T element;\n   private Node<T> next, prev;\n\n   public Node<T>(){\n      next = prev = element = null;\n   }\n\n   public Node<T>(Node<T> n, Node<T> p, T elem){\n      next = n;\n      prev = p;\n      element = elem;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> getNext(){\n      return next;\n   }\n\n   public void setElem(T elem){\n      element = elem;\n   }\n\n   public T getElem(){\n      return element;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> setPrev(Node<T> p){\n      prev = p;\n   }\n\n   public getPrev(){\n      return prev;\n   }\n}\n"}
{"id": 21973, "name": "Doubly-linked list_Element definition", "source": "Translate Swift to Python: typealias NodePtr<T> = UnsafeMutablePointer<Node<T>>\n\nclass Node<T> {\n  var value: T\n  fileprivate var prev: NodePtr<T>?\n  fileprivate var next: NodePtr<T>?\n\n  init(value: T, prev: NodePtr<T>? = nil, next: NodePtr<T>? = nil) {\n    self.value = value\n    self.prev = prev\n    self.next = next\n  }\n}\n", "target": "class Node(object):\n     def __init__(self, data = None, prev = None, next = None):\n         self.prev = prev\n         self.next = next\n         self.data = data\n     def __str__(self):\n         return str(self.data)\n     def __repr__(self):\n         return repr(self.data)\n     def iter_forward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.next\n     def iter_backward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.prev\n"}
{"id": 22436, "name": "Dot product", "source": "Translate Swift to C#: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22437, "name": "Dot product", "source": "Translate Swift to C#: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22440, "name": "Dot product", "source": "Translate Swift to Java: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22441, "name": "Dot product", "source": "Translate Swift to Java: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22442, "name": "Dot product", "source": "Translate Swift to Python: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22443, "name": "Dot product", "source": "Translate Swift to Python: func dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22756, "name": "Count in factors", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=1; i<=22; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tList<int> f = Factorize(i);\n\t\t\t\tConsole.Write( i + \":  \" + f[0] );\n\t\t\t\tfor( int j=1; j<f.Count; j++ )\n\t\t\t\t{\n\t\t\t\t\tConsole.Write( \" * \" + f[j] );\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static List<int> Factorize( int n )\n\t\t{\n\t\t\tList<int> l = new List<int>();\n\t\t    \n\t\t\tif ( n == 1 )\n\t\t\t{\n\t\t\t\tl.Add(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = 2;\n\t\t\t\twhile( n > 1 ) \n\t\t\t\t{\n\t\t\t\t\twhile( n % k == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tl.Add( k );\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn l;\n\t\t}\t\n\t}\n}\n"}
{"id": 22758, "name": "Count in factors", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "public class CountingInFactors{ \n    public static void main(String[] args){\n        for(int i = 1; i<= 10; i++){\n            System.out.println(i + \" = \"+ countInFactors(i));\n        }\n \n        for(int i = 9991; i <= 10000; i++){\n        \tSystem.out.println(i + \" = \"+ countInFactors(i));\n        }\n    }\n \n    private static String countInFactors(int n){\n        if(n == 1) return \"1\";\n \n        StringBuilder sb = new StringBuilder();\n \n        n = checkFactor(2, n, sb);\n        if(n == 1) return sb.toString();\n \n        n = checkFactor(3, n, sb);\n        if(n == 1) return sb.toString();\n \n        for(int i = 5; i <= n; i+= 2){\n            if(i % 3 == 0)continue;\n \n            n = checkFactor(i, n, sb);\n            if(n == 1)break;\n        }\n \n        return sb.toString();\n    }\n \n    private static int checkFactor(int mult, int n, StringBuilder sb){\n        while(n % mult == 0 ){\n            if(sb.length() > 0) sb.append(\" x \");\n            sb.append(mult);\n            n /= mult;\n        }\n        return n;\n    }\n}\n"}
{"id": 22759, "name": "Count in factors", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func primeDecomposition() -> [Self] {\n    guard self > 1 else { return [] }\n\n    func step(_ x: Self) -> Self {\n      return 1 + (x << 2) - ((x >> 1) << 1)\n    }\n\n    let maxQ = Self(Double(self).squareRoot())\n    var d: Self = 1\n    var q: Self = self & 1 == 0 ? 2 : 3\n\n    while q <= maxQ && self % q != 0 {\n      q = step(d)\n      d += 1\n    }\n\n    return q <= maxQ ? [q] + (self / q).primeDecomposition() : [self]\n  }\n}\n\nfor i in 1...20 {\n  if i == 1 {\n    print(\"1 = 1\")\n  } else {\n    print(\"\\(i) = \\(i.primeDecomposition().map(String.init).joined(separator: \" x \"))\")\n  }\n}\n", "target": "from functools import lru_cache\n\nprimes = [2, 3, 5, 7, 11, 13, 17]    \n\n@lru_cache(maxsize=2000)\ndef pfactor(n):\n    if n == 1:\n        return [1]\n    n2 = n // 2 + 1\n    for p in primes:\n        if p <= n2:\n            d, m = divmod(n, p)\n            if m == 0:\n                if d > 1:\n                    return [p] + pfactor(d)\n                else:\n                    return [p]\n        else:\n            if n > primes[-1]:\n                primes.append(n)\n            return [n]\n        \nif __name__ == '__main__':\n    mx = 5000\n    for n in range(1, mx + 1):\n        factors = pfactor(n)\n        if n <= 10 or n >= mx - 20:\n            print( '%4i %5s %s' % (n,\n                                   '' if factors != [n] or n == 1 else 'prime',\n                                   'x'.join(str(i) for i in factors)) )\n        if n == 11:\n            print('...')\n            \n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\n    print(pfactor.cache_info())\n"}
{"id": 23647, "name": "String case", "source": "Translate Swift to C#: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23649, "name": "String case", "source": "Translate Swift to Java: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23650, "name": "String case", "source": "Translate Swift to Python: import Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 24516, "name": "Arithmetic-geometric mean", "source": "Translate Swift to C#: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24517, "name": "Arithmetic-geometric mean", "source": "Translate Swift to C#: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24520, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Java: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24521, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Java: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24522, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Python: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24523, "name": "Arithmetic-geometric mean", "source": "Translate Swift to Python: import Darwin\n\nenum AGRError : Error {\n\tcase undefined\n}\n\nfunc agm(_ a: Double, _ g: Double, _ iota: Double = 1e-8) throws -> Double {\n\tvar a = a\n\tvar g = g\n\tvar a1: Double = 0\n\tvar g1: Double = 0\n\t\n\tguard a * g >= 0 else {\n\t\tthrow AGRError.undefined\n\t}\n\t\n\twhile abs(a - g) > iota {\n\t\ta1 = (a + g) / 2\n\t\tg1 = sqrt(a * g)\n\t\ta = a1\n\t\tg = g1\n\t}\n\t\n\treturn a\n}\n\ndo {\n\ttry print(agm(1, 1 / sqrt(2)))\n} catch {\n\tprint(\"agr is undefined when a * g < 0\")\n}\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24983, "name": "Chinese remainder theorem", "source": "Translate Swift to C#: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24984, "name": "Chinese remainder theorem", "source": "Translate Swift to C#: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "using System;\nusing System.Linq;\n\nnamespace ChineseRemainderTheorem\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] n = { 3, 5, 7 };\n            int[] a = { 2, 3, 2 };\n\n            int result = ChineseRemainderTheorem.Solve(n, a);\n\n            int counter = 0;\n            int maxCount = n.Length - 1;\n            while (counter <= maxCount)\n            {\n                Console.WriteLine($\"{result} \u2261 {a[counter]} (mod {n[counter]})\");\n                counter++;\n            }\n        }\n    }\n\n    public static class ChineseRemainderTheorem\n    {\n        public static int Solve(int[] n, int[] a)\n        {\n            int prod = n.Aggregate(1, (i, j) => i * j);\n            int p;\n            int sm = 0;\n            for (int i = 0; i < n.Length; i++)\n            {\n                p = prod / n[i];\n                sm += a[i] * ModularMultiplicativeInverse(p, n[i]) * p;\n            }\n            return sm % prod;\n        }\n\n        private static int ModularMultiplicativeInverse(int a, int mod)\n        {\n            int b = a % mod;\n            for (int x = 1; x < mod; x++)\n            {\n                if ((b * x) % mod == 1)\n                {\n                    return x;\n                }\n            }\n            return 1;\n        }\n    }\n}\n"}
{"id": 24987, "name": "Chinese remainder theorem", "source": "Translate Swift to Java: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n"}
{"id": 24988, "name": "Chinese remainder theorem", "source": "Translate Swift to Java: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "import static java.util.Arrays.stream;\n\npublic class ChineseRemainderTheorem {\n\n    public static int chineseRemainder(int[] n, int[] a) {\n\n        int prod = stream(n).reduce(1, (i, j) -> i * j);\n\n        int p, sm = 0;\n        for (int i = 0; i < n.length; i++) {\n            p = prod / n[i];\n            sm += a[i] * mulInv(p, n[i]) * p;\n        }\n        return sm % prod;\n    }\n\n    private static int mulInv(int a, int b) {\n        int b0 = b;\n        int x0 = 0;\n        int x1 = 1;\n\n        if (b == 1)\n            return 1;\n\n        while (a > 1) {\n            int q = a / b;\n            int amb = a % b;\n            a = b;\n            b = amb;\n            int xqx = x1 - q * x0;\n            x1 = x0;\n            x0 = xqx;\n        }\n\n        if (x1 < 0)\n            x1 += b0;\n\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        int[] n = {3, 5, 7};\n        int[] a = {2, 3, 2};\n        System.out.println(chineseRemainder(n, a));\n    }\n}\n"}
{"id": 24989, "name": "Chinese remainder theorem", "source": "Translate Swift to Python: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 24990, "name": "Chinese remainder theorem", "source": "Translate Swift to Python: import Darwin\n\n\n\nfunc euclid(_ m:Int, _ n:Int) -> (Int,Int) {\n    if m % n == 0 {\n        return (0,1)\n    } else {\n        let rs = euclid(n % m, m)\n        let r = rs.1 - rs.0 * (n / m)\n        let s = rs.0\n\n        return (r,s)\n    }\n}\n\n\n\nfunc gcd(_ m:Int, _ n:Int) -> Int {\n    let rs = euclid(m, n)\n    return m * rs.0 + n * rs.1\n}\n\n\n\nfunc coprime(_ m:Int, _ n:Int) -> Bool {\n    return gcd(m,n) == 1 ? true : false\n}\n\ncoprime(14,26)\n\n\n\n\nfunc crt(_ a_i:[Int], _ n_i:[Int]) -> Int {\n    \n    \n    \n    \n    let divs = n_i.enumerated()\n    \n    \n    divs.forEach{\n        n in divs.filter{ $0.0 < n.0 }.forEach{\n            assert(coprime(n.1, $0.1))\n        }\n    }\n    \n    \n    let N = n_i.map{$0}.reduce(1, *)\n    \n    \n    var s:[Int] = []\n    \n    \n    n_i.forEach{ s += [euclid($0, N / $0).1] }\n    \n    \n    var x = 0\n    a_i.enumerated().forEach{\n        x += $0.1 * s[$0.0] * N / n_i[$0.0]\n    }\n\n    \n    return x % N\n}\n\nlet a = [2,3,2]\nlet n = [3,5,7]\n\nlet x = crt(a,n)\n\nprint(x)\n", "target": "\ndef chinese_remainder(n, a):\n    sum = 0\n    prod = reduce(lambda a, b: a*b, n)\n\n    for n_i, a_i in zip(n, a):\n        p = prod / n_i\n        sum += a_i * mul_inv(p, n_i) * p\n    return sum % prod\n\n\ndef mul_inv(a, b):\n    b0 = b\n    x0, x1 = 0, 1\n    if b == 1: return 1\n    while a > 1:\n        q = a / b\n        a, b = b, a%b\n        x0, x1 = x1 - q * x0, x0\n    if x1 < 0: x1 += b0\n    return x1\n\nif __name__ == '__main__':\n    n = [3, 5, 7]\n    a = [2, 3, 2]\n    print chinese_remainder(n, a)\n"}
{"id": 25277, "name": "Stable marriage problem", "source": "Translate Swift to C#: class Person {\n    let name:String\n    var candidateIndex = 0\n    var fiance:Person?\n    var candidates = [Person]()\n    \n    init(name:String) {\n        self.name = name\n    }\n    \n    func rank(p:Person) -> Int {\n        for (i, candidate) in enumerate(self.candidates) {\n            if candidate === p {\n                return i\n            }\n        }\n        return self.candidates.count + 1\n    }\n    \n    func prefers(p:Person) -> Bool {\n        if let fiance = self.fiance {\n            return self.rank(p) < self.rank(fiance)\n        }\n        return false\n    }\n    \n    func nextCandidate() -> Person? {\n        if self.candidateIndex >= self.candidates.count {\n            return nil\n        }\n        return self.candidates[candidateIndex++]\n    }\n    \n    func engageTo(p:Person) {\n        p.fiance?.fiance = nil\n        p.fiance = self\n        self.fiance?.fiance = nil\n        self.fiance = p\n    }\n    \n    func swapWith(p:Person) {\n        let thisFiance = self.fiance\n        let pFiance = p.fiance\n        println(\"\\(self.name) swapped partners with \\(p.name)\")\n        if pFiance != nil && thisFiance != nil {\n            self.engageTo(pFiance!)\n            p.engageTo(thisFiance!)\n        }\n    }\n}\n\nfunc isStable(guys:[Person], gals:[Person]) -> Bool {\n    for guy in guys {\n        for gal in gals {\n            if guy.prefers(gal) && gal.prefers(guy) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc engageEveryone(guys:[Person]) {\n    var done = false\n    while !done {\n        done = true\n        for guy in guys {\n            if guy.fiance == nil {\n                done = false\n                if let gal = guy.nextCandidate() {\n                    if gal.fiance == nil || gal.prefers(guy) {\n                        guy.engageTo(gal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc doMarriage() {\n    let abe  = Person(name: \"Abe\")\n    let bob  = Person(name: \"Bob\")\n    let col  = Person(name: \"Col\")\n    let dan  = Person(name: \"Dan\")\n    let ed   = Person(name: \"Ed\")\n    let fred = Person(name: \"Fred\")\n    let gav  = Person(name: \"Gav\")\n    let hal  = Person(name: \"Hal\")\n    let ian  = Person(name: \"Ian\")\n    let jon  = Person(name: \"Jon\")\n    let abi  = Person(name: \"Abi\")\n    let bea  = Person(name: \"Bea\")\n    let cath = Person(name: \"Cath\")\n    let dee  = Person(name: \"Dee\")\n    let eve  = Person(name: \"Eve\")\n    let fay  = Person(name: \"Fay\")\n    let gay  = Person(name: \"Gay\")\n    let hope = Person(name: \"Hope\")\n    let ivy  = Person(name: \"Ivy\")\n    let jan  = Person(name: \"Jan\")\n    \n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal]\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal]\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon]\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed]\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob]\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal]\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian]\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred]\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan]\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n    \n    let guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon]\n    let gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan]\n    \n    engageEveryone(guys)\n    \n    for guy in guys {\n        println(\"\\(guy.name) is engaged to \\(guy.fiance!.name)\")\n    }\n    \n    println(\"Stable = \\(isStable(guys, gals))\")\n    jon.swapWith(fred)\n    println(\"Stable = \\(isStable(guys, gals))\")\n    \n}\n\ndoMarriage()\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace StableMarriage\n{\n    class Person\n    {\n        private int _candidateIndex;\n        public string Name { get; set; }\n        public List<Person> Prefs { get; set; }\n        public Person Fiance { get; set; }\n        \n        public Person(string name) {\n            Name = name;\n            Prefs = null;\n            Fiance = null;\n            _candidateIndex = 0;\n        }\n        public bool Prefers(Person p) {\n            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);\n        }\n        public Person NextCandidateNotYetProposedTo() {\n            if (_candidateIndex >= Prefs.Count) return null;\n            return Prefs[_candidateIndex++];\n        }\n        public void EngageTo(Person p) {\n            if (p.Fiance != null) p.Fiance.Fiance = null;\n            p.Fiance = this;\n            if (Fiance != null) Fiance.Fiance = null;\n            Fiance = p;\n        }\n    }\n    \n    static class MainClass\n    {\n        static public bool IsStable(List<Person> men) {\n            List<Person> women = men[0].Prefs;\n            foreach (Person guy in men) {\n                foreach (Person gal in women) {\n                    if (guy.Prefers(gal) && gal.Prefers(guy))\n                        return false;\n                }\n            }\n            return true;\n        }\n        \n        static void DoMarriage() {\n            Person abe  = new Person(\"abe\");\n            Person bob  = new Person(\"bob\");\n            Person col  = new Person(\"col\");\n            Person dan  = new Person(\"dan\");\n            Person ed   = new Person(\"ed\");\n            Person fred = new Person(\"fred\");\n            Person gav  = new Person(\"gav\");\n            Person hal  = new Person(\"hal\");\n            Person ian  = new Person(\"ian\");\n            Person jon  = new Person(\"jon\");\n            Person abi  = new Person(\"abi\");\n            Person bea  = new Person(\"bea\");\n            Person cath = new Person(\"cath\");\n            Person dee  = new Person(\"dee\");\n            Person eve  = new Person(\"eve\");\n            Person fay  = new Person(\"fay\");\n            Person gay  = new Person(\"gay\");\n            Person hope = new Person(\"hope\");\n            Person ivy  = new Person(\"ivy\");\n            Person jan  = new Person(\"jan\");\n            \n            abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};\n            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};\n            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};\n            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};\n            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};\n            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};\n            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};\n            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};\n            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};\n            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};\n            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};\n            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};\n            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};\n            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};\n            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};\n            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};\n            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};\n            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};\n            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};\n            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};\n            \n            List<Person> men = new List<Person>(abi.Prefs);\n            \n            int freeMenCount = men.Count;\n            while (freeMenCount > 0) {\n                foreach (Person guy in men) {\n                    if (guy.Fiance == null) {\n                        Person gal = guy.NextCandidateNotYetProposedTo();\n                        if (gal.Fiance == null) {\n                            guy.EngageTo(gal);\n                            freeMenCount--;\n                        } else if (gal.Prefers(guy)) {\n                            guy.EngageTo(gal);\n                        }\n                    }\n                }\n            }\n            \n            foreach (Person guy in men) {\n                Console.WriteLine(\"{0} is engaged to {1}\", guy.Name, guy.Fiance.Name);\n            }\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n            \n            Console.WriteLine(\"\\nSwitching fred & jon's partners\");\n            Person jonsFiance = jon.Fiance;\n            Person fredsFiance = fred.Fiance;\n            fred.EngageTo(jonsFiance);\n            jon.EngageTo(fredsFiance);\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n        }\n        \n        public static void Main(string[] args)\n        {\n            DoMarriage();\n        }\n    }\n}\n"}
{"id": 25279, "name": "Stable marriage problem", "source": "Translate Swift to Python: class Person {\n    let name:String\n    var candidateIndex = 0\n    var fiance:Person?\n    var candidates = [Person]()\n    \n    init(name:String) {\n        self.name = name\n    }\n    \n    func rank(p:Person) -> Int {\n        for (i, candidate) in enumerate(self.candidates) {\n            if candidate === p {\n                return i\n            }\n        }\n        return self.candidates.count + 1\n    }\n    \n    func prefers(p:Person) -> Bool {\n        if let fiance = self.fiance {\n            return self.rank(p) < self.rank(fiance)\n        }\n        return false\n    }\n    \n    func nextCandidate() -> Person? {\n        if self.candidateIndex >= self.candidates.count {\n            return nil\n        }\n        return self.candidates[candidateIndex++]\n    }\n    \n    func engageTo(p:Person) {\n        p.fiance?.fiance = nil\n        p.fiance = self\n        self.fiance?.fiance = nil\n        self.fiance = p\n    }\n    \n    func swapWith(p:Person) {\n        let thisFiance = self.fiance\n        let pFiance = p.fiance\n        println(\"\\(self.name) swapped partners with \\(p.name)\")\n        if pFiance != nil && thisFiance != nil {\n            self.engageTo(pFiance!)\n            p.engageTo(thisFiance!)\n        }\n    }\n}\n\nfunc isStable(guys:[Person], gals:[Person]) -> Bool {\n    for guy in guys {\n        for gal in gals {\n            if guy.prefers(gal) && gal.prefers(guy) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc engageEveryone(guys:[Person]) {\n    var done = false\n    while !done {\n        done = true\n        for guy in guys {\n            if guy.fiance == nil {\n                done = false\n                if let gal = guy.nextCandidate() {\n                    if gal.fiance == nil || gal.prefers(guy) {\n                        guy.engageTo(gal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc doMarriage() {\n    let abe  = Person(name: \"Abe\")\n    let bob  = Person(name: \"Bob\")\n    let col  = Person(name: \"Col\")\n    let dan  = Person(name: \"Dan\")\n    let ed   = Person(name: \"Ed\")\n    let fred = Person(name: \"Fred\")\n    let gav  = Person(name: \"Gav\")\n    let hal  = Person(name: \"Hal\")\n    let ian  = Person(name: \"Ian\")\n    let jon  = Person(name: \"Jon\")\n    let abi  = Person(name: \"Abi\")\n    let bea  = Person(name: \"Bea\")\n    let cath = Person(name: \"Cath\")\n    let dee  = Person(name: \"Dee\")\n    let eve  = Person(name: \"Eve\")\n    let fay  = Person(name: \"Fay\")\n    let gay  = Person(name: \"Gay\")\n    let hope = Person(name: \"Hope\")\n    let ivy  = Person(name: \"Ivy\")\n    let jan  = Person(name: \"Jan\")\n    \n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal]\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal]\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon]\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed]\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob]\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal]\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian]\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred]\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan]\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n    \n    let guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon]\n    let gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan]\n    \n    engageEveryone(guys)\n    \n    for guy in guys {\n        println(\"\\(guy.name) is engaged to \\(guy.fiance!.name)\")\n    }\n    \n    println(\"Stable = \\(isStable(guys, gals))\")\n    jon.swapWith(fred)\n    println(\"Stable = \\(isStable(guys, gals))\")\n    \n}\n\ndoMarriage()\n", "target": "import copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            \n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            \n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                \n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    \n                    guysfree.append(fiance)\n            else:\n                \n                if guyslist:\n                    \n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n"}
{"id": 25650, "name": "Day of the week", "source": "Translate Swift to C#: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25652, "name": "Day of the week", "source": "Translate Swift to Java: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25653, "name": "Day of the week", "source": "Translate Swift to Python: import Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26364, "name": "Short-circuit evaluation", "source": "Translate Swift to C#: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": "using System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 26366, "name": "Short-circuit evaluation", "source": "Translate Swift to Java: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": "module test\n    {\n    @Inject Console console;\n\n    static Boolean show(String name, Boolean value)\n        {\n        console.print($\"{name}()={value}\");\n        return value;\n        }\n\n    void run()\n        {\n        val a = show(\"a\", _);\n        val b = show(\"b\", _);\n\n        for (Boolean v1 : False..True)\n            {\n            for (Boolean v2 : False..True)\n                {\n                console.print($\"a({v1}) && b({v2}) == {a(v1) && b(v2)}\");\n                console.print();\n                console.print($\"a({v1}) || b({v2}) == {a(v1) || b(v2)}\");\n                console.print();\n                }\n            }\n        }\n    }\n"}
{"id": 26367, "name": "Short-circuit evaluation", "source": "Translate Swift to Python: func a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n", "target": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n"}
{"id": 26744, "name": "ISBN13 check digit", "source": "Translate Swift to C#: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26745, "name": "ISBN13 check digit", "source": "Translate Swift to C#: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26748, "name": "ISBN13 check digit", "source": "Translate Swift to Java: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26749, "name": "ISBN13 check digit", "source": "Translate Swift to Java: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26750, "name": "ISBN13 check digit", "source": "Translate Swift to Python: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26751, "name": "ISBN13 check digit", "source": "Translate Swift to Python: func checkISBN(isbn: String) -> Bool {\n  guard !isbn.isEmpty else {\n    return false\n  }\n\n  let sum = isbn\n    .compactMap({ $0.wholeNumberValue })\n    .enumerated()\n    .map({ $0.offset & 1 == 1 ? 3 * $0.element : $0.element })\n    .reduce(0, +)\n\n  return sum % 10 == 0\n}\n\nlet cases = [\n  \"978-1734314502\",\n  \"978-1734314509\",\n  \"978-1788399081\",\n  \"978-1788399083\"\n]\n\nfor isbn in cases {\n  print(\"\\(isbn) => \\(checkISBN(isbn: isbn) ? \"good\" : \"bad\")\")\n}\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 27050, "name": "Days between dates", "source": "Translate Swift to C#: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27051, "name": "Days between dates", "source": "Translate Swift to C#: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "using System;\nusing System.Globalization;\n\npublic class Program\n{\n    public static void Main() => WriteLine(DateDiff(\"1970-01-01\", \"2019-10-18\"));\n\n    public static int DateDiff(string d1, string d2) {\n        var a = DateTime.ParseExact(d1, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        var b = DateTime.ParseExact(d2, \"yyyy-MM-dd\", CultureInfo.InvariantCulture);\n        return (int)(b - a).TotalDays;\n    }\n}\n"}
{"id": 27054, "name": "Days between dates", "source": "Translate Swift to Java: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27055, "name": "Days between dates", "source": "Translate Swift to Java: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class DaysBetweenDates {\n    public static void main(String[] args) {\n        LocalDate fromDate = LocalDate.parse(\"2019-01-01\");\n        LocalDate toDate = LocalDate.parse(\"2019-10-19\");\n        long diff = ChronoUnit.DAYS.between(fromDate, toDate);\n        System.out.printf(\"Number of days between %s and %s: %d\\n\", fromDate, toDate, diff);\n    }\n}\n"}
{"id": 27056, "name": "Days between dates", "source": "Translate Swift to Python: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27057, "name": "Days between dates", "source": "Translate Swift to Python: import Foundation\n\nfunc daysFromTimeInterval(_ interval: Double) -> Int {\n  return Int(interval) / 86400\n}\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nprint(\"Enter date one (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date1Str = readLine(strippingNewline: true), let date1 = formatter.date(from: date1Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nprint(\"Enter date two (yyyy-MM-dd): \", terminator: \"\")\n\nguard let date2Str = readLine(strippingNewline: true), let date2 = formatter.date(from: date2Str) else {\n  fatalError(\"Invalid date two\")\n}\n\nlet (start, end) = date1 > date2 ? (date2, date1) : (date1, date2)\nlet days = daysFromTimeInterval(DateInterval(start: start, end: end).duration)\n\nprint(\"There are \\(days) days between \\(start) and \\(end)\")\n", "target": "\nimport sys\n\n\n\ndef days( y,m,d ):\n  \n  m = (m + 9) % 12 \n  y = y - m/10\n\n  \n  result = 365*y + y/4 - y/100 + y/400 + (m*306 + 5)/10 + ( d - 1 )\n  return result\n\ndef diff(one,two):\n  [y1,m1,d1] = one.split('-')\n  [y2,m2,d2] = two.split('-')\n  \n  year2 = days( int(y2),int(m2),int(d2))\n  year1 = days( int(y1), int(m1), int(d1) )\n  return year2 - year1\n\nif __name__ == \"__main__\":\n  one = sys.argv[1]\n  two = sys.argv[2]\n  print diff(one,two)\n"}
{"id": 27297, "name": "Look-and-say sequence", "source": "Translate Swift to C#: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27299, "name": "Look-and-say sequence", "source": "Translate Swift to Java: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27300, "name": "Look-and-say sequence", "source": "Translate Swift to Python: func lookAndSay(_ seq: [Int]) -> [Int] {\n  var result = [Int]()\n  var cur = seq[0]\n  var curRunLength = 1\n\n  for i in seq.dropFirst() {\n    if cur == i {\n      curRunLength += 1\n    } else {\n      result.append(curRunLength)\n      result.append(cur)\n      curRunLength = 1\n      cur = i\n    }\n  }\n\n  result.append(curRunLength)\n  result.append(cur)\n\n  return result\n}\n\nvar seq = [1]\n\nfor i in 0..<10 {\n  print(\"Seq \\(i): \\(seq)\")\n  seq = lookAndSay(seq)\n}\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 27652, "name": "Closures_Value capture", "source": "Translate Swift to C#: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27653, "name": "Closures_Value capture", "source": "Translate Swift to C#: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        var captor = (Func<int, Func<int>>)(number => () => number * number);\n        var functions = Enumerable.Range(0, 10).Select(captor);\n        foreach (var function in functions.Take(9))\n        {\n            Console.WriteLine(function());\n        }\n    }\n}\n"}
{"id": 27656, "name": "Closures_Value capture", "source": "Translate Swift to Java: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27657, "name": "Closures_Value capture", "source": "Translate Swift to Java: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "import java.util.function.Supplier;\nimport java.util.ArrayList;\n\npublic class ValueCapture {\n    public static void main(String[] args) {\n\tArrayList<Supplier<Integer>> funcs = new ArrayList<>();\n\tfor (int i = 0; i < 10; i++) {\n\t    int j = i;\n\t    funcs.add(() -> j * j);\n\t}\n\n\tSupplier<Integer> foo = funcs.get(3);\n\tSystem.out.println(foo.get()); \n    }\n}\n"}
{"id": 27658, "name": "Closures_Value capture", "source": "Translate Swift to Python: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 27659, "name": "Closures_Value capture", "source": "Translate Swift to Python: var funcs: [() -> Int] = []\nfor var i = 0; i < 10; i++ {\n  funcs.append({ i * i })\n}\nprintln(funcs[3]()) \n", "target": "funcs = []\nfor i in range(10):\n    funcs.append(lambda: i * i)\nprint funcs[3]() \n"}
{"id": 28393, "name": "Caesar cipher", "source": "Translate Swift to C#: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28395, "name": "Caesar cipher", "source": "Translate Swift to Java: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28396, "name": "Caesar cipher", "source": "Translate Swift to Python: func usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) \n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  \n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } \n  if 96 == cv { cv = 45 }  \n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc ? key : 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4 != CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\") != charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\") != charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\") != charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\" != caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\" != caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28725, "name": "Lucas-Lehmer test", "source": "Translate Swift to C#: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading.Tasks;\n\nnamespace LucasLehmerTestForRosettaCode\n{\n    public class LucasLehmerTest\n    {\n        static BigInteger ZERO = new BigInteger(0);\n        static BigInteger ONE = new BigInteger(1);\n        static BigInteger TWO = new BigInteger(2);\n        static BigInteger FOUR = new BigInteger(4);\n\n        private static bool isMersennePrime(int p) \n        {\n            if (p % 2 == 0) return (p == 2);\n            else {\n                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)\n                    if (p % i == 0) return false; \n                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;\n                BigInteger s = FOUR;\n                for (int i = 3; i <= p; i++)\n                    s = (s * s - TWO) % m_p;\n                return s == ZERO;\n            } \n        }\n\n        public static int[] GetMersennePrimeNumbers(int upTo)\n        {\n            List<int> response = new List<int>();\n            Parallel.For(2, upTo + 1, i => {\n                if (isMersennePrime(i)) response.Add(i);\n            });\n            response.Sort();\n            return response.ToArray();\n        }\n\n        static void Main(string[] args)\n        {\n            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);\n            foreach (int mp in mersennePrimes)\n                Console.Write(\"M\" + mp+\" \");\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 28727, "name": "Lucas-Lehmer test", "source": "Translate Swift to Java: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "import java.math.BigInteger;\npublic class Mersenne\n{\n\n    public static boolean isPrime(int p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            int to = (int)Math.sqrt(p);\n            for (int i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public static boolean isMersennePrime(int p) {\n        if (p == 2)\n            return true;\n        else {\n            BigInteger m_p = BigInteger.ONE.shiftLeft(p).subtract(BigInteger.ONE);\n            BigInteger s = BigInteger.valueOf(4);\n            for (int i = 3; i <= p; i++)\n                s = s.multiply(s).subtract(BigInteger.valueOf(2)).mod(m_p);\n            return s.equals(BigInteger.ZERO);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int upb;\n        if (args.length == 0)\n            upb = 500;\n        else\n            upb = Integer.parseInt(args[0]);\n\n        System.out.print(\" Finding Mersenne primes in M[2..\" + upb + \"]:\\nM2 \");\n        for (int p = 3; p <= upb; p += 2)\n            if (isPrime(p) && isMersennePrime(p))\n                System.out.print(\" M\" + p);\n        System.out.println();\n    }\n}\n"}
{"id": 28728, "name": "Lucas-Lehmer test", "source": "Translate Swift to Python: import BigInt         \nimport Darwin\n\nfunc Eratosthenes(upTo: Int) -> [Int] {\n    \n    let maxroot = Int(sqrt(Double(upTo)))\n    \n    var isprime = [Bool](repeating: true, count: upTo+1 )\n    for i in 2...maxroot {\n        if isprime[i] {\n            for k in stride(from: upTo/i, through: i, by: -1) {\n                if isprime[k] {\n                    isprime[i*k] = false }\n            }\n        }\n    }\n    var result = [Int]()\n    for i in 2...upTo {\n        if isprime[i] {\n            result.append( i)\n        }\n    }\n    return result\n}\n\nfunc lucasLehmer(_ p: Int) -> Bool {\n    let m = BigInt(2).power(p) - 1\n    var s = BigInt(4)\n    \n    for _ in 0..<p-2 {\n        s = ((s * s) - 2) % m\n    }\n    \n    return s == 0\n}\n\nfor prime in Eratosthenes(upTo: 128) where lucasLehmer(prime) {\n    let mprime = BigInt(2).power(prime) - 1\n    print(\"2^\\(prime) - 1 = \\(mprime) is prime\")\n}\n", "target": "from sys import stdout\nfrom math import sqrt, log\n\ndef is_prime ( p ):\n  if p == 2: return True \n  elif p <= 1 or p % 2 == 0: return False\n  else:\n    for i in range(3, int(sqrt(p))+1, 2 ): \n      if p % i == 0: return False\n    return True\n\ndef is_mersenne_prime ( p ):\n  if p == 2:\n    return True\n  else:\n    m_p = ( 1 << p ) - 1\n    s = 4\n    for i in range(3, p+1): \n      s = (s ** 2 - 2) % m_p\n    return s == 0\n\nprecision = 20000   \nlong_bits_width = precision * log(10, 2)\nupb_prime = int( long_bits_width - 1 ) / 2    \nupb_count = 45      \n\nprint (\" Finding Mersenne primes in M[2..%d]:\"%upb_prime)\n\ncount=0\nfor p in range(2, int(upb_prime+1)): \n  if is_prime(p) and is_mersenne_prime(p):\n    print(\"M%d\"%p),\n    stdout.flush()\n    count += 1\n  if count >= upb_count: break\nprint\n"}
{"id": 28963, "name": "FizzBuzz", "source": "Translate Swift to C#: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28965, "name": "FizzBuzz", "source": "Translate Swift to Java: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28966, "name": "FizzBuzz", "source": "Translate Swift to Python: for i in 1...100 {\n    switch (i % 3, i % 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29197, "name": "Monty Hall problem", "source": "Translate Swift to C#: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29199, "name": "Monty Hall problem", "source": "Translate Swift to Java: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29200, "name": "Monty Hall problem", "source": "Translate Swift to Python: import Foundation\n\nfunc montyHall(doors: Int = 3, guess: Int, switch: Bool) -> Bool {\n  guard doors > 2, guess > 0, guess <= doors else { fatalError() }\n\n  let winningDoor = Int.random(in: 1...doors)\n\n  return winningDoor == guess ? !`switch` : `switch`\n}\n\nvar switchResults = [Bool]()\n\nfor _ in 0..<1_000 {\n  let guess = Int.random(in: 1...3)\n  let wasRight = montyHall(guess: guess, switch: true)\n\n  switchResults.append(wasRight)\n}\n\nlet switchWins = switchResults.filter({ $0 }).count\n\nprint(\"Switching would've won \\((Double(switchWins) / Double(switchResults.count)) * 100)% of games\")\nprint(\"Not switching would've won \\(((Double(switchResults.count - switchWins)) / Double(switchResults.count)) * 100)% of games\")\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29360, "name": "Polymorphic copy", "source": "Translate Swift to C#: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "using System;\n\nclass T\n{\n    public virtual string Name()\n    {\n        return \"T\";\n    }\n\n    public virtual T Clone()\n    {\n        return new T();\n    }\n}\n\nclass S : T\n{\n    public override string Name()\n    {\n        return \"S\";\n    }\n\n    public override T Clone()\n    {\n        return new S();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        T original = new S();\n        T clone = original.Clone();\n\n        Console.WriteLine(original.Name());\n        Console.WriteLine(clone.Name());\n    }\n}\n"}
{"id": 29362, "name": "Polymorphic copy", "source": "Translate Swift to Java: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "class T implements Cloneable {\n    public String name() { return \"T\"; }\n    public T copy() {\n        try {\n            return (T)super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n\nclass S extends T {\n    public String name() { return \"S\"; }\n}\n\npublic class PolymorphicCopy {\n    public static T copier(T x) { return x.copy(); }\n    public static void main(String[] args) {\n        T obj1 = new T();\n        S obj2 = new S();\n        System.out.println(copier(obj1).name()); \n        System.out.println(copier(obj2).name()); \n    }\n}\n"}
{"id": 29363, "name": "Polymorphic copy", "source": "Translate Swift to Python: class T {\n  required init() { } \n  func identify() {\n    println(\"I am a genuine T\")\n  }\n  func copy() -> T {\n    let newObj : T = self.dynamicType() \n    \n    \n    \n    return newObj\n  }\n}\n\nclass S : T {\n  override func identify()  {\n    println(\"I am an S\")\n  }\n}\n\nlet original : T = S()\nlet another : T = original.copy()\nprintln(original === another) \nanother.identify() \n", "target": "import copy\n\nclass T:\n   def classname(self): \n      return self.__class__.__name__\n\n   def __init__(self):\n      self.myValue = \"I'm a T.\"\n\n   def speak(self):\n      print self.classname(), 'Hello', self.myValue\n\n   def clone(self):\n      return copy.copy(self)\n\nclass S1(T):\n   def speak(self):\n      print self.classname(),\"Meow\", self.myValue\n\nclass S2(T):\n   def speak(self):\n      print self.classname(),\"Woof\", self.myValue\n\n\nprint \"creating initial objects of types S1, S2, and T\"\na = S1()\na.myValue = 'Green'\na.speak()\n\nb = S2()\nb.myValue = 'Blue'\nb.speak()\n\nu = T()\nu.myValue = 'Purple'\nu.speak()\n\nprint \"Making copy of a as u, colors and types should match\"\nu = a.clone()\nu.speak()\na.speak()\nprint \"Assigning new color to u, A's color should be unchanged.\"\nu.myValue = \"Orange\"\nu.speak()\na.speak()\n\nprint \"Assigning u to reference same object as b, colors and types should match\"\nu = b\nu.speak()\nb.speak()\nprint \"Assigning new color to u. Since u,b references same object b's color changes as well\"\nu.myValue = \"Yellow\"\nu.speak()\nb.speak()\n"}
{"id": 29616, "name": "User input_Text", "source": "Translate Swift to C#: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29618, "name": "User input_Text", "source": "Translate Swift to Java: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29619, "name": "User input_Text", "source": "Translate Swift to Python: print(\"Enter a string: \", terminator: \"\")\nif let str = readLine() {\n  print(str)\n}\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 30658, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to C#: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\n\nclass Program\n{\n    static void ThreadStart(object item)\n    {\n        Thread.Sleep(1000 * (int)item);\n        Console.WriteLine(item);\n    }\n\n    static void SleepSort(IEnumerable<int> items)\n    {\n        foreach (var item in items)\n        {\n            new Thread(ThreadStart).Start(item);\n        }\n    }\n\n    static void Main(string[] arguments)\n    {\n        SleepSort(arguments.Select(int.Parse));\n    }\n}\n"}
{"id": 30660, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to Java: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "import java.util.concurrent.CountDownLatch;\n\npublic class SleepSort {\n\tpublic static void sleepSortAndPrint(int[] nums) {\n\t\tfinal CountDownLatch doneSignal = new CountDownLatch(nums.length);\n\t\tfor (final int num : nums) {\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoneSignal.countDown();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoneSignal.await();\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tThread.sleep(num * 1000);\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] nums = new int[args.length];\n\t\tfor (int i = 0; i < args.length; i++)\n\t\t\tnums[i] = Integer.parseInt(args[i]);\n\t\tsleepSortAndPrint(nums);\n\t}\n}\n"}
{"id": 30661, "name": "Sorting algorithms_Sleep sort", "source": "Translate Swift to Python: import Foundation\n\nfor i in [5, 2, 4, 6, 1, 7, 20, 14] {\n    let time = dispatch_time(DISPATCH_TIME_NOW,\n        Int64(i * Int(NSEC_PER_SEC)))\n    \n    dispatch_after(time, dispatch_get_main_queue()) {\n        print(i)\n    }\n}\n\nCFRunLoopRun()\n", "target": "from time import sleep\nfrom threading import Timer\n\ndef sleepsort(values):\n    sleepsort.result = []\n    def add1(x):\n        sleepsort.result.append(x)\n    mx = values[0]\n    for v in values:\n        if mx < v: mx = v\n        Timer(v, add1, [v]).start()\n    sleep(mx+1)\n    return sleepsort.result\n\nif __name__ == '__main__':\n    x = [3,2,4,7,3,6,9,1]\n    if sleepsort(x) == sorted(x):\n        print('sleep sort worked for:',x)\n    else:\n        print('sleep sort FAILED for:',x)\n"}
{"id": 31233, "name": "Sort numbers lexicographically", "source": "Translate Swift to C#: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    public static void Main() {\n        foreach (int n in new [] { 0, 5, 13, 21, -22 }) WriteLine($\"{n}: {string.Join(\", \", LexOrder(n))}\");\n    }\n\n    public static IEnumerable<int> LexOrder(int n) => (n < 1 ? Range(n, 2 - n) : Range(1, n)).OrderBy(i => i.ToString());\n}\n"}
{"id": 31235, "name": "Sort numbers lexicographically", "source": "Translate Swift to Java: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "import java.util.List;\nimport java.util.stream.*;\n\npublic class LexicographicalNumbers {\n\n    static List<Integer> lexOrder(int n) {\n        int first = 1, last = n;\n        if (n < 1) {\n            first = n;\n            last = 1;\n        }\n        return IntStream.rangeClosed(first, last)\n                        .mapToObj(Integer::toString)\n                        .sorted()\n                        .map(Integer::valueOf)\n                        .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"In lexicographical order:\\n\");\n        int[] ints = {0, 5, 13, 21, -22};\n        for (int n : ints) {\n           System.out.printf(\"%3d: %s\\n\", n, lexOrder(n));\n        }\n    }\n}\n"}
{"id": 31236, "name": "Sort numbers lexicographically", "source": "Translate Swift to Python: func lex(n: Int) -> [Int] {\n  return stride(from: 1, through: n, by: n.signum()).map({ String($0) }).sorted().compactMap(Int.init)\n}\n\nprint(\"13: \\(lex(n: 13))\")\nprint(\"21: \\(lex(n: 21))\")\nprint(\"-22: \\(lex(n: -22))\")\n", "target": "n=13\nprint(sorted(range(1,n+1), key=str))\n"}
{"id": 31566, "name": "Remove vowels from a string", "source": "Translate Swift to C#: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31567, "name": "Remove vowels from a string", "source": "Translate Swift to C#: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31570, "name": "Remove vowels from a string", "source": "Translate Swift to Java: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31571, "name": "Remove vowels from a string", "source": "Translate Swift to Java: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31572, "name": "Remove vowels from a string", "source": "Translate Swift to Python: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31573, "name": "Remove vowels from a string", "source": "Translate Swift to Python: func isVowel(_ char: Character) -> Bool {\n    switch (char) {\n    case \"a\", \"A\", \"e\", \"E\", \"i\", \"I\", \"o\", \"O\", \"u\", \"U\":\n        return true\n    default:\n        return false\n    }\n}\n\nfunc removeVowels(string: String) -> String {\n    return string.filter{!isVowel($0)}\n}\n\nlet str = \"The Swift Programming Language\"\nprint(str)\nprint(removeVowels(string: str))\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31801, "name": "Forward difference", "source": "Translate Swift to C#: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"id": 31803, "name": "Forward difference", "source": "Translate Swift to Java: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": "import java.util.Arrays;\npublic class FD {\n    public static void main(String args[]) {\n        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};\n        System.out.println(Arrays.toString(dif(a, 1)));\n        System.out.println(Arrays.toString(dif(a, 2)));\n        System.out.println(Arrays.toString(dif(a, 9)));\n        System.out.println(Arrays.toString(dif(a, 10)));      \n        System.out.println(Arrays.toString(dif(a, 11)));\n        System.out.println(Arrays.toString(dif(a, -1)));\n        System.out.println(Arrays.toString(dif(a, 0)));\n    }\n\n    public static double[] dif(double[] a, int n) {\n        if (n < 0)\n            return null; \n\n        for (int i = 0; i < n && a.length > 0; i++) {\n            double[] b = new double[a.length - 1];\n            for (int j = 0; j < b.length; j++){\n                b[j] = a[j+1] - a[j];\n            }\n            a = b; \n        }\n        return a;\n    }\n}\n"}
{"id": 31804, "name": "Forward difference", "source": "Translate Swift to Python: func forwardsDifference<T: SignedNumeric>(of arr: [T]) -> [T] {\n  return zip(arr.dropFirst(), arr).map({ $0.0 - $0.1 })\n}\n\nfunc nthForwardsDifference<T: SignedNumeric>(of arr: [T], n: Int) -> [T] {\n  assert(n >= 0)\n\n  switch (arr, n) {\n  case ([], _):\n    return []\n  case let (arr, 0):\n    return arr\n  case let (arr, i):\n    return nthForwardsDifference(of: forwardsDifference(of: arr), n: i - 1)\n  }\n}\n\nfor diff in (0...9).map({ nthForwardsDifference(of: [90, 47, 58, 29, 22, 32, 55, 5, 55, 73], n: $0) }) {\n  print(diff)\n}\n", "target": ">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\n>>> \n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\n\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 0)\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 1)\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\n>>> difn(s, 2)\n[54, -40, 22, 17, 13, -73, 100, -32]\n\n>>> from pprint import pprint\n>>> pprint( [difn(s, i) for i in xrange(10)] )\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\n [54, -40, 22, 17, 13, -73, 100, -32],\n [-94, 62, -5, -4, -86, 173, -132],\n [156, -67, 1, -82, 259, -305],\n [-223, 68, -83, 341, -564],\n [291, -151, 424, -905],\n [-442, 575, -1329],\n [1017, -1904],\n [-2921]]\n"}
{"id": 32064, "name": "Guess the number_With feedback", "source": "Translate Swift to C#: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 32066, "name": "Guess the number_With feedback", "source": "Translate Swift to Java: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 32067, "name": "Guess the number_With feedback", "source": "Translate Swift to Python: import Cocoa\n\nvar found = false\n\nlet randomNum = Int(arc4random_uniform(100) + 1)\n\nprintln(\"Guess a number between 1 and 100\\n\")\n\nwhile (!found) {\n    var fh = NSFileHandle.fileHandleWithStandardInput()\n    \n    println(\"Enter a number: \")\n    let data = fh.availableData\n    let str = NSString(data: data, encoding: NSUTF8StringEncoding)\n    if (str?.integerValue == randomNum) {\n        found = true\n        println(\"Well guessed!\")\n    } else if (str?.integerValue < randomNum) {\n        println(\"Good try but the number is more than that!\")\n    } else if (str?.integerValue > randomNum) {\n        println(\"Good try but the number is less than that!\")\n    }\n}\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32306, "name": "Compound data type", "source": "Translate Swift to C#: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32308, "name": "Compound data type", "source": "Translate Swift to Java: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32309, "name": "Compound data type", "source": "Translate Swift to Python: \nstruct Point {\n    var x:Int\n    var y:Int\n}\n\n\ntypealias PointTuple = (Int, Int)\n\n\nclass PointClass {\n    var x:Int!\n    var y:Int!\n    \n    init(x:Int, y:Int) {\n        self.x = x\n        self.y = y\n    }\n}\n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32573, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to C#: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32575, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to Java: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32576, "name": "Sorting algorithms_Bogosort", "source": "Translate Swift to Python: import Darwin\n\nfunc shuffle<T>(inout array: [T]) {\n  for i in 1..<array.count {\n    let j = Int(arc4random_uniform(UInt32(i)))\n    (array[i], array[j]) = (array[j], array[i])\n  }\n}\n\nfunc issorted<T:Comparable>(ary: [T]) -> Bool {\n  for i in 0..<(ary.count-1) {\n    if ary[i] > ary[i+1] {\n      return false\n    }\n  }\n  return true\n}\n\nfunc bogosort<T:Comparable>(inout ary: [T]) {\n  while !issorted(ary) {\n    shuffle(&ary)\n  }\n}\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32843, "name": "Cumulative standard deviation", "source": "Translate Swift to C#: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32845, "name": "Cumulative standard deviation", "source": "Translate Swift to Java: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32846, "name": "Cumulative standard deviation", "source": "Translate Swift to Python: import Darwin\nclass stdDev{\n    \n    var n:Double = 0.0\n    var sum:Double = 0.0\n    var sum2:Double = 0.0\n    \n    init(){\n        \n        let testData:[Double] = [2,4,4,4,5,5,7,9];\n        for x in testData{\n            \n            var a:Double = calcSd(x)\n            println(\"value \\(Int(x)) SD = \\(a)\");\n        }\n        \n    }\n    \n    func calcSd(x:Double)->Double{\n        \n        n += 1\n        sum += x\n        sum2 += x*x\n        return sqrt( sum2 / n - sum*sum / n / n)\n    }\n    \n}\nvar aa = stdDev()\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 33123, "name": "Palindrome detection", "source": "Translate Swift to C#: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 33125, "name": "Palindrome detection", "source": "Translate Swift to Java: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 33126, "name": "Palindrome detection", "source": "Translate Swift to Python: import Foundation\n\n\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33402, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to C#: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33404, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to Java: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33405, "name": "Loop over multiple arrays simultaneously", "source": "Translate Swift to Python: let a1 = [\"a\", \"b\", \"c\"]\nlet a2 = [\"A\", \"B\", \"C\"]\nlet a3 = [1, 2, 3]\n\nfor i in 0 ..< a1.count {\n    println(\"\\(a1[i])\\(a2[i])\\(a3[i])\")\n}\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33653, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to C#: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33655, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to Java: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33656, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Swift to Python: extension Collection where Element: Comparable {\n  public func cocktailSorted() -> [Element] {\n    var swapped = false\n    var ret = Array(self)\n\n    guard count > 1 else {\n      return ret\n    }\n    \n    repeat {\n      for i in 0...ret.count-2 where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n\n      guard swapped else { \n        break \n      }\n\n      swapped = false\n\n      for i in stride(from: ret.count - 2, through: 0, by: -1) where ret[i] > ret[i + 1] {\n        (ret[i], ret[i + 1]) = (ret[i + 1], ret[i])\n        swapped = true\n      }\n    } while swapped\n\n    return ret\n  }\n}\n\nlet arr = (1...10).shuffled()\n\nprint(\"Before: \\(arr)\")\nprint(\"Cocktail sort: \\(arr.cocktailSorted())\")\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 34534, "name": "Heronian triangles", "source": "Translate Swift to C#: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34535, "name": "Heronian triangles", "source": "Translate Swift to C#: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34538, "name": "Heronian triangles", "source": "Translate Swift to Java: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34539, "name": "Heronian triangles", "source": "Translate Swift to Java: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34540, "name": "Heronian triangles", "source": "Translate Swift to Python: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34541, "name": "Heronian triangles", "source": "Translate Swift to Python: import Foundation\n\ntypealias PrimitiveHeronianTriangle = (s1:Int, s2:Int, s3:Int, p:Int, a:Int)\n\nfunc heronianArea(side1 s1:Int, side2 s2:Int, side3 s3:Int) -> Int? {\n    let d1 = Double(s1)\n    let d2 = Double(s2)\n    let d3 = Double(s3)\n    \n    let s = (d1 + d2 + d3) / 2.0\n    let a = sqrt(s * (s - d1) * (s - d2) * (s - d3))\n    \n    if a % 1 != 0 || a <= 0 {\n        return nil\n    } else {\n        return Int(a)\n    }\n}\n\nfunc gcd(a:Int, b:Int) -> Int {\n    if b != 0 {\n        return gcd(b, a % b)\n    } else {\n        return abs(a)\n    }\n}\n\nvar triangles = [PrimitiveHeronianTriangle]()\n\nfor s1 in 1...200 {\n    for s2 in 1...s1 {\n        for s3 in 1...s2 {\n            if gcd(s1, gcd(s2, s3)) == 1, let a = heronianArea(side1: s1, side2: s2, side3: s3) {\n                triangles.append((s3, s2, s1, s1 + s2 + s3, a))\n            }\n        }\n    }\n}\n\nsort(&triangles) {t1, t2 in\n    if t1.a < t2.a || t1.a == t2.a && t1.p < t2.p {\n        return true\n    } else {\n        return false\n    }\n}\n\nprintln(\"Number of primitive Heronian triangles with sides up to 200: \\(triangles.count)\\n\")\nprintln(\"First ten sorted by area, then perimeter, then maximum side:\\n\")\nprintln(\"Sides\\t\\t\\tPerimeter\\tArea\")\n\nfor t in triangles[0...9] {\n    println(\"\\(t.s1)\\t\\(t.s2)\\t\\(t.s3)\\t\\t\\(t.p)\\t\\t\\(t.a)\")\n}\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 36209, "name": "Continued fraction", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36210, "name": "Continued fraction", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 36213, "name": "Continued fraction", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36214, "name": "Continued fraction", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 36215, "name": "Continued fraction", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36216, "name": "Continued fraction", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\npublic struct CycledSequence<WrappedSequence: Sequence> {\n  private var seq: WrappedSequence\n  private var iter: WrappedSequence.Iterator\n\n  init(seq: WrappedSequence) {\n    self.seq = seq\n    self.iter = seq.makeIterator()\n  }\n}\n\nextension CycledSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> WrappedSequence.Element? {\n    if let ele = iter.next() {\n      return ele\n    } else {\n      iter = seq.makeIterator()\n\n      return iter.next()\n    }\n  }\n}\n\nextension Sequence {\n  public func cycled() -> CycledSequence<Self> {\n    return CycledSequence(seq: self)\n  }\n}\n\npublic struct ChainedSequence<Element> {\n  private var sequences: [AnySequence<Element>]\n  private var iter: AnyIterator<Element>\n  private var curSeq = 0\n\n  init(chain: ChainedSequence) {\n    self.sequences = chain.sequences\n    self.iter = chain.iter\n    self.curSeq = chain.curSeq\n  }\n\n  init<Seq: Sequence>(_ seq: Seq) where Seq.Element == Element {\n    sequences = [AnySequence(seq)]\n    iter = sequences[curSeq].makeIterator()\n  }\n\n  func chained<Seq: Sequence>(with seq: Seq) -> ChainedSequence where Seq.Element == Element {\n    var res = ChainedSequence(chain: self)\n\n    res.sequences.append(AnySequence(seq))\n\n    return res\n  }\n}\n\nextension ChainedSequence: Sequence, IteratorProtocol {\n  public mutating func next() -> Element? {\n    if let el = iter.next() {\n      return el\n    }\n\n    curSeq += 1\n\n    guard curSeq != sequences.endIndex else {\n      return nil\n    }\n\n    iter = sequences[curSeq].makeIterator()\n\n    return iter.next()\n  }\n}\n\nextension Sequence {\n  public func chained<Seq: Sequence>(with other: Seq) -> ChainedSequence<Element> where Seq.Element == Element {\n    return ChainedSequence(self).chained(with: other)\n  }\n}\n\nfunc continuedFraction<T: Sequence, V: Sequence>(\n  _ seq1: T,\n  _ seq2: V,\n  iterations: Int = 1000\n) -> Double where T.Element: BinaryInteger, T.Element == V.Element {\n  return zip(seq1, seq2).prefix(iterations).reversed().reduce(0.0, { Double($1.0) + (Double($1.1) / $0) })\n}\n\nlet sqrtA = [1].chained(with: [2].cycled())\nlet sqrtB = [1].cycled()\n\nprint(\"\u221a2 \u2248 \\(continuedFraction(sqrtA, sqrtB))\")\n\nlet napierA = [2].chained(with: 1...)\nlet napierB = [1].chained(with: 1...)\n\nprint(\"e \u2248 \\(continuedFraction(napierA, napierB))\")\n\nlet piA = [3].chained(with: [6].cycled())\nlet piB = (1...).lazy.map({ (2 * $0 - 1).power(2) })\n\nprint(\"\u03c0 \u2248 \\(continuedFraction(piA, piB))\")\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36700, "name": "Quine", "source": "Translate Swift to C#: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36701, "name": "Quine", "source": "Translate Swift to C#: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36704, "name": "Quine", "source": "Translate Swift to Java: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36705, "name": "Quine", "source": "Translate Swift to Java: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36706, "name": "Quine", "source": "Translate Swift to Python: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36707, "name": "Quine", "source": "Translate Swift to Python: ({print($0+$0.debugDescription+\")\")})(\"({print($0+$0.debugDescription+\\\")\\\")})(\")\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37091, "name": "Problem of Apollonius", "source": "Translate Swift to C#: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n"}
{"id": 37092, "name": "Problem of Apollonius", "source": "Translate Swift to Java: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "public class Circle\n{\n public double[] center;\n public double radius;\n public Circle(double[] center, double radius)\n {\n  this.center = center;\n  this.radius = radius;\n }\n public String toString()\n {\n  return String.format(\"Circle[x=%.2f,y=%.2f,r=%.2f]\",center[0],center[1],\n\t\t       radius);\n }\n}\n\npublic class ApolloniusSolver\n{\n\n public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,\n\t\t\t\t      int s2, int s3)\n {\n  float x1 = c1.center[0];\n  float y1 = c1.center[1];\n  float r1 = c1.radius;\n  float x2 = c2.center[0];\n  float y2 = c2.center[1];\n  float r2 = c2.radius;\n  float x3 = c3.center[0];\n  float y3 = c3.center[1];\n  float r3 = c3.radius;\n\n  \n  \n  float v11 = 2*x2 - 2*x1;\n  float v12 = 2*y2 - 2*y1;\n  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;\n  float v14 = 2*s2*r2 - 2*s1*r1;\n\n  float v21 = 2*x3 - 2*x2;\n  float v22 = 2*y3 - 2*y2;\n  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;\n  float v24 = 2*s3*r3 - 2*s2*r2;\n\n  float w12 = v12/v11;\n  float w13 = v13/v11;\n  float w14 = v14/v11;\n\n  float w22 = v22/v21-w12;\n  float w23 = v23/v21-w13;\n  float w24 = v24/v21-w14;\n\n  float P = -w23/w22;\n  float Q = w24/w22;\n  float M = -w12*P-w13;\n  float N = w14 - w12*Q;\n\n  float a = N*N + Q*Q - 1;\n  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;\n  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;\n\n  \n  \n  float D = b*b-4*a*c;\n  float rs = (-b-Math.sqrt(D))/(2*a);\n  float xs = M + N * rs;\n  float ys = P + Q * rs;\n  return new Circle(new double[]{xs,ys}, rs);\n }\n public static void main(final String[] args)\n {\n  Circle c1 = new Circle(new double[]{0,0}, 1);\n  Circle c2 = new Circle(new double[]{4,0}, 1);\n  Circle c3 = new Circle(new double[]{2,4}, 2);\n  \n  System.out.println(solveApollonius(c1,c2,c3,1,1,1));\n  \n  System.out.println(solveApollonius(c1,c2,c3,-1,-1,-1));\n }\n}\n"}
{"id": 37093, "name": "Problem of Apollonius", "source": "Translate Swift to Python: import Foundation\n\nstruct Circle {\n    let center:[Double]!\n    let radius:Double!\n    \n    init(center:[Double], radius:Double) {\n        self.center = center\n        self.radius = radius\n    }\n    \n    func toString() -> String {\n        return \"Circle[x=\\(center[0]),y=\\(center[1]),r=\\(radius)]\"\n    }\n}\n\nfunc solveApollonius(c1:Circle, c2:Circle, c3:Circle,\n    s1:Double, s2:Double, s3:Double) -> Circle {\n    \n        let x1 = c1.center[0]\n        let y1 = c1.center[1]\n        let r1 = c1.radius\n        let x2 = c2.center[0]\n        let y2 = c2.center[1]\n        let r2 = c2.radius\n        let x3 = c3.center[0]\n        let y3 = c3.center[1]\n        let r3 = c3.radius\n        \n        let v11 = 2*x2 - 2*x1\n        let v12 = 2*y2 - 2*y1\n        let v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n        let v14 = 2*s2*r2 - 2*s1*r1\n        \n        let v21 = 2*x3 - 2*x2\n        let v22 = 2*y3 - 2*y2\n        let v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n        let v24 = 2*s3*r3 - 2*s2*r2\n        \n        let w12 = v12/v11\n        let w13 = v13/v11\n        let w14 = v14/v11\n        \n        let w22 = v22/v21-w12\n        let w23 = v23/v21-w13\n        let w24 = v24/v21-w14\n        \n        let P = -w23/w22\n        let Q = w24/w22\n        let M = -w12*P-w13\n        let N = w14 - w12*Q\n        \n        let a = N*N + Q*Q - 1\n        let b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n        let c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n        \n        let D = b*b-4*a*c\n        \n        let rs = (-b - sqrt(D)) / (2*a)\n        let xs = M + N * rs\n        let ys = P + Q * rs\n        \n        return  Circle(center: [xs,ys], radius: rs)\n        \n}\n\nlet c1 = Circle(center: [0,0], radius: 1)\nlet c2 = Circle(center: [4,0], radius: 1)\nlet c3 = Circle(center: [2,4], radius: 2)\n\nprintln(solveApollonius(c1,c2,c3,1,1,1).toString())\nprintln(solveApollonius(c1,c2,c3,-1,-1,-1).toString())\n", "target": "from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n"}
{"id": 37718, "name": "Quaternion type", "source": "Translate Swift to C#: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37719, "name": "Quaternion type", "source": "Translate Swift to C#: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37722, "name": "Quaternion type", "source": "Translate Swift to Java: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37723, "name": "Quaternion type", "source": "Translate Swift to Java: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37724, "name": "Quaternion type", "source": "Translate Swift to Python: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37725, "name": "Quaternion type", "source": "Translate Swift to Python: import Foundation\n\nstruct Quaternion {\n  var a, b, c, d: Double\n  \n  static let i = Quaternion(a: 0, b: 1, c: 0, d: 0)\n  static let j = Quaternion(a: 0, b: 0, c: 1, d: 0)\n  static let k = Quaternion(a: 0, b: 0, c: 0, d: 1)\n}\nextension Quaternion: Equatable {\n  static func ==(lhs: Quaternion, rhs: Quaternion) -> Bool {\n    return (lhs.a, lhs.b, lhs.c, lhs.d) == (rhs.a, rhs.b, rhs.c, rhs.d)\n  }\n}\nextension Quaternion: ExpressibleByIntegerLiteral {\n  init(integerLiteral: Double) {\n    a = integerLiteral\n    b = 0\n    c = 0\n    d = 0\n  }\n}\nextension Quaternion: Numeric {\n  var magnitude: Double {\n    return norm\n  }\n  init?<T>(exactly: T) { \n    return nil\n  }\n  public static func + (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func - (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func * (lhs: Quaternion, rhs: Quaternion) -> Quaternion {\n    return Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n  public static func += (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a + rhs.a,\n      b: lhs.b + rhs.b,\n      c: lhs.c + rhs.c,\n      d: lhs.d + rhs.d\n    )\n  }\n  public static func -= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a - rhs.a,\n      b: lhs.b - rhs.b,\n      c: lhs.c - rhs.c,\n      d: lhs.d - rhs.d\n    )\n  }\n  public static func *= (lhs: inout Quaternion, rhs: Quaternion) {\n    lhs = Quaternion(\n      a: lhs.a*rhs.a - lhs.b*rhs.b - lhs.c*rhs.c - lhs.d*rhs.d,\n      b: lhs.a*rhs.b + lhs.b*rhs.a + lhs.c*rhs.d - lhs.d*rhs.c,\n      c: lhs.a*rhs.c - lhs.b*rhs.d + lhs.c*rhs.a + lhs.d*rhs.b,\n      d: lhs.a*rhs.d + lhs.b*rhs.c - lhs.c*rhs.b + lhs.d*rhs.a\n    )\n  }\n}\nextension Quaternion: CustomStringConvertible {\n  var description: String {\n    let formatter = NumberFormatter()\n    formatter.positivePrefix = \"+\"\n    let f: (Double) -> String = { formatter.string(from: $0 as NSNumber)! }\n    return [f(a), f(b), \"i\", f(c), \"j\", f(d), \"k\"].joined()\n  }\n}\nextension Quaternion {\n  var norm: Double {\n    return sqrt(a*a + b*b + c*c + d*d)\n  }\n  var conjugate: Quaternion {\n    return Quaternion(a: a, b: -b, c: -c, d: -d)\n  }\n  public static func + (lhs: Double, rhs: Quaternion) -> Quaternion {\n    var result = rhs\n    result.a += lhs\n    return result\n  }\n  public static func + (lhs: Quaternion, rhs: Double) -> Quaternion {\n    var result = lhs\n    result.a += rhs\n    return result\n  }\n  public static func * (lhs: Double, rhs: Quaternion) -> Quaternion {\n    return Quaternion(a: lhs*rhs.a, b: lhs*rhs.b, c: lhs*rhs.c, d: lhs*rhs.d)\n  }\n  public static func * (lhs: Quaternion, rhs: Double) -> Quaternion {\n    return Quaternion(a: lhs.a*rhs, b: lhs.b*rhs, c: lhs.c*rhs, d: lhs.d*rhs)\n  }\n  public static prefix func - (x: Quaternion) -> Quaternion {\n    return Quaternion(a: -x.a, b: -x.b, c: -x.c, d: -x.d)\n  }\n}\n\nlet q:  Quaternion = 1 + 2 * .i + 3 * .j + 4 * .k \nlet q1: Quaternion = 2 + 3 * .i + 4 * .j + 5 * .k \nlet q2: Quaternion = 3 + 4 * .i + 5 * .j + 6 * .k \nlet r: Double = 7\n\nprint(\"\"\"\n  q  = \\(q)\n  q1 = \\(q1)\n  q2 = \\(q2)\n  r = \\(r)\n  -q = \\(-q)\n  \u2016q\u2016 = \\(q.norm)\n  conjugate of q = \\(q.conjugate)\n  r + q = q + r = \\(r+q) = \\(q+r)\n  q\u2081 + q\u2082 = \\(q1 + q2) = \\(q2 + q1)\n  qr = rq = \\(q*r) = \\(r*q)\n  q\u2081q\u2082 = \\(q1 * q2)\n  q\u2082q\u2081 = \\(q2 * q1)\n  q\u2081q\u2082 \u2260 q\u2082q\u2081 is \\(q1*q2 != q2*q1)\n\"\"\")\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 38095, "name": "Character codes", "source": "Translate Swift to C#: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 38097, "name": "Character codes", "source": "Translate Swift to Java: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 38098, "name": "Character codes", "source": "Translate Swift to Python: let c1: UnicodeScalar = \"a\"\nprintln(c1.value) \nlet c2: UnicodeScalar = \"\u03c0\"\nprintln(c2.value) \n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38916, "name": "Generic swap", "source": "Translate Swift to C#: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38918, "name": "Generic swap", "source": "Translate Swift to Java: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38919, "name": "Generic swap", "source": "Translate Swift to Python: func swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n", "target": "a, b = b, a\n"}
{"id": 39428, "name": "Modular arithmetic", "source": "Translate Swift to C#: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39429, "name": "Modular arithmetic", "source": "Translate Swift to C#: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39432, "name": "Modular arithmetic", "source": "Translate Swift to Java: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39433, "name": "Modular arithmetic", "source": "Translate Swift to Java: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39434, "name": "Modular arithmetic", "source": "Translate Swift to Python: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39435, "name": "Modular arithmetic", "source": "Translate Swift to Python: precedencegroup ExponentiationGroup {\n  higherThan: MultiplicationPrecedence\n}\n\ninfix operator ** : ExponentiationGroup\n\nprotocol Ring {\n  associatedtype RingType: Numeric\n\n  var one: Self { get }\n\n  static func +(_ lhs: Self, _ rhs: Self) -> Self\n  static func *(_ lhs: Self, _ rhs: Self) -> Self\n  static func **(_ lhs: Self, _ rhs: Int) -> Self\n}\n\nextension Ring  {\n  static func **(_ lhs: Self, _ rhs: Int) -> Self {\n    var ret = lhs.one\n\n    for _ in stride(from: rhs, to: 0, by: -1) {\n      ret = ret * lhs\n    }\n\n    return ret\n  }\n}\n\nstruct ModInt: Ring {\n  typealias RingType = Int\n\n  var value: Int\n  var modulo: Int\n\n  var one: ModInt { ModInt(1, modulo: modulo) }\n\n  init(_ value: Int, modulo: Int) {\n    self.value = value\n    self.modulo = modulo\n  }\n\n  static func +(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value + rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n\n  static func *(lhs: ModInt, rhs: ModInt) -> ModInt {\n    precondition(lhs.modulo == rhs.modulo)\n\n    return ModInt((lhs.value * rhs.value) % lhs.modulo, modulo: lhs.modulo)\n  }\n}\n\nfunc f<T: Ring>(_ x: T) -> T { (x ** 100) + x + x.one }\n\nlet x = ModInt(10, modulo: 13)\nlet y = f(x)\n\nprint(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \\(y)\")\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39641, "name": "String append", "source": "Translate Swift to C#: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39643, "name": "String append", "source": "Translate Swift to Java: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39644, "name": "String append", "source": "Translate Swift to Python: var s = \"foo\"              \ns += \"bar\"                 \nprint(s)                   \ns.appendContentsOf(\"baz\")  \nprint(s)                   \n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39875, "name": "Count in octal", "source": "Translate Swift to C#: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39877, "name": "Count in octal", "source": "Translate Swift to Java: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39878, "name": "Count in octal", "source": "Translate Swift to Python: import Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40428, "name": "Sum of a series", "source": "Translate Swift to C#: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40430, "name": "Sum of a series", "source": "Translate Swift to Java: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40431, "name": "Sum of a series", "source": "Translate Swift to Python: func sumSeries(var n: Int) -> Double {\n    var ret: Double = 0\n    \n    for i in 1...n {\n        ret += (1 / pow(Double(i), 2))\n    }\n    \n    return ret\n}\n\noutput: 1.64393456668156\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 40715, "name": "Sierpinski carpet", "source": "Translate Swift to C#: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static List<string> NextCarpet(List<string> carpet)\n    {\n        return carpet.Select(x => x + x + x)\n                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))\n                     .Concat(carpet.Select(x => x + x + x)).ToList();\n    }\n\n    static List<string> SierpinskiCarpet(int n)\n    {\n        return Enumerable.Range(1, n).Aggregate(new List<string> { \"#\" }, (carpet, _) => NextCarpet(carpet));\n    }\n\n    static void Main(string[] args)\n    {\n        foreach (string s in SierpinskiCarpet(3))\n            Console.WriteLine(s);\n    }\n}\n"}
{"id": 40717, "name": "Sierpinski carpet", "source": "Translate Swift to Java: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "public static boolean inCarpet(long x, long y) {\n    while (x!=0 && y!=0) {\n        if (x % 3 == 1 && y % 3 == 1)\n            return false;\n        x /= 3;\n        y /= 3;\n    }\n    return true;\n}\n \npublic static void carpet(final int n) {\n    final double power = Math.pow(3,n);\n    for(long i = 0; i < power; i++) {\n        for(long j = 0; j < power; j++) {\n            System.out.print(inCarpet(i, j) ? \"*\" : \" \");\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 40718, "name": "Sierpinski carpet", "source": "Translate Swift to Python: import Foundation\nfunc sierpinski_carpet(n:Int) -> String {\n    func middle(str:String) -> String {\n        let spacer = str.stringByReplacingOccurrencesOfString(\"#\", withString:\" \", options:nil, range:nil)\n        return str + spacer + str\n    }\n    \n    var carpet = [\"#\"]\n    for i in 1...n {\n        let a = carpet.map{$0 + $0 + $0}\n        let b = carpet.map(middle)\n        carpet = a + b + a\n    }\n    return \"\\n\".join(carpet)\n}\n\nprintln(sierpinski_carpet(3))\n", "target": "def setup():\n    size(729, 729)\n    fill(0)\n    background(255)\n    noStroke()\n    rect(width / 3, height / 3, width / 3, width / 3)\n    rectangles(width / 3, height / 3, width / 3)\n\ndef rectangles(x, y, s):\n    if s < 1: return\n    xc, yc = x - s, y - s\n    for row in range(3):\n        for col in range(3):\n            if not (row == 1 and col == 1):\n                xx, yy = xc + row * s, yc + col * s\n                delta = s / 3\n                rect(xx + delta, yy + delta, delta, delta)\n                rectangles(xx + s / 3, yy + s / 3, s / 3)\n"}
{"id": 41052, "name": "Associative array_Creation", "source": "Translate Swift to C#: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "System.Collections.HashTable map = new System.Collections.HashTable();\nmap[\"key1\"] = \"foo\";\n"}
{"id": 41054, "name": "Associative array_Creation", "source": "Translate Swift to Java: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "Map<String, Int> map = new HashMap();\nmap[\"foo\"] = 5;      \nmap[\"bar\"] = 10;\nmap[\"baz\"] = 15;\nmap[\"foo\"] = 6;      \n"}
{"id": 41055, "name": "Associative array_Creation", "source": "Translate Swift to Python: \nvar a = [String: Int]()\n\nvar b: [String: Int] = [:]\n\n\nvar c = [String: Int](minimumCapacity: 42)\n\n\nc[\"foo\"] = 3\n\n\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "target": "hash = dict()  \nhash = dict(red=\"FF0000\", green=\"00FF00\", blue=\"0000FF\")\nhash = { 'key1':1, 'key2':2, }\nvalue = hash[key]\n"}
{"id": 42177, "name": "Mutual recursion", "source": "Translate Swift to C#: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "namespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 42179, "name": "Mutual recursion", "source": "Translate Swift to Java: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n"}
{"id": 42180, "name": "Mutual recursion", "source": "Translate Swift to Python: func F(n: Int) -> Int {\n  return n == 0 ? 1 : n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0 ? 0 : n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "target": "def F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n"}
{"id": 42594, "name": "Narcissistic decimal number", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42595, "name": "Narcissistic decimal number", "source": "Translate Swift to C#: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "using System;\n\nnamespace Narcissistic\n{\n    class Narcissistic\n    {\n        public bool isNarcissistic(int z)\n        {\n            if (z < 0) return false;\n            string n = z.ToString();\n            int t = 0, l = n.Length;\n            foreach (char c in n)\n                t += Convert.ToInt32(Math.Pow(Convert.ToDouble(c - 48), l));\n\n            return t == z;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Narcissistic n = new Narcissistic();\n            int c = 0, x = 0;\n            while (c < 25)\n            {\n                if (n.isNarcissistic(x))\n                {\n                    if (c % 5 == 0) Console.WriteLine();\n                    Console.Write(\"{0,7} \", x);\n                    c++;\n                }\n                x++;\n            }\n            Console.WriteLine(\"\\n\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 42598, "name": "Narcissistic decimal number", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42599, "name": "Narcissistic decimal number", "source": "Translate Swift to Java: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "public class Narc{\n\tpublic static boolean isNarc(long x){\n\t\tif(x < 0) return false;\n\t\t\n\t\tString xStr = Long.toString(x);\n\t\tint m = xStr.length();\n\t\tlong sum = 0;\n\t\t\n\t\tfor(char c : xStr.toCharArray()){\n\t\t\tsum += Math.pow(Character.digit(c, 10), m);\n\t\t}\n\t\treturn sum == x;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(long x = 0, count = 0; count < 25; x++){\n\t\t\tif(isNarc(x)){\n\t\t\t\tSystem.out.print(x + \" \");\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 42600, "name": "Narcissistic decimal number", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 42601, "name": "Narcissistic decimal number", "source": "Translate Swift to Python: extension BinaryInteger {\n  @inlinable\n  public var isNarcissistic: Bool {\n    let digits = String(self).map({ Int(String($0))! })\n    let m = digits.count\n\n    guard m != 1 else {\n      return true\n    }\n\n    return digits.map({ $0.power(m) }).reduce(0, +) == self\n  }\n\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n\n}\n\nlet narcs = Array((0...).lazy.filter({ $0.isNarcissistic }).prefix(25))\n\nprint(\"First 25 narcissistic numbers are \\(narcs)\")\n", "target": "from __future__ import print_function\nfrom itertools import count, islice\n\ndef narcissists():\n    for digits in count(0):\n        digitpowers = [i**digits for i in range(10)]\n        for n in range(int(10**(digits-1)), 10**digits):\n            div, digitpsum = n, 0\n            while div:\n                div, mod = divmod(div, 10)\n                digitpsum += digitpowers[mod]\n            if n == digitpsum:\n                yield n\n\nfor i, n in enumerate(islice(narcissists(), 25), 1):\n    print(n, end=' ')\n    if i % 5 == 0: print() \nprint()\n"}
{"id": 43281, "name": "First-class functions", "source": "Translate Swift to C#: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var cube = new Func<double, double>(x => Math.Pow(x, 3.0));\n        var croot = new Func<double, double>(x => Math.Pow(x, 1 / 3.0));\n\n        var functionTuples = new[]\n        {\n            (forward: Math.Sin, backward: Math.Asin),\n            (forward: Math.Cos, backward: Math.Acos),\n            (forward: cube,     backward: croot)\n        };\n\n        foreach (var ft in functionTuples)\n        {\n            Console.WriteLine(ft.backward(ft.forward(0.5)));\n        }\n    }\n}\n"}
{"id": 43283, "name": "First-class functions", "source": "Translate Swift to Java: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": "import java.util.ArrayList;\n\npublic class FirstClass{\n\t\n\tpublic interface Function<A,B>{\n\t\tB apply(A x);\n\t}\n\t\n\tpublic static <A,B,C> Function<A, C> compose(\n\t\t\tfinal Function<B, C> f, final Function<A, B> g) {\n\t\treturn new Function<A, C>() {\n\t\t\t@Override public C apply(A x) {\n\t\t\t\treturn f.apply(g.apply(x));\n\t\t\t}\n\t\t};\n\t}\n\t \n\tpublic static void main(String[] args){\n\t\tArrayList<Function<Double, Double>> functions =\n\t\t\tnew ArrayList<Function<Double,Double>>();\n\t\t\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.cos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.tan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tfunctions.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn x * x;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\n\t\tArrayList<Function<Double, Double>> inverse = new ArrayList<Function<Double,Double>>();\n\t\t\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.acos(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.atan(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tinverse.add(\n\t\t\t\tnew Function<Double, Double>(){\n\t\t\t\t\t@Override public Double apply(Double x){\n\t\t\t\t\t\treturn Math.sqrt(x);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tSystem.out.println(\"Compositions:\");\n\t\tfor(int i = 0; i < functions.size(); i++){\n\t\t\tSystem.out.println(compose(functions.get(i), inverse.get(i)).apply(0.5));\n\t\t}\n\t\tSystem.out.println(\"Hard-coded compositions:\");\n\t\tSystem.out.println(Math.cos(Math.acos(0.5)));\n\t\tSystem.out.println(Math.tan(Math.atan(0.5)));\n\t\tSystem.out.println(Math.pow(Math.sqrt(0.5), 2));\n\t}\n}\n"}
{"id": 43284, "name": "First-class functions", "source": "Translate Swift to Python: import Darwin\nfunc compose<A,B,C>(f: (B) -> C, g: (A) -> B) -> (A) -> C {\n  return { f(g($0)) }\n}\nlet funclist = [ { (x: Double) in sin(x) }, { (x: Double) in cos(x) }, { (x: Double) in pow(x, 3) } ]\nlet funclisti = [ { (x: Double) in asin(x) }, { (x: Double) in acos(x) }, { (x: Double) in cbrt(x) } ]\nprintln(map(zip(funclist, funclisti)) { f, inversef in compose(f, inversef)(0.5) })\n", "target": ">>> \n>>> from math import sin, cos, acos, asin\n>>> \n>>> cube = lambda x: x * x * x\n>>> croot = lambda x: x ** (1/3.0)\n>>> \n>>> \n>>> compose = lambda f1, f2: ( lambda x: f1(f2(x)) )\n>>> \n>>> funclist = [sin, cos, cube]\n>>> funclisti = [asin, acos, croot]\n>>> \n>>> [compose(inversef, f)(.5) for f, inversef in zip(funclist, funclisti)]\n[0.5, 0.4999999999999999, 0.5]\n>>>\n"}
{"id": 43606, "name": "Test a function", "source": "Translate Swift to C#: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing PalindromeDetector.ConsoleApp;\n\nnamespace PalindromeDetector.VisualStudioTests\n{\n    [TestClass]\n    public class VSTests\n    {\n        [TestMethod]\n        public void PalindromeDetectorCanUnderstandPalindrome()\n        {\n            \n            bool expected = true;\n            bool actual;\n            actual = Program.IsPalindrome(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"1\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindrome(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ingirumimusnocteetconsumimurigni\");\n            Assert.AreEqual(expected, actual);\n        }\n        [TestMethod]\n        public void PalindromeDetecotryCanUnderstandNonPalindrome()\n        {\n            bool notExpected = true;\n            bool actual = Program.IsPalindrome(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n            actual = Program.IsPalindromeNonRecursive(\"ThisIsNotAPalindrome\");\n            Assert.AreNotEqual(notExpected, actual);\n        }\n    }\n}\n"}
{"id": 43608, "name": "Test a function", "source": "Translate Swift to Java: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "import static ExampleClass.pali; \nimport static ExampleClass.rPali; \nimport org.junit.*;\npublic class PalindromeTest extends junit.framework.TestCase {\n    @Before\n    public void setUp(){\n        \n        \n    }\n    @After\n    public void tearDown(){\n        \n        \n    }\n\n    \n    @Test\n    public void testNonrecursivePali() throws Exception {\n        assertTrue(pali(\"abcba\"));\n        assertTrue(pali(\"aa\"));\n        assertTrue(pali(\"a\"));\n        assertTrue(pali(\"\"));\n        assertFalse(pali(\"ab\"));\n        assertFalse(pali(\"abcdba\"));\n    }\n    \n    @Test\n    public void testRecursivePali() throws Exception {\n        assertTrue(rPali(\"abcba\"));\n        assertTrue(rPali(\"aa\"));\n        assertTrue(rPali(\"a\"));\n        assertTrue(rPali(\"\"));\n        assertFalse(rPali(\"ab\"));\n        assertFalse(rPali(\"abcdba\"));\n    }\n\n    \n    @Test(expected=WhateverException.class)\n    public void except(){\n        \n    }\n}\n"}
{"id": 43609, "name": "Test a function", "source": "Translate Swift to Python: import Cocoa\nimport XCTest\n\nclass PalindromTests: XCTestCase {\n    \n    override func setUp() {\n        super.setUp()\n        \n    }\n    \n    override func tearDown() {\n        super.tearDown()\n    }\n    \n    func testPalindrome() {\n        \n        XCTAssert(isPalindrome(\"abcba\"), \"Pass\")\n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"a\"), \"Pass\")\n        XCTAssert(isPalindrome(\"\"), \"Pass\")\n        XCTAssert(isPalindrome(\"ab\"), \"Pass\") \n        XCTAssert(isPalindrome(\"aa\"), \"Pass\")\n        XCTAssert(isPalindrome(\"abcdba\"), \"Pass\") \n    }\n    \n    func testPalindromePerformance() {\n        \n        self.measureBlock() {\n            var _is = isPalindrome(\"abcba\")\n        }\n    }\n}\n", "target": "def is_palindrome(s):\n    \n    return s == s[::-1]\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    \n\nif __name__ == \"__main__\":\n    _test()\n"}
{"id": 43993, "name": "Determine if a string is numeric", "source": "Translate Swift to C#: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43995, "name": "Determine if a string is numeric", "source": "Translate Swift to Java: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43996, "name": "Determine if a string is numeric", "source": "Translate Swift to Python: func isNumeric(a: String) -> Bool {\n  return Double(a) != nil\n}\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44562, "name": "Determine if a string is collapsible", "source": "Translate Swift to C#: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44563, "name": "Determine if a string is collapsible", "source": "Translate Swift to C#: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        string[] input = {\n            \"\",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                    --- Harry S Truman  \"\n        };\n        foreach (string s in input) {\n            Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n            string c = Collapse(s);\n            Console.WriteLine($\"new: {c.Length} \u00ab\u00ab\u00ab{c}\u00bb\u00bb\u00bb\");\n        }\n    }\n\n    static string Collapse(string s) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 44566, "name": "Determine if a string is collapsible", "source": "Translate Swift to Java: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44567, "name": "Determine if a string is collapsible", "source": "Translate Swift to Java: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 44568, "name": "Determine if a string is collapsible", "source": "Translate Swift to Python: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44569, "name": "Determine if a string is collapsible", "source": "Translate Swift to Python: let strings = [\n\t\"\",\n\t#\"\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln \"#,\n\t\"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n\t\"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n\t\"                                                   ---  Harry S Truman  \",\n\t\"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n\t\"headmistressship\",\n\t\"aardvark\",\n\t\"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\"\n]\n\nlet collapsedStrings = strings.map { $0.replacingOccurrences( of: #\"(.)\\1*\"#, with: \"$1\", options: .regularExpression)}\n\nfor (original, collapsed) in zip(strings, collapsedStrings) {\n\tprint (String(format: \"%03d \u00ab%@\u00bb\\n%03d \u00ab%@\u00bb\\n\", original.count, original, collapsed.count, collapsed))\n}\n", "target": "from itertools import groupby\n\ndef collapser(txt):\n    return ''.join(item for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    for txt in strings:\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        this = \"Collapsed\"\n        sqz = collapser(txt)\n        print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 44774, "name": "Inheritance_Multiple", "source": "Translate Swift to C#: protocol Camera {\n    \n}\n\nprotocol Phone {\n    \n}\n\nclass CameraPhone: Camera, Phone {\n    \n}\n", "target": "interface ICamera {\n    \n}\n\nclass MobilePhone {\n    \n}\n\nclass CameraPhone: ICamera, MobilePhone {\n    \n}\n"}
{"id": 44776, "name": "Inheritance_Multiple", "source": "Translate Swift to Java: protocol Camera {\n    \n}\n\nprotocol Phone {\n    \n}\n\nclass CameraPhone: Camera, Phone {\n    \n}\n", "target": "public interface Camera{\n   \n   \n   \n}\n"}
{"id": 45133, "name": "Zero to the zero power", "source": "Translate Swift to C#: import Darwin\nprint(pow(0.0,0.0))\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45134, "name": "Zero to the zero power", "source": "Translate Swift to C#: import Darwin\nprint(pow(0.0,0.0))\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 45137, "name": "Zero to the zero power", "source": "Translate Swift to Python: import Darwin\nprint(pow(0.0,0.0))\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45138, "name": "Zero to the zero power", "source": "Translate Swift to Python: import Darwin\nprint(pow(0.0,0.0))\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45497, "name": "Runge-Kutta method", "source": "Translate Swift to C#: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45498, "name": "Runge-Kutta method", "source": "Translate Swift to C#: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45501, "name": "Runge-Kutta method", "source": "Translate Swift to Java: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45502, "name": "Runge-Kutta method", "source": "Translate Swift to Java: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45503, "name": "Runge-Kutta method", "source": "Translate Swift to Python: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45504, "name": "Runge-Kutta method", "source": "Translate Swift to Python: import Foundation\n\nfunc rk4(dx: Double, x: Double, y: Double, f: (Double, Double) -> Double) -> Double {\n    let k1 = dx * f(x, y)\n    let k2 = dx * f(x + dx / 2, y + k1 / 2)\n    let k3 = dx * f(x + dx / 2, y + k2 / 2)\n    let k4 = dx * f(x + dx, y + k3)\n\n    return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6\n}\n\nvar y = [Double]()\nvar x: Double = 0.0\nvar y2: Double = 0.0\n\nvar x0: Double = 0.0\nvar x1: Double = 10.0\nvar dx: Double = 0.1\n\nvar i = 0\nvar n = Int(1 + (x1 - x0) / dx)\n\ny.append(1)\nfor i in 1..<n {\n    y.append(rk4(dx, x: x0 + dx * (Double(i) - 1), y: y[i - 1]) { (x: Double, y: Double) -> Double in\n        return x * sqrt(y)\n    })\n}\n\nprint(\" x         y        rel. err.\")\nprint(\"------------------------------\")\n\nfor (var i = 0; i < n; i += 10) {\n    x = x0 + dx * Double(i)\n    y2 = pow(x * x / 4 + 1, 2)\n\n    print(String(format: \"%2g  %11.6g    %11.5g\", x, y[i], y[i]/y2 - 1))\n}\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45754, "name": "Multiplication tables", "source": "Translate Swift to C#: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45756, "name": "Multiplication tables", "source": "Translate Swift to Java: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45757, "name": "Multiplication tables", "source": "Translate Swift to Python: import Foundation\n\nlet size = 12\n \nfunc printRow(with:Int, upto:Int) {\n    \n    print(String(repeating: \" \", count: (with-1)*4), terminator: \"\")\n\n    for i in with...upto {\n            print(String(format: \"%l4d\", i*with), terminator: \"\")\n    }\n    print()\n}\n\nprint(\"    \", terminator: \"\"); printRow( with: 1, upto: size)\nprint( String(repeating: \"\u2013\", count: (size+1)*4 ))\nfor i in 1...size {\n    print(String(format: \"%l4d\",i), terminator:\"\")\n    printRow( with: i, upto: size)\n }\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 46165, "name": "Comma quibbling", "source": "Translate Swift to C#: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46166, "name": "Comma quibbling", "source": "Translate Swift to C#: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 46169, "name": "Comma quibbling", "source": "Translate Swift to Java: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46170, "name": "Comma quibbling", "source": "Translate Swift to Java: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 46171, "name": "Comma quibbling", "source": "Translate Swift to Python: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46172, "name": "Comma quibbling", "source": "Translate Swift to Python: let inputs = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]]\n\nfunc quibbling(var words:[String]) {\n    if words.count == 0 {\n        println(\"{}\")\n    } else if words.count == 1 {\n        println(\"{\\(words[0])}\")\n    } else if words.count == 2 {\n        println(\"{\\(words[0]) and \\(words[1])}\")\n    } else {\n        var output = \"{\"\n        while words.count != 2 {\n            output += words.removeAtIndex(0) + \", \"\n        }\n        output += \"\\(words.removeAtIndex(0)) and \\(words.removeAtIndex(0))}\"\n        \n        println(output)\n    }\n}\n\nfor word in inputs {\n    quibbling(word)\n}\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46659, "name": "Count the coins", "source": "Translate Swift to C#: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46660, "name": "Count the coins", "source": "Translate Swift to C#: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "    \n    class Program\n    {\n        static long Count(int[] C, int m, int n)\n        {\n            var table = new long[n + 1];\n            table[0] = 1;\n            for (int i = 0; i < m; i++)\n                for (int j = C[i]; j <= n; j++)\n                    table[j] += table[j - C[i]];\n            return table[n];\n        }\n        static void Main(string[] args)\n        {\n            var C = new int[] { 1, 5, 10, 25 };\n            int m = C.Length;\n            int n = 100;\n            Console.WriteLine(Count(C, m, n));  \n            Console.ReadLine();\n        }\n    }\n"}
{"id": 46663, "name": "Count the coins", "source": "Translate Swift to Java: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46664, "name": "Count the coins", "source": "Translate Swift to Java: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "import java.util.Arrays;\nimport java.math.BigInteger;\n\nclass CountTheCoins {\n    private static BigInteger countChanges(int amount, int[] coins){\n        final int n = coins.length;\n        int cycle = 0;\n        for (int c : coins)\n            if (c <= amount && c >= cycle)\n                cycle = c + 1;\n        cycle *= n;\n        BigInteger[] table = new BigInteger[cycle];\n        Arrays.fill(table, 0, n, BigInteger.ONE);\n        Arrays.fill(table, n, cycle, BigInteger.ZERO);\n\n        int pos = n;\n        for (int s = 1; s <= amount; s++) {\n            for (int i = 0; i < n; i++) {\n                if (i == 0 && pos >= cycle)\n                    pos = 0;\n                if (coins[i] <= s) {\n                    final int q = pos - (coins[i] * n);\n                    table[pos] = (q >= 0) ? table[q] : table[q + cycle];\n                }\n                if (i != 0)\n                    table[pos] = table[pos].add(table[pos - 1]);\n                pos++;\n            }\n        }\n\n        return table[pos - 1];\n    }\n\n    public static void main(String[] args) {\n        final int[][] coinsUsEu = {{100, 50, 25, 10, 5, 1},\n                                   {200, 100, 50, 20, 10, 5, 2, 1}};\n\n        for (int[] coins : coinsUsEu) {\n            System.out.println(countChanges(     100,\n                Arrays.copyOfRange(coins, 2, coins.length)));\n            System.out.println(countChanges(  100000, coins));\n            System.out.println(countChanges( 1000000, coins));\n            System.out.println(countChanges(10000000, coins) + \"\\n\");\n        }\n    }\n}\n"}
{"id": 46665, "name": "Count the coins", "source": "Translate Swift to Python: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 46666, "name": "Count the coins", "source": "Translate Swift to Python: import BigInt\n\nfunc countCoins(amountCents cents: Int, coins: [Int]) -> BigInt {\n  let cycle = coins.filter({ $0 <= cents }).map({ $0 + 1 }).max()! * coins.count\n  var table = [BigInt](repeating: 0, count: cycle)\n\n  for x in 0..<coins.count {\n    table[x] = 1\n  }\n\n  var pos = coins.count\n\n  for s in 1..<cents+1 {\n    for i in 0..<coins.count {\n      if i == 0 && pos >= cycle {\n        pos = 0\n      }\n\n      if coins[i] <= s {\n        let q = pos - coins[i] * coins.count\n        table[pos] = q >= 0 ? table[q] : table[q + cycle]\n      }\n\n      if i != 0 {\n        table[pos] += table[pos - 1]\n      }\n\n      pos += 1\n    }\n  }\n\n  return table[pos - 1]\n}\n\nlet usCoins = [100, 50, 25, 10, 5, 1]\nlet euCoins = [200, 100, 50, 20, 10, 5, 2, 1]\n\nfor set in [usCoins, euCoins] {\n  print(countCoins(amountCents: 100, coins: Array(set.dropFirst(2))))\n  print(countCoins(amountCents: 100000, coins: set))\n  print(countCoins(amountCents: 1000000, coins: set))\n  print(countCoins(amountCents: 10000000, coins: set))\n  print()\n}\n", "target": "def changes(amount, coins):\n    ways = [0] * (amount + 1)\n    ways[0] = 1\n    for coin in coins:\n        for j in xrange(coin, amount + 1):\n            ways[j] += ways[j - coin]\n    return ways[amount]\n\nprint changes(100, [1, 5, 10, 25])\nprint changes(100000, [1, 5, 10, 25, 50, 100])\n"}
{"id": 47136, "name": "Ackermann function", "source": "Translate Swift to C#: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 47138, "name": "Ackermann function", "source": "Translate Swift to Java: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 47139, "name": "Ackermann function", "source": "Translate Swift to Python: func ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47404, "name": "Enumerations", "source": "Translate Swift to C#: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n"}
{"id": 47406, "name": "Enumerations", "source": "Translate Swift to Java: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": "enum Fruits{\n   APPLE, BANANA, CHERRY\n}\n"}
{"id": 47407, "name": "Enumerations", "source": "Translate Swift to Python: enum Fruit {\n    case Apple\n    case Banana\n    case Cherry\n}\n\nenum Fruit {\n    case Apple, Banana, Cherry\n}\n \nenum Season : Int {\n    case Winter = 1\n    case Spring = 2\n    case Summer = 3\n    case Autumn = 4\n}\n", "target": ">>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n"}
{"id": 47940, "name": "Hello world_Text", "source": "Translate Swift to C#: print(\"Hello world!\")\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47942, "name": "Hello world_Text", "source": "Translate Swift to Java: print(\"Hello world!\")\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 48161, "name": "Hash from two arrays", "source": "Translate Swift to C#: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "static class Program\n{\n    static void Main()\n    {\n        System.Collections.Hashtable h = new System.Collections.Hashtable();\n\n        string[] keys = { \"foo\", \"bar\", \"val\" };\n        string[] values = { \"little\", \"miss\", \"muffet\" };\n\n        System.Diagnostics.Trace.Assert(keys.Length == values.Length, \"Arrays are not same length.\");\n\n        for (int i = 0; i < keys.Length; i++)\n        {\n            h.Add(keys[i], values[i]);\n        }\n    }\n}\n"}
{"id": 48163, "name": "Hash from two arrays", "source": "Translate Swift to Java: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "import java.util.HashMap;\npublic static void main(String[] args){\n\tString[] keys= {\"a\", \"b\", \"c\"};\n\tint[] vals= {1, 2, 3};\n\tHashMap<String, Integer> hash= new HashMap<String, Integer>();\n\n\tfor(int i= 0; i < keys.length; i++){\n\t   hash.put(keys[i], vals[i]);\n\t}\n}\n"}
{"id": 48164, "name": "Hash from two arrays", "source": "Translate Swift to Python: let keys = [\"a\",\"b\",\"c\"]\nlet vals = [1,2,3]\nvar hash = [String: Int]()\nfor (key, val) in zip(keys, vals) {\n  hash[key] = val\n}\n", "target": "keys = ['a', 'b', 'c']\nvalues = [1, 2, 3]\nhash = {key: value for key, value in zip(keys, values)}\n"}
{"id": 49418, "name": "Loops_Continue", "source": "Translate Swift to C#: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49420, "name": "Loops_Continue", "source": "Translate Swift to Java: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49421, "name": "Loops_Continue", "source": "Translate Swift to Python: for i in 1...10 {\n    print(i, terminator: \"\")\n    if i % 5 == 0 {\n        print()\n        continue\n    }\n    print(\", \", terminator: \"\")\n}\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 49704, "name": "Filter", "source": "Translate Swift to C#: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );\nArrayList evens = new ArrayList();\nforeach( int i in array )\n{\n        if( (i%2) == 0 )\n                evens.Add( i );\n}\nforeach( int i in evens )\n       System.Console.WriteLine( i.ToString() );\n"}
{"id": 49706, "name": "Filter", "source": "Translate Swift to Java: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "int[] array = {1, 2, 3, 4, 5 };\nList<Integer> evensList = new ArrayList<Integer>();\nfor (int  i: array) {\n    if (i % 2 == 0) evensList.add(i);\n}\nint[] evens = evensList.toArray(new int[0]);\n"}
{"id": 49707, "name": "Filter", "source": "Translate Swift to Python: let numbers = [1,2,3,4,5,6]\nlet even_numbers = numbers.filter { $0 % 2 == 0 }\nprintln(even_numbers)\n", "target": "values = range(10)\nevens = [x for x in values if not x & 1]\nievens = (x for x in values if not x & 1) \n\nevens = filter(lambda x: not x & 1, values)\n"}
{"id": 50161, "name": "Sieve of Eratosthenes", "source": "Translate Swift to C#: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50163, "name": "Sieve of Eratosthenes", "source": "Translate Swift to Java: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50164, "name": "Sieve of Eratosthenes", "source": "Translate Swift to Python: import Foundation \n\nlet max = 1_000_000\nlet maxroot = Int(sqrt(Double(max)))\nlet startingPoint = Date()\n\nvar isprime = [Bool](repeating: true, count: max+1 )\nfor i in 2...maxroot {\n    if isprime[i] {\n        for k in stride(from: max/i, through: i, by: -1) {\n            if isprime[k] {\n                isprime[i*k] = false }\n        }\n    }\n}\n\nvar count = 0\nfor i in 2...max {\n    if isprime[i] {\n        count += 1\n    }\n}\nprint(\"\\(count) primes found under \\(max)\")\n\nprint(\"\\(startingPoint.timeIntervalSinceNow * -1) seconds\")\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 50543, "name": "Sort disjoint sublist", "source": "Translate Swift to C#: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n     \npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n     \npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n     \n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n     \n}\n"}
{"id": 50545, "name": "Sort disjoint sublist", "source": "Translate Swift to Java: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Disjoint {\n    public static <T extends Comparable<? super T>> void sortDisjoint(\n            List<T> array, int[] idxs) {\n        Arrays.sort(idxs);\n        List<T> disjoint = new ArrayList<T>();\n        for (int idx : idxs) {\n            disjoint.add(array.get(idx));\n        }\n        Collections.sort(disjoint);\n        int i = 0;\n        for (int idx : idxs) {\n            array.set(idx, disjoint.get(i++));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0);\n        int[] indices = {6, 1, 7};\n        System.out.println(list);\n        sortDisjoint(list, indices);\n        System.out.println(list);\n    }\n}\n"}
{"id": 50546, "name": "Sort disjoint sublist", "source": "Translate Swift to Python: struct DisjointSublistView<T> : MutableCollectionType {\n  let array : UnsafeMutablePointer<T>\n  let indexes : [Int]\n  \n  subscript (position: Int) -> T {\n    get {\n      return array[indexes[position]]\n    }\n    set {\n      array[indexes[position]] = newValue\n    }\n  }\n  var startIndex : Int { return 0 }\n  var endIndex : Int { return indexes.count }\n  func generate() -> IndexingGenerator<DisjointSublistView<T>> { return IndexingGenerator(self) }\n}\n\nfunc sortDisjointSublist<T : Comparable>(inout array: [T], indexes: [Int]) {\n  var d = DisjointSublistView(array: &array, indexes: sorted(indexes))\n  sort(&d)\n}\n\nvar a = [7, 6, 5, 4, 3, 2, 1, 0]\nlet ind = [6, 1, 7]\nsortDisjointSublist(&a, ind)\nprintln(a)\n", "target": ">>> def sort_disjoint_sublist(data, indices):\n\tindices = sorted(indices)\n\tvalues  = sorted(data[i] for i in indices)\n\tfor index, value in zip(indices, values):\n\t\tdata[index] = value\n\n\t\t\n>>> d = [7, 6, 5, 4, 3, 2, 1, 0]\n>>> i = set([6, 1, 7])\n>>> sort_disjoint_sublist(d, i)\n>>> d\n[7, 0, 5, 4, 3, 2, 1, 6]\n>>> \n>>> def sort_disjoint_sublist(data, indices):\n\tfor index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value\n\n\t\n>>>\n"}
{"id": 50691, "name": "Kronecker product", "source": "Translate Swift to C#: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class KroneckerProduct\n{\n    public static void Main() {\n        int[,] left = { {1, 2}, {3, 4} };\n        int[,] right = { {0, 5}, {6, 7} };\n        Print(Multiply(left, right));\n\n        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };\n        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };\n        Print(Multiply(left, right));\n    }\n\n    static int[,] Multiply(int[,] left, int[,] right) {\n        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));\n        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));\n        int[,] result = new int[lRows * rRows, lColumns * rColumns];\n\n        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {\n            Copy(r * rRows, c * rColumns, left[r, c]);\n        }\n        return result;\n        \n        void Copy(int startRow, int startColumn, int multiplier) {\n            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {\n                result[startRow + r, startColumn + c] = right[r, c] * multiplier;\n            }\n        }\n    }\n\n    static void Print(int[,] matrix) {\n        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));\n        int width = matrix.Cast<int>().Select(LengthOf).Max();\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"| \" + string.Join(\" \", Range(0, columns).Select(column => (matrix[row, column] + \"\").PadLeft(width, ' '))) + \" |\");\n        }\n        Console.WriteLine();\n    }\n\n    private static int LengthOf(int i) {\n        if (i < 0) return LengthOf(-i) + 1;\n        int length = 0;\n        while (i > 0) {\n            length++;\n            i /= 10;\n        }\n        return length;\n    }\n\n}\n"}
{"id": 50693, "name": "Kronecker product", "source": "Translate Swift to Java: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "package kronecker;\n\n\npublic class Product {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void print_matrix(final int[][] m) {\n    \n    \n    \n    \n    final String[][] sts = new String[m.length][];\n    int max_length = 0;  \n    for (int im = 0; im < m.length; im++) {\n      sts[im] = new String[m[im].length];\n      for (int jm = 0; jm < m[im].length; jm++) {\n        final String st = String.valueOf(m[im][jm]);\n        if (st.length() > max_length) {\n          max_length = st.length();\n        }\n        sts[im][jm] = st;\n      }\n    }\n\n    \n    \n    \n    final String format = String.format(\"%%%ds\", max_length);\n    for (int im = 0; im < m.length; im++) {\n      System.out.print(\"|\");\n      \n      for (int jm = 0; jm < m[im].length - 1; jm++) {\n        System.out.format(format, m[im][jm]);\n        System.out.print(\" \");\n      }\n      System.out.format(format, m[im][m[im].length - 1]);\n      System.out.println(\"|\");\n    }\n  }\n\n  \n  private static void test(final int[][] a, final int[][] b) {\n    \n    System.out.println(\"Testing Kronecker product\");\n    System.out.println(\"Size of matrix a: \" + a.length + \" by \" + a[0].length);\n    System.out.println(\"Matrix a:\");\n    print_matrix(a);\n    System.out.println(\"Size of matrix b: \" + b.length + \" by \" + b[0].length);\n    System.out.println(\"Matrix b:\");\n    print_matrix(b);\n    System.out.println(\"Calculating matrix c as Kronecker product\");\n    final int[][] c = product(a, b);\n    System.out.println(\"Size of matrix c: \" + c.length + \" by \" + c[0].length);\n    System.out.println(\"Matrix c:\");\n    print_matrix(c);\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] a = new int[2][];  \n    a[0] = new int[]{1, 2};\n    a[1] = new int[]{3, 4};\n    final int[][] b = new int[2][];  \n    b[0] = new int[]{0, 5};\n    b[1] = new int[]{6, 7};\n    \n    test(a, b);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] a = new int[3][];  \n    a[0] = new int[]{0, 1, 0};\n    a[1] = new int[]{1, 1, 1};\n    a[2] = new int[]{0, 1, 0};\n    final int[][] b = new int[3][];  \n    b[0] = new int[]{1, 1, 1, 1};\n    b[1] = new int[]{1, 0, 0, 1};\n    b[2] = new int[]{1, 1, 1, 1};\n    \n    test(a, b);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n  }\n\n}\n"}
{"id": 50694, "name": "Kronecker product", "source": "Translate Swift to Python: func kronecker(m1: [[Int]], m2: [[Int]]) -> [[Int]] {\n  let m = m1.count\n  let n = m1[0].count\n  let p = m2.count\n  let q = m2[0].count\n  let rtn = m * p\n  let ctn = n * q\n\n  var res = Array(repeating: Array(repeating: 0, count: ctn), count: rtn)\n\n  for i in 0..<m {\n    for j in 0..<n {\n      for k in 0..<p {\n        for l in 0..<q {\n          res[p * i + k][q * j + l] = m1[i][j] * m2[k][l]\n        }\n      }\n    }\n  }\n\n  return res\n}\n\nfunc printMatrix<T>(_ matrix: [[T]]) {\n  guard !matrix.isEmpty else {\n    print()\n\n    return\n  }\n\n  let rows = matrix.count\n  let cols = matrix[0].count\n\n  for i in 0..<rows {\n    for j in 0..<cols {\n      print(matrix[i][j], terminator: \" \")\n    }\n\n    print()\n  }\n}\n\n\nfunc printProducts(a: [[Int]], b: [[Int]]) {\n  print(\"Matrix A:\")\n  printMatrix(a)\n  print(\"Matrix B:\")\n  printMatrix(b)\n  print(\"kronecker a b:\")\n  printMatrix(kronecker(m1: a, m2: b))\n  print()\n}\n\nlet a = [\n  [1, 2],\n  [3, 4]\n]\n\nlet b = [\n  [0, 5],\n  [6, 7]\n]\n\nprintProducts(a: a, b: b)\n\nlet a2 = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0]\n]\n\nlet b2 = [\n  [1, 1, 1, 1],\n  [1, 0, 0, 1],\n  [1, 1, 1, 1]\n]\n\nprintProducts(a: a2, b: b2)\n", "target": "\n\n\na1 = [[1, 2], [3, 4]]\nb1 = [[0, 5], [6, 7]]\n\n\na2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nb2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n\ndef kronecker(matrix1, matrix2):\n    final_list = []\n    sub_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        counter = 0\n        check = 0\n        while check < count:\n            for num1 in elem1:\n                for num2 in matrix2[counter]:\n                    sub_list.append(num1 * num2)\n            counter += 1\n            final_list.append(sub_list)\n            sub_list = []\n            check +=1\n            \n    return final_list\n\n\nresult1 = kronecker(a1, b1)\nfor elem in result1:\n    print(elem)\n\nprint(\"\")\n\n\nresult2 = kronecker(a2, b2)\nfor elem in result2:\n    print(elem)\n"}
{"id": 51088, "name": "Split a character string based on change of character", "source": "Translate Swift to C#: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51089, "name": "Split a character string based on change of character", "source": "Translate Swift to C#: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 51092, "name": "Split a character string based on change of character", "source": "Translate Swift to Java: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51093, "name": "Split a character string based on change of character", "source": "Translate Swift to Java: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 51094, "name": "Split a character string based on change of character", "source": "Translate Swift to Python: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51095, "name": "Split a character string based on change of character", "source": "Translate Swift to Python: public extension String {\n  func splitOnChanges() -> [String] {\n    guard !isEmpty else {\n      return []\n    }\n\n    var res = [String]()\n    var workingChar = first!\n    var workingStr = \"\\(workingChar)\"\n\n    for char in dropFirst() {\n      if char != workingChar {\n        res.append(workingStr)\n        workingStr = \"\\(char)\"\n        workingChar = char\n      } else {\n        workingStr += String(char)\n      }\n    }\n\n    res.append(workingStr)\n\n    return res\n  }\n}\n\nprint(\"gHHH5YY++\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51297, "name": "Truncatable primes", "source": "Translate Swift to C#: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "using System;  \nusing System.Collections.Generic;\nclass truncatable_primes\n{\n    static void Main()\n    {\n        uint m = 1000000;\n        Console.Write(\"L \" + L(m) + \" R \" + R(m) + \"  \");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) { L(m); R(m); }\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint L(uint n)\n    {\n        n -= n & 1; n--;\n        for (uint d, d1 = 100; ; n -= 2)\n        {\n            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;\n            if ((d = n % 10) == 3 || d == 7)\n            {\n                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;\n                if (d1 > n && isP(n)) return n; d1 = 100;\n            }\n        }\n    }\n\n    static uint R(uint m)\n    {\n        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;\n        for (int i = 1; i < p.Count; n = 10 * p[i++])\n        {\n            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);\n        }\n        return p[p.Count - 1];\n    }\n\n    static bool isP(uint n)\n    {\n        if (n < 7) return n == 2 || n == 3 || n == 5;\n        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;\n        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)\n            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||\n                n % (d + 06) == 0 || n % (d + 10) == 0 ||\n                n % (d + 12) == 0 || n % (d + 16) == 0 ||\n                n % (d + 22) == 0 || n % (d + 24) == 0) return false;\n        return true;\n    }\n}\n"}
{"id": 51299, "name": "Truncatable primes", "source": "Translate Swift to Java: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "import java.util.BitSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tfinal int MAX = 1000000;\n\n\t\t\n\t\tBitSet primeList = new BitSet(MAX>>1); \n\t\tprimeList.set(0,primeList.size(),true); \n\n\t\tint sqroot = (int) Math.sqrt(MAX); \n\t\tprimeList.clear(0); \n\t\tfor(int num = 3; num <= sqroot; num+=2) \n\t\t{ \n\t\t\tif( primeList.get(num >> 1) ) \n\t\t\t{ \n\t\t\t\tint inc = num << 1;\n\t\t\t\tfor(int factor = num * num; factor < MAX; factor += inc) \n\t\t\t\t{ \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprimeList.clear(factor >> 1); \n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\n\t\t\n\t\tint rightTrunc = -1, leftTrunc = -1;\n\t\tfor(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)\n\t\t{\n\t\t\tif(primeList.get(prime>>1))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(rightTrunc == -1)\n\t\t\t\t{\n\t\t\t\t\tint right = prime;\n\t\t\t\t\twhile(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;\n\t\t\t\t\tif(right == 0) rightTrunc = prime;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(leftTrunc == -1 )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tString left = Integer.toString(prime);\n\t\t\t\t\tif(!left.contains(\"0\"))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile( left.length() > 0 ){\n\t\t\t\t\t\t\tint iLeft = Integer.parseInt(left);\n\t\t\t\t\t\t\tif(!primeList.get( iLeft >> 1)) break;\n\t\t\t\t\t\t\tleft = left.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left.length() == 0) leftTrunc = prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftTrunc != -1 && rightTrunc != -1) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Left  Truncatable\u00a0: \" + leftTrunc);\n\t\tSystem.out.println(\"Right Truncatable\u00a0: \" + rightTrunc);\n\t}\n}\n"}
{"id": 51300, "name": "Truncatable primes", "source": "Translate Swift to Python: func isPrime(_ n: Int) -> Bool {\n    if n < 2 {\n        return false\n    }\n    if n % 2 == 0 {\n        return n == 2\n    }\n    if n % 3 == 0 {\n        return n == 3\n    }\n    var p = 5\n    while p * p <= n {\n        if n % p == 0 {\n            return false\n        }\n        p += 2\n        if n % p == 0 {\n            return false\n        }\n        p += 4\n    }\n    return true\n}\n\nfunc isLeftTruncatable(_ p: Int) -> Bool {\n    var n = 10\n    var q = p\n    while p > n {\n        if !isPrime(p % n) || q == p % n {\n            return false\n        }\n        q = p % n\n        n *= 10\n    }\n    return true\n}\n\nfunc isRightTruncatable(_ p: Int) -> Bool {\n    var q = p / 10\n    while q > 0 {\n        if !isPrime(q) {\n            return false\n        }\n        q /= 10\n    }\n    return true\n}\n\nlet limit = 1000000\nvar largestLeft = 0\nvar largestRight = 0\nvar p = limit\nwhile p >= 2 {\n    if isPrime(p) && isLeftTruncatable(p) {\n        largestLeft = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest left truncatable prime is \\(largestLeft)\")\np = limit\nwhile p >= 2 {\n    if isPrime(p) && isRightTruncatable(p) {\n        largestRight = p\n        break\n    }\n    p -= 1\n}\nprint(\"Largest right truncatable prime is \\(largestRight)\")\n", "target": "maxprime = 1000000\n\ndef primes(n):\n    multiples = set()\n    prime = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            prime.append(i)\n            multiples.update(set(range(i*i, n+1, i)))\n    return prime\n\ndef truncatableprime(n):\n    'Return a longest left and right truncatable primes below n'\n    primelist = [str(x) for x in primes(n)[::-1]]\n    primeset = set(primelist)\n    for n in primelist:\n        \n        alltruncs = set(n[i:] for i in range(len(n)))\n        if alltruncs.issubset(primeset):\n            truncateleft = int(n)\n            break\n    for n in primelist:\n        \n        alltruncs = set([n[:i+1] for i in range(len(n))])\n        if alltruncs.issubset(primeset):\n            truncateright = int(n)\n            break\n    return truncateleft, truncateright\n\nprint(truncatableprime(maxprime))\n"}
{"id": 51414, "name": "Singleton", "source": "Translate Swift to C#: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": "public sealed class Singleton1 \n{\n    private static Singleton1 instance;\n    private static readonly object lockObj = new object();\n    \n    public static Singleton1 Instance {\n        get {\n            lock(lockObj) {\n                if (instance == null) {\n                    instance = new Singleton1();\n                }\n            }\n            return instance;\n        }\n    }\n}\n"}
{"id": 51416, "name": "Singleton", "source": "Translate Swift to Java: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": "class Singleton\n{\n    private static Singleton myInstance;\n    public static Singleton getInstance()\n    {\n        if (myInstance == null)\n        {\n            synchronized(Singleton.class)\n            {\n                if (myInstance == null)\n                {\n                    myInstance = new Singleton();\n                }\n            }\n        }\n\n        return myInstance;\n    }\n\n    protected Singleton()\n    {\n        \n    }\n\n    \n}\n"}
{"id": 51417, "name": "Singleton", "source": "Translate Swift to Python: class SingletonClass {\n\nstatic let sharedInstance = SingletonClass()\n\n    \n    private override init(){\n    \n    }\n}\n\nlet sharedObject = SingletonClass.sharedInstance\n", "target": ">>> class Borg(object):\n\t__state = {}\n\tdef __init__(self):\n\t\tself.__dict__ = self.__state\n\t\n\n\t\n>>> b1 = Borg()\n>>> b2 = Borg()\n>>> b1 is b2\nFalse\n>>> b1.datum = range(5)\n>>> b1.datum\n[0, 1, 2, 3, 4]\n>>> b2.datum\n[0, 1, 2, 3, 4]\n>>> b1.datum is b2.datum\nTrue\n>>> \n"}
{"id": 51739, "name": "Nested function", "source": "Translate Swift to C#: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51740, "name": "Nested function", "source": "Translate Swift to C#: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51743, "name": "Nested function", "source": "Translate Swift to Java: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51744, "name": "Nested function", "source": "Translate Swift to Java: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51745, "name": "Nested function", "source": "Translate Swift to Python: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51746, "name": "Nested function", "source": "Translate Swift to Python: func makeList(_ separator: String) -> String {\n  var counter = 1\n  \n  func makeItem(_ item: String) -> String {\n    let result = String(counter) + separator + item + \"\\n\"\n    counter += 1\n    return result\n  }\n  \n  return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n}\n\nprint(makeList(\". \"))\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 52007, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to C#: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "namespace RosettaCode {\n  using System;\n\n  public class MergeSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    public const Int32 MERGES_DEFAULT = 6;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    protected UInt32[] Positions { get; set; }\n\n    private Int32 merges;\n    public Int32 Merges {\n      get { return merges; }\n      set {\n        \n        if (value > 1)\n          merges = value;\n        else\n          throw new ArgumentOutOfRangeException($\"value = {value} must be greater than one\", nameof(Merges));\n\n        if (Positions == null || Positions.Length != merges)\n          Positions = new UInt32[merges];\n      }\n    }\n    #endregion\n\n    #region Constructors\n    public MergeSort(UInt32 insertionLimit, Int32 merges) {\n      InsertionLimit = insertionLimit;\n      Merges = merges;\n    }\n\n    public MergeSort()\n      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      \n      var entries2 = new T[entries.Length];\n      Sort(entries, entries2, 0, entries.Length - 1);\n    }\n\n    \n    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      if (length < 2) return;      \n      if (length < Merges || length < InsertionLimit) {\n        InsertionSort<T>.Sort(entries1, first, last);\n        return;\n      }\n\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size) {\n        var right = left + Math.Min(remaining, size) - 1;\n        Sort(entries1, entries2, left, right);\n      }\n\n      Merge(entries1, entries2, first, last);\n      Array.Copy(entries2, first, entries1, first, length);\n    }\n    #endregion\n\n    #region Merge Methods\n    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      Array.Clear(Positions, 0, Merges);\n      \n      for (var index = first; index <= last; index++)\n        entries2[index] = remove(entries1, first, last);\n    }\n\n    private T remove(T[] entries, Int32 first, Int32 last) {\n      T entry = default;\n      Int32? found = default;\n      var length = last + 1 - first;\n\n      var index = 0;\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {\n        var position = Positions[index];\n        if (position < Math.Min(remaining, size)) {\n          var next = entries[left + position];\n          if (!found.HasValue || entry.CompareTo(next) > 0) {\n            found = index;\n            entry = next;\n          }\n        }\n      }\n\n      \n      Positions[found.Value]++;\n      return entry;\n    }\n    #endregion\n\n    #region Math Methods\n    private static Int32 ceiling(Int32 numerator, Int32 denominator) {\n      return (numerator + denominator - 1) / denominator;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 52009, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to Java: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 52010, "name": "Sorting algorithms_Merge sort", "source": "Translate Swift to Python: \n\n\n\n\nimport Foundation\n\nfunc mergeSort(_ array: [Int]) -> [Int] {\n  guard array.count > 1 else { return array }\n\n  let middleIndex = array.count / 2\n\n  let leftPart = mergeSort(Array(array[0..<middleIndex]))\n  let rightPart = mergeSort(Array(array[middleIndex..<array.count]))\n\n  func merge(left: [Int], right: [Int]) -> [Int] {\n    var leftIndex = 0\n    var rightIndex = 0\n  \n    var merged = [Int]()\n    merged.reserveCapacity(left.count + right.count)\n  \n    while leftIndex < left.count && rightIndex < right.count {\n      if left[leftIndex] < right[rightIndex] {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n      } else if left[leftIndex] > right[rightIndex] {\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      } else {\n        merged.append(left[leftIndex])\n        leftIndex += 1\n        merged.append(right[rightIndex])\n        rightIndex += 1\n      }\n    }\n  \n    while leftIndex < left.count {\n      merged.append(left[leftIndex])\n      leftIndex += 1\n    }\n  \n    while rightIndex < right.count {\n      merged.append(right[rightIndex])\n      rightIndex += 1\n    }\n  \n    return merged\n  }\n\n  return merge(left: leftPart, right: rightPart)\n}\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52727, "name": "Word frequency", "source": "Translate Swift to C#: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52728, "name": "Word frequency", "source": "Translate Swift to C#: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace WordCount {\n    class Program {\n        static void Main(string[] args) {\n            var text = File.ReadAllText(\"135-0.txt\").ToLower();\n\n            var match = Regex.Match(text, \"\\\\w+\");\n            Dictionary<string, int> freq = new Dictionary<string, int>();\n            while (match.Success) {\n                string word = match.Value;\n                if (freq.ContainsKey(word)) {\n                    freq[word]++;\n                } else {\n                    freq.Add(word, 1);\n                }\n\n                match = match.NextMatch();\n            }\n\n            Console.WriteLine(\"Rank  Word  Frequency\");\n            Console.WriteLine(\"====  ====  =========\");\n            int rank = 1;\n            foreach (var elem in freq.OrderByDescending(a => a.Value).Take(10)) {\n                Console.WriteLine(\"{0,2}    {1,-4}    {2,5}\", rank++, elem.Key, elem.Value);\n            }\n        }\n    }\n}\n"}
{"id": 52731, "name": "Word frequency", "source": "Translate Swift to Java: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52732, "name": "Word frequency", "source": "Translate Swift to Java: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class WordCount {\n    public static void main(String[] args) throws IOException {\n        Path path = Paths.get(\"135-0.txt\");\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes);\n        text = text.toLowerCase();\n\n        Pattern r = Pattern.compile(\"\\\\p{javaLowerCase}+\");\n        Matcher matcher = r.matcher(text);\n        Map<String, Integer> freq = new HashMap<>();\n        while (matcher.find()) {\n            String word = matcher.group();\n            Integer current = freq.getOrDefault(word, 0);\n            freq.put(word, current + 1);\n        }\n\n        List<Map.Entry<String, Integer>> entries = freq.entrySet()\n            .stream()\n            .sorted((i1, i2) -> Integer.compare(i2.getValue(), i1.getValue()))\n            .limit(10)\n            .collect(Collectors.toList());\n\n        System.out.println(\"Rank  Word  Frequency\");\n        System.out.println(\"====  ====  =========\");\n        int rank = 1;\n        for (Map.Entry<String, Integer> entry : entries) {\n            String word = entry.getKey();\n            Integer count = entry.getValue();\n            System.out.printf(\"%2d   \u00a0%-4s    %5d\\n\", rank++, word, count);\n        }\n    }\n}\n"}
{"id": 52733, "name": "Word frequency", "source": "Translate Swift to Python: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 52734, "name": "Word frequency", "source": "Translate Swift to Python: import Foundation\n\nfunc printTopWords(path: String, count: Int) throws {\n    \n    let text = try String(contentsOfFile: path, encoding: String.Encoding.utf8)\n    var dict = Dictionary<String, Int>()\n    \n    let regex = try NSRegularExpression(pattern: \"\\\\w+\")\n    regex.enumerateMatches(in: text, range: NSRange(text.startIndex..., in: text)) {\n        (match, _, _) in\n        guard let match = match else { return }\n        let word = String(text[Range(match.range, in: text)!]).lowercased()\n        dict[word, default: 0] += 1\n    }\n    \n    let wordCounts = dict.sorted(by: {$0.1 > $1.1})\n    \n    print(\"Rank\\tWord\\tCount\")\n    for (i, (word, n)) in wordCounts.prefix(count).enumerated() {\n        print(\"\\(i + 1)\\t\\(word)\\t\\(n)\")\n    }\n}\n\ndo {\n    try printTopWords(path: \"135-0.txt\", count: 10)\n} catch {\n    print(error.localizedDescription)\n}\n", "target": "import collections\nimport re\nimport string\nimport sys\n\ndef main():\n  counter = collections.Counter(re.findall(r\"\\w+\",open(sys.argv[1]).read().lower()))\n  print counter.most_common(int(sys.argv[2]))\n\nif __name__ == \"__main__\":\n  main()\n"}
{"id": 53242, "name": "Tic-tac-toe", "source": "Translate Swift to C#: import Darwin\n\nenum Token : CustomStringConvertible {\n\tcase cross, circle\n\t\n\tfunc matches(tokens: [Token?]) -> Bool {\n\t\tfor token in tokens {\n\t\t\tguard let t = token, t == self else { \n\t\t\t\treturn false \n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\t\n\tfunc emptyCell(in tokens: [Token?]) -> Int? {\n\t\tif tokens[0] == nil \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == self {\n\t\t\treturn 0\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == nil \n\t\t&& tokens[2] == self {\n\t\t\treturn 1\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == nil {\n\t\t\treturn 2\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tvar description: String {\n\t\tswitch self {\n\t\t\tcase .cross: return \"x\" \n\t\t\tcase .circle: return \"o\"\n\t\t}\n\t}\n}\n\nstruct Board {\n\tvar cells: [Token?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil]\n\t\n\tfunc cells(atCol col: Int) -> [Token?] {\n\t\treturn [cells[col], cells[col + 3], cells[col + 6]]\n\t}\n\t\n\tfunc cells(atRow row: Int) -> [Token?] {\n\t\treturn [cells[row * 3], cells[row * 3 + 1], cells[row * 3 + 2]]\n\t}\n\t\n\tfunc cellsTopLeft() -> [Token?] {\n\t\treturn [cells[0], cells[4], cells[8]]\n\t}\n\t\n\tfunc cellsBottomLeft() -> [Token?] {\n\t\treturn [cells[6], cells[4], cells[2]]\n\t}\n\t\n\tfunc winner() -> Token? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif Token.cross.matches(tokens: r0)\n\t\t|| Token.cross.matches(tokens: r1)\n\t\t|| Token.cross.matches(tokens: r2)\n\t\t|| Token.cross.matches(tokens: c0)\n\t\t|| Token.cross.matches(tokens: c1)\n\t\t|| Token.cross.matches(tokens: c2)\n\t\t|| Token.cross.matches(tokens: tl)\n\t\t|| Token.cross.matches(tokens: bl) {\n\t\t\treturn .cross\n\t\t} else \n\t\tif Token.circle.matches(tokens: r0)\n\t\t|| Token.circle.matches(tokens: r1)\n\t\t|| Token.circle.matches(tokens: r2)\n\t\t|| Token.circle.matches(tokens: c0)\n\t\t|| Token.circle.matches(tokens: c1)\n\t\t|| Token.circle.matches(tokens: c2)\n\t\t|| Token.circle.matches(tokens: tl)\n\t\t|| Token.circle.matches(tokens: bl) {\n\t\t\treturn .circle\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc atCapacity() -> Bool {\n\t\treturn cells.filter { $0 == nil }.count == 0\n\t}\n\t\n\tmutating func play(token: Token, at location: Int) {\n\t\tcells[location] = token\n\t}\n\t\n\tfunc findBestLocation(for player: Token) -> Int? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif let cell = player.emptyCell(in: r0) {\n\t\t\treturn cell\n\t\t} else if let cell = player.emptyCell(in: r1) {\n\t\t\treturn cell + 3\n\t\t} else if let cell = player.emptyCell(in: r2) {\n\t\t\treturn cell + 6\n\t\t} else if let cell = player.emptyCell(in: c0) {\n\t\t\treturn cell * 3\n\t\t} else if let cell = player.emptyCell(in: c1) {\n\t\t\treturn cell * 3 + 1\n\t\t} else if let cell = player.emptyCell(in: c2) {\n\t\t\treturn cell * 3 + 2\n\t\t} else if let cell = player.emptyCell(in: tl) {\n\t\t\treturn cell == 0 ? 0 : (cell == 1 ? 4 : 8)\n\t\t} else if let cell = player.emptyCell(in: bl) {\n\t\t\treturn cell == 0 ? 6 : (cell == 1 ? 4 : 2)\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc findMove() -> Int {\n\t\tlet empties = cells.enumerated().filter { $0.1 == nil }\n\t\tlet r = Int(arc4random()) % empties.count\n\t\treturn empties[r].0\n\t}\n}\n\nextension Board : CustomStringConvertible {\n\tvar description: String {\n\t\tvar result = \"\\n---------------\\n\"\n\t\tfor (idx, cell) in cells.enumerated() {\n\t\t\tif let cell = cell {\n\t\t\t\tresult += \"| \\(cell) |\"\n\t\t\t} else {\n\t\t\t\tresult += \"| \\(idx) |\"\n\t\t\t}\n\t\t\t\n\t\t\tif (idx + 1) % 3 == 0 {\n\t\t\t\tresult += \"\\n---------------\\n\"\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\nwhile true {\n\tvar board = Board()\n\tprint(\"Who do you want to play as ('o' or 'x'): \", separator: \"\", terminator: \"\")\n\tlet answer = readLine()?.characters.first ?? \"x\"\n\t\n\tvar player: Token = answer == \"x\" ? .cross : .circle\n\tvar pc: Token = player == .cross ? .circle : .cross\n\t\n\tprint(board)\n\t\n\twhile true {\n\t\tprint(\"Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\tvar pos = Int(readLine() ?? \"0\") ?? 0\n\t\twhile !board.atCapacity() && board.cells[pos] != nil {\n\t\t\tprint(\"Invalid move. Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\t\tpos = Int(readLine() ?? \"0\") ?? 0\n\t\t}\n\t\t\n\t\tif board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tboard.play(token: player, at: pos)\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t} else if board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tif let win = board.findBestLocation(for: pc) {\n\t\t\tboard.play(token: pc, at: win)\n\t\t} else if let def = board.findBestLocation(for: player) {\n\t\t\tboard.play(token: pc, at: def)\n\t\t} else {\n\t\t\tboard.play(token: pc, at: board.findMove())\n\t\t}\n\t\t\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    \n    static string[][] Players = new string[][] { \n      new string[] { \"COMPUTER\", \"X\" }, \n      new string[] { \"HUMAN\", \"O\" }     \n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    \n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] { \n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, \n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, \n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    \n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  \n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    \n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        \n        \n        int selectedMove = getSemiRandomMove(player);\n        \n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  \n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  \n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  \n      {\n        if (GameBoard[i] == Unplayed && x < 0)    \n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    \n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    \n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    \n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  \n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"id": 53244, "name": "Tic-tac-toe", "source": "Translate Swift to Python: import Darwin\n\nenum Token : CustomStringConvertible {\n\tcase cross, circle\n\t\n\tfunc matches(tokens: [Token?]) -> Bool {\n\t\tfor token in tokens {\n\t\t\tguard let t = token, t == self else { \n\t\t\t\treturn false \n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\t\n\tfunc emptyCell(in tokens: [Token?]) -> Int? {\n\t\tif tokens[0] == nil \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == self {\n\t\t\treturn 0\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == nil \n\t\t&& tokens[2] == self {\n\t\t\treturn 1\n\t\t} else\n\t\tif tokens[0] == self \n\t\t&& tokens[1] == self \n\t\t&& tokens[2] == nil {\n\t\t\treturn 2\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tvar description: String {\n\t\tswitch self {\n\t\t\tcase .cross: return \"x\" \n\t\t\tcase .circle: return \"o\"\n\t\t}\n\t}\n}\n\nstruct Board {\n\tvar cells: [Token?] = [nil, nil, nil, nil, nil, nil, nil, nil, nil]\n\t\n\tfunc cells(atCol col: Int) -> [Token?] {\n\t\treturn [cells[col], cells[col + 3], cells[col + 6]]\n\t}\n\t\n\tfunc cells(atRow row: Int) -> [Token?] {\n\t\treturn [cells[row * 3], cells[row * 3 + 1], cells[row * 3 + 2]]\n\t}\n\t\n\tfunc cellsTopLeft() -> [Token?] {\n\t\treturn [cells[0], cells[4], cells[8]]\n\t}\n\t\n\tfunc cellsBottomLeft() -> [Token?] {\n\t\treturn [cells[6], cells[4], cells[2]]\n\t}\n\t\n\tfunc winner() -> Token? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif Token.cross.matches(tokens: r0)\n\t\t|| Token.cross.matches(tokens: r1)\n\t\t|| Token.cross.matches(tokens: r2)\n\t\t|| Token.cross.matches(tokens: c0)\n\t\t|| Token.cross.matches(tokens: c1)\n\t\t|| Token.cross.matches(tokens: c2)\n\t\t|| Token.cross.matches(tokens: tl)\n\t\t|| Token.cross.matches(tokens: bl) {\n\t\t\treturn .cross\n\t\t} else \n\t\tif Token.circle.matches(tokens: r0)\n\t\t|| Token.circle.matches(tokens: r1)\n\t\t|| Token.circle.matches(tokens: r2)\n\t\t|| Token.circle.matches(tokens: c0)\n\t\t|| Token.circle.matches(tokens: c1)\n\t\t|| Token.circle.matches(tokens: c2)\n\t\t|| Token.circle.matches(tokens: tl)\n\t\t|| Token.circle.matches(tokens: bl) {\n\t\t\treturn .circle\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc atCapacity() -> Bool {\n\t\treturn cells.filter { $0 == nil }.count == 0\n\t}\n\t\n\tmutating func play(token: Token, at location: Int) {\n\t\tcells[location] = token\n\t}\n\t\n\tfunc findBestLocation(for player: Token) -> Int? {\n\t\tlet r0 = cells(atRow: 0)\n\t\tlet r1 = cells(atRow: 1)\n\t\tlet r2 = cells(atRow: 2)\n\t\tlet c0 = cells(atCol: 0)\n\t\tlet c1 = cells(atCol: 1)\n\t\tlet c2 = cells(atCol: 2)\n\t\tlet tl = cellsTopLeft()\n\t\tlet bl = cellsBottomLeft()\n\t\t\n\t\tif let cell = player.emptyCell(in: r0) {\n\t\t\treturn cell\n\t\t} else if let cell = player.emptyCell(in: r1) {\n\t\t\treturn cell + 3\n\t\t} else if let cell = player.emptyCell(in: r2) {\n\t\t\treturn cell + 6\n\t\t} else if let cell = player.emptyCell(in: c0) {\n\t\t\treturn cell * 3\n\t\t} else if let cell = player.emptyCell(in: c1) {\n\t\t\treturn cell * 3 + 1\n\t\t} else if let cell = player.emptyCell(in: c2) {\n\t\t\treturn cell * 3 + 2\n\t\t} else if let cell = player.emptyCell(in: tl) {\n\t\t\treturn cell == 0 ? 0 : (cell == 1 ? 4 : 8)\n\t\t} else if let cell = player.emptyCell(in: bl) {\n\t\t\treturn cell == 0 ? 6 : (cell == 1 ? 4 : 2)\n\t\t}\n\t\treturn nil\n\t}\n\t\n\tfunc findMove() -> Int {\n\t\tlet empties = cells.enumerated().filter { $0.1 == nil }\n\t\tlet r = Int(arc4random()) % empties.count\n\t\treturn empties[r].0\n\t}\n}\n\nextension Board : CustomStringConvertible {\n\tvar description: String {\n\t\tvar result = \"\\n---------------\\n\"\n\t\tfor (idx, cell) in cells.enumerated() {\n\t\t\tif let cell = cell {\n\t\t\t\tresult += \"| \\(cell) |\"\n\t\t\t} else {\n\t\t\t\tresult += \"| \\(idx) |\"\n\t\t\t}\n\t\t\t\n\t\t\tif (idx + 1) % 3 == 0 {\n\t\t\t\tresult += \"\\n---------------\\n\"\n\t\t\t}\n\t\t}\n\t\treturn result\n\t}\n}\n\nwhile true {\n\tvar board = Board()\n\tprint(\"Who do you want to play as ('o' or 'x'): \", separator: \"\", terminator: \"\")\n\tlet answer = readLine()?.characters.first ?? \"x\"\n\t\n\tvar player: Token = answer == \"x\" ? .cross : .circle\n\tvar pc: Token = player == .cross ? .circle : .cross\n\t\n\tprint(board)\n\t\n\twhile true {\n\t\tprint(\"Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\tvar pos = Int(readLine() ?? \"0\") ?? 0\n\t\twhile !board.atCapacity() && board.cells[pos] != nil {\n\t\t\tprint(\"Invalid move. Choose cell to play on: \", separator: \"\", terminator: \"\")\n\t\t\tpos = Int(readLine() ?? \"0\") ?? 0\n\t\t}\n\t\t\n\t\tif board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tboard.play(token: player, at: pos)\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t} else if board.atCapacity() {\n\t\t\tprint(\"Draw\")\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tif let win = board.findBestLocation(for: pc) {\n\t\t\tboard.play(token: pc, at: win)\n\t\t} else if let def = board.findBestLocation(for: player) {\n\t\t\tboard.play(token: pc, at: def)\n\t\t} else {\n\t\t\tboard.play(token: pc, at: board.findMove())\n\t\t}\n\t\t\n\t\tprint(board)\n\t\t\n\t\tif let winner = board.winner() {\n\t\t\tprint(\"winner is \\(winner)\")\n\t\t\tbreak\n\t\t}\n\t}\n}\n", "target": "\n\nimport random\n\nboard = list('123456789')\nwins = ((0,1,2), (3,4,5), (6,7,8),\n        (0,3,6), (1,4,7), (2,5,8),\n        (0,4,8), (2,4,6))\n\ndef printboard():\n    print('\\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))\n\ndef score():\n    for w in wins:\n        b = board[w[0]]\n        if b in 'XO' and all (board[i] == b for i in w):\n            return b, [i+1 for i in w]\n    return None, None\n\ndef finished():\n    return all (b in 'XO' for b in board)\n\ndef space():\n    return [ b for b in board if b not in 'XO']\n\ndef my_turn(xo):\n    options = space()\n    choice = random.choice(options)\n    board[int(choice)-1] = xo\n    return choice\n\ndef your_turn(xo):\n    options = space()\n    while True:\n        choice = input(\" Put your %s in any of these positions: %s \"\n                       % (xo, ''.join(options))).strip()\n        if choice in options:\n            break\n        print( \"Whoops I don't understand the input\" )\n    board[int(choice)-1] = xo\n    return choice\n\ndef me(xo='X'):\n    printboard()\n    print('I go at', my_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\ndef you(xo='O'):\n    printboard()\n    \n    print('You went at', your_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\n\nprint(__doc__)\nwhile not finished():\n    s = me('X')\n    if s[0]:\n        printboard()\n        print(\"\\n%s wins across %s\" % s)\n        break\n    if not finished():\n        s = you('O')\n        if s[0]:\n            printboard()\n            print(\"\\n%s wins across %s\" % s)\n            break\nelse:\n    print('\\nA draw')\n"}
{"id": 53500, "name": "Pick random element", "source": "Translate Swift to C#: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53502, "name": "Pick random element", "source": "Translate Swift to Java: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53503, "name": "Pick random element", "source": "Translate Swift to Python: import Darwin\n\nlet myList = [1, 2, 4, 5, 62, 234, 1, -1]\nprint(myList[Int(arc4random_uniform(UInt32(myList.count)))])\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 53756, "name": "Jensen's Device", "source": "Translate Swift to C#: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "using System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"id": 53758, "name": "Jensen's Device", "source": "Translate Swift to Java: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "import java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n"}
{"id": 53759, "name": "Jensen's Device", "source": "Translate Swift to Python: var i = 42 \n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n", "target": "class Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    \n    temp = 0\n    i.value = lo\n    while i.value <= hi:  \n        temp += term() \n        i.value += 1   \n    return temp\n\ni = Ref()\n\n\n\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n"}
{"id": 54031, "name": "Greatest element of a list", "source": "Translate Swift to C#: if let x = [4,3,5,9,2,3].maxElement() {\n  print(x) \n}\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 54033, "name": "Greatest element of a list", "source": "Translate Swift to Java: if let x = [4,3,5,9,2,3].maxElement() {\n  print(x) \n}\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 54137, "name": "Safe addition", "source": "Translate Swift to C#: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": "using System;\n\nnamespace SafeAddition {\n    class Program {\n        static float NextUp(float d) {\n            if (d == 0.0) return float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl++;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static float NextDown(float d) {\n            if (d == 0.0) return -float.Epsilon;\n            if (float.IsNaN(d) || float.IsNegativeInfinity(d) || float.IsPositiveInfinity(d)) return d;\n\n            byte[] bytes = BitConverter.GetBytes(d);\n            int dl = BitConverter.ToInt32(bytes, 0);\n            dl--;\n            bytes = BitConverter.GetBytes(dl);\n\n            return BitConverter.ToSingle(bytes, 0);\n        }\n\n        static Tuple<float, float> SafeAdd(float a, float b) {\n            return new Tuple<float, float>(NextDown(a + b), NextUp(a + b));\n        }\n\n        static void Main(string[] args) {\n            float a = 1.20f;\n            float b = 0.03f;\n\n            Console.WriteLine(\"({0} + {1}) is in the range {2}\", a, b, SafeAdd(a, b));\n        }\n    }\n}\n"}
{"id": 54139, "name": "Safe addition", "source": "Translate Swift to Java: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": "public class SafeAddition {\n    private static double stepDown(double d) {\n        return Math.nextAfter(d, Double.NEGATIVE_INFINITY);\n    }\n\n    private static double stepUp(double d) {\n        return Math.nextUp(d);\n    }\n\n    private static double[] safeAdd(double a, double b) {\n        return new double[]{stepDown(a + b), stepUp(a + b)};\n    }\n\n    public static void main(String[] args) {\n        double a = 1.2;\n        double b = 0.03;\n        double[] result = safeAdd(a, b);\n        System.out.printf(\"(%.2f +\u00a0%.2f) is in the range\u00a0%.16f..%.16f\", a, b, result[0], result[1]);\n    }\n}\n"}
{"id": 54140, "name": "Safe addition", "source": "Translate Swift to Python: let a = 1.2\nlet b = 0.03\n\nprint(\"\\(a) + \\(b) is in the range \\((a + b).nextDown)...\\((a + b).nextUp)\")\n", "target": ">>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n0.9999999999999999\n>>> from math import fsum\n>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])\n1.0\n"}
{"id": 54274, "name": "Discordian date", "source": "Translate Swift to C#: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n    \n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"id": 54276, "name": "Discordian date", "source": "Translate Swift to Java: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class DiscordianDate {\n    final static String[] seasons = {\"Chaos\", \"Discord\", \"Confusion\",\n        \"Bureaucracy\", \"The Aftermath\"};\n\n    final static String[] weekday = {\"Sweetmorn\", \"Boomtime\", \"Pungenday\",\n        \"Prickle-Prickle\", \"Setting Orange\"};\n\n    final static String[] apostle = {\"Mungday\", \"Mojoday\", \"Syaday\",\n        \"Zaraday\", \"Maladay\"};\n\n    final static String[] holiday = {\"Chaoflux\", \"Discoflux\", \"Confuflux\",\n        \"Bureflux\", \"Afflux\"};\n\n    public static String discordianDate(final GregorianCalendar date) {\n        int y = date.get(Calendar.YEAR);\n        int yold = y + 1166;\n        int dayOfYear = date.get(Calendar.DAY_OF_YEAR);\n\n        if (date.isLeapYear(y)) {\n            if (dayOfYear == 60)\n                return \"St. Tib's Day, in the YOLD \" + yold;\n            else if (dayOfYear > 60)\n                dayOfYear--;\n        }\n\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        if (seasonDay == 5)\n            return apostle[dayOfYear / 73] + \", in the YOLD \" + yold;\n        if (seasonDay == 50)\n            return holiday[dayOfYear / 73] + \", in the YOLD \" + yold;\n\n        String season = seasons[dayOfYear / 73];\n        String dayOfWeek = weekday[dayOfYear % 5];\n\n        return String.format(\"%s, day %s of %s in the YOLD %s\",\n                dayOfWeek, seasonDay, season, yold);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(discordianDate(new GregorianCalendar()));\n\n        test(2010, 6, 22, \"Pungenday, day 57 of Confusion in the YOLD 3176\");\n        test(2012, 1, 28, \"Prickle-Prickle, day 59 of Chaos in the YOLD 3178\");\n        test(2012, 1, 29, \"St. Tib's Day, in the YOLD 3178\");\n        test(2012, 2, 1, \"Setting Orange, day 60 of Chaos in the YOLD 3178\");\n        test(2010, 0, 5, \"Mungday, in the YOLD 3176\");\n        test(2011, 4, 3, \"Discoflux, in the YOLD 3177\");\n        test(2015, 9, 19, \"Boomtime, day 73 of Bureaucracy in the YOLD 3181\");\n    }\n\n    private static void test(int y, int m, int d, final String result) {\n        assert (discordianDate(new GregorianCalendar(y, m, d)).equals(result));\n    }\n}\n"}
{"id": 54277, "name": "Discordian date", "source": "Translate Swift to Python: import Foundation\n\nlet monthDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\nlet seasons = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureacracy\", \"The Aftermath\"]\nlet dayNames = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"]\nlet holyDays1 = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"]\nlet holyDays2 = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"]\n\nfunc discordianDate(date: Date) -> String {\n    let calendar = Calendar.current\n    let year = calendar.component(.year, from: date)\n    let month = calendar.component(.month, from: date)\n    let day = calendar.component(.day, from: date)\n    let discYear = year + 1166\n    if month == 2 && day == 29 {\n        return \"St. Tib's Day in the YOLD \\(discYear)\"\n    }\n    let dayOfYear = monthDays[month - 1] + day - 1\n    let season = dayOfYear/73\n    let weekDay = dayOfYear % 5\n    let dayOfSeason = 1 + dayOfYear % 73\n    let ddate = \"\\(dayNames[weekDay]), day \\(dayOfSeason) of \\(seasons[season]) in the YOLD \\(discYear)\"\n    switch (dayOfSeason) {\n    case 5:\n        return ddate + \". Celebrate \\(holyDays1[season])!\"\n    case 50:\n        return ddate + \". Celebrate \\(holyDays2[season])!\"\n    default:\n        return ddate\n    }\n}\n\nfunc showDiscordianDate(year: Int, month: Int, day: Int) {\n    let calendar = Calendar.current\n    let date = calendar.date(from: DateComponents(year: year, month: month, day: day))!\n    let ddate = discordianDate(date: date)\n    let format = DateFormatter()\n    format.dateFormat = \"yyyy-MM-dd\"\n    print(\"\\(format.string(from: date)): \\(ddate)\")\n}\n\nshowDiscordianDate(year: 2022, month: 1, day: 20)\nshowDiscordianDate(year: 2020, month: 9, day: 21)\nshowDiscordianDate(year: 2020, month: 2, day: 29)\nshowDiscordianDate(year: 2019, month: 7, day: 15)\nshowDiscordianDate(year: 2025, month: 3, day: 19)\nshowDiscordianDate(year: 2017, month: 12, day: 8)\n", "target": "import datetime, calendar\n\nDISCORDIAN_SEASONS = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"]\n\ndef ddate(year, month, day):\n    today = datetime.date(year, month, day)\n    is_leap_year = calendar.isleap(year)\n    if is_leap_year and month == 2 and day == 29:\n        return \"St. Tib's Day, YOLD \" + (year + 1166)\n    \n    day_of_year = today.timetuple().tm_yday - 1\n    \n    if is_leap_year and day_of_year >= 60:\n        day_of_year -= 1 \n    \n    season, dday = divmod(day_of_year, 73)\n    return \"%s %d, YOLD %d\" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\n"}
{"id": 54699, "name": "Binary digits", "source": "Translate Swift to C#: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54701, "name": "Binary digits", "source": "Translate Swift to Java: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54702, "name": "Binary digits", "source": "Translate Swift to Python: for num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 54885, "name": "Dijkstra's algorithm", "source": "Translate Swift to C#: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "using static System.Linq.Enumerable;\nusing static System.String;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System;\nusing EdgeList = System.Collections.Generic.List<(int node, double weight)>;\n\npublic static class Dijkstra\n{\n    public static void Main() {\n        Graph graph = new Graph(6);\n        Func<char, int> id = c => c - 'a';\n        Func<int , char> name = i => (char)(i + 'a');\n        foreach (var (start, end, cost) in new [] {\n            ('a', 'b', 7),\n            ('a', 'c', 9),\n            ('a', 'f', 14),\n            ('b', 'c', 10),\n            ('b', 'd', 15),\n            ('c', 'd', 11),\n            ('c', 'f', 2),\n            ('d', 'e', 6),\n            ('e', 'f', 9),\n        }) {\n            graph.AddEdge(id(start), id(end), cost);\n        }\n\n        var path = graph.FindPath(id('a'));\n        for (int d = id('b'); d <= id('f'); d++) {\n            WriteLine(Join(\" -> \", Path(id('a'), d).Select(p => $\"{name(p.node)}({p.distance})\").Reverse()));\n        }\n        \n        IEnumerable<(double distance, int node)> Path(int start, int destination) {\n            yield return (path[destination].distance, destination);\n            for (int i = destination; i != start; i = path[i].prev) {\n                yield return (path[path[i].prev].distance, path[i].prev);\n            }\n        }\n    }\n\n}\n\nsealed class Graph\n{\n    private readonly List<EdgeList> adjacency;\n\n    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();\n\n    public int Count => adjacency.Count;\n    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);\n    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;\n\n    public bool AddEdge(int s, int e, double weight) {\n        if (HasEdge(s, e)) return false;\n        adjacency[s].Add((e, weight));\n        return true;\n    }\n\n    public (double distance, int prev)[] FindPath(int start) {\n        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();\n        info[start].distance = 0;\n        var visited = new System.Collections.BitArray(adjacency.Count);\n\n        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));\n        heap.Push((start, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            if (visited[current.node]) continue;\n            var edges = adjacency[current.node];\n            for (int n = 0; n < edges.Count; n++) {\n                int v = edges[n].node;\n                if (visited[v]) continue;\n                double alt = info[current.node].distance + edges[n].weight;\n                if (alt < info[v].distance) {\n                    info[v] = (alt, current.node);\n                    heap.Push((v, alt));\n                }\n            }\n            visited[current.node] = true;\n        }\n        return info;\n    }\n\n}\n\nsealed class Heap<T>\n{\n    private readonly IComparer<T> comparer;\n    private readonly List<T> list = new List<T> { default };\n\n    public Heap() : this(default(IComparer<T>)) { }\n\n    public Heap(IComparer<T> comparer) {\n        this.comparer = comparer ?? Comparer<T>.Default;\n    }\n\n    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }\n\n    public int Count => list.Count - 1;\n\n    public void Push(T element) {\n        list.Add(element);\n        SiftUp(list.Count - 1);\n    }\n\n    public T Pop() {\n        T result = list[1];\n        list[1] = list[list.Count - 1];\n        list.RemoveAt(list.Count - 1);\n        SiftDown(1);\n        return result;\n    }\n\n    private static int Parent(int i) => i / 2;\n    private static int Left(int i) => i * 2;\n    private static int Right(int i) => i * 2 + 1;\n\n    private void SiftUp(int i) {\n        while (i > 1) {\n            int parent = Parent(i);\n            if (comparer.Compare(list[i], list[parent]) > 0) return;\n            (list[parent], list[i]) = (list[i], list[parent]);\n            i = parent;\n        }\n    }\n\n    private void SiftDown(int i) {\n        for (int left = Left(i); left < list.Count; left = Left(i)) {\n            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;\n            int right = Right(i);\n            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;\n            if (smallest == i) return;\n            (list[i], list[smallest]) = (list[smallest], list[i]);\n            i = smallest;\n        }\n    }\n\n}\n"}
{"id": 54887, "name": "Dijkstra's algorithm", "source": "Translate Swift to Java: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Dijkstra {\n   private static final Graph.Edge[] GRAPH = {\n      new Graph.Edge(\"a\", \"b\", 7),\n      new Graph.Edge(\"a\", \"c\", 9),\n      new Graph.Edge(\"a\", \"f\", 14),\n      new Graph.Edge(\"b\", \"c\", 10),\n      new Graph.Edge(\"b\", \"d\", 15),\n      new Graph.Edge(\"c\", \"d\", 11),\n      new Graph.Edge(\"c\", \"f\", 2),\n      new Graph.Edge(\"d\", \"e\", 6),\n      new Graph.Edge(\"e\", \"f\", 9),\n   };\n   private static final String START = \"a\";\n   private static final String END = \"e\";\n   \n   public static void main(String[] args) {\n      Graph g = new Graph(GRAPH);\n      g.dijkstra(START);\n      g.printPath(END);\n      \n   }\n}\n\nclass Graph {\n   private final Map<String, Vertex> graph; \n   \n   \n   public static class Edge {\n      public final String v1, v2;\n      public final int dist;\n      public Edge(String v1, String v2, int dist) {\n         this.v1 = v1;\n         this.v2 = v2;\n         this.dist = dist;\n      }\n   }\n   \n   \n  public static class Vertex implements Comparable<Vertex>{\n\tpublic final String name;\n\tpublic int dist = Integer.MAX_VALUE; \n\tpublic Vertex previous = null;\n\tpublic final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n\tpublic Vertex(String name)\n\t{\n\t\tthis.name = name;\n\t}\n\n\tprivate void printPath()\n\t{\n\t\tif (this == this.previous)\n\t\t{\n\t\t\tSystem.out.printf(\"%s\", this.name);\n\t\t}\n\t\telse if (this.previous == null)\n\t\t{\n\t\t\tSystem.out.printf(\"%s(unreached)\", this.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.previous.printPath();\n\t\t\tSystem.out.printf(\" -> %s(%d)\", this.name, this.dist);\n\t\t}\n\t}\n\n\tpublic int compareTo(Vertex other)\n\t{\n\t\tif (dist == other.dist)\n\t\t\treturn name.compareTo(other.name);\n\n\t\treturn Integer.compare(dist, other.dist);\n\t}\n\n\t@Override public String toString()\n\t{\n\t\treturn \"(\" + name + \", \" + dist + \")\";\n\t}\n}\n   \n   \n   public Graph(Edge[] edges) {\n      graph = new HashMap<>(edges.length);\n      \n      \n      for (Edge e : edges) {\n         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n      }\n      \n      \n      for (Edge e : edges) {\n         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n         \n      }\n   }\n   \n    \n   public void dijkstra(String startName) {\n      if (!graph.containsKey(startName)) {\n         System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n         return;\n      }\n      final Vertex source = graph.get(startName);\n      NavigableSet<Vertex> q = new TreeSet<>();\n      \n      \n      for (Vertex v : graph.values()) {\n         v.previous = v == source ? source : null;\n         v.dist = v == source ? 0 : Integer.MAX_VALUE;\n         q.add(v);\n      }\n      \n      dijkstra(q);\n   }\n   \n   \n   private void dijkstra(final NavigableSet<Vertex> q) {      \n      Vertex u, v;\n      while (!q.isEmpty()) {\n         \n         u = q.pollFirst(); \n         if (u.dist == Integer.MAX_VALUE) break; \n         \n         \n         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n            v = a.getKey(); \n            \n            final int alternateDist = u.dist + a.getValue();\n            if (alternateDist < v.dist) { \n               q.remove(v);\n               v.dist = alternateDist;\n               v.previous = u;\n               q.add(v);\n            } \n         }\n      }\n   }\n   \n   \n   public void printPath(String endName) {\n      if (!graph.containsKey(endName)) {\n         System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n         return;\n      }\n      \n      graph.get(endName).printPath();\n      System.out.println();\n   }\n   \n   public void printAllPaths() {\n      for (Vertex v : graph.values()) {\n         v.printPath();\n         System.out.println();\n      }\n   }\n}\n"}
{"id": 54888, "name": "Dijkstra's algorithm", "source": "Translate Swift to Python: typealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n", "target": "from collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        \n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        \n \n        while q:\n            \n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  \n                    dist[v] = alt\n                    previous[v] = u\n        \n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n"}
{"id": 55759, "name": "Find the intersection of two lines", "source": "Translate Swift to C#: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55760, "name": "Find the intersection of two lines", "source": "Translate Swift to C#: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55763, "name": "Find the intersection of two lines", "source": "Translate Swift to Java: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55764, "name": "Find the intersection of two lines", "source": "Translate Swift to Java: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55765, "name": "Find the intersection of two lines", "source": "Translate Swift to Python: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55766, "name": "Find the intersection of two lines", "source": "Translate Swift to Python: struct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Line {\n  var p1: Point\n  var p2: Point\n\n  var slope: Double {\n    guard p1.x - p2.x != 0.0 else { return .nan }\n\n    return (p1.y-p2.y) / (p1.x-p2.x)\n  }\n\n  func intersection(of other: Line) -> Point? {\n    let ourSlope = slope\n    let theirSlope = other.slope\n\n    guard ourSlope != theirSlope else { return nil }\n\n    if ourSlope.isNaN && !theirSlope.isNaN {\n      return Point(x: p1.x, y: (p1.x - other.p1.x) * theirSlope + other.p1.y)\n    } else if theirSlope.isNaN && !ourSlope.isNaN {\n      return Point(x: other.p1.x, y: (other.p1.x - p1.x) * ourSlope + p1.y)\n    } else {\n      let x = (ourSlope*p1.x - theirSlope*other.p1.x + other.p1.y - p1.y) / (ourSlope - theirSlope)\n      return Point(x: x, y: theirSlope*(x - other.p1.x) + other.p1.y)\n    }\n  }\n}\n\nlet l1 = Line(p1: Point(x: 4.0, y: 0.0), p2: Point(x: 6.0, y: 10.0))\nlet l2 = Line(p1: Point(x: 0.0, y: 3.0), p2: Point(x: 10.0, y: 7.0))\n\nprint(\"Intersection at\u00a0: \\(l1.intersection(of: l2)!)\")\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 56175, "name": "Align columns", "source": "Translate Swift to C#: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56176, "name": "Align columns", "source": "Translate Swift to Java: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56177, "name": "Align columns", "source": "Translate Swift to Python: import Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 56518, "name": "Longest common prefix", "source": "Translate Swift to C#: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56519, "name": "Longest common prefix", "source": "Translate Swift to C#: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "using System;\n\nnamespace LCP {\n    class Program {\n        public static string LongestCommonPrefix(params string[] sa) {\n            if (null == sa) return \"\"; \n            string ret = \"\";\n            int idx = 0;\n\n            while (true) {\n                char thisLetter = '\\0';\n                foreach (var word in sa) {\n                    if (idx == word.Length) {\n                        \n                        return ret;\n                    }\n                    if (thisLetter == '\\0') {\n                        \n                        thisLetter = word[idx];\n                    }\n                    if (thisLetter != word[idx]) {\n                        return ret;\n                    }\n                }\n\n                \n                ret += thisLetter;\n                idx++;\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(LongestCommonPrefix(\"interspecies\", \"interstellar\", \"interstate\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"dungeon\"));\n            Console.WriteLine(LongestCommonPrefix(\"throne\", \"\", \"throne\"));\n            Console.WriteLine(LongestCommonPrefix(\"cheese\"));\n            Console.WriteLine(LongestCommonPrefix(\"\"));\n            Console.WriteLine(LongestCommonPrefix(null));\n            Console.WriteLine(LongestCommonPrefix(\"prefix\", \"suffix\"));\n            Console.WriteLine(LongestCommonPrefix(\"foo\", \"foobar\"));\n        }\n    }\n}\n"}
{"id": 56522, "name": "Longest common prefix", "source": "Translate Swift to Java: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56523, "name": "Longest common prefix", "source": "Translate Swift to Java: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "public class LCP {\n    public static String lcp(String... list){\n        if(list == null) return \"\";\n        String ret = \"\";\n        int idx = 0;\n\n        while(true){\n            char thisLetter = 0;\n            for(String word : list){\n                if(idx == word.length()){ \n                    return ret;\n                }\n                if(thisLetter == 0){ \n                    thisLetter = word.charAt(idx);\n                }\n                if(thisLetter != word.charAt(idx)){ \n                    return ret;\n                }\n            }\n            ret += thisLetter;\n            idx++;\n        }\n    }\n    \n    public static void main(String[] args){\n        System.out.println(lcp(\"interspecies\",\"interstellar\",\"interstate\"));\n        System.out.println(lcp(\"throne\",\"throne\"));\n        System.out.println(lcp(\"throne\",\"dungeon\"));\n        System.out.println(lcp(\"throne\",\"\",\"throne\"));\n        System.out.println(lcp(\"cheese\"));\n        System.out.println(lcp(\"\"));\n        System.out.println(lcp(null));\n        System.out.println(lcp(\"prefix\",\"suffix\"));\n        System.out.println(lcp(\"foo\",\"foobar\"));\n    }\n}\n"}
{"id": 56524, "name": "Longest common prefix", "source": "Translate Swift to Python: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56525, "name": "Longest common prefix", "source": "Translate Swift to Python: func commonPrefix(string1: String, string2: String) -> String {\n    return String(zip(string1, string2).prefix(while: {$0 == $1}).map{$0.0})\n}\n\nfunc longestCommonPrefix(_ strings: [String]) -> String {\n    switch (strings.count) {\n    case 0:\n        return \"\"\n    case 1:\n        return strings[0]\n    default:\n        return commonPrefix(string1: strings.min()!, string2: strings.max()!)\n    }\n}\n\nfunc printLongestCommonPrefix(_ strings: [String]) {\n    print(\"lcp(\\(strings)) = \\\"\\(longestCommonPrefix(strings))\\\"\")\n}\n\nprintLongestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"])\nprintLongestCommonPrefix([\"throne\", \"throne\"])\nprintLongestCommonPrefix([\"throne\", \"dungeon\"])\nprintLongestCommonPrefix([\"throne\", \"\", \"throne\"])\nprintLongestCommonPrefix([\"cheese\"])\nprintLongestCommonPrefix([\"\"])\nprintLongestCommonPrefix([])\nprintLongestCommonPrefix([\"prefix\", \"suffix\"])\nprintLongestCommonPrefix([\"foo\", \"foobar\"])\n", "target": "import os.path\n\ndef lcp(*s):\n    return os.path.commonprefix(s)\n\nassert lcp(\"interspecies\",\"interstellar\",\"interstate\") == \"inters\"\nassert lcp(\"throne\",\"throne\") == \"throne\"\nassert lcp(\"throne\",\"dungeon\") == \"\"\nassert lcp(\"cheese\") == \"cheese\"\nassert lcp(\"\") == \"\"\nassert lcp(\"prefix\",\"suffix\") == \"\"\nassert lcp(\"foo\",\"foobar\") == \"foo\"\n"}
{"id": 56774, "name": "String matching", "source": "Translate Swift to C#: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "class Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); \n\t\tvalue = \"abab\".Contains(\"bb\"); \n\t\tvalue = \"abab\".Contains(\"ab\"); \n\t\tint loc = \"abab\".IndexOf(\"bb\"); \n\t\tloc = \"abab\".IndexOf(\"ab\"); \n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); \n\t}\n}\n"}
{"id": 56776, "name": "String matching", "source": "Translate Swift to Java: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "\"abcd\".startsWith(\"ab\") \n\"abcd\".endsWith(\"zn\") \n\"abab\".contains(\"bb\") \n\"abab\".contains(\"ab\") \nint loc = \"abab\".indexOf(\"bb\") \nloc = \"abab\".indexOf(\"ab\") \nloc = \"abab\".indexOf(\"ab\",loc+1) \n"}
{"id": 56777, "name": "String matching", "source": "Translate Swift to Python: var str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           \nstr.hasPrefix(\"hell\")           \n\nstr.containsString(\"llo\")       \nstr.containsString(\"xxoo\")      \n\nstr.hasSuffix(\"playground\")     \nstr.hasSuffix(\"world\")          \n", "target": "\"abcd\".startswith(\"ab\") \n\"abcd\".endswith(\"zn\") \n\"bb\" in \"abab\" \n\"ab\" in \"abab\" \nloc = \"abab\".find(\"bb\") \nloc = \"abab\".find(\"ab\") \nloc = \"abab\".find(\"ab\",loc+1) \n"}
{"id": 57057, "name": "Real constants and functions", "source": "Translate Swift to C#: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 57059, "name": "Real constants and functions", "source": "Translate Swift to Java: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 57060, "name": "Real constants and functions", "source": "Translate Swift to Python: import Darwin\n\nM_E \nM_PI \nsqrt(x) \nlog(x) \nexp(x) \nabs(x) \nfloor(x) \nceil(x) \npow(x,y) \n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57235, "name": "Singly-linked list_Element definition", "source": "Translate Swift to C#: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    \n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n"}
{"id": 57237, "name": "Singly-linked list_Element definition", "source": "Translate Swift to Java: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class Link\n{\n    Link next;\n    int data;\n}\n"}
{"id": 57238, "name": "Singly-linked list_Element definition", "source": "Translate Swift to Python: class Node<T>{\n    var data:T?=nil\n    var next:Node?=nil\n    init(input:T){\n        data=input\n        next=nil\n    }\n}\n", "target": "class LinkedList(object):\n     \n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n"}
{"id": 57357, "name": "Pell's equation", "source": "Translate Swift to C#: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "using System;\nusing System.Numerics;\n\nstatic class Program\n{\n    static void Fun(ref BigInteger a, ref BigInteger b, int c)\n    {\n        BigInteger t = a; a = b; b = b * c + t;\n    }\n\n    static void SolvePell(int n, ref BigInteger a, ref BigInteger b)\n    {\n        int x = (int)Math.Sqrt(n), y = x, z = 1, r = x << 1;\n        BigInteger e1 = 1, e2 = 0, f1 = 0, f2 = 1;\n        while (true)\n        {\n            y = r * z - y; z = (n - y * y) / z; r = (x + y) / z;\n            Fun(ref e1, ref e2, r); Fun(ref f1, ref f2, r); a = f2; b = e2; Fun(ref b, ref a, x);\n            if (a * a - n * b * b == 1) return;\n        }\n    }\n\n    static void Main()\n    {\n        BigInteger x, y; foreach (int n in new[] { 61, 109, 181, 277 })\n        {\n            SolvePell(n, ref x, ref y);\n            Console.WriteLine(\"x^2 - {0,3} * y^2 = 1 for x = {1,27:n0} and y = {2,25:n0}\", n, x, y);\n        }\n    }\n}\n"}
{"id": 57359, "name": "Pell's equation", "source": "Translate Swift to Java: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PellsEquation {\n\n    public static void main(String[] args) {\n        NumberFormat format = NumberFormat.getInstance();\n        for ( int n : new int[] {61, 109, 181, 277, 8941} ) {\n            BigInteger[] pell = pellsEquation(n);\n            System.out.printf(\"x^2 - %3d * y^2 = 1 for:%n    x = %s%n    y = %s%n%n\", n,  format.format(pell[0]),  format.format(pell[1]));\n        }\n    }\n\n    private static final BigInteger[] pellsEquation(int n) {\n        int a0 = (int) Math.sqrt(n);\n        if ( a0*a0 == n ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid n = \" + n);\n        }\n        List<Integer> continuedFrac = continuedFraction(n);\n        int count = 0;\n        BigInteger ajm2 = BigInteger.ONE;\n        BigInteger ajm1 = new BigInteger(a0 + \"\");\n        BigInteger bjm2 = BigInteger.ZERO;\n        BigInteger bjm1 = BigInteger.ONE;\n        boolean stop = (continuedFrac.size() % 2 == 1);\n        if ( continuedFrac.size() == 2 ) {\n            stop = true;\n        }\n        while ( true ) {\n            count++;\n            BigInteger bn = new BigInteger(continuedFrac.get(count) + \"\");\n            BigInteger aj = bn.multiply(ajm1).add(ajm2);\n            BigInteger bj = bn.multiply(bjm1).add(bjm2);\n            if ( stop && (count == continuedFrac.size()-2 || continuedFrac.size() == 2) ) {\n                return new BigInteger[] {aj, bj};\n            }\n            else if (continuedFrac.size() % 2 == 0 && count == continuedFrac.size()-2 ) {\n                stop = true;\n            }\n            if ( count == continuedFrac.size()-1 ) {\n                count = 0;\n            }\n            ajm2 = ajm1;\n            ajm1 = aj;\n            bjm2 = bjm1;\n            bjm1 = bj;\n        }\n    }\n\n    private static final List<Integer> continuedFraction(int n) {\n        List<Integer> answer = new ArrayList<Integer>();\n        int a0 = (int) Math.sqrt(n);\n        answer.add(a0);\n        int a = -a0;\n        int aStart = a;\n        int b = 1;\n        int bStart = b;\n\n        while ( true ) {\n            \n            int[] values = iterateFrac(n, a, b);\n            answer.add(values[0]);\n            a = values[1];\n            b = values[2];\n            if (a == aStart && b == bStart) break;\n        }\n        return answer;\n    }\n    \n    \n    \n    \n    private static final int[] iterateFrac(int n, int a, int b) {\n        int x = (int) Math.floor((b * Math.sqrt(n) - b * a)/(n - a * a));\n        int[] answer = new int[3];\n        answer[0] = x;\n        answer[1] = -(b * a + x *(n - a * a)) / b;\n        answer[2] = (n - a * a) / b;\n        return answer;\n    }\n\n\n}\n"}
{"id": 57360, "name": "Pell's equation", "source": "Translate Swift to Python: func solvePell<T: BinaryInteger>(n: T, _ a: inout T, _ b: inout T) {\n  func swap(_ a: inout T, _ b: inout T, mul by: T) {\n    (a, b) = (b, b * by + a)\n  }\n\n  let x = T(Double(n).squareRoot())\n  var y = x\n  var z = T(1)\n  var r = x << 1\n  var e1 = T(1)\n  var e2 = T(0)\n  var f1 = T(0)\n  var f2 = T(1)\n\n  while true {\n    y = r * z - y\n    z = (n - y * y) / z\n    r = (x + y) / z\n\n    swap(&e1, &e2, mul: r)\n    swap(&f1, &f2, mul: r)\n\n    (a, b) = (f2, e2)\n\n    swap(&b, &a, mul: x)\n\n    if a * a - n * b * b == 1 {\n      return\n    }\n  }\n}\n\nvar x = BigInt(0)\nvar y = BigInt(0)\n\nfor n in [61, 109, 181, 277] {\n  solvePell(n: BigInt(n), &x, &y)\n\n  print(\"x\\u{00b2} - \\(n)y\\u{00b2} = 1 for x = \\(x) and y = \\(y)\")\n}\n", "target": "import math\n\ndef solvePell(n):\n    x = int(math.sqrt(n))\n    y, z, r = x, 1, x << 1\n    e1, e2 = 1, 0\n    f1, f2 = 0, 1\n    while True:\n        y = r * z - y\n        z = (n - y * y) // z\n        r = (x + y) // z\n\n        e1, e2 = e2, e1 + e2 * r\n        f1, f2 = f2, f1 + f2 * r\n\n        a, b = f2 * x + e2, f2\n        if a * a - n * b * b == 1:\n            return a, b\n\nfor n in [61, 109, 181, 277]:\n    x, y = solvePell(n)\n    print(\"x^2 - %3d * y^2 = 1 for x = %27d and y = %25d\" % (n, x, y))\n"}
{"id": 57536, "name": "System time", "source": "Translate Swift to Java: import Foundation\n\nvar \u231a\ufe0f = NSDate()\nprintln(\u231a\ufe0f)\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57920, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to C#: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57921, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to C#: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class FindPalindromicNumbers\n{\n    static void Main(string[] args)\n    {\n        var query =\n            PalindromicTernaries()\n            .Where(IsPalindromicBinary)\n            .Take(6);\n        foreach (var x in query) {\n            Console.WriteLine(\"Decimal: \" + x);\n            Console.WriteLine(\"Ternary: \" + ToTernary(x));\n            Console.WriteLine(\"Binary: \" + Convert.ToString(x, 2));\n            Console.WriteLine();\n        }\n    }\n\n    public static IEnumerable<long> PalindromicTernaries() {\n        yield return 0;\n        yield return 1;\n        yield return 13;\n        yield return 23;\n\n        var f = new List<long> {0};\n        long fMiddle = 9;\n        while (true) {\n            for (long edge = 1; edge < 3; edge++) {\n                int i;\n                do {\n                    \n                    long result = fMiddle;\n                    long fLeft = fMiddle * 3;\n                    long fRight = fMiddle / 3;\n                    for (int j = f.Count - 1; j >= 0; j--) {\n                        result += (fLeft + fRight) * f[j];\n                        fLeft *= 3;\n                        fRight /= 3;\n                    }\n                    result += (fLeft + fRight) * edge;\n                    yield return result;\n\n                    \n                    for (i = f.Count - 1; i >= 0; i--) {\n                        if (f[i] == 2) {\n                            f[i] = 0;\n                        } else {\n                            f[i]++;\n                            break;\n                        }\n                    }\n                } while (i >= 0);\n            }\n            f.Add(0);\n            fMiddle *= 3;\n        }\n    }\n\n    public static bool IsPalindromicBinary(long number) {\n        long n = number;\n        long reverse = 0;\n        while (n != 0) {\n            reverse <<= 1;\n            if ((n & 1) == 1) reverse++;\n            n >>= 1;\n        }\n        return reverse == number;\n    }\n\n    public static string ToTernary(long n)\n    {\n        if (n == 0) return \"0\";\n        string result = \"\";\n        while (n > 0) {        {\n            result = (n % 3) + result;\n            n /= 3;\n        }\n        return result;\n    }\n\n}\n"}
{"id": 57922, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Java: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57923, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Java: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "public class Pali23 {\n\tpublic static boolean isPali(String x){\n\t\treturn x.equals(new StringBuilder(x).reverse().toString());\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tfor(long i = 0, count = 0; count < 6;i++){\n\t\t\tif((i & 1) == 0 && (i != 0)) continue; \n\t\t\t\n\t\t\t\n\t\t\tif(isPali(Long.toBinaryString(i)) && isPali(Long.toString(i, 3))){\n\t\t\t\tSystem.out.println(i + \", \" + Long.toBinaryString(i) + \", \" + Long.toString(i, 3));\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 57924, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Python: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 57925, "name": "Find palindromic numbers in both binary and ternary bases", "source": "Translate Swift to Python: import Foundation\n\nfunc isPalin2(n: Int) -> Bool {\n  var x = 0\n  var n = n\n\n  guard n & 1 != 0 else {\n    return n == 0\n  }\n\n  while x < n {\n    x = x << 1 | n & 1\n    n >>= 1\n  }\n\n  return n == x || n == x >> 1\n}\n\nfunc reverse3(n: Int) -> Int {\n  var x = 0\n  var n = n\n\n  while n > 0 {\n    x = x * 3 + (n % 3)\n    n /= 3\n  }\n\n  return x\n}\n\nfunc printN(_ n: Int, base: Int) {\n  var n = n\n\n  print(\" \", terminator: \"\")\n\n  repeat {\n    print(\"\\(n % base)\", terminator: \"\")\n\n    n /= base\n  } while n > 0\n\n  print(\"(\\(base))\", terminator: \"\")\n}\n\nfunc show(n: Int) {\n  print(n, terminator: \"\")\n  printN(n, base: 2)\n  printN(n, base: 3)\n  print()\n}\n\nprivate var count = 0\nprivate var lo = 0\nprivate var (hi, pow2, pow3) = (1, 1, 1)\n\nshow(n: 0)\n\nwhile true {\n  var n: Int\n\n  for i in lo..<hi {\n    n = (i * 3 + 1) * pow3 + reverse3(n: i)\n\n    guard isPalin2(n: n) else {\n      continue\n    }\n\n    show(n: n)\n    count += 1\n\n    guard count < 7 else {\n      exit(0)\n    }\n  }\n\n  if hi == pow3 {\n    pow3 *= 3\n  } else {\n    pow2 *= 4\n  }\n\n  while true {\n    while pow2 <= pow3 {\n      pow2 *= 4\n    }\n\n    let lo2 = (pow2 / pow3 - 1) / 3\n    let hi2 = (pow2 * 2 / pow3 - 1) / 3 + 1\n    let lo3 = pow3 / 3\n    let hi3 = pow3\n\n    if lo2 >= hi3 {\n      pow3 *= 3\n    } else if lo3 >= hi2 {\n      pow2 *= 4\n    } else {\n      lo = max(lo2, lo3)\n      hi = min(hi2, hi3)\n      break\n    }\n  }\n}\n", "target": "from itertools import islice\n\ndigits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n\ndef baseN(num,b):\n  if num == 0: return \"0\"\n  result = \"\"\n  while num != 0:\n    num, d = divmod(num, b)\n    result += digits[d]\n  return result[::-1] \n\ndef pal2(num):\n    if num == 0 or num == 1: return True\n    based = bin(num)[2:]\n    return based == based[::-1]\n\ndef pal_23():\n    yield 0\n    yield 1\n    n = 1\n    while True:\n        n += 1\n        b = baseN(n, 3)\n        revb = b[::-1]\n        \n        for trial in ('{0}{1}'.format(b, revb), '{0}0{1}'.format(b, revb),\n                      '{0}1{1}'.format(b, revb), '{0}2{1}'.format(b, revb)):\n            t = int(trial, 3)\n            if pal2(t):\n                yield t\n\nfor pal23 in islice(pal_23(), 6):\n    print(pal23, baseN(pal23, 3), baseN(pal23, 2))\n"}
{"id": 59305, "name": "URL decoding", "source": "Translate Swift to C#: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59306, "name": "URL decoding", "source": "Translate Swift to C#: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "using System;\n\nnamespace URLEncode\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            Console.WriteLine(Decode(\"http%3A%2F%2Ffoo%20bar%2F\"));\n        }\n\n        private static string Decode(string uri)\n        {\n            return Uri.UnescapeDataString(uri);\n        }\n    }\n}\n"}
{"id": 59309, "name": "URL decoding", "source": "Translate Swift to Java: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59310, "name": "URL decoding", "source": "Translate Swift to Java: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String encoded = \"http%3A%2F%2Ffoo%20bar%2F\";\n        String normal = URLDecoder.decode(encoded, \"utf-8\");\n        System.out.println(normal);\n    }\n}\n"}
{"id": 59311, "name": "URL decoding", "source": "Translate Swift to Python: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59312, "name": "URL decoding", "source": "Translate Swift to Python: import Foundation\n\nlet encoded = \"http%3A%2F%2Ffoo%20bar%2F\"\nif let normal = encoded.stringByReplacingPercentEscapesUsingEncoding(NSUTF8StringEncoding) {\n  println(normal)\n}\n", "target": "\nimport urllib\nprint urllib.unquote(\"http%3A%2F%2Ffoo%20bar%2F\")\n\nfrom urllib.parse import unquote\nprint(unquote('http%3A%2F%2Ffoo%20bar%2F'))\n"}
{"id": 59548, "name": "Closest-pair problem", "source": "Translate Swift to C#: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "class Segment\n{\n    public Segment(PointF p1, PointF p2)\n    {\n        P1 = p1;\n        P2 = p2;\n    }\n\n    public readonly PointF P1;\n    public readonly PointF P2;\n\n    public float Length()\n    {\n        return (float)Math.Sqrt(LengthSquared());\n    }\n\n    public float LengthSquared()\n    {\n        return (P1.X - P2.X) * (P1.X - P2.X)\n            + (P1.Y - P2.Y) * (P1.Y - P2.Y);\n    }\n}\n"}
{"id": 59550, "name": "Closest-pair problem", "source": "Translate Swift to Java: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "import java.util.*;\n\npublic class ClosestPair\n{\n  public static class Point\n  {\n    public final double x;\n    public final double y;\n    \n    public Point(double x, double y)\n    {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public String toString()\n    {  return \"(\" + x + \", \" + y + \")\";  }\n  }\n  \n  public static class Pair\n  {\n    public Point point1 = null;\n    public Point point2 = null;\n    public double distance = 0.0;\n    \n    public Pair()\n    {  }\n    \n    public Pair(Point point1, Point point2)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      calcDistance();\n    }\n    \n    public void update(Point point1, Point point2, double distance)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      this.distance = distance;\n    }\n    \n    public void calcDistance()\n    {  this.distance = distance(point1, point2);  }\n    \n    public String toString()\n    {  return point1 + \"-\" + point2 + \"\u00a0: \" + distance;  }\n  }\n  \n  public static double distance(Point p1, Point p2)\n  {\n    double xdist = p2.x - p1.x;\n    double ydist = p2.y - p1.y;\n    return Math.hypot(xdist, ydist);\n  }\n  \n  public static Pair bruteForce(List<? extends Point> points)\n  {\n    int numPoints = points.size();\n    if (numPoints < 2)\n      return null;\n    Pair pair = new Pair(points.get(0), points.get(1));\n    if (numPoints > 2)\n    {\n      for (int i = 0; i < numPoints - 1; i++)\n      {\n        Point point1 = points.get(i);\n        for (int j = i + 1; j < numPoints; j++)\n        {\n          Point point2 = points.get(j);\n          double distance = distance(point1, point2);\n          if (distance < pair.distance)\n            pair.update(point1, point2, distance);\n        }\n      }\n    }\n    return pair;\n  }\n  \n  public static void sortByX(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.x < point2.x)\n            return -1;\n          if (point1.x > point2.x)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static void sortByY(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.y < point2.y)\n            return -1;\n          if (point1.y > point2.y)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static Pair divideAndConquer(List<? extends Point> points)\n  {\n    List<Point> pointsSortedByX = new ArrayList<Point>(points);\n    sortByX(pointsSortedByX);\n    List<Point> pointsSortedByY = new ArrayList<Point>(points);\n    sortByY(pointsSortedByY);\n    return divideAndConquer(pointsSortedByX, pointsSortedByY);\n  }\n  \n  private static Pair divideAndConquer(List<? extends Point> pointsSortedByX, List<? extends Point> pointsSortedByY)\n  {\n    int numPoints = pointsSortedByX.size();\n    if (numPoints <= 3)\n      return bruteForce(pointsSortedByX);\n    \n    int dividingIndex = numPoints >>> 1;\n    List<? extends Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex);\n    List<? extends Point> rightOfCenter = pointsSortedByX.subList(dividingIndex, numPoints);\n    \n    List<Point> tempList = new ArrayList<Point>(leftOfCenter);\n    sortByY(tempList);\n    Pair closestPair = divideAndConquer(leftOfCenter, tempList);\n    \n    tempList.clear();\n    tempList.addAll(rightOfCenter);\n    sortByY(tempList);\n    Pair closestPairRight = divideAndConquer(rightOfCenter, tempList);\n    \n    if (closestPairRight.distance < closestPair.distance)\n      closestPair = closestPairRight;\n    \n    tempList.clear();\n    double shortestDistance =closestPair.distance;\n    double centerX = rightOfCenter.get(0).x;\n    for (Point point : pointsSortedByY)\n      if (Math.abs(centerX - point.x) < shortestDistance)\n        tempList.add(point);\n    \n    for (int i = 0; i < tempList.size() - 1; i++)\n    {\n      Point point1 = tempList.get(i);\n      for (int j = i + 1; j < tempList.size(); j++)\n      {\n        Point point2 = tempList.get(j);\n        if ((point2.y - point1.y) >= shortestDistance)\n          break;\n        double distance = distance(point1, point2);\n        if (distance < closestPair.distance)\n        {\n          closestPair.update(point1, point2, distance);\n          shortestDistance = distance;\n        }\n      }\n    }\n    return closestPair;\n  }\n  \n  public static void main(String[] args)\n  {\n    int numPoints = (args.length == 0) ? 1000 : Integer.parseInt(args[0]);\n    List<Point> points = new ArrayList<Point>();\n    Random r = new Random();\n    for (int i = 0; i < numPoints; i++)\n      points.add(new Point(r.nextDouble(), r.nextDouble()));\n    System.out.println(\"Generated \" + numPoints + \" random points\");\n    long startTime = System.currentTimeMillis();\n    Pair bruteForceClosestPair = bruteForce(points);\n    long elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Brute force (\" + elapsedTime + \" ms): \" + bruteForceClosestPair);\n    startTime = System.currentTimeMillis();\n    Pair dqClosestPair = divideAndConquer(points);\n    elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Divide and conquer (\" + elapsedTime + \" ms): \" + dqClosestPair);\n    if (bruteForceClosestPair.distance != dqClosestPair.distance)\n      System.out.println(\"MISMATCH\");\n  }\n}\n"}
{"id": 59551, "name": "Closest-pair problem", "source": "Translate Swift to Python: import Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n", "target": "\n\nfrom random import randint, randrange\nfrom operator import itemgetter, attrgetter\n\ninfinity = float('inf')\n\n\n\ndef bruteForceClosestPair(point):\n    numPoints = len(point)\n    if numPoints < 2:\n        return infinity, (None, None)\n    return min( ((abs(point[i] - point[j]), (point[i], point[j]))\n                 for i in range(numPoints-1)\n                 for j in range(i+1,numPoints)),\n                key=itemgetter(0))\n\ndef closestPair(point):\n    xP = sorted(point, key= attrgetter('real'))\n    yP = sorted(point, key= attrgetter('imag'))\n    return _closestPair(xP, yP)\n\ndef _closestPair(xP, yP):\n    numPoints = len(xP)\n    if numPoints <= 3:\n        return bruteForceClosestPair(xP)\n    Pl = xP[:numPoints/2]\n    Pr = xP[numPoints/2:]\n    Yl, Yr = [], []\n    xDivider = Pl[-1].real\n    for p in yP:\n        if p.real <= xDivider:\n            Yl.append(p)\n        else:\n            Yr.append(p)\n    dl, pairl = _closestPair(Pl, Yl)\n    dr, pairr = _closestPair(Pr, Yr)\n    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)\n    \n    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]\n    numCloseY = len(closeY)\n    if numCloseY > 1:\n        \n        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))\n                         for i in range(numCloseY-1)\n                         for j in range(i+1,min(i+8, numCloseY))),\n                        key=itemgetter(0))\n        return (dm, pairm) if dm <= closestY[0] else closestY\n    else:\n        return dm, pairm\n    \ndef times():\n    \n    import timeit\n\n    functions = [bruteForceClosestPair, closestPair]\n    for f in functions:\n        print 'Time for', f.__name__, timeit.Timer(\n            '%s(pointList)' % f.__name__,\n            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)\n    \n\n\npointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)]\n\nif __name__ == '__main__':\n    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]\n    print pointList\n    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)\n    print '            closestPair:', closestPair(pointList)\n    for i in range(10):\n        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]\n        print '\\n', pointList\n        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)\n        print '           closestPair:', closestPair(pointList)\n    print '\\n'\n    times()\n    times()\n    times()\n"}
{"id": 59974, "name": "99 bottles of beer", "source": "Translate Swift to C#: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59975, "name": "99 bottles of beer", "source": "Translate Swift to C#: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59978, "name": "99 bottles of beer", "source": "Translate Swift to Java: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59979, "name": "99 bottles of beer", "source": "Translate Swift to Java: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59980, "name": "99 bottles of beer", "source": "Translate Swift to Python: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59981, "name": "99 bottles of beer", "source": "Translate Swift to Python: for i in (1...99).reversed() {\n\tprint(\"\\(i) bottles of beer on the wall, \\(i) bottles of beer.\")\n\tlet next = i == 1 ? \"no\" : (i-1).description\n\tprint(\"Take one down and pass it around, \\(next) bottles of beer on the wall.\")\n}\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60250, "name": "Concurrent computing", "source": "Translate Swift to C#: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "static Random tRand = new Random();\n\nstatic void Main(string[] args)\n{\n\tThread t = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Enjoy\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Rosetta\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Code\");\n\n\tConsole.ReadLine();\n}\n\nprivate static void WriteText(object p)\n{\n\tThread.Sleep(tRand.Next(1000, 4000));\n\tConsole.WriteLine(p);\n}\n"}
{"id": 60252, "name": "Concurrent computing", "source": "Translate Swift to Java: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "import java.util.concurrent.CyclicBarrier;\n\npublic class Threads\n{\n  public static class DelayedMessagePrinter implements Runnable\n  {\n    private CyclicBarrier barrier;\n    private String msg;\n    \n    public DelayedMessagePrinter(CyclicBarrier barrier, String msg)\n    {\n      this.barrier = barrier;\n      this.msg = msg;\n    }\n    \n    public void run()\n    {\n      try\n      {  barrier.await();  }\n      catch (Exception e)\n      {  }\n      System.out.println(msg);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    CyclicBarrier barrier = new CyclicBarrier(3);\n    new Thread(new DelayedMessagePrinter(barrier, \"Enjoy\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Rosetta\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Code\")).start();\n  }\n}\n"}
{"id": 60253, "name": "Concurrent computing", "source": "Translate Swift to Python: import Foundation\n\nlet myList = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in myList {\n    dispatch_async(dispatch_get_global_queue(0, 0)) {\n        NSLog(word)\n    }\n}\n\ndispatch_main()\n", "target": "let words = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in words:\n    (word) |> async (w) =>\n        sleep(random())\n        print(w)\n"}
{"id": 60480, "name": "Strip a set of characters from a string", "source": "Translate Swift to C#: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60482, "name": "Strip a set of characters from a string", "source": "Translate Swift to Java: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60483, "name": "Strip a set of characters from a string", "source": "Translate Swift to Python: extension String {\n  func stripCharactersInSet(chars: [Character]) -> String {\n    return String(seq: filter(self) {find(chars, $0) == nil})\n  }\n}\n\nlet aString = \"She was a soul stripper. She took my heart!\"\nlet chars: [Character] = [\"a\", \"e\", \"i\"]\n\nprintln(aString.stripCharactersInSet(chars))\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60855, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to C#: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60856, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to C#: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60859, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Java: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60860, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Java: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60861, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Python: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60862, "name": "Isqrt (integer square root) of X", "source": "Translate Swift to Python: import BigInt\n\nfunc integerSquareRoot<T: BinaryInteger>(_ num: T) -> T {\n    var x: T = num\n    var q: T = 1\n    while q <= x {\n        q <<= 2\n    }\n    var r: T = 0\n    while q > 1 {\n        q >>= 2\n        let t: T = x - r - q\n        r >>= 1\n        if t >= 0 {\n            x = t\n            r += q\n        }\n    }\n    return r\n}\n\nfunc pad(string: String, width: Int) -> String {\n    if string.count >= width {\n        return string\n    }\n    return String(repeating: \" \", count: width - string.count) + string\n}\n\nfunc commatize<T: BinaryInteger>(_ num: T) -> String {\n    let string = String(num)\n    var result = String()\n    result.reserveCapacity(4 * string.count / 3)\n    var i = 0\n    for ch in string {\n        if i > 0 && i % 3 == string.count % 3 {\n            result += \",\"\n        }\n        result.append(ch)\n        i += 1\n    }\n    return result\n}\n\nprint(\"Integer square root for numbers 0 to 65:\")\nfor n in 0...65 {\n    print(integerSquareRoot(n), terminator: \" \")\n}\n\nlet powerWidth = 83\nlet isqrtWidth = 42\nprint(\"\\n\\nInteger square roots of odd powers of 7 from 1 to 73:\")\nprint(\" n |\\(pad(string: \"7 ^ n\", width: powerWidth)) |\\(pad(string: \"isqrt(7 ^ n)\", width: isqrtWidth))\")\nprint(String(repeating: \"-\", count: powerWidth + isqrtWidth + 6))\nvar p: BigInt = 7\nfor n in stride(from: 1, through: 73, by: 2) {\n    let power = pad(string: commatize(p), width: powerWidth)\n    let isqrt = pad(string: commatize(integerSquareRoot(p)), width: isqrtWidth)\n    print(\"\\(pad(string: String(n), width: 2)) |\\(power) |\\(isqrt)\")\n    p *= 49\n}\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61175, "name": "Jewels and stones", "source": "Translate Swift to C#: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61176, "name": "Jewels and stones", "source": "Translate Swift to C#: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(Count(\"aAAbbbb\", \"Aa\"));\n        Console.WriteLine(Count(\"ZZ\", \"z\"));\n    }\n\n    private static int Count(string stones, string jewels) {\n        var bag = jewels.ToHashSet();\n        return stones.Count(bag.Contains);\n    }\n}\n"}
{"id": 61179, "name": "Jewels and stones", "source": "Translate Swift to Java: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61180, "name": "Jewels and stones", "source": "Translate Swift to Java: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class App {\n    private static int countJewels(String stones, String jewels) {\n        Set<Character> bag = new HashSet<>();\n        for (char c : jewels.toCharArray()) {\n            bag.add(c);\n        }\n\n        int count = 0;\n        for (char c : stones.toCharArray()) {\n            if (bag.contains(c)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(countJewels(\"aAAbbbb\", \"aA\"));\n        System.out.println(countJewels(\"ZZ\", \"z\"));\n    }\n}\n"}
{"id": 61181, "name": "Jewels and stones", "source": "Translate Swift to Python: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61182, "name": "Jewels and stones", "source": "Translate Swift to Python: func countJewels(_ stones: String, _ jewels: String) -> Int {\n  return stones.map({ jewels.contains($0) ? 1 : 0 }).reduce(0, +)\n}\n\nprint(countJewels(\"aAAbbbb\", \"aA\"))\nprint(countJewels(\"ZZ\", \"z\"))\n", "target": "def countJewels(s, j):\n    return sum(x in j for x in s)\n\nprint countJewels(\"aAAbbbb\", \"aA\")\nprint countJewels(\"ZZ\", \"z\")\n"}
{"id": 61440, "name": "Factorial", "source": "Translate Swift to C#: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61442, "name": "Factorial", "source": "Translate Swift to Java: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61443, "name": "Factorial", "source": "Translate Swift to Python: func factorial(_ n: Int) -> Int {\n\treturn n < 2 ? 1 : (2...n).reduce(1, *)\n}\n", "target": "import math\nmath.factorial(n)\n"}
{"id": 61648, "name": "Polynomial regression", "source": "Translate Swift to C#: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": "        public static double[] Polyfit(double[] x, double[] y, int degree)\n        {\n            \n            var v = new DenseMatrix(x.Length, degree + 1);\n            for (int i = 0; i < v.RowCount; i++)\n                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);\n            var yv = new DenseVector(y).ToColumnMatrix();\n            QR<double> qr = v.QR();\n            \n            \n            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);\n            var q = v.Multiply(r.Inverse());\n            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));\n            return p.Column(0).ToArray();\n        }\n"}
{"id": 61650, "name": "Polynomial regression", "source": "Translate Swift to Java: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": "import java.util.Arrays;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.stream.IntStream;\n\npublic class PolynomialRegression {\n    private static void polyRegression(int[] x, int[] y) {\n        int n = x.length;\n        double xm = Arrays.stream(x).average().orElse(Double.NaN);\n        double ym = Arrays.stream(y).average().orElse(Double.NaN);\n        double x2m = Arrays.stream(x).map(a -> a * a).average().orElse(Double.NaN);\n        double x3m = Arrays.stream(x).map(a -> a * a * a).average().orElse(Double.NaN);\n        double x4m = Arrays.stream(x).map(a -> a * a * a * a).average().orElse(Double.NaN);\n        double xym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            xym += x[i] * y[i];\n        }\n        xym /= Math.min(x.length, y.length);\n        double x2ym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            x2ym += x[i] * x[i] * y[i];\n        }\n        x2ym /= Math.min(x.length, y.length);\n\n        double sxx = x2m - xm * xm;\n        double sxy = xym - xm * ym;\n        double sxx2 = x3m - xm * x2m;\n        double sx2x2 = x4m - x2m * x2m;\n        double sx2y = x2ym - x2m * ym;\n\n        double b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double a = ym - b * xm - c * x2m;\n\n        IntToDoubleFunction abc = (int xx) -> a + b * xx + c * xx * xx;\n\n        System.out.println(\"y = \" + a + \" + \" + b + \"x + \" + c + \"x^2\");\n        System.out.println(\" Input  Approximation\");\n        System.out.println(\" x   y     y1\");\n        for (int i = 0; i < n; ++i) {\n            System.out.printf(\"%2d %3d  %5.1f\\n\", x[i], y[i], abc.applyAsDouble(x[i]));\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] x = IntStream.range(0, 11).toArray();\n        int[] y = new int[]{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321};\n        polyRegression(x, y);\n    }\n}\n"}
{"id": 61651, "name": "Polynomial regression", "source": "Translate Swift to Python: let x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlet y = [1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]\n\nfunc average(_ input: [Int]) -> Int {\n    return input.reduce(0, +) / input.count\n}\n\nfunc polyRegression(x: [Int], y: [Int]) {\n    let xm = average(x)\n    let ym = average(y)\n    let x2m = average(x.map { $0 * $0 })\n    let x3m = average(x.map { $0 * $0 * $0 })\n    let x4m = average(x.map { $0 * $0 * $0 * $0 })\n    let xym = average(zip(x,y).map { $0 * $1 })\n    let x2ym = average(zip(x,y).map { $0 * $0 * $1 })\n\n    let sxx = x2m - xm * xm\n    let sxy = xym - xm * ym\n    let sxx2 = x3m - xm * x2m\n    let sx2x2 = x4m - x2m * x2m\n    let sx2y = x2ym - x2m * ym\n \n    let b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)\n    let a = ym - b * xm - c * x2m\n\n    func abc(xx: Int) -> Int {\n        return (a + b * xx) + (c * xx * xx)\n    }\n    \n    print(\"y = \\(a) + \\(b)x + \\(c)x^2\\n\")\n    print(\" Input  Approximation\")\n    print(\" x   y     y1\")\n    \n    for i in 0 ..< x.count {\n        let result = Double(abc(xx: i))\n        print(String(format: \"%2d %3d  %5.1f\", x[i], y[i], result))\n    }\n}\n\npolyRegression(x: x, y: y)\n", "target": ">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]\n>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]\n>>> coeffs = numpy.polyfit(x,y,deg=2)\n>>> coeffs\narray([ 3.,  2.,  1.])\n"}
{"id": 61884, "name": "Menu", "source": "Translate Swift to C#: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61886, "name": "Menu", "source": "Translate Swift to Java: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61887, "name": "Menu", "source": "Translate Swift to Python: func getMenuInput(selections: [String]) -> String {\n  guard !selections.isEmpty else {\n    return \"\"\n  }\n\n  func printMenu() {\n    for (i, str) in selections.enumerated() {\n      print(\"\\(i + 1)) \\(str)\")\n    }\n\n    print(\"Selection: \", terminator: \"\")\n  }\n\n  while true {\n    printMenu()\n\n    guard let input = readLine(strippingNewline: true), !input.isEmpty else {\n      return \"\"\n    }\n\n    guard let n = Int(input), n > 0, n <= selections.count else {\n      continue\n    }\n\n    return selections[n - 1]\n  }\n}\n\nlet selected = getMenuInput(selections: [\n  \"fee fie\",\n  \"huff and puff\",\n  \"mirror mirror\",\n  \"tick tock\"\n])\n\nprint(\"You chose: \\(selected)\")\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62284, "name": "Greatest subsequential sum", "source": "Translate Swift to C#: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62285, "name": "Greatest subsequential sum", "source": "Translate Swift to C#: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62288, "name": "Greatest subsequential sum", "source": "Translate Swift to Java: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62289, "name": "Greatest subsequential sum", "source": "Translate Swift to Java: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62290, "name": "Greatest subsequential sum", "source": "Translate Swift to Python: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62291, "name": "Greatest subsequential sum", "source": "Translate Swift to Python: func maxSubseq(sequence: [Int]) -> (Int, Int, Int) {\n    var maxSum = 0, thisSum = 0, i = 0\n    var start = 0, end = -1\n    for (j, seq) in sequence.enumerated() {\n        thisSum += seq\n        if thisSum < 0 {\n            i = j + 1\n            thisSum = 0\n        } else if (thisSum > maxSum) {\n            maxSum = thisSum\n            start = i\n            end = j\n        }\n    }\n    return start <= end && start >= 0 && end >= 0\n        ? (start, end + 1, maxSum) : (0, 0, 0)\n}\n\nlet a = [-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]\nlet (start, end, maxSum) = maxSubseq(sequence: a)\nprint(\"Max sum = \\(maxSum)\")\nprint(a[start..<end])\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62825, "name": "Integer sequence", "source": "Translate Swift to C#: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62826, "name": "Integer sequence", "source": "Translate Swift to C#: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62829, "name": "Integer sequence", "source": "Translate Swift to Java: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62830, "name": "Integer sequence", "source": "Translate Swift to Java: var i = 0\nwhile true {\n    println(i++)\n}\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 63088, "name": "Fibonacci sequence", "source": "Translate Swift to C#: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 63090, "name": "Fibonacci sequence", "source": "Translate Swift to Java: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 63091, "name": "Fibonacci sequence", "source": "Translate Swift to Python: import Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63369, "name": "Averages_Arithmetic mean", "source": "Translate Swift to C#: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63371, "name": "Averages_Arithmetic mean", "source": "Translate Swift to Java: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63372, "name": "Averages_Arithmetic mean", "source": "Translate Swift to Python: func meanDoubles(s: [Double]) -> Double {\n  return s.reduce(0, +) / Double(s.count)\n}\nfunc meanInts(s: [Int]) -> Double {\n  return meanDoubles(s.map{Double($0)})\n}\n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63811, "name": "Sort an array of composite structures", "source": "Translate Swift to C#: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n"}
{"id": 63813, "name": "Sort an array of composite structures", "source": "Translate Swift to Java: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n"}
{"id": 63814, "name": "Sort an array of composite structures", "source": "Translate Swift to Python: extension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n", "target": "people = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n"}
{"id": 64651, "name": "Calculating the value of e", "source": "Translate Swift to C#: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64652, "name": "Calculating the value of e", "source": "Translate Swift to C#: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64655, "name": "Calculating the value of e", "source": "Translate Swift to Java: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64656, "name": "Calculating the value of e", "source": "Translate Swift to Java: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64657, "name": "Calculating the value of e", "source": "Translate Swift to Python: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64658, "name": "Calculating the value of e", "source": "Translate Swift to Python: import Foundation\n\n\nfunc calculateE(epsilon: Double = 1.0e-15) -> Double {\n  var fact: UInt64 = 1\n  var e = 2.0, e0 = 0.0\n  var n = 2\n\n  repeat {\n    e0 = e\n    fact *= UInt64(n)\n    n += 1\n    e += 1.0 / Double(fact)\n  } while fabs(e - e0) >= epsilon\n\n  return e\n}\n\nprint(String(format: \"e =\u00a0%.15f\\n\", arguments: [calculateE()]))\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64859, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to C#: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "using System; \nclass Exceptions\n{\n  class U0 : Exception { }\n  class U1 : Exception { }\n  static int i;\n  static void foo()\n  {\n    for (i = 0; i < 2; i++)\n      try\n      {\n        bar();\n      }\n      catch (U0) {\n        Console.WriteLine(\"U0 Caught\");\n      }\n  }\n  static void bar()\n  {\n    baz();\n  }\n  static void baz(){\n    if (i == 0)\n      throw new U0();\n    throw new U1();\n  }\n\n  public static void Main()\n  {\n    foo();\n  }\n}\n"}
{"id": 64861, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to Java: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "class U0 extends Exception { }\nclass U1 extends Exception { }\n\npublic class ExceptionsTest {\n    public static void foo() throws U1 {\n        for (int i = 0; i <= 1; i++) {\n            try {\n                bar(i);\n            } catch (U0 e) {\n                System.out.println(\"Function foo caught exception U0\");\n            }\n        }\n    }\n\n    public static void bar(int i) throws U0, U1 {\n        baz(i); \n    }\n\n    public static void baz(int i) throws U0, U1 {\n        if (i == 0)\n            throw new U0();\n        else\n            throw new U1();\n    }\n\n    public static void main(String[] args) throws U1 {\n        foo();\n    }\n}\n"}
{"id": 64862, "name": "Exceptions_Catch an exception thrown in a nested call", "source": "Translate Swift to Python: enum MyException : ErrorType {\n  case U0\n  case U1\n}\n\nfunc foo() throws {\n  for i in 0 ... 1 {\n    do {\n      try bar(i)\n    } catch MyException.U0 {\n      print(\"Function foo caught exception U0\")\n    }\n  }\n}\n\nfunc bar(i: Int) throws {\n  try baz(i) \n}\n\nfunc baz(i: Int) throws {\n  if i == 0 {\n    throw MyException.U0\n  } else {\n    throw MyException.U1\n  }\n}\n\ntry foo()\n", "target": "class U0(Exception): pass\nclass U1(Exception): pass\n\ndef foo():\n    for i in range(2):\n        try:\n            bar(i)\n        except U0:\n            print(\"Function foo caught exception U0\")\n\ndef bar(i):\n    baz(i) \n\ndef baz(i):\n    raise U1 if i else U0\n\nfoo()\n"}
{"id": 65076, "name": "Symmetric difference", "source": "Translate Swift to C#: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.SymmetricDifference\n{\n    public static class IEnumerableExtension\n    {\n        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)\n        {\n            return @this.Except(that).Concat(that.Except(@this));\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            var a = new[] { \"John\", \"Bob\", \"Mary\", \"Serena\" };\n            var b = new[] { \"Jim\", \"Mary\", \"John\", \"Bob\" };\n\n            foreach (var element in a.SymmetricDifference(b))\n            {\n                Console.WriteLine(element);\n            }\n        }\n    }\n}\n"}
{"id": 65078, "name": "Symmetric difference", "source": "Translate Swift to Java: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": "Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};\nSet<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};\n\n\nSet<String> notInSetA = setB.clone();\nnotInSetA.removeAll(setA);\n\nSet<String> notInSetB = setA.clone();\nnotInSetB.removeAll(setB);\n\nSet<String> symmetricDifference = new Set<String>();\nsymmetricDifference.addAll(notInSetA);\nsymmetricDifference.addAll(notInSetB);\n\n\nSet<String> union = setA.clone();\nunion.addAll(setB);\n\nSet<String> intersection = setA.clone();\nintersection.retainAll(setB);\n\nSet<String> symmetricDifference2 = union.clone();\nsymmetricDifference2.removeAll(intersection);\n\nSystem.debug('Not in set A: ' + notInSetA);\nSystem.debug('Not in set B: ' + notInSetB);\nSystem.debug('Symmetric Difference: ' + symmetricDifference);\nSystem.debug('Symmetric Difference 2: ' + symmetricDifference2);\n"}
{"id": 65079, "name": "Symmetric difference", "source": "Translate Swift to Python: let setA : Set<String> = [\"John\", \"Bob\", \"Mary\", \"Serena\"]\nlet setB : Set<String> = [\"Jim\", \"Mary\", \"John\", \"Bob\"]\nprintln(setA.exclusiveOr(setB)) \nprintln(setA.subtract(setB)) \n", "target": ">>> setA = {\"John\", \"Bob\", \"Mary\", \"Serena\"}\n>>> setB = {\"Jim\", \"Mary\", \"John\", \"Bob\"}\n>>> setA ^ setB \n{'Jim', 'Serena'}\n>>> setA - setB \n{'Serena'}\n>>> setB - setA \n{'Jim'}\n>>> setA | setB \n{'John', 'Bob', 'Jim', 'Serena', 'Mary'}\n>>> setA & setB \n{'Bob', 'John', 'Mary'}\n"}
{"id": 65287, "name": "Inheritance_Single", "source": "Translate Swift to C#: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65289, "name": "Inheritance_Single", "source": "Translate Swift to Java: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65290, "name": "Inheritance_Single", "source": "Translate Swift to Python: class Animal {\n  \n}\n\nclass Dog : Animal {\n  \n}\n\nclass Lab : Dog {\n  \n}\n\nclass Collie : Dog {\n  \n}\n\nclass Cat : Animal {\n  \n}\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 65551, "name": "Averages_Mode", "source": "Translate Swift to C#:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n     \n        static void Main(string[] args)\n        {\n            \n            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; \n\n            var query =     from numbers in myList \n                            group numbers by numbers \n                            into groupedNumbers\n                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; \n            \n            int max = query.Max(g => g.Count);\n            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);\n            foreach (var item in modes)\n            {\n                Console.WriteLine(item);\n            }\n            \n            Console.ReadLine();\n        }\n\n             \n       \n    }\n     \n    \n}\n"}
{"id": 65553, "name": "Averages_Mode", "source": "Translate Swift to Java:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); \n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); \n    }\n}\n"}
{"id": 65554, "name": "Averages_Mode", "source": "Translate Swift to Python:  \n\nextension Collection where Element: Hashable {\n\n    \n    func mode() -> Element? {\n        var frequencies = [Element: Int]()\n\n        \n        for element in self {\n            frequencies[element] = (frequencies[element] ?? 0) + 1\n        }\n\n        \n        if let ( mode, _ ) = frequencies.max(by: { $0.value < $1.value }) {\n            return mode\n        } else {\n            return nil\n        }\n    }\n\n}\n\n[\"q\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"z\", \"c\", \"c\", \"c\"].mode() \n[1, 1, 2, 3, 3, 3, 3, 4, 4, 4].mode() \n\nlet emptyArray: [Int] = []\nemptyArray.mode() \n", "target": ">>> from collections import defaultdict\n>>> def modes(values):\n\tcount = defaultdict(int)\n\tfor v in values:\n\t\tcount[v] +=1\n\tbest = max(count.values())\n\treturn [k for k,v in count.items() if v == best]\n\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\n[6]\n>>> modes((1,1,2,4,4))\n[1, 4]\n"}
{"id": 65780, "name": "Monte Carlo methods", "source": "Translate Swift to C#: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": "using System;\n\nclass Program {\n    static double MonteCarloPi(int n) {\n        int inside = 0;\n        Random r = new Random();\n\n        for (int i = 0; i < n; i++) {\n            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {\n                inside++;\n            }\n        }\n\n        return 4.0 * inside / n;\n    }\n\n    static void Main(string[] args) {\n        int value = 1000;\n        for (int n = 0; n < 5; n++) {\n            value *= 10;\n            Console.WriteLine(\"{0}:{1}\", value.ToString(\"#,###\").PadLeft(11, ' '), MonteCarloPi(value));\n        }\n    }\n}\n"}
{"id": 65782, "name": "Monte Carlo methods", "source": "Translate Swift to Java: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": "public class MC {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getPi(10000));\n\t\tSystem.out.println(getPi(100000));\n\t\tSystem.out.println(getPi(1000000));\n\t\tSystem.out.println(getPi(10000000));\n\t\tSystem.out.println(getPi(100000000));\n\t\t\n\t}\n\tpublic static double getPi(int numThrows){\n\t\tint inCircle= 0;\n\t\tfor(int i= 0;i < numThrows;i++){\n\t\t\t\n\t\t\t\n\t\t\tdouble randX= (Math.random() * 2) - 1;\n\t\t\tdouble randY= (Math.random() * 2) - 1;\n\t\t\t\n\t\t\tdouble dist= Math.sqrt(randX * randX + randY * randY);\n\t\t\t\n\t\t\tif(dist < 1){\n\t\t\t\tinCircle++;\n\t\t\t}\n\t\t}\n\t\treturn 4.0 * inCircle / numThrows;\n\t}\n}\n"}
{"id": 65783, "name": "Monte Carlo methods", "source": "Translate Swift to Python: import Foundation\n\nfunc mcpi(sampleSize size:Int) -> Double {\n    var x = 0 as Double\n    var y = 0 as Double\n    var m = 0 as Double\n    \n    for i in 0..<size {\n        x = Double(arc4random()) / Double(UINT32_MAX)\n        y = Double(arc4random()) / Double(UINT32_MAX)\n        \n        if ((x * x) + (y * y) < 1) {\n            m += 1\n        }\n    }\n    \n    return (4.0 * m) / Double(size)\n}\n\nprintln(mcpi(sampleSize: 100))\nprintln(mcpi(sampleSize: 1000))\nprintln(mcpi(sampleSize: 10000))\nprintln(mcpi(sampleSize: 100000))\nprintln(mcpi(sampleSize: 1000000))\nprintln(mcpi(sampleSize: 10000000))\nprintln(mcpi(sampleSize: 100000000))\n", "target": ">>> import random, math\n>>> throws = 1000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1520000000000001\n>>> throws = 1000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1396359999999999\n>>> throws = 100000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1415666400000002\n"}
{"id": 66138, "name": "N'th", "source": "Translate Swift to C#: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66140, "name": "N'th", "source": "Translate Swift to Java: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66141, "name": "N'th", "source": "Translate Swift to Python: func addSuffix(n:Int) -> String {\n    if n % 100 / 10 == 1 {\n        return \"th\"\n    }\n    \n    switch n % 10 {\n    case 1:\n        return \"st\"\n    case 2:\n        return \"nd\"\n    case 3:\n        return \"rd\"\n    default:\n        return \"th\"\n    }\n}\n\nfor i in 0...25 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 250...265 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\nfor i in 1000...1025 {\n    print(\"\\(i)\\(addSuffix(i)) \")\n}\nprintln()\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66623, "name": "Levenshtein distance", "source": "Translate Swift to C#: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66624, "name": "Levenshtein distance", "source": "Translate Swift to C#: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66627, "name": "Levenshtein distance", "source": "Translate Swift to Java: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66628, "name": "Levenshtein distance", "source": "Translate Swift to Java: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66629, "name": "Levenshtein distance", "source": "Translate Swift to Python: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66630, "name": "Levenshtein distance", "source": "Translate Swift to Python: func levDis(w1: String, w2: String) -> Int {\n  \n  let (t, s) = (w1.characters, w2.characters)\n  \n  let empty = Repeat(count: s.count, repeatedValue: 0)\n  var mat = [[Int](0...s.count)] + (1...t.count).map{[$0] + empty}\n  \n  for (i, tLett) in t.enumerate() {\n    for (j, sLett) in s.enumerate() {\n      mat[i + 1][j + 1] = tLett == sLett ?\n        mat[i][j] : min(mat[i][j], mat[i][j + 1], mat[i + 1][j]).successor()\n    }\n  }\n  return mat.last!.last!\n}\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 67806, "name": "Array length", "source": "Translate Swift to C#: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67807, "name": "Array length", "source": "Translate Swift to C#: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67810, "name": "Array length", "source": "Translate Swift to Java: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67811, "name": "Array length", "source": "Translate Swift to Java: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67812, "name": "Array length", "source": "Translate Swift to Python: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67813, "name": "Array length", "source": "Translate Swift to Python: let fruits = [\"apple\", \"orange\"] \nlet fruitsCount = fruits.count \n\nprint(fruitsCount) \n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 68108, "name": "Bulls and cows", "source": "Translate Swift to C#: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "using System;\n\nnamespace BullsnCows\n{\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n            KnuthShuffle<int>(ref nums);\n            int[] chosenNum = new int[4];\n            Array.Copy(nums, chosenNum, 4);\n\n            Console.WriteLine(\"Your Guess\u00a0?\");\n            while (!game(Console.ReadLine(), chosenNum))\n            {\n                Console.WriteLine(\"Your next Guess\u00a0?\");\n            }\n            \n            Console.ReadKey();\n        }\n\n        public static void KnuthShuffle<T>(ref T[] array)\n        {\n            System.Random random = new System.Random();\n            for (int i = 0; i < array.Length; i++)\n            {\n                int j = random.Next(array.Length);\n                T temp = array[i]; array[i] = array[j]; array[j] = temp;\n            }\n        }\n\n        public static bool game(string guess, int[] num)\n        {\n            char[] guessed = guess.ToCharArray();\n            int bullsCount = 0, cowsCount = 0;\n\n            if (guessed.Length != 4)\n            {\n                Console.WriteLine(\"Not a valid guess.\");\n                return false;\n            }\n\n            for (int i = 0; i < 4; i++)\n            {\n                int curguess = (int) char.GetNumericValue(guessed[i]);\n                if (curguess < 1 || curguess > 9)\n                {\n                    Console.WriteLine(\"Digit must be ge greater 0 and lower 10.\");\n                    return false;\n                }\n                if (curguess == num[i])\n                {\n                    bullsCount++;\n                }\n                else\n                {\n                    for (int j = 0; j < 4; j++)\n                    {\n                        if (curguess == num[j])\n                            cowsCount++;\n                    }\n                }\n            }\n\n            if (bullsCount == 4)\n            {\n                Console.WriteLine(\"Congratulations! You have won!\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(\"Your Score is {0} bulls and {1} cows\", bullsCount, cowsCount);\n                return false;\n            }\n        }\n    }\n}\n"}
{"id": 68110, "name": "Bulls and cows", "source": "Translate Swift to Java: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "import java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class BullsAndCows{\n\tpublic static void main(String[] args){\n\t\tRandom gen= new Random();\n\t\tint target;\n\t\twhile(hasDupes(target= (gen.nextInt(9000) + 1000)));\n\t\tString targetStr = target +\"\";\n\t\tboolean guessed = false;\n\t\tScanner input = new Scanner(System.in);\n\t\tint guesses = 0;\n\t\tdo{\n\t\t\tint bulls = 0;\n\t\t\tint cows = 0;\n\t\t\tSystem.out.print(\"Guess a 4-digit number with no duplicate digits: \");\n\t\t\tint guess;\n\t\t\ttry{\n\t\t\t\tguess = input.nextInt();\n\t\t\t\tif(hasDupes(guess) || guess < 1000) continue;\n\t\t\t}catch(InputMismatchException e){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tguesses++;\n\t\t\tString guessStr = guess + \"\";\n\t\t\tfor(int i= 0;i < 4;i++){\n\t\t\t\tif(guessStr.charAt(i) == targetStr.charAt(i)){\n\t\t\t\t\tbulls++;\n\t\t\t\t}else if(targetStr.contains(guessStr.charAt(i)+\"\")){\n\t\t\t\t\tcows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bulls == 4){\n\t\t\t\tguessed = true;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(cows+\" Cows and \"+bulls+\" Bulls.\");\n\t\t\t}\n\t\t}while(!guessed);\n\t\tSystem.out.println(\"You won after \"+guesses+\" guesses!\");\n\t}\n\n\tpublic static boolean hasDupes(int num){\n\t\tboolean[] digs = new boolean[10];\n\t\twhile(num > 0){\n\t\t\tif(digs[num%10]) return true;\n\t\t\tdigs[num%10] = true;\n\t\t\tnum/= 10;\n\t\t}\n\t\treturn false;\n\t}\n}\n"}
{"id": 68111, "name": "Bulls and cows", "source": "Translate Swift to Python: func generateRandomNumArray(numDigits: Int = 4) -> [Character]\n{\n\tguard (1 ... 9).contains(numDigits) else { fatalError(\"number out of range\") }\n\n\treturn Array(\"123456789\".shuffled()[0 ..< numDigits])\n}\n\nfunc parseGuess(_ guess: String, numDigits: Int = 4) -> String?\n{\n\tguard guess.count == numDigits else { return nil }\n    \n\tlet guessArray = guess.filter{ $0.isASCII && $0.isWholeNumber }\n\n  \tguard Set(guessArray).count == numDigits else { return nil }\n\n  \treturn guessArray\n}\n\nfunc pluralIfNeeded(_ count: Int, _ units: String) -> String\n{\n\treturn \"\\(count) \" + units + (count == 1 ? \"\" : \"s\")\n}\n\nvar guessAgain = \"y\"\nwhile guessAgain == \"y\"\n{\n  \tlet num = generateRandomNumArray()\n  \tvar bulls = 0\n  \tvar cows = 0\n\n  \tprint(\"Please enter a 4 digit number with digits between 1-9, no repetitions: \")\n\n  \tif let guessStr = readLine(strippingNewline: true), let guess = parseGuess(guessStr)\n\t{\n\t\tfor (guess, actual) in zip(guess, num)\n\t\t{\n\t\t\tif guess == actual\n\t\t\t{\n\t  \t\t\tbulls += 1\n\t\t\t}\n\t\t\telse if num.contains(guess)\n\t\t\t{\n\t  \t\t\tcows += 1\n\t\t\t}\n  \t\t}\n\n\t\tprint(\"Actual number: \" + num)\n\t\tprint(\"Your score: \\(pluralIfNeeded(bulls, \"bull\")) and \\(pluralIfNeeded(cows, \"cow\"))\\n\")\n\t\tprint(\"Would you like to play again? (y): \")\n\n\t\tguessAgain = readLine(strippingNewline: true)?.lowercased() ?? \"n\"\n\t}\n\telse\n\t{\n\t\tprint(\"Invalid input\")\n  \t}\n}\n", "target": "\n\nimport random\n\ndigits = '123456789'\nsize = 4\nchosen = ''.join(random.sample(digits,size))\n\nprint  % (size, size)\nguesses = 0\nwhile True:\n    guesses += 1\n    while True:\n        \n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\n        if len(guess) == size and \\\n           all(char in digits for char in guess) \\\n           and len(set(guess)) == size:\n            break\n        print \"Problem, try again. You need to enter %i unique digits from 1 to 9\" % size\n    if guess == chosen:\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\n        break\n    bulls = cows = 0\n    for i in range(size):\n        if guess[i] == chosen[i]:\n            bulls += 1\n        elif guess[i] in chosen:\n            cows += 1\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)\n"}
{"id": 68287, "name": "Chowla numbers", "source": "Translate Swift to C#: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "using System;\n\nnamespace chowla_cs\n{\n    class Program\n    {\n        static int chowla(int n)\n        {\n            int sum = 0;\n            for (int i = 2, j; i * i <= n; i++)\n                if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n            return sum;\n        }\n\n        static bool[] sieve(int limit)\n        {\n            \n            \n            bool[] c = new bool[limit];\n            for (int i = 3; i * 3 < limit; i += 2)\n                if (!c[i] && (chowla(i) == 0))\n                    for (int j = 3 * i; j < limit; j += 2 * i)\n                        c[j] = true;\n            return c;\n        }\n\n        static void Main(string[] args)\n        {\n            for (int i = 1; i <= 37; i++)\n                Console.WriteLine(\"chowla({0}) = {1}\", i, chowla(i));\n            int count = 1, limit = (int)(1e7), power = 100;\n            bool[] c = sieve(limit);\n            for (int i = 3; i < limit; i += 2)\n            {\n                if (!c[i]) count++;\n                if (i == power - 1)\n                {\n                    Console.WriteLine(\"Count of primes up to {0,10:n0} = {1:n0}\", power, count);\n                    power *= 10;\n                }\n            }\n\n            count = 0; limit = 35000000;\n            int k = 2, kk = 3, p;\n            for (int i = 2; ; i++)\n            {\n                if ((p = k * kk) > limit) break;\n                if (chowla(p) == p - 1)\n                {\n                    Console.WriteLine(\"{0,10:n0} is a number that is perfect\", p);\n                    count++;\n                }\n                k = kk + 1; kk += k;\n            }\n            Console.WriteLine(\"There are {0} perfect numbers <= 35,000,000\", count);\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 68289, "name": "Chowla numbers", "source": "Translate Swift to Java: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "public class Chowla {\n\n    public static void main(String[] args) {\n        int[] chowlaNumbers = findChowlaNumbers(37);\n        for (int i = 0; i < chowlaNumbers.length; i++) {\n            System.out.printf(\"chowla(%d) = %d%n\", (i+1), chowlaNumbers[i]);\n        }\n        System.out.println();\n\n        int[][] primes = countPrimes(100, 10_000_000);\n        for (int i = 0; i < primes.length; i++) {\n            System.out.printf(Locale.US, \"There is\u00a0%,d primes up to\u00a0%,d%n\", primes[i][1], primes[i][0]);\n        }\n        System.out.println();\n\n        int[] perfectNumbers = findPerfectNumbers(35_000_000);\n        for (int i = 0; i < perfectNumbers.length; i++) {\n            System.out.printf(\"%d is a perfect number%n\", perfectNumbers[i]);\n        }\n        System.out.printf(Locale.US, \"There are %d perfect numbers <\u00a0%,d%n\", perfectNumbers.length, 35_000_000);\n    }\n\n    public static int chowla(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n is not positive\");\n        int sum = 0;\n        for (int i = 2, j; i * i <= n; i++)\n            if (n % i == 0) sum += i + (i == (j = n / i) ? 0 : j);\n        return sum;\n    }\n\n    protected static int[][] countPrimes(int power, int limit) {\n        int count = 0;\n        int[][] num = new int[countMultiplicity(limit, power)][2];\n        for (int n = 2, i=0;  n <= limit; n++) {\n            if (chowla(n) == 0) count++;\n            if (n % power == 0) {\n                num[i][0] = power;\n                num[i][1] = count;\n                i++;\n                power *= 10;\n            }\n        }\n        return num;\n    }\n\n    protected static int countMultiplicity(int limit, int start) {\n        int count = 0;\n        int cur = limit;\n        while(cur >= start) {\n            count++;\n            cur = cur/10;\n        }\n        return count;\n    }\n\n    protected static int[] findChowlaNumbers(int limit) {\n        int[] num = new int[limit];\n        for (int i = 0; i < limit; i++) {\n            num[i] = chowla(i+1);\n        }\n        return num;\n    }\n\n    protected static int[] findPerfectNumbers(int limit) {\n        int count = 0;\n        int[] num = new int[count];\n\n        int k = 2, kk = 3, p;\n        while ((p = k * kk) < limit) {\n            if (chowla(p) == p - 1) {\n                num = increaseArr(num);\n                num[count++] = p;\n            }\n            k = kk + 1;\n            kk += k;\n        }\n        return num;\n    }\n\n    private static int[] increaseArr(int[] arr) {\n        int[] tmp = new int[arr.length + 1];\n        System.arraycopy(arr, 0, tmp, 0, arr.length);\n        return tmp;\n    }\n}\n"}
{"id": 68290, "name": "Chowla numbers", "source": "Translate Swift to Python: import Foundation\n\n@inlinable\npublic func chowla<T: BinaryInteger>(n: T) -> T {\n  stride(from: 2, to: T(Double(n).squareRoot()+1), by: 1)\n    .lazy\n    .filter({ n % $0 == 0 })\n    .reduce(0, {(s: T, m: T) in\n      m*m == n ? s + m : s + m + (n / m)\n    })\n}\n\nextension Dictionary where Key == ClosedRange<Int> {\n  subscript(n: Int) -> Value {\n    get {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      return self[key]!\n    }\n\n    set {\n      guard let key = keys.first(where: { $0.contains(n) }) else {\n        fatalError(\"dict does not contain range for \\(n)\")\n      }\n\n      self[key] = newValue\n    }\n  }\n}\n\nlet lock = DispatchSemaphore(value: 1)\n\nvar perfect = [Int]()\nvar primeCounts = [\n  1...100: 0,\n  101...1_000: 0,\n  1_001...10_000: 0,\n  10_001...100_000: 0,\n  100_001...1_000_000: 0,\n  1_000_001...10_000_000: 0\n]\n\nfor i in 1...37 {\n  print(\"chowla(\\(i)) = \\(chowla(n: i))\")\n}\n\nDispatchQueue.concurrentPerform(iterations: 35_000_000) {i in\n  let chowled = chowla(n: i)\n\n  if chowled == 0 && i > 1 && i < 10_000_000 {\n    lock.wait()\n    primeCounts[i] += 1\n    lock.signal()\n  }\n\n  if chowled == i - 1 && i > 1 {\n    lock.wait()\n    perfect.append(i)\n    lock.signal()\n  }\n}\n\nlet numPrimes = primeCounts\n  .sorted(by: { $0.key.lowerBound < $1.key.lowerBound })\n  .reduce(into: [(Int, Int)](), {counts, oneCount in\n    guard !counts.isEmpty else {\n      counts.append((oneCount.key.upperBound, oneCount.value))\n\n      return\n    }\n\n    counts.append((oneCount.key.upperBound, counts.last!.1 + oneCount.value))\n  })\n\nfor (upper, count) in numPrimes {\n  print(\"Number of primes < \\(upper) = \\(count)\")\n}\n\nfor p in perfect {\n  print(\"\\(p) is a perfect number\")\n}\n", "target": "\nfrom sympy import divisors\n\ndef chowla(n):\n    return 0 if n < 2 else sum(divisors(n, generator=True)) - 1 -n\n\ndef is_prime(n):\n    return chowla(n) == 0\n\ndef primes_to(n):\n    return sum(chowla(i) == 0 for i in range(2, n))\n\ndef perfect_between(n, m):\n    c = 0\n    print(f\"\\nPerfect numbers between [{n:_}, {m:_})\")\n    for i in range(n, m):\n        if i > 1 and chowla(i) == i - 1:\n            print(f\"  {i:_}\")\n            c += 1\n    print(f\"Found {c} Perfect numbers between [{n:_}, {m:_})\")\n    \n\nif __name__ == '__main__':\n    for i in range(1, 38):\n        print(f\"chowla({i:2}) == {chowla(i)}\")\n    for i in range(2, 6):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1, 1_000_000)\n    print()\n    for i in range(6, 8):\n        print(f\"primes_to({10**i:_}) == {primes_to(10**i):_}\")\n    perfect_between(1_000_000, 35_000_000)\n"}
{"id": 68686, "name": "Accumulator factory", "source": "Translate Swift to C#: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68687, "name": "Accumulator factory", "source": "Translate Swift to C#: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68690, "name": "Accumulator factory", "source": "Translate Swift to Java: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68691, "name": "Accumulator factory", "source": "Translate Swift to Java: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68692, "name": "Accumulator factory", "source": "Translate Swift to Python: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68693, "name": "Accumulator factory", "source": "Translate Swift to Python: func makeAccumulator(var sum: Double) -> Double -> Double {\n  return {\n    sum += $0\n    return sum\n  }\n}\n\nlet x = makeAccumulator(1)\nx(5)\nlet _ = makeAccumulator(3)\nprintln(x(2.3))\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 69384, "name": "Averages_Root mean square", "source": "Translate Swift to C#: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69385, "name": "Averages_Root mean square", "source": "Translate Swift to C#: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69388, "name": "Averages_Root mean square", "source": "Translate Swift to Java: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69389, "name": "Averages_Root mean square", "source": "Translate Swift to Java: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69390, "name": "Averages_Root mean square", "source": "Translate Swift to Python: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69391, "name": "Averages_Root mean square", "source": "Translate Swift to Python: extension Collection where Element: FloatingPoint {\n  @inlinable\n  public func rms() -> Element {\n    return (lazy.map({ $0 * $0 }).reduce(0, +) / Element(count)).squareRoot()\n  }\n}\n\nprint(\"RMS of 1...10: \\((1...10).map(Double.init).rms())\")\n", "target": "sqrt(mean(x\u00b2))\n"}
{"id": 69774, "name": "Pi", "source": "Translate Swift to C#: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n"}
{"id": 69776, "name": "Pi", "source": "Translate Swift to Java: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "import java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n"}
{"id": 69777, "name": "Pi", "source": "Translate Swift to Python: \n\n\n\n\n\n\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n", "target": "def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n"}
{"id": 70339, "name": "Loops_Foreach", "source": "Translate Swift to C#: for i in [1,2,3] {\n   print(i)\n}\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70341, "name": "Loops_Foreach", "source": "Translate Swift to Java: for i in [1,2,3] {\n   print(i)\n}\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 71363, "name": "Order two numerical lists", "source": "Translate Swift to C#: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71364, "name": "Order two numerical lists", "source": "Translate Swift to C#: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "namespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n"}
{"id": 71367, "name": "Order two numerical lists", "source": "Translate Swift to Java: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71368, "name": "Order two numerical lists", "source": "Translate Swift to Java: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n"}
{"id": 71369, "name": "Order two numerical lists", "source": "Translate Swift to Python: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71370, "name": "Order two numerical lists", "source": "Translate Swift to Python: let a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) \n", "target": ">>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n"}
{"id": 71950, "name": "Combinations with repetitions", "source": "Translate Swift to C#: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MultiCombinations\n{\n    private static void Main()\n    {\n        var set = new List<string> { \"iced\", \"jam\", \"plain\" };\n        var combinations = GenerateCombinations(set, 2);\n\n        foreach (var combination in combinations)\n        {\n            string combinationStr = string.Join(\" \", combination);\n            Console.WriteLine(combinationStr);\n        }\n\n        var donuts = Enumerable.Range(1, 10).ToList();\n\n        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;\n\n        Console.WriteLine(\"{0} ways to order 3 donuts given 10 types\", donutsCombinationsNumber);\n    }\n    \n    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)\n    {\n        var combinations = new List<List<T>>();\n\n        if (k == 0)\n        {\n            var emptyCombination = new List<T>();\n            combinations.Add(emptyCombination);\n\n            return combinations;\n        }\n\n        if (combinationList.Count == 0)\n        {\n            return combinations;\n        }\n\n        T head = combinationList[0];\n        var copiedCombinationList = new List<T>(combinationList);\n        \n        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);\n\n        foreach (var subcombination in subcombinations)\n        {\n            subcombination.Insert(0, head);\n            combinations.Add(subcombination);\n        }\n\n        combinationList.RemoveAt(0);\n        combinations.AddRange(GenerateCombinations(combinationList, k));\n\n        return combinations;\n    }\n}\n"}
{"id": 71952, "name": "Combinations with repetitions", "source": "Translate Swift to Java: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": "import com.objectwave.utility.*;\n\npublic class MultiCombinationsTester {\n\n    public MultiCombinationsTester() throws CombinatoricException {\n        Object[] objects = {\"iced\", \"jam\", \"plain\"};\n        \n        \n        \n        MultiCombinations mc = new MultiCombinations(objects, 2);\n        while (mc.hasMoreElements()) {\n            for (int i = 0; i < mc.nextElement().length; i++) {\n                System.out.print(mc.nextElement()[i].toString() + \" \");\n            }\n            System.out.println();\n        }\n\n        \n        System.out.println(\"----------\");\n        System.out.println(\"The ways to choose 3 items from 10 with replacement = \" + MultiCombinations.c(10, 3));\n    } \n\n    public static void main(String[] args) throws CombinatoricException {\n        new MultiCombinationsTester();\n    }\n} \n"}
{"id": 71953, "name": "Combinations with repetitions", "source": "Translate Swift to Python: func combosWithRep<T>(var objects: [T], n: Int) -> [[T]] {\n  if n == 0 { return [[]] } else {\n    var combos = [[T]]()\n    while let element = objects.last {\n      combos.appendContentsOf(combosWithRep(objects, n: n - 1).map{ $0 + [element] })\n      objects.removeLast()\n    }\n    return combos\n  }\n}\nprint(combosWithRep([\"iced\", \"jam\", \"plain\"], n: 2).map {$0.joinWithSeparator(\" and \")}.joinWithSeparator(\"\\n\"))\n", "target": ">>> from itertools import combinations_with_replacement\n>>> n, k = 'iced jam plain'.split(), 2\n>>> list(combinations_with_replacement(n,k))\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\n>>> \n>>> len(list(combinations_with_replacement(range(10), 3)))\n220\n>>>\n"}
{"id": 72307, "name": "Multiple distinct objects", "source": "Translate Swift to C#: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72308, "name": "Multiple distinct objects", "source": "Translate Swift to C#: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72311, "name": "Multiple distinct objects", "source": "Translate Swift to Java: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72312, "name": "Multiple distinct objects", "source": "Translate Swift to Java: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72313, "name": "Multiple distinct objects", "source": "Translate Swift to Python: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "[Foo()] * n \n"}
{"id": 72314, "name": "Multiple distinct objects", "source": "Translate Swift to Python: class Foo { }\n\nvar foos = [Foo]()\nfor i in 0..<n {\n    foos.append(Foo())\n}\n\n\nvar foos_WRONG = [Foo](count: n, repeatedValue: Foo())  \n", "target": "[Foo()] * n \n"}
{"id": 72858, "name": "Bell numbers", "source": "Translate Swift to C#: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72859, "name": "Bell numbers", "source": "Translate Swift to C#: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace BellNumbers {\n    public static class Utility {\n        public static void Init<T>(this T[] array, T value) {\n            if (null == array) return;\n            for (int i = 0; i < array.Length; ++i) {\n                array[i] = value;\n            }\n        }\n    }\n\n    class Program {\n        static BigInteger[][] BellTriangle(int n) {\n            BigInteger[][] tri = new BigInteger[n][];\n            for (int i = 0; i < n; ++i) {\n                tri[i] = new BigInteger[i];\n                tri[i].Init(BigInteger.Zero);\n            }\n            tri[1][0] = 1;\n            for (int i = 2; i < n; ++i) {\n                tri[i][0] = tri[i - 1][i - 2];\n                for (int j = 1; j < i; ++j) {\n                    tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1];\n                }\n            }\n            return tri;\n        }\n\n        static void Main(string[] args) {\n            var bt = BellTriangle(51);\n            Console.WriteLine(\"First fifteen and fiftieth Bell numbers:\");\n            for (int i = 1; i < 16; ++i) {\n                Console.WriteLine(\"{0,2}: {1}\", i, bt[i][0]);\n            }\n            Console.WriteLine(\"50: {0}\", bt[50][0]);\n            Console.WriteLine();\n            Console.WriteLine(\"The first ten rows of Bell's triangle:\");\n            for (int i = 1; i < 11; ++i) {\n                \n                var it = bt[i].GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n        }\n    }\n}\n"}
{"id": 72862, "name": "Bell numbers", "source": "Translate Swift to Java: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72863, "name": "Bell numbers", "source": "Translate Swift to Java: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Bell {\n    private static class BellTriangle {\n        private List<Integer> arr;\n\n        BellTriangle(int n) {\n            int length = n * (n + 1) / 2;\n            arr = new ArrayList<>(length);\n            for (int i = 0; i < length; ++i) {\n                arr.add(0);\n            }\n\n            set(1, 0, 1);\n            for (int i = 2; i <= n; ++i) {\n                set(i, 0, get(i - 1, i - 2));\n                for (int j = 1; j < i; ++j) {\n                    int value = get(i, j - 1) + get(i - 1, j - 1);\n                    set(i, j, value);\n                }\n            }\n        }\n\n        private int index(int row, int col) {\n            if (row > 0 && col >= 0 && col < row) {\n                return row * (row - 1) / 2 + col;\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int get(int row, int col) {\n            int i = index(row, col);\n            return arr.get(i);\n        }\n\n        public void set(int row, int col, int value) {\n            int i = index(row, col);\n            arr.set(i, value);\n        }\n    }\n\n    public static void main(String[] args) {\n        final int rows = 15;\n        BellTriangle bt = new BellTriangle(rows);\n\n        System.out.println(\"First fifteen Bell numbers:\");\n        for (int i = 0; i < rows; ++i) {\n            System.out.printf(\"%2d: %d\\n\", i + 1, bt.get(i + 1, 0));\n        }\n\n        for (int i = 1; i <= 10; ++i) {\n            System.out.print(bt.get(i, 0));\n            for (int j = 1; j < i; ++j) {\n                System.out.printf(\", %d\", bt.get(i, j));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 72864, "name": "Bell numbers", "source": "Translate Swift to Python: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 72865, "name": "Bell numbers", "source": "Translate Swift to Python: public struct BellTriangle<T: BinaryInteger> {\n  @usableFromInline\n  var arr: [T]\n\n  @inlinable\n  public internal(set) subscript(row row: Int, col col: Int) -> T {\n    get { arr[row * (row - 1) / 2 + col] }\n    set { arr[row * (row - 1) / 2 + col] = newValue }\n  }\n\n  @inlinable\n  public init(n: Int) {\n    arr = Array(repeating: 0, count: n * (n + 1) / 2)\n\n    self[row: 1, col: 0] = 1\n\n    for i in 2...n {\n      self[row: i, col: 0] = self[row: i - 1, col: i - 2]\n\n      for j in 1..<i {\n        self[row: i, col: j] = self[row: i, col: j - 1] + self[row: i - 1, col: j - 1]\n      }\n    }\n  }\n}\n\nlet tri = BellTriangle<Int>(n: 15)\n\nprint(\"First 15 Bell numbers:\")\n\nfor i in 1...15 {\n  print(\"\\(i): \\(tri[row: i, col: 0])\")\n}\n\nfor i in 1...10 {\n  print(tri[row: i, col: 0], terminator: \"\")\n\n  for j in 1..<i {\n    print(\", \\(tri[row: i, col: j])\", terminator: \"\")\n  }\n\n  print()\n}\n", "target": "def bellTriangle(n):\n    tri = [None] * n\n    for i in xrange(n):\n        tri[i] = [0] * i\n    tri[1][0] = 1\n    for i in xrange(2, n):\n        tri[i][0] = tri[i - 1][i - 2]\n        for j in xrange(1, i):\n            tri[i][j] = tri[i][j - 1] + tri[i - 1][j - 1]\n    return tri\n\ndef main():\n    bt = bellTriangle(51)\n    print \"First fifteen and fiftieth Bell numbers:\"\n    for i in xrange(1, 16):\n        print \"%2d: %d\" % (i, bt[i][0])\n    print \"50:\", bt[50][0]\n    print\n    print \"The first ten rows of Bell's triangle:\"\n    for i in xrange(1, 11):\n        print bt[i]\n\nmain()\n"}
{"id": 73250, "name": "Modular exponentiation", "source": "Translate Swift to C#: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73251, "name": "Modular exponentiation", "source": "Translate Swift to C#: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main() {\n        var a = BigInteger.Parse(\"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        var b = BigInteger.Parse(\"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        var m = BigInteger.Pow(10, 40);\n        Console.WriteLine(BigInteger.ModPow(a, b, m));\n    }\n}\n"}
{"id": 73254, "name": "Modular exponentiation", "source": "Translate Swift to Java: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73255, "name": "Modular exponentiation", "source": "Translate Swift to Java: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "import java.math.BigInteger;\n\npublic class PowMod {\n    public static void main(String[] args){\n        BigInteger a = new BigInteger(\n      \"2988348162058574136915891421498819466320163312926952423791023078876139\");\n        BigInteger b = new BigInteger(\n      \"2351399303373464486466122544523690094744975233415544072992656881240319\");\n        BigInteger m = new BigInteger(\"10000000000000000000000000000000000000000\");\n        \n        System.out.println(a.modPow(b, m));\n    }\n}\n"}
{"id": 73256, "name": "Modular exponentiation", "source": "Translate Swift to Python: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73257, "name": "Modular exponentiation", "source": "Translate Swift to Python: import BigInt\n\nfunc modPow<T: BinaryInteger>(n: T, e: T, m: T) -> T {\n  guard e != 0 else {\n    return 1\n  }\n\n  var res = T(1)\n  var base = n % m\n  var exp = e\n\n  while true {\n    if exp & 1 == 1 {\n      res *= base\n      res %= m\n    }\n\n    if exp == 1 {\n      return res\n    }\n\n    exp /= 2\n    base *= base\n    base %= m\n  }\n}\n\nlet a = BigInt(\"2988348162058574136915891421498819466320163312926952423791023078876139\")\nlet b = BigInt(\"2351399303373464486466122544523690094744975233415544072992656881240319\")\n\nprint(modPow(n: a, e: b, m: BigInt(10).power(40)))\n", "target": "a = 2988348162058574136915891421498819466320163312926952423791023078876139\nb = 2351399303373464486466122544523690094744975233415544072992656881240319\nm = 10 ** 40\nprint(pow(a, b, m))\n"}
{"id": 73530, "name": "Josephus problem", "source": "Translate Swift to C#: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": "namespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n"}
{"id": 73532, "name": "Josephus problem", "source": "Translate Swift to Java: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": "import java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n"}
{"id": 73533, "name": "Josephus problem", "source": "Translate Swift to Python: class Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n", "target": ">>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n"}
{"id": 73760, "name": "Pathological floating point problems", "source": "Translate Swift to C#: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73761, "name": "Pathological floating point problems", "source": "Translate Swift to Java: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73762, "name": "Pathological floating point problems", "source": "Translate Swift to Java: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73763, "name": "Pathological floating point problems", "source": "Translate Swift to Python: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73764, "name": "Pathological floating point problems", "source": "Translate Swift to Python: extension Numeric where Self: Strideable {\n  @inlinable\n  public func power(_ n: Self) -> Self {\n    return stride(from: 0, to: n, by: 1).lazy.map({_ in self }).reduce(1, *)\n  }\n}\n\nprotocol PathologicalFloat: SignedNumeric, Strideable, ExpressibleByFloatLiteral {\n  static var e: Self { get }\n\n  static func /(_ lhs: Self, _ rhs: Self) -> Self\n}\n\nextension Double: PathologicalFloat {\n  static var e: Double { Double(\"2.71828182845904523536028747135266249\")! }\n}\n\nextension Float: PathologicalFloat {\n  static var e: Float { Float(\"2.7182818284590\")! }\n}\n\nextension Decimal: PathologicalFloat {\n  static var e: Decimal { Decimal(string: \"2.71828182845904523536028747135266249\")! }\n}\n\nextension BDouble: PathologicalFloat {\n  static var e: BDouble { BDouble(\"2.71828182845904523536028747135266249\")! }\n\n  public func advanced(by n: BDouble) -> BDouble { self + n }\n  public func distance(to other: BDouble) -> BDouble { abs(self - other) }\n}\n\nfunc badSequence<T: PathologicalFloat>(n: Int) -> T {\n  guard n != 1 else { return 2 }\n  guard n != 2 else { return -4 }\n\n  var a: T = 2, b: T = -4\n\n  for _ in stride(from: 2, to: n, by: 1) {\n    (a, b) = (b, 111 - 1130  / b + 3000 / (a * b))\n  }\n\n  return b\n}\n\nfunc chaoticBank<T: PathologicalFloat>(years: T) -> T {\n  var balance = T.e - 1\n\n  for year: T in stride(from: 1, through: 25, by: 1) {\n    balance = (balance * year) - 1\n  }\n\n  return balance\n}\n\nfunc rumpFunction<T: PathologicalFloat>(_ a: T, _ b: T) -> T {\n  let aSquared = a.power(2)\n  let bSix = b.power(6)\n\n  let f1 = 333.75 * bSix\n  let f2 = aSquared * (11 * aSquared * b.power(2) - bSix - 121 * b.power(4) - 2)\n  let f3 = 5.5 * b.power(8) + a / (2 * b)\n\n  return f1 + f2 + f3\n}\n\nfunc fmt<T: CVarArg>(_ n: T) -> String { String(format: \"%16.16f\", n) }\n\nprint(\"Bad sequence\")\nfor i in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100] {\n  let vFloat: Float = badSequence(n: i)\n  let vDouble: Double = badSequence(n: i)\n  let vDecimal: Decimal = badSequence(n: i)\n  let vBigDouble: BDouble = badSequence(n: i)\n\n  print(\"v(\\(i)) as Float \\(fmt(vFloat)); as Double = \\(fmt(vDouble)); as Decimal = \\(vDecimal); as BDouble = \\(vBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n}\n\n\nlet bankFloat: Float = chaoticBank(years: 25)\nlet bankDouble: Double = chaoticBank(years: 25)\nlet bankDecimal: Decimal = chaoticBank(years: 25)\nlet bankBigDouble: BDouble = chaoticBank(years: 25)\n\nprint(\"\\nChaotic bank\")\nprint(\"After 25 years your bank will be \\(bankFloat) if stored as a Float\")\nprint(\"After 25 years your bank will be \\(bankDouble) if stored as a Double\")\nprint(\"After 25 years your bank will be \\(bankDecimal) if stored as a Decimal\")\nprint(\"After 25 years your bank will be \\(bankBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false)) if stored as a BigDouble\")\n\nlet rumpFloat: Float = rumpFunction(77617.0, 33096.0)\nlet rumpDouble: Double = rumpFunction(77617.0, 33096.0)\nlet rumpDecimal: Decimal = rumpFunction(77617.0, 33096.0)\nlet rumpBigDouble: BDouble = rumpFunction(77617.0, 33096.0)\n\nprint(\"\\nRump's function\")\nprint(\"rump(77617.0, 33096.0) as Float \\(rumpFloat); as Double = \\(rumpDouble); as Decimal = \\(rumpDecimal); as BDouble = \\(rumpBigDouble.decimalExpansion(precisionAfterDecimalPoint: 16, rounded: false))\")\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 74465, "name": "Array concatenation", "source": "Translate Swift to C#: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74467, "name": "Array concatenation", "source": "Translate Swift to Java: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74468, "name": "Array concatenation", "source": "Translate Swift to Python: let array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 74731, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to C#: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    \n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        \n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound >> 1; divisor++)\n            for (int i = divisor << 1; i <= bound; i += divisor)\n                sum[i] += divisor;\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] > i) abundant++;\n            else if (sum[i] == i) perfect++;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0; int sum = 0;\n        for (int i = 2, d, r = 1; i <= bound; i++) {\n            if ((d = r * r - i) < 0) r++;\n            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;\n            if (d == 0) sum += r;\n            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }\n            sum = 1;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        for (int i = 2; i <= bound; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => i % div == 0).Sum();\n            switch (sum.CompareTo(i)) {\n                case 0: perfect++; break;\n                case 1: abundant++; break;\n            }\n        }\n        deficient = bound - abundant - perfect;\n    }\n}\n"}
{"id": 74733, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to Java: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n \n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n \n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n \n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"}
{"id": 74734, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Swift to Python: var deficients = 0 \nvar perfects = 0 \nvar abundants = 0 \n\n\ndeficients++\n\n\nfor i in 2...20000 {\n\n    var sumPd = 1 \n    \n    var maxPdToTest = i/2 \n\n    for var j = 2; j < maxPdToTest; j++ {\n        \n        if (i%j) == 0 {\n            \n            sumPd += j\n            \n            \n            maxPdToTest = i / j\n            \n            \n            if maxPdToTest != j {\n                sumPd += maxPdToTest\n            }\n        }\n    }\n    \n    \n    if sumPd < i {\n        deficients++\n    } else if sumPd > i {\n        abundants++\n    } else {\n        perfects++\n    }\n}\n\nprintln(\"There are \\(deficients) deficient, \\(perfects) perfect and \\(abundants) abundant integers from 1 to 20000.\")\n", "target": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>> \n>>> rangemax = 20000\n>>> \n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n... \n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n... \n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"}
{"id": 74896, "name": "Leonardo numbers", "source": "Translate Swift to C#: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n"}
{"id": 74898, "name": "Leonardo numbers", "source": "Translate Swift to Java: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n"}
{"id": 74899, "name": "Leonardo numbers", "source": "Translate Swift to Python: struct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n", "target": "def Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n"}
{"id": 75104, "name": "Variadic function", "source": "Translate Swift to C#: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        PrintAll(\"test\", \"rosetta code\", 123, 5.6);\n    }\n\n    static void PrintAll(params object[] varargs) {\n        foreach (var i in varargs) {\n            Console.WriteLine(i);\n        }\n    }\n}\n"}
{"id": 75106, "name": "Variadic function", "source": "Translate Swift to Java: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "module VariadicFunction\n    {\n    void show(String[] strings)\n        {\n        @Inject Console console;\n        strings.forEach(s -> console.print(s));\n        }\n\n    void run()\n        {\n        show([\"hello\", \"world\"]);\n\n        String s1 = \"not\";\n        String s2 = \"a\";\n        String s3 = \"constant\";\n        String s4 = \"literal\";\n        show([s1, s2, s3, s4]);\n        }\n    }\n"}
{"id": 75107, "name": "Variadic function", "source": "Translate Swift to Python: func printAll<T>(things: T...) {\n  \n  for i in things {\n    print(i)\n  }\n}\n", "target": "def print_all(*things):\n    for x in things:\n        print x\n"}
{"id": 75781, "name": "Exponentiation operator", "source": "Translate Swift to C#: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"5^5 = \" + Expon(5, 5));\n\tConsole.WriteLine(\"5.5^5 = \" + Expon(5.5, 5));\n\tConsole.ReadLine();\n}\n\nstatic double Expon(int Val, int Pow) \n{\n\treturn Math.Pow(Val, Pow);\n}\nstatic double Expon(double Val, int Pow)\n{\n\treturn Math.Pow(Val, Pow);\n}\n"}
{"id": 75783, "name": "Exponentiation operator", "source": "Translate Swift to Java: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "public class Exp{\n   public static void main(String[] args){\n      System.out.println(pow(2,30));\n      System.out.println(pow(2.0,30)); \n      System.out.println(pow(2.0,-2));\n   }\n\n   public static double pow(double base, int exp){\n      if(exp < 0) return 1 / pow(base, -exp);\n      double ans = 1.0;\n      for(;exp > 0;--exp) ans *= base;\n      return ans;\n   }\n}\n"}
{"id": 75784, "name": "Exponentiation operator", "source": "Translate Swift to Python: func raise<T: Numeric>(_ base: T, to exponent: Int) -> T {\n    precondition(exponent >= 0, \"Exponent has to be nonnegative\")\n    return Array(repeating: base, count: exponent).reduce(1, *)\n}\n\ninfix operator **: MultiplicationPrecedence\n\nfunc **<T: Numeric>(lhs: T, rhs: Int) -> T {\n    return raise(lhs, to: rhs)\n}\n\nlet someFloat: Float = 2\nlet someInt: Int = 10\n\nassert(raise(someFloat, to: someInt) == 1024)\nassert(someFloat ** someInt == 1024)\nassert(raise(someInt, to: someInt) == 10000000000)\nassert(someInt ** someInt == 10000000000)\n", "target": "MULTIPLY = lambda x, y: x*y\n\nclass num(float):\n    \n    \n    def __pow__(self, b):\n        return reduce(MULTIPLY, [self]*b, 1)\n\n\nprint num(2).__pow__(3)\nprint num(2) ** 3\n\n\nprint num(2.3).__pow__(8)\nprint num(2.3) ** 8\n"}
{"id": 76031, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to C#: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 76033, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to Java: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 76034, "name": "Sorting algorithms_Bubble sort", "source": "Translate Swift to Python: func bubbleSort<T:Comparable>(list:inout[T]) {\n    var done = false\n    while !done {\n        done = true\n        for i in 1..<list.count {\n            if list[i - 1] > list[i] {\n                (list[i], list[i - 1]) = (list[i - 1], list[i])\n                done = false\n            }\n        }\n    }\n}\n\nvar list1 = [3, 1, 7, 5, 2, 5, 3, 8, 4]\nprint(list1)\nbubbleSort(list: &list1)\nprint(list1)\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 76889, "name": "Approximate equality", "source": "Translate Swift to C#: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76890, "name": "Approximate equality", "source": "Translate Swift to C#: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76893, "name": "Approximate equality", "source": "Translate Swift to Java: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76894, "name": "Approximate equality", "source": "Translate Swift to Java: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76895, "name": "Approximate equality", "source": "Translate Swift to Python: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 76896, "name": "Approximate equality", "source": "Translate Swift to Python: import Foundation\n\nextension FloatingPoint {\n  @inlinable\n  public func isAlmostEqual(\n    to other: Self,\n    tolerance: Self = Self.ulpOfOne.squareRoot()\n  ) -> Bool {\n    \n    \n    assert(tolerance >= .ulpOfOne && tolerance < 1, \"tolerance should be in [.ulpOfOne, 1).\")\n\n    \n    \n    \n    guard self.isFinite && other.isFinite else {\n      return rescaledAlmostEqual(to: other, tolerance: tolerance)\n    }\n\n    \n    \n    \n    let scale = max(abs(self), abs(other), .leastNormalMagnitude)\n    return abs(self - other) < scale*tolerance\n  }\n\n  @usableFromInline\n  internal func rescaledAlmostEqual(to other: Self, tolerance: Self) -> Bool {\n    \n    \n    if self.isNaN || other.isNaN { return false }\n    if self.isInfinite {\n      if other.isInfinite { return self == other }\n\n      \n      \n      \n      let scaledSelf = Self(sign: self.sign,\n        exponent: Self.greatestFiniteMagnitude.exponent,\n        significand: 1)\n      let scaledOther = Self(sign: .plus,\n        exponent: -1,\n        significand: other)\n\n      \n      return scaledSelf.isAlmostEqual(to: scaledOther, tolerance: tolerance)\n    }\n\n    \n    \n    return other.rescaledAlmostEqual(to: self, tolerance: tolerance)\n  }\n}\n\nlet testCases = [\n  (100000000000000.01, 100000000000000.011),\n  (100.01, 100.011),\n  (10000000000000.001 / 10000.0, 1000000000.0000001000),\n  (0.001, 0.0010000001),\n  (0.000000000000000000000101, 0.0),\n  (sqrt(2) * sqrt(2), 2.0),\n  (-sqrt(2) * sqrt(2), -2.0),\n  (3.14159265358979323846, 3.14159265358979324)\n]\n\nfor testCase in testCases {\n  print(\"\\(testCase.0), \\(testCase.1) => \\(testCase.0.isAlmostEqual(to: testCase.1))\")\n}\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 77151, "name": "Greatest common divisor", "source": "Translate Swift to C#: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77153, "name": "Greatest common divisor", "source": "Translate Swift to Java: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77154, "name": "Greatest common divisor", "source": "Translate Swift to Python: \n\nfunc gcd(var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a % b) }\n    \n    return a\n}\n\n\n\nfunc gcdr (var a: Int, var b: Int) -> Int {\n    \n    a = abs(a); b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0 ? a : gcd_rec(b, a % b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n", "target": "from fractions import gcd\n"}
{"id": 77431, "name": "Luhn test of credit card numbers", "source": "Translate Swift to C#: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77433, "name": "Luhn test of credit card numbers", "source": "Translate Swift to Java: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77434, "name": "Luhn test of credit card numbers", "source": "Translate Swift to Python: func luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset % 2 == 0\n        return even ? digit : digit == 9 ? 9 : digit * 2 % 9\n    }).reduce(0, +) % 10 == 0\n}\n\nluhn(\"49927398716\") \nluhn(\"49927398717\") \n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77712, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to C#: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77714, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to Java: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77715, "name": "Sorting algorithms_Quicksort", "source": "Translate Swift to Python: func quicksort<T where T : Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T : Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 77930, "name": "Date manipulation", "source": "Translate Swift to C#: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        CultureInfo ci=CultureInfo.CreateSpecificCulture(\"en-US\");\n        string dateString = \"March 7 2009 7:30pm EST\";\n        string format = \"MMMM d yyyy h:mmtt z\";\n        DateTime myDateTime = DateTime.ParseExact(dateString.Replace(\"EST\",\"+6\"),format,ci) ;\n        DateTime newDateTime = myDateTime.AddHours(12).AddDays(1) ;\n        Console.WriteLine(newDateTime.ToString(format).Replace(\"-5\",\"EST\")); \n\n        Console.ReadLine();\n    }\n}\n"}
{"id": 77932, "name": "Date manipulation", "source": "Translate Swift to Java: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "import java.time.*;\nimport java.time.format.*;\n\nclass Main {  \n  public static void main(String args[]) { \n    String dateStr = \"March 7 2009 7:30pm EST\";\n\n    DateTimeFormatter df = new DateTimeFormatterBuilder()\n\t\t\t\t.parseCaseInsensitive()\n\t\t\t\t.appendPattern(\"MMMM d yyyy h:mma zzz\")\n\t\t\t\t.toFormatter();\n\t\t\n    ZonedDateTime after12Hours = ZonedDateTime.parse(dateStr, df).plusHours(12);\n  \n    System.out.println(\"Date: \" + dateStr);\n    System.out.println(\"+12h: \" + after12Hours.format(df));\n\n    ZonedDateTime after12HoursInCentralEuropeTime = after12Hours.withZoneSameInstant(ZoneId.of(\"CET\"));\n    System.out.println(\"+12h (in Central Europe): \" + after12HoursInCentralEuropeTime.format(df));\n  }\n}\n"}
{"id": 77933, "name": "Date manipulation", "source": "Translate Swift to Python: import Foundation\n\nlet formatter = DateFormatter()\n\nformatter.dateFormat = \"MMMM dd yyyy hh:mma zzz\"\n\nguard let date = formatter.date(from: \"March 7 2009 7:30pm EST\") else {\n  fatalError()\n}\n\nprint(formatter.string(from: date))\nprint(formatter.string(from: date + 60 * 60 * 12))\n", "target": "import datetime\n\ndef mt():\n\tdatime1=\"March 7 2009 7:30pm EST\"\n\tformatting = \"%B %d %Y %I:%M%p \"\n\tdatime2 = datime1[:-3]  \n\ttdelta = datetime.timedelta(hours=12)\t\t\n\ts3 = datetime.datetime.strptime(datime2, formatting)\n\tdatime2 = s3+tdelta\n\tprint datime2.strftime(\"%B %d %Y %I:%M%p %Z\") + datime1[-3:]\n\nmt()\n"}
{"id": 78216, "name": "Rot-13", "source": "Translate Swift to C#: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78218, "name": "Rot-13", "source": "Translate Swift to Java: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78219, "name": "Rot-13", "source": "Translate Swift to Python: func rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78355, "name": "Parametric polymorphism", "source": "Translate Swift to C#: class Tree<T> {\n  var value: T?\n  var left: Tree<T>?\n  var right: Tree<T>?\n  \n  func replaceAll(value: T?) {\n    self.value = value\n    left?.replaceAll(value)\n    right?.replaceAll(value)\n  }\n}\n", "target": "using System;\n\nclass BinaryTree<T>\n{\n    public T value;\n    public BinaryTree<T> left;\n    public BinaryTree<T> right;\n\n    public BinaryTree(T value)\n    {\n        this.value = value;\n    }\n\n    public BinaryTree<U> Map<U>(Func<T, U> f)\n    {\n        BinaryTree<U> tree = new BinaryTree<U>(f(this.value));\n        if (this.left != null)\n        {\n            tree.left = this.left.Map(f);\n        }\n        if (this.right != null)\n        {\n            tree.right = this.right.Map(f);\n        }\n        return tree;\n    }\n}\n"}
{"id": 78357, "name": "Parametric polymorphism", "source": "Translate Swift to Java: class Tree<T> {\n  var value: T?\n  var left: Tree<T>?\n  var right: Tree<T>?\n  \n  func replaceAll(value: T?) {\n    self.value = value\n    left?.replaceAll(value)\n    right?.replaceAll(value)\n  }\n}\n", "target": "public class Tree<T>{\n\tprivate T value;\n\tprivate Tree<T> left;\n\tprivate Tree<T> right;\n\n\tpublic void replaceAll(T value){\n\t\tthis.value = value;\n\t\tif (left != null)\n\t\t\tleft.replaceAll(value);\n\t\tif (right != null)\n\t\t\tright.replaceAll(value);\n\t}\n}\n"}
{"id": 79533, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to C#: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79534, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to C#: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79537, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Java: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79538, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Java: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79539, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Python: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79540, "name": "Sum multiples of 3 and 5", "source": "Translate Swift to Python: var n:Int=1000\n\nfunc sum(x:Int)->Int{\n\t\n\tvar s:Int=0\n\tfor i in 0...x{\n\t\tif i%3==0 || i%5==0\n\t\t{\n\t\t\ts=s+i\n\t\t}\n\t\t\n\t}\n\treturn s\n}\n\nvar sumofmult:Int=sum(x:n)\nprint(sumofmult)\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79865, "name": "Pascal's triangle", "source": "Translate Swift to C#: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "using System;\n\nnamespace RosettaCode {\n\n    class PascalsTriangle {\n\n        public static void CreateTriangle(int n) {\n            if (n > 0) {\n                for (int i = 0; i < n; i++) {\n                    int c = 1;\n                    Console.Write(\" \".PadLeft(2 * (n - 1 - i)));\n                    for (int k = 0; k <= i; k++) {\n                        Console.Write(\"{0}\", c.ToString().PadLeft(3));\n                        c = c * (i - k) / (k + 1);\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n\n        public static void Main() {\n            CreateTriangle(8);\n        }\n    }\n}\n"}
{"id": 79867, "name": "Pascal's triangle", "source": "Translate Swift to Java: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "import java.util.ArrayList;\n...\npublic static void genPyrN(int rows){\n\tif(rows < 0) return;\n\t\n\tArrayList<Integer> last = new ArrayList<Integer>();\n\tlast.add(1);\n\tSystem.out.println(last);\n\tfor(int i= 1;i <= rows;++i){\n\t\t\n\t\tArrayList<Integer> thisRow= new ArrayList<Integer>();\n\t\tthisRow.add(last.get(0)); \n\t\tfor(int j= 1;j < i;++j){\n\t\t\t\n\t\t\tthisRow.add(last.get(j - 1) + last.get(j));\n\t\t}\n\t\tthisRow.add(last.get(0)); \n\t\tlast= thisRow;\n\t\tSystem.out.println(thisRow);\n\t}\n}\n"}
{"id": 79868, "name": "Pascal's triangle", "source": "Translate Swift to Python: func pascal(n:Int)->[Int]{\n    if n==1{\n        let a=[1]\n        print(a)\n        return a\n    }\n    else{\n        var a=pascal(n:n-1)\n        var temp=a\n        for i in 0..<a.count{\n            if i+1==a.count{\n                temp.append(1)\n                break\n            }\n            temp[i+1] = a[i]+a[i+1]\n        }\n        a=temp\n        print(a)\n        return a\n    }\n}\nlet waste = pascal(n:10)\n", "target": "def pascal(n):\n   \n   row = [1]\n   k = [0]\n   for x in range(max(n,0)):\n      print row\n      row=[l+r for l,r in zip(row+k,k+row)]\n   return n>=1\n"}
{"id": 80149, "name": "Logical operations", "source": "Translate Swift to C#: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80151, "name": "Logical operations", "source": "Translate Swift to Java: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80152, "name": "Logical operations", "source": "Translate Swift to Python: func logic(a: Bool, b: Bool) {\n  println(\"a AND b: \\(a && b)\");\n  println(\"a OR b: \\(a || b)\");\n  println(\"NOT a: \\(!a)\");\n}\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80526, "name": "Perfect shuffle", "source": "Translate Swift to C#: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80527, "name": "Perfect shuffle", "source": "Translate Swift to C#: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80530, "name": "Perfect shuffle", "source": "Translate Swift to Java: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80531, "name": "Perfect shuffle", "source": "Translate Swift to Java: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80532, "name": "Perfect shuffle", "source": "Translate Swift to Python: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80533, "name": "Perfect shuffle", "source": "Translate Swift to Python: func perfectShuffle<T>(_ arr: [T]) -> [T]? {\n  guard arr.count & 1 == 0 else {\n    return nil\n  }\n\n  let half = arr.count / 2\n  var res = [T]()\n\n  for i in 0..<half {\n    res.append(arr[i])\n    res.append(arr[i + half])\n  }\n\n  return res\n}\n\nlet decks = [\n  Array(1...8),\n  Array(1...24),\n  Array(1...52),\n  Array(1...100),\n  Array(1...1020),\n  Array(1...1024),\n  Array(1...10000)\n]\n\nfor deck in decks {\n  var shuffled = deck\n  var shuffles = 0\n\n  repeat {\n    shuffled = perfectShuffle(shuffled)!\n    shuffles += 1\n  } while shuffled != deck\n\n  print(\"Deck of \\(shuffled.count) took \\(shuffles) shuffles to get back to original order\")\n}\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80984, "name": "Conway's Game of Life", "source": "Translate Swift to C#: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80986, "name": "Conway's Game of Life", "source": "Translate Swift to Java: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80987, "name": "Conway's Game of Life", "source": "Translate Swift to Python: struct Cell: Hashable {\n  var x: Int\n  var y: Int\n}\n\nstruct Colony {\n  private var height: Int\n  private var width: Int\n  private var cells: Set<Cell>\n\n  init(cells: Set<Cell>, height: Int, width: Int) {\n    self.cells = cells\n    self.height = height\n    self.width = width\n  }\n\n  private func neighborCounts() -> [Cell: Int] {\n    var counts = [Cell: Int]()\n\n    for cell in cells.flatMap(Colony.neighbors(for:)) {\n      counts[cell, default: 0] += 1\n    }\n\n    return counts\n  }\n\n  private static func neighbors(for cell: Cell) -> [Cell] {\n    return [\n      Cell(x: cell.x - 1, y: cell.y - 1),\n      Cell(x: cell.x,     y: cell.y - 1),\n      Cell(x: cell.x + 1, y: cell.y - 1),\n      Cell(x: cell.x - 1, y: cell.y),\n      Cell(x: cell.x + 1, y: cell.y),\n      Cell(x: cell.x - 1, y: cell.y + 1),\n      Cell(x: cell.x,     y: cell.y + 1),\n      Cell(x: cell.x + 1, y: cell.y + 1),\n    ]\n  }\n\n  func printColony() {\n    for y in 0..<height {\n      for x in 0..<width {\n        let char = cells.contains(Cell(x: x, y: y)) ? \"0\" : \".\"\n\n        print(\"\\(char) \", terminator: \"\")\n      }\n\n      print()\n    }\n  }\n\n  mutating func run(iterations: Int) {\n    print(\"(0)\")\n    printColony()\n    print()\n\n    for i in 1...iterations {\n      print(\"(\\(i))\")\n      runGeneration()\n      printColony()\n      print()\n    }\n  }\n\n  private mutating func runGeneration() {\n    cells = Set(neighborCounts().compactMap({keyValue in\n      switch (keyValue.value, cells.contains(keyValue.key)) {\n      case (2, true), (3, _):\n        return keyValue.key\n      case _:\n        return nil\n      }\n    }))\n  }\n}\n\nlet blinker = [Cell(x: 1, y: 0), Cell(x: 1, y: 1), Cell(x: 1, y: 2)] as Set\n\nvar col = Colony(cells: blinker, height: 3, width: 3)\n\nprint(\"Blinker: \")\ncol.run(iterations: 3)\n\nlet glider = [\n  Cell(x: 1, y: 0),\n  Cell(x: 2, y: 1),\n  Cell(x: 0, y: 2),\n  Cell(x: 1, y: 2),\n  Cell(x: 2, y: 2)\n] as Set\n\ncol = Colony(cells: glider, height: 8, width: 8)\n\nprint(\"Glider: \")\ncol.run(iterations: 20)\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 82121, "name": "Gaussian elimination", "source": "Translate Swift to C#: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 82124, "name": "Gaussian elimination", "source": "Translate Swift to Java: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82125, "name": "Gaussian elimination", "source": "Translate Swift to Java: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 82126, "name": "Gaussian elimination", "source": "Translate Swift to Python: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82127, "name": "Gaussian elimination", "source": "Translate Swift to Python: func gaussEliminate(_ sys: [[Double]]) -> [Double]? {\n  var system = sys\n\n  let size = system.count\n\n  for i in 0..<size-1 where system[i][i] != 0 {\n    for j in i..<size-1 {\n      let factor = system[j + 1][i] / system[i][i]\n\n      for k in i..<size+1 {\n        system[j + 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  for i in (1..<size).reversed() where system[i][i] != 0 {\n    for j in (1..<i+1).reversed() {\n      let factor = system[j - 1][i] / system[i][i]\n\n      for k in (0..<size+1).reversed() {\n        system[j - 1][k] -= factor * system[i][k]\n      }\n    }\n  }\n\n  var solutions = [Double]()\n\n  for i in 0..<size {\n    guard system[i][i] != 0 else {\n      return nil\n    }\n\n    system[i][size] /= system[i][i]\n    system[i][i] = 1\n    solutions.append(system[i][size])\n  }\n\n  return solutions\n}\n\nlet sys = [\n  [1.00, 0.00, 0.00, 0.00, 0.00, 0.00, -0.01],\n  [1.00, 0.63, 0.39, 0.25, 0.16, 0.10, 0.61],\n  [1.00, 1.26, 1.58, 1.98, 2.49, 3.13, 0.91],\n  [1.00, 1.88, 3.55, 6.70, 12.62, 23.80, 0.99],\n  [1.00, 2.51, 6.32, 15.88, 39.90, 100.28, 0.60],\n  [1.00, 3.14, 9.87, 31.01, 97.41, 306.02, 0.02]\n]\n\nguard let sols = gaussEliminate(sys) else {\n  fatalError(\"No solutions\")\n}\n\nfor (i, f) in sols.enumerated() {\n  print(\"X\\(i + 1) = \\(f)\")\n}\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}

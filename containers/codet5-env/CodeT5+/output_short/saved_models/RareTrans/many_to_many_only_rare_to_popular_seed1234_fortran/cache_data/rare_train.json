{"id": 99, "name": "Arithmetic_Integer", "source": "Translate Fortran to C#:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); \n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); \n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n"}
{"id": 103, "name": "Arithmetic_Integer", "source": "Translate Fortran to Java:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "import java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        \n        int difference = a - b; \n        int product = a * b;    \n        int division = a / b;   \n        int remainder = a % b;  \n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   \n        System.out.println(\"remainder of a / b = \" + remainder);   \n    }\n}\n"}
{"id": 104, "name": "Arithmetic_Integer", "source": "Translate Fortran to Python:  INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n", "target": "x = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\" % (x + y)\nprint \"Difference: %d\" % (x - y)\nprint \"Product: %d\" % (x * y)\nprint \"Quotient: %d\" % (x / y)     \n                                   \nprint \"Remainder: %d\" % (x % y)    \nprint \"Quotient: %d with Remainder: %d\" % divmod(x, y)\nprint \"Power: %d\" % x**y\n\n\nraw_input( )\n"}
{"id": 648, "name": "Percentage difference between images", "source": "Translate Fortran to C#: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "using System;\nusing System.Drawing;\n\nclass Program\n{\n    static void Main()\n    {\n        Bitmap img1 = new Bitmap(\"Lenna50.jpg\");\n        Bitmap img2 = new Bitmap(\"Lenna100.jpg\");\n\n        if (img1.Size != img2.Size)\n        {\n            Console.Error.WriteLine(\"Images are of different sizes\");\n            return;\n        }\n\n        float diff = 0;\n\n        for (int y = 0; y < img1.Height; y++)\n        {\n            for (int x = 0; x < img1.Width; x++)\n            {\n                Color pixel1 = img1.GetPixel(x, y);\n                Color pixel2 = img2.GetPixel(x, y);\n\n                diff += Math.Abs(pixel1.R - pixel2.R);\n                diff += Math.Abs(pixel1.G - pixel2.G);\n                diff += Math.Abs(pixel1.B - pixel2.B);\n            }\n        }\n\n        Console.WriteLine(\"diff: {0}\u00a0%\", 100 * (diff / 255) / (img1.Width * img1.Height * 3));\n    }\n}\n"}
{"id": 652, "name": "Percentage difference between images", "source": "Translate Fortran to Java: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImgDiffPercent {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        \n        \n        BufferedImage img1 = ImageIO.read(new File(\"Lenna50.jpg\"));\n        BufferedImage img2 = ImageIO.read(new File(\"Lenna100.jpg\"));\n\n        double p = getDifferencePercent(img1, img2);\n        System.out.println(\"diff percent: \" + p);\n    }\n\n    private static double getDifferencePercent(BufferedImage img1, BufferedImage img2) {\n        int width = img1.getWidth();\n        int height = img1.getHeight();\n        int width2 = img2.getWidth();\n        int height2 = img2.getHeight();\n        if (width != width2 || height != height2) {\n            throw new IllegalArgumentException(String.format(\"Images must have the same dimensions: (%d,%d) vs. (%d,%d)\", width, height, width2, height2));\n        }\n\n        long diff = 0;\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                diff += pixelDiff(img1.getRGB(x, y), img2.getRGB(x, y));\n            }\n        }\n        long maxDiff = 3L * 255 * width * height;\n\n        return 100.0 * diff / maxDiff;\n    }\n\n    private static int pixelDiff(int rgb1, int rgb2) {\n        int r1 = (rgb1 >> 16) & 0xff;\n        int g1 = (rgb1 >>  8) & 0xff;\n        int b1 =  rgb1        & 0xff;\n        int r2 = (rgb2 >> 16) & 0xff;\n        int g2 = (rgb2 >>  8) & 0xff;\n        int b2 =  rgb2        & 0xff;\n        return Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);\n    }\n}\n"}
{"id": 653, "name": "Percentage difference between images", "source": "Translate Fortran to Python: program ImageDifference\n\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: input1_u = 20, &\n                        input2_u = 21\n\n  type(rgbimage) :: lenna1, lenna2\n  real           :: totaldiff\n\n\n  open(input1_u, file=\"Lenna100.ppm\", action=\"read\")\n  open(input2_u, file=\"Lenna50.ppm\", action=\"read\")\n  call read_ppm(input1_u, lenna1)\n  call read_ppm(input2_u, lenna2)\n  close(input1_u)\n  close(input2_u)\n\n  totaldiff = sum(  (abs(lenna1%red - lenna2%red) + &\n                     abs(lenna1%green - lenna2%green) + &\n                     abs(lenna1%blue - lenna2%blue)) / 255.0 )\n\n\n  print *, 100.0 * totaldiff / (lenna1%width * lenna1%height * 3.0)\n\n  call free_img(lenna1)\n  call free_img(lenna2)\n\nend program ImageDifference\n", "target": "from PIL import Image\n\ni1 = Image.open(\"image1.jpg\")\ni2 = Image.open(\"image2.jpg\")\nassert i1.mode == i2.mode, \"Different kinds of images.\"\nassert i1.size == i2.size, \"Different sizes.\"\n\npairs = zip(i1.getdata(), i2.getdata())\nif len(i1.getbands()) == 1:\n    \n    dif = sum(abs(p1-p2) for p1,p2 in pairs)\nelse:\n    dif = sum(abs(c1-c2) for p1,p2 in pairs for c1,c2 in zip(p1,p2))\n\nncomponents = i1.size[0] * i1.size[1] * 3\nprint (\"Difference (percentage):\", (dif / 255.0 * 100) / ncomponents)\n"}
{"id": 833, "name": "Bitwise operations", "source": "Translate Fortran to C#: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "static void bitwise(int a, int b)\n        {\n            Console.WriteLine(\"a and b is {0}\", a & b);\n            Console.WriteLine(\"a or b is {0}\", a | b);\n            Console.WriteLine(\"a xor b is {0}\", a ^ b);\n            Console.WriteLine(\"not a is {0}\", ~a);\n            Console.WriteLine(\"a lshift b is {0}\", a << b);\n            Console.WriteLine(\"a arshift b is {0}\", a >> b); \n                                                             \n            uint c = (uint)a;\n            Console.WriteLine(\"c rshift b is {0}\", c >> b); \n                                                            \n            \n        }\n"}
{"id": 836, "name": "Bitwise operations", "source": "Translate Fortran to Java: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "module BitwiseOps\n    {\n    @Inject Console console;\n    void run()\n        {\n        for ((Int64 n1, Int64 n2) : [0=7, 1=5, 42=2, 0x123456789ABCDEF=0xFF])  \n            {\n            static String hex(Int64 n)   \n                {\n                \n                return n.toByteArray() [(n.leadingZeroCount / 8).minOf(7) ..< 8].toString();\n                }\n\n            console.print($|For values {n1} ({hex(n1)}) and {n2} ({hex(n2)}):\n                           |  {hex(n1)} AND {hex(n2)} = {hex(n1 & n2)}\n                           |  {hex(n1)} OR {hex(n2)} = {hex(n1 | n2)}\n                           |  {hex(n1)} XOR {hex(n2)} = {hex(n1 ^ n2)}\n                           |  NOT {hex(n1)} = {hex(~n1)}\n                           |  left shift {hex(n1)} by {n2} = {hex(n1 << n2)}\n                           |  right shift {hex(n1)} by {n2} = {hex(n1 >> n2)}\n                           |  right arithmetic shift {hex(n1)} by {n2} = {hex(n1 >>> n2)}\n                           |  left rotate {hex(n1)} by {n2} = {hex(n1.rotateLeft(n2))}\n                           |  right rotate {hex(n1)} by {n2} = {hex(n1.rotateRight(n2))}\n                           |  leftmost bit of {hex(n1)} = {hex(n1.leftmostBit)}\n                           |  rightmost bit of {hex(n1)} = {hex(n1.rightmostBit)}\n                           |  leading zero count of {hex(n1)} = {n1.leadingZeroCount}\n                           |  trailing zero count of {hex(n1)} = {n1.trailingZeroCount}\n                           |  bit count (aka \"population\") of {hex(n1)} = {n1.bitCount}\n                           |  reversed bits of {hex(n1)} = {hex(n1.reverseBits())}\n                           |  reverse bytes of {hex(n1)} = {hex(n1.reverseBytes())}\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 837, "name": "Bitwise operations", "source": "Translate Fortran to Python: integer :: i, j = -1, k = 42\nlogical :: a\n    \ni = bit_size(j)       \n    \n\ni = iand(k, j)        \ni = ior(k, j)         \ni = ieor(k, j)        \ni = not(j)            \n    \n\na = btest(i, 4)       \ni = ibclr(k, 8)       \ni = ibset(k, 13)      \n    \n\ni = ishft(k, j)       \n                      \ni = ishftc(k, j)      \n                      \ni = ishftc(k, j, 20)  \n                      \ni = ibits(k, 7, 8)    \n                      \n                      \n                      \n", "target": "def bitwise_built_ins(width, a, b):\n    mask = (1 << width) - 1\n    print(f)\n\ndef rotr(width, a, n):\n    \"Rotate a, n times to the right\"\n    if n < 0:\n        return rotl(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return ((a >> n)    \n                | ((a & ((1 << n) - 1))   \n                   << (width - n)))  \n\ndef rotl(width, a, n):\n    \"Rotate a, n times to the left\"\n    if n < 0:\n        return rotr(width, a, -n)\n    elif n == 0:\n        return a\n    else:\n        mask = (1 << width) - 1\n        a, n = a & mask, n % width\n        return (((a << n) & mask)      \n                | (a >> (width - n)))  \n    \ndef asr(width, a, n):\n    \"Arithmetic shift a, n times to the right. (sign preserving).\"\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    if n < 0:\n        return  (a << -n) & mask\n    elif n == 0:\n        return a\n    elif n >= width:\n        return mask if a & top_bit_mask else 0\n    else:\n        a = a & mask\n        if a & top_bit_mask:    \n            signs = (1 << n) - 1\n            return a >> n | (signs << width - n)\n        else:\n            return a >> n\n    \n      \ndef helper_funcs(width, a):\n    mask, top_bit_mask = ((1 << width) - 1), 1 << (width - 1)\n    aa = a | top_bit_mask  \n    print(f)\n\nif __name__ == '__main__':\n    bitwise_built_ins(8, 27, 125)\n    helper_funcs(8, 27)\n"}
{"id": 1085, "name": "Stem-and-leaf plot", "source": "Translate Fortran to C#:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static void Main()\n    {\n        const string data =\n        \"12 127 28 42 39 113 42 18 44 118 44 37 113 124 37 48 127 36 29 31 \" +\n        \"125 139 131 115 105 132 104 123 35 113 122 42 117 119 58 109 23 \" +\n        \"105 63 27 44 105 99 41 128 121 116 125 32 61 37 127 29 113 121 58 \" +\n        \"114 126 53 114 96 25 109 7 31 141 46 13 27 43 117 116 27 7 68 40 31 \" +\n        \"115 124 42 128 52 71 118 117 38 27 106 33 117 116 111 40 119 47 \" +\n        \"105 57 122 109 124 115 43 120 43 27 27 18 28 48 125 107 114 34 \" +\n        \"133 45 120 30 127 31 116 146\";\n\n        int[] ints = data.Split(' ').Select(int.Parse).ToArray();\n\n        StemAndLeafPlot(ints);\n\n        Console.ReadKey();\n    }\n\n    public static void StemAndLeafPlot(int[] arr)\n    {\n        int stemMax = arr.Max() / 10;\n        int stemMin = arr.Min() / 10;\n        Array.Sort(arr);\n\n        for (int i = stemMin; i <= stemMax; i++)\n        {\n            Console.Write(\"{0,3} | \", i);\n            foreach (var t in arr)\n            {\n                if (t < 10 * i)\n                    continue;\n                if (t >= 10 * (i + 1))\n                    break;\n                Console.Write(\"{0} \", t % 10);\n            }\n            Console.WriteLine(\"\");\n        }\n    }\n}\n"}
{"id": 1088, "name": "Stem-and-leaf plot", "source": "Translate Fortran to Java:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class StemAndLeaf {\n\tprivate static int[] data = { 12, 127, 28, 42, 39, 113, 42, 18, 44, 118,\n\t\t\t44, 37, 113, 124, 37, 48, 127, 36, 29, 31, 125, 139, 131, 115, 105,\n\t\t\t132, 104, 123, 35, 113, 122, 42, 117, 119, 58, 109, 23, 105, 63,\n\t\t\t27, 44, 105, 99, 41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113,\n\t\t\t121, 58, 114, 126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27,\n\t\t\t43, 117, 116, 27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118,\n\t\t\t117, 38, 27, 106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122,\n\t\t\t109, 124, 115, 43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34,\n\t\t\t133, 45, 120, 30, 127, 31, 116, 146 };\n\t\n\tpublic static Map<Integer, List<Integer>> createPlot(int... data){\n\t\tMap<Integer, List<Integer>> plot = new TreeMap<Integer, List<Integer>>();\n\t\tint highestStem = -1; \n\t\tfor(int datum:data){\n\t\t\tint leaf = datum % 10;\n\t\t\tint stem = datum / 10; \n\t\t\tif(stem > highestStem){\n\t\t\t\thighestStem = stem;\n\t\t\t}\n\t\t\tif(plot.containsKey(stem)){\n\t\t\t\tplot.get(stem).add(leaf);\n\t\t\t}else{\n\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\tlist.add(leaf);\n\t\t\t\tplot.put(stem, list);\n\t\t\t}\n\t\t}\n\t\tif(plot.keySet().size() < highestStem + 1  ){\n\t\t\tfor(int i = 0; i <= highestStem; i++){\n\t\t\t\tif(!plot.containsKey(i)){\n\t\t\t\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\t\t\t\tplot.put(i, list);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plot;\n\t}\n\t\n\tpublic static void printPlot(Map<Integer, List<Integer>> plot){\n\t\tfor(Map.Entry<Integer, List<Integer>> line : plot.entrySet()){\n\t\t\tCollections.sort(line.getValue());\n\t\t\tSystem.out.println(line.getKey() + \" | \" + line.getValue());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tMap<Integer, List<Integer>> plot = createPlot(data);\n\t\tprintPlot(plot);\n\t}\n}\n"}
{"id": 1089, "name": "Stem-and-leaf plot", "source": "Translate Fortran to Python:       SUBROUTINE COMBSORT(A,N)\n       INTEGER A(*)\t\n       INTEGER N\t\n       INTEGER H,T\t\n       LOGICAL CURSE\n        H = N - 1\t\t\n    1   H = MAX(1,H*10/13)\t\n        IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n        CURSE = .FALSE.\t\t\n        DO I = N - H,1,-1\t\n          IF (A(I) .GT. A(I + H)) THEN\t\n            T=A(I); A(I)=A(I+H); A(I+H)=T\t\n            CURSE = .TRUE.\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        IF (CURSE .OR. H.GT.1) GO TO 1\t\n      END SUBROUTINE COMBSORT\t\n\n      SUBROUTINE TOPIARY(A,N)\t\n       INTEGER A(*)\t\t\n       INTEGER N\t\t\n       INTEGER CLIP\t\t\n       PARAMETER (CLIP = 10)\t\n       INTEGER I1,I2,STEM\t\n        CALL COMBSORT(A,N)\t\n        STEM = A(1)/CLIP\t\n        I1 = 1\t\t\t\n        I2 = I1\t\t\t\n   10   I2 = I2 + 1\t\t\t\n        IF (I2 .GT. N) GO TO 11\t\t\n        IF (A(I2)/CLIP .EQ.STEM) GO TO 10\t\nCast forth a STEM line, corresponding to elements I1:I2 - 1.\n   11   WRITE (6,12) STEM,ABS(MOD(A(I1:I2 - 1),CLIP))\t\n   12   FORMAT (I4,\"|\",(100I1))\t\t\n        IF (I2 .GT. N) RETURN\t\t\n        I1 = I2\t\t\t\t\nChug along to the next STEM value.\n   13   STEM = STEM + 1\t\t\t\n        IF (A(I2)/CLIP.GT.STEM) GO TO 11\n        GO TO 10\t\t\t\n      END SUBROUTINE TOPIARY\t\n\n      PROGRAM TEST\n      INTEGER VALUES(121)\t\n      DATA VALUES/\t\t\n     o  12,127, 28, 42, 39,113, 42, 18, 44,118,\t\n     1  44, 37,113,124, 37, 48,127, 36, 29, 31,\t\n     2 125,139,131,115,105,132,104,123, 35,113,\n     3 122, 42,117,119, 58,109, 23,105, 63, 27,\n     4  44,105, 99, 41,128,121,116,125, 32, 61,\n     5  37,127, 29,113,121, 58,114,126, 53,114,\n     6  96, 25,109,  7, 31,141, 46, 13, 27, 43,\n     7 117,116, 27,  7, 68, 40, 31,115,124, 42,\n     8 128, 52, 71,118,117, 38, 27,106, 33,117,\n     9 116,111, 40,119, 47,105, 57,122,109,124,\n     o 115, 43,120, 43, 27, 27, 18, 28, 48,125,\n     1 107,114, 34,133, 45,120, 30,127, 31,116,\n     2 146/\n        CALL TOPIARY(VALUES,121)\n      END\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nfrom math import floor\n\nStem = namedtuple('Stem', 'data, leafdigits')\n\ndata0 = Stem((12, 127, 28, 42, 39, 113, 42, 18, 44, 118, 44, 37, 113, 124, 37,\n              48, 127, 36, 29, 31, 125, 139, 131, 115, 105, 132, 104, 123, 35,\n              113, 122, 42, 117, 119, 58, 109, 23, 105, 63, 27, 44, 105, 99,\n              41, 128, 121, 116, 125, 32, 61, 37, 127, 29, 113, 121, 58, 114,\n              126, 53, 114, 96, 25, 109, 7, 31, 141, 46, 13, 27, 43, 117, 116,\n              27, 7, 68, 40, 31, 115, 124, 42, 128, 52, 71, 118, 117, 38, 27,\n              106, 33, 117, 116, 111, 40, 119, 47, 105, 57, 122, 109, 124, 115,\n              43, 120, 43, 27, 27, 18, 28, 48, 125, 107, 114, 34, 133, 45, 120,\n              30, 127, 31, 116, 146),\n             1.0)\n\ndef stemplot(stem):\n    d = []\n    interval = int(10**int(stem.leafdigits))\n    for data in sorted(stem.data):\n        data = int(floor(data))\n        stm, lf = divmod(data,interval)\n        d.append( (int(stm), int(lf)) )\n    stems, leafs = list(zip(*d))\n    stemwidth = max(len(str(x)) for x in stems)\n    leafwidth = max(len(str(x)) for x in leafs)\n    laststem, out = min(stems) - 1, []\n    for s,l in d:\n        while laststem < s:\n            laststem += 1\n            out.append('\\n%*i |' % ( stemwidth, laststem))\n        out.append(' %0*i' % (leafwidth, l))\n    out.append('\\n\\nKey:\\n Stem multiplier: %i\\n X | Y  =>  %i*X+Y\\n'\n               % (interval, interval))\n    return ''.join(out)\n\nif __name__ == '__main__':\n    print( stemplot(data0) )\n"}
{"id": 1325, "name": "Flatten a list", "source": "Translate Fortran to C#: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1326, "name": "Flatten a list", "source": "Translate Fortran to C#: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "using System;\nusing System.Collections;\nusing System.Linq;\n\nnamespace RosettaCodeTasks\n{\n\tstatic class FlattenList\n\t{\n\t\tpublic static ArrayList Flatten(this ArrayList List)\n\t\t{\n\t\t\tArrayList NewList = new ArrayList ( );\n\n\t\t\tNewList.AddRange ( List );\n\n\t\t\twhile ( NewList.OfType<ArrayList> ( ).Count ( ) > 0 )\n\t\t\t{\n\t\t\t\tint index = NewList.IndexOf ( NewList.OfType<ArrayList> ( ).ElementAt ( 0 ) );\n\t\t\t\tArrayList Temp = (ArrayList)NewList[index];\n\t\t\t\tNewList.RemoveAt ( index );\n\t\t\t\tNewList.InsertRange ( index, Temp );\n\t\t\t}\n\t\t\t\n\t\t\treturn NewList;\n\t\t}\n\t}\n}\n"}
{"id": 1332, "name": "Flatten a list", "source": "Translate Fortran to Java: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1333, "name": "Flatten a list", "source": "Translate Fortran to Java: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\n\npublic final class FlattenUtil {\n\n\tpublic static List<Object> flatten(List<?> list) {\n\t\tList<Object> retVal = new LinkedList<Object>();\n\t\tflatten(list, retVal);\n\t\treturn retVal;\n\t}\n\n\tpublic static void flatten(List<?> fromTreeList, List<Object> toFlatList) {\n\t\tfor (Object item : fromTreeList) {\n\t\t\tif (item instanceof List<?>) {\n\t\t\t\tflatten((List<?>) item, toFlatList);\n\t\t\t} else {\n\t\t\t\ttoFlatList.add(item);\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 1334, "name": "Flatten a list", "source": "Translate Fortran to Python: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 1335, "name": "Flatten a list", "source": "Translate Fortran to Python: \n\n\nmodule flat\n  implicit none\n\n  type n\n     integer                             :: a\n     type(n), dimension(:), pointer      :: p => null()\n     logical                             :: empty = .false.\n  end type\n\ncontains\n\n  recursive subroutine del(this)\n  type(n), intent(inout) :: this\n  integer                :: i\n  if (associated(this%p)) then\n    do i = 1, size(this%p)\n       call del(this%p(i))\n    end do\n  end if\n  end subroutine\n\n  function join(xs) result (r)\n  type(n), dimension(:), target :: xs\n  type(n)                       :: r\n  integer                       :: i\n  if (size(xs)>0) then\n    allocate(r%p(size(xs)), source=xs)\n    do i = 1, size(xs)\n      r%p(i) = xs(i)\n    end do\n  else\n    r%empty = .true.\n  end if\n  end function\n\n  recursive subroutine flatten1(x,r) \n  integer, dimension (:), allocatable, intent(inout) :: r\n  type(n), intent(in)                                :: x\n  integer, dimension (:), allocatable                :: tmp\n  integer                                            :: i\n  if (associated(x%p)) then\n    do i = 1, size(x%p)\n      call flatten1(x%p(i), r)\n    end do\n  elseif (.not. x%empty) then\n    allocate(tmp(size(r)+1))\n    tmp(1:size(r)) = r\n    tmp(size(r)+1) = x%a\n    call move_alloc(tmp, r)\n  end if\n  end subroutine\n\n  function flatten(x) result (r)\n  type(n), intent(in)                                :: x\n  integer, dimension(:), allocatable                 :: r\n  allocate(r(0))\n  call flatten1(x,r)\n  end function\n\n  recursive subroutine show(x)\n  type(n)   :: x\n  integer   :: i\n  if (x%empty) then \n    write (*, \"(a)\", advance=\"no\") \"[]\"\n  elseif (associated(x%p)) then\n    write (*, \"(a)\", advance=\"no\") \"[\"\n    do i = 1, size(x%p)\n      call show(x%p(i))\n      if (i<size(x%p)) then\n        write (*, \"(a)\", advance=\"no\") \", \"\n      end if\n    end do\n    write (*, \"(a)\", advance=\"no\") \"]\"\n  else\n    write (*, \"(g0)\", advance=\"no\") x%a\n  end if\n  end subroutine\n\n  function fromString(line) result (r)\n  character(len=*)                      :: line\n  type (n)                              :: r\n  type (n), dimension(:), allocatable   :: buffer, buffer1\n  integer, dimension(:), allocatable    :: stack, stack1\n  integer                               :: sp,i0,i,j, a, cur, start\n  character                             :: c\n \n  if (.not. allocated(buffer)) then\n    allocate (buffer(5)) \n  end if\n  if (.not. allocated(stack)) then\n    allocate (stack(5))\n  end if\n\n  sp = 1; cur = 1; i = 1\n  do\n    if ( i > len_trim(line) ) exit\n    c = line(i:i)\n    if (c==\"[\") then\n      if (sp>size(stack)) then \n        allocate(stack1(2*size(stack)))\n        stack1(1:size(stack)) = stack\n        call move_alloc(stack1, stack)\n      end if\n      stack(sp) = cur;  sp = sp + 1; i = i+1\n    elseif (c==\"]\") then\n      sp = sp - 1; start = stack(sp)\n      r = join(buffer(start:cur-1))\n      do j = start, cur-1\n        call del(buffer(j))\n      end do\n      buffer(start) = r; cur = start+1; i = i+1\n    elseif (index(\" ,\",c)>0) then\n      i = i + 1; continue\n    elseif (index(\"-123456789\",c)>0) then\n      i0 = i\n      do \n        if ((i>len_trim(line)).or. &\n            index(\"1234567890\",line(i:i))==0) then\n          read(line(i0:i-1),*) a\n          if (cur>size(buffer)) then\n            allocate(buffer1(2*size(buffer)))\n            buffer1(1:size(buffer)) = buffer\n            call move_alloc(buffer1, buffer)\n          end if\n          buffer(cur) = n(a); cur = cur + 1; exit\n        else\n          i = i+1\n        end if\n      end do\n    else\n       stop \"input corrupted\"\n    end if\n  end do\n  end function\nend module\n\nprogram main\n  use flat\n  type (n)  :: x\n  x = fromString(\"[[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\")\n  write(*, \"(a)\", advance=\"no\") \"input  \u00a0: \"\n  call show(x)\n  print *\n  write (*,\"(a)\", advance=\"no\") \"flatten\u00a0: [\"\n  write (*, \"(*(i0,:,:', '))\", advance=\"no\") flatten(x)\n  print *, \"]\"\nend program\n", "target": ">>> def flatten(lst):\n\treturn sum( ([x] if not isinstance(x, list) else flatten(x)\n\t\t     for x in lst), [] )\n\n>>> lst = [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n>>> flatten(lst)\n[1, 2, 3, 4, 5, 6, 7, 8]\n"}
{"id": 2148, "name": "String interpolation (included)", "source": "Translate Fortran to C#: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": "class Program\n{\n    static void Main()\n    {\n        string extra = \"little\";\n        string formatted = $\"Mary had a {extra} lamb.\";\n        System.Console.WriteLine(formatted);\n    }\n}\n"}
{"id": 2152, "name": "String interpolation (included)", "source": "Translate Fortran to Java: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": "String original = \"Mary had a X lamb\";\nString little = \"little\";\nString replaced = original.replace(\"X\", little); \nSystem.out.println(replaced);\n\nSystem.out.printf(\"Mary had a %s lamb.\", little);\n\nString formatted = String.format(\"Mary had a %s lamb.\", little);\nSystem.out.println(formatted);\n"}
{"id": 2153, "name": "String interpolation (included)", "source": "Translate Fortran to Python: program interpolate\n\n  write (*,*) trim(inter(\"Mary had a X lamb.\",\"X\",\"little\"))\n\ncontains\n\n  elemental function inter(string,place,ins) result(new)\n    character(len=*), intent(in)                          :: string,place,ins\n    character(len=len(string)+max(0,len(ins)-len(place))) :: new\n    integer                                               :: idx\n    idx = index(string,place)\n    if ( idx == 0 ) then\n      new = string\n    else\n      new = string(1:idx-1)//ins//string(idx+len(place):len(string))\n    end if\n  end function inter\n  \nend program interpolate\n", "target": ">>> original = 'Mary had a %s lamb.'\n>>> extra = 'little'\n>>> original % extra\n'Mary had a little lamb.'\n"}
{"id": 2485, "name": "Babbage problem", "source": "Translate Fortran to C#:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2486, "name": "Babbage problem", "source": "Translate Fortran to C#:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "namespace Babbage_Problem\n{\n    class iterateNumbers\n    {\n        public iterateNumbers()\n        {\n            long baseNumberSquared = 0; \n            long baseNumber = 0;  \n\n            do  \n            {\n                baseNumber += 1; \n                baseNumberSquared = baseNumber * baseNumber; \n            }\n            while (Right6Digits(baseNumberSquared) != 269696); \n\n            Console.WriteLine(\"The smallest integer whose square ends in 269,696 is \" + baseNumber);\n            Console.WriteLine(\"The square is \" + baseNumberSquared);\n\n        }\n\n        private long Right6Digits(long baseNumberSquared)\n        {\n\n            string numberAsString = baseNumberSquared.ToString(); \n\n            if (numberAsString.Length < 6) { return baseNumberSquared; }; \n\n            numberAsString = numberAsString.Substring(numberAsString.Length - 6);  \n\n            return long.Parse(numberAsString); \n\n        }\n    }\n}}\n"}
{"id": 2492, "name": "Babbage problem", "source": "Translate Fortran to Java:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2493, "name": "Babbage problem", "source": "Translate Fortran to Java:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "public class Test {\n\n    public static void main(String[] args) {\n\n        \n        int n = 0;\n\n        \n        do {\n\n            \n            n++;\n\n        \n        } while (n * n % 1000_000 != 269696);\n\n        \n        System.out.println(n);\n    }\n}\n"}
{"id": 2494, "name": "Babbage problem", "source": "Translate Fortran to Python:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2495, "name": "Babbage problem", "source": "Translate Fortran to Python:       DO 3 N=1,99736\n      IF(MODF(N*N,1000000)-269696)3,4,3\n 3    CONTINUE\n 4    PRINT 5,N\n 5    FORMAT(I6)\n      STOP\n", "target": "\n\n\nn=0 \n\n\n\n\nwhile n**2 % 1000000 != 269696:\n\n    \n    \n    \n    \n    n += 1 \n\nprint(n) \n"}
{"id": 2904, "name": "Ternary logic", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "using System;\n\n\n\n\n\n\n\npublic static class NullableBoolExtension\n{\n    public static bool? Implies(this bool? left, bool? right)\n    {\n        return !left | right;\n    }\n\n    public static bool? IsEquivalentTo(this bool? left, bool? right)\n    {\n        return left.HasValue && right.HasValue ? left == right : default(bool?);\n    }\n\n    public static string Format(this bool? value)\n    {\n        return value.HasValue ? value.Value.ToString() : \"Maybe\";\n    }\n}\n\npublic class Program\n{\n    private static void Main()\n    {\n        var values = new[] { true, default(bool?), false };\n\n        foreach (var left in values)\n        {\n            Console.WriteLine(\"\u00ac{0} = {1}\", left.Format(), (!left).Format());\n            foreach (var right in values)\n            {\n                Console.WriteLine(\"{0} & {1} = {2}\", left.Format(), right.Format(), (left & right).Format());\n                Console.WriteLine(\"{0} | {1} = {2}\", left.Format(), right.Format(), (left | right).Format());\n                Console.WriteLine(\"{0} \u2192 {1} = {2}\", left.Format(), right.Format(), left.Implies(right).Format());\n                Console.WriteLine(\"{0} \u2261 {1} = {2}\", left.Format(), right.Format(), left.IsEquivalentTo(right).Format());\n            }\n        }\n    }\n}\n"}
{"id": 2907, "name": "Ternary logic", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "public class Logic{\n\tpublic static enum Trit{\n\t\tTRUE, MAYBE, FALSE;\n\t\t\n\t\tpublic Trit and(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == FALSE) ? FALSE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit or(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn TRUE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit tIf(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn (other == TRUE) ? TRUE : MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit not(){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn FALSE;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic Trit equals(Trit other){\n\t\t\tif(this == TRUE){\n\t\t\t\treturn other;\n\t\t\t}else if(this == MAYBE){\n\t\t\t\treturn MAYBE;\n\t\t\t}else{\n\t\t\t\treturn other.not();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tfor(Trit a:Trit.values()){\n\t\t\tSystem.out.println(\"not \" + a + \": \" + a.not());\n\t\t}\n\t\tfor(Trit a:Trit.values()){\n\t\t\tfor(Trit b:Trit.values()){\n\t\t\t\tSystem.out.println(a+\" and \"+b+\": \"+a.and(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" or \"+b+\": \"+a.or(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" implies \"+b+\": \"+a.tIf(b)+\n\t\t\t\t\t\t\"\\t \"+a+\" = \"+b+\": \"+a.equals(b));\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 2908, "name": "Ternary logic", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule trit\n\n  real, parameter :: true = 1,  false = 0, maybe = 0.5\n\ncontains\n\n  real function tnot(y)\n    real, intent(in) :: y\n    tnot = 1 - y\n  end function tnot\n\n  real function tand(x, y)\n    real, intent(in) :: x, y\n    tand = min(x, y)\n  end function tand\n\n  real function tor(x, y)\n    real, intent(in) :: x, y\n    tor = max(x, y)\n  end function tor\n\n  real function tif(x, y)\n    real, intent(in) :: x, y\n    tif = tor(y, tnot(x))\n  end function tif\n\n  real function teq(x, y)\n    real, intent(in) :: x, y\n    teq = tor(tand(tnot(x), tnot(y)), tand(x, y))\n  end function teq\n\nend module trit\n\nprogram ternaryLogic\n  use trit\n  integer :: i\n  real, dimension(3) :: a = [false, maybe, true] \n  write(6,'(/a)')'ternary not' ; write(6, '(3f4.1/)') (tnot(a(i)), i = 1 , 3)\n  write(6,'(/a)')'ternary and' ; call table(tand, a, a)\n  write(6,'(/a)')'ternary or' ; call table(tor, a, a)\n  write(6,'(/a)')'ternary if' ; call table(tif, a, a)\n  write(6,'(/a)')'ternary eq' ; call table(teq, a, a)\n\ncontains\n\n  subroutine table(u, x, y) \n    real, external :: u\n    real, dimension(3), intent(in) :: x, y\n    integer :: i, j\n    write(6, '(3(3f4.1/))') ((u(x(i), y(j)), j=1,3), i=1,3)\n  end subroutine table\n\nend program ternaryLogic\n", "target": "class Trit(int):\n    def __new__(cls, value):\n        if value == 'TRUE':\n            value = 1\n        elif value == 'FALSE':\n            value = 0\n        elif value == 'MAYBE':\n            value = -1\n        return super(Trit, cls).__new__(cls, value // (abs(value) or 1)) \n\n    def __repr__(self):\n        if self > 0:\n            return 'TRUE'\n        elif self == 0:\n            return 'FALSE'\n        return 'MAYBE'\n\n    def __str__(self):\n        return repr(self)\n\n    def __bool__(self):\n        if self > 0:\n            return True\n        elif self == 0:\n            return False\n        else:\n            raise ValueError(\"invalid literal for bool(): '%s'\" % self)\n\n    def __or__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __ror__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][1]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][1]\n            except:\n                return NotImplemented\n\n    def __and__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __rand__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][0]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][0]\n            except:\n                return NotImplemented\n\n    def __xor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __rxor__(self, other):\n        if isinstance(other, Trit):\n            return _ttable[(self, other)][2]\n        else:\n            try:\n                return _ttable[(self, Trit(bool(other)))][2]\n            except:\n                return NotImplemented\n\n    def __invert__(self):\n        return _ttable[self]\n    \n    def __getattr__(self, name):\n        if name in ('_n', 'flip'):\n            \n            \n            \n            return _ttable[self]\n        else:\n            raise AttributeError \n\n\n        \nTRUE, FALSE, MAYBE = Trit(1), Trit(0), Trit(-1)\n\n_ttable = {\n    \n         TRUE: FALSE,\n        FALSE:  TRUE,\n        MAYBE: MAYBE,\n    \n        (MAYBE, MAYBE): (MAYBE, MAYBE, MAYBE),\n        (MAYBE, FALSE): (FALSE, MAYBE, MAYBE),\n        (MAYBE,  TRUE): (MAYBE,  TRUE, MAYBE),\n        (FALSE, MAYBE): (FALSE, MAYBE, MAYBE),\n        (FALSE, FALSE): (FALSE, FALSE, FALSE),\n        (FALSE,  TRUE): (FALSE,  TRUE,  TRUE),\n        ( TRUE, MAYBE): (MAYBE,  TRUE, MAYBE),\n        ( TRUE, FALSE): (FALSE,  TRUE,  TRUE),\n        ( TRUE,  TRUE): ( TRUE,  TRUE, FALSE),\n    }\n\n\nvalues = ('FALSE', 'TRUE ', 'MAYBE')\n\nprint(\"\\nTrit logical inverse, '~'\")\nfor a in values:\n    expr = '~%s' % a\n    print('  %s = %s' % (expr, eval(expr)))\n\nfor op, ophelp in (('&', 'and'), ('|', 'or'), ('^', 'exclusive-or')):\n    print(\"\\nTrit logical %s, '%s'\" % (ophelp, op))\n    for a in values:\n        for b in values:\n            expr = '%s %s %s' % (a, op, b)\n            print('  %s = %s' % (expr, eval(expr)))\n"}
{"id": 3194, "name": "Find limit of recursion", "source": "Translate Fortran to C#: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3195, "name": "Find limit of recursion", "source": "Translate Fortran to C#: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "using System;\nclass RecursionLimit\n{\n  static void Main(string[] args)\n  {\n    Recur(0);\n  }\n \n  private static void Recur(int i) \n  {\n    Console.WriteLine(i);\n    Recur(i + 1);\n  }\n}\n"}
{"id": 3200, "name": "Find limit of recursion", "source": "Translate Fortran to Java: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3201, "name": "Find limit of recursion", "source": "Translate Fortran to Java: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "public class RecursionTest {\n\t\n    private static void recurse(int i) {\n        try {\n\t    recurse(i+1);\n\t} catch (StackOverflowError e) {\n\t    System.out.print(\"Recursion depth on this system is \" + i + \".\");\n\t}\n    }\n\t\n    public static void main(String[] args) {\n        recurse(0);\n    }\n}\n"}
{"id": 3202, "name": "Find limit of recursion", "source": "Translate Fortran to Python: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 3203, "name": "Find limit of recursion", "source": "Translate Fortran to Python: program recursion_depth\n\n  implicit none\n\n  call recurse (1)\n\ncontains\n\n  recursive subroutine recurse (i)\n\n    implicit none\n    integer, intent (in) :: i\n\n    write (*, '(i0)') i\n    call recurse (i + 1)\n\n  end subroutine recurse\n\nend program recursion_depth\n", "target": "import sys\nprint(sys.getrecursionlimit())\n"}
{"id": 4111, "name": "CSV data manipulation", "source": "Translate Fortran to C#: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4112, "name": "CSV data manipulation", "source": "Translate Fortran to C#: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "using System.IO;\nusing System.Linq;\n\nnamespace CSV_data_manipulation\n{\n    class Program\n    {\n        static void Main()\n        {\n            var input = File.ReadAllLines(\"test_in.csv\");\n            var output = input.Select((line, i) =>\n            {\n                if (i == 0)\n                    return line + \",SUM\";\n                var sum = line.Split(',').Select(int.Parse).Sum();\n                return line + \",\" + sum;\n            }).ToArray();\n            File.WriteAllLines(\"test_out.csv\", output);\n        }\n    }\n}\n"}
{"id": 4117, "name": "CSV data manipulation", "source": "Translate Fortran to Java: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4118, "name": "CSV data manipulation", "source": "Translate Fortran to Java: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import java.io.*;\nimport java.awt.Point;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class CSV {\n\n    private HashMap<Point, String> _map = new HashMap<Point, String>();\n    private int _cols;\n    private int _rows;\n\n    public void open(File file) throws FileNotFoundException, IOException {\n        open(file, ',');\n    }\n\n    public void open(File file, char delimiter)\n            throws FileNotFoundException, IOException {\n        Scanner scanner = new Scanner(file);\n        scanner.useDelimiter(Character.toString(delimiter));\n\n        clear();\n\n        while(scanner.hasNextLine()) {\n            String[] values = scanner.nextLine().split(Character.toString(delimiter));\n\n            int col = 0;\n            for ( String value: values ) {\n                _map.put(new Point(col, _rows), value);\n                _cols = Math.max(_cols, ++col);\n            }\n            _rows++;\n        }\n        scanner.close();\n    }\n\n    public void save(File file) throws IOException {\n        save(file, ',');\n    }\n\n    public void save(File file, char delimiter) throws IOException {\n        FileWriter fw = new FileWriter(file);\n        BufferedWriter bw = new BufferedWriter(fw);\n\n        for (int row = 0; row < _rows; row++) {\n            for (int col = 0; col < _cols; col++) {\n                Point key = new Point(col, row);\n                if (_map.containsKey(key)) {\n                    bw.write(_map.get(key));\n                }\n\n                if ((col + 1) < _cols) {\n                    bw.write(delimiter);\n                }\n            }\n            bw.newLine();\n        }\n        bw.flush();\n        bw.close();\n    }\n\n    public String get(int col, int row) {\n        String val = \"\";\n        Point key = new Point(col, row);\n        if (_map.containsKey(key)) {\n            val = _map.get(key);\n        }\n        return val;\n    }\n\n    public void put(int col, int row, String value) {\n        _map.put(new Point(col, row), value);\n        _cols = Math.max(_cols, col+1);\n        _rows = Math.max(_rows, row+1);\n    }\n\n    public void clear() {\n        _map.clear();\n        _cols = 0;\n        _rows = 0;\n    }\n\n    public int rows() {\n        return _rows;\n    }\n\n    public int cols() {\n        return _cols;\n    }\n\n    public static void main(String[] args) {\n        try {\n            CSV csv = new CSV();\n\n            csv.open(new File(\"test_in.csv\"));\n            csv.put(0, 0, \"Column0\");\n            csv.put(1, 1, \"100\");\n            csv.put(2, 2, \"200\");\n            csv.put(3, 3, \"300\");\n            csv.put(4, 4, \"400\");\n            csv.save(new File(\"test_out.csv\"));\n        } catch (Exception e) {\n        }\n    }\n}\n"}
{"id": 4119, "name": "CSV data manipulation", "source": "Translate Fortran to Python: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4120, "name": "CSV data manipulation", "source": "Translate Fortran to Python: program rowsum\n    implicit none\n    character(:), allocatable :: line, name, a(:)\n    character(20) :: fmt\n    double precision, allocatable :: v(:)\n    integer :: n, nrow, ncol, i\n    \n    call get_command_argument(1, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(1, name)\n    open(unit=10, file=name, action=\"read\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n    \n    call get_command_argument(2, length=n)\n    allocate(character(n) :: name)\n    call get_command_argument(2, name)\n    open(unit=11, file=name, action=\"write\", form=\"formatted\", access=\"stream\")\n    deallocate(name)\n\n    nrow = 0\n    ncol = 0\n    do while (readline(10, line))\n        nrow = nrow + 1\n        \n        call split(line, a)\n        \n        if (nrow == 1) then\n            ncol = size(a)\n            write(11, \"(A)\", advance=\"no\") line\n            write(11, \"(A)\") \",Sum\"\n            allocate(v(ncol + 1))\n            write(fmt, \"('(',G0,'(G0,:,''',A,'''))')\") ncol + 1, \",\"\n        else\n            if (size(a) /= ncol) then\n                print \"(A,' ',G0)\", \"Invalid number of values on row\", nrow\n                stop\n            end if\n\n            do i = 1, ncol\n                read(a(i), *) v(i)\n            end do\n            v(ncol + 1) = sum(v(1:ncol))\n            write(11, fmt) v\n        end if\n    end do\n    close(10)\n    close(11)\ncontains\n    function readline(unit, line)\n        use iso_fortran_env\n        logical :: readline\n        integer :: unit, ios, n\n        character(:), allocatable :: line\n        character(10) :: buffer\n        \n        line = \"\"\n        readline = .false.\n        do\n            read(unit, \"(A)\", advance=\"no\", size=n, iostat=ios) buffer\n            if (ios == iostat_end) return\n            readline = .true.\n            line = line // buffer(1:n)\n            if (ios == iostat_eor) return\n        end do\n    end function\n\n    subroutine split(line, array, separator)\n        character(*) line\n        character(:), allocatable :: array(:)\n        character, optional :: separator\n        character :: sep\n        integer :: n, m, p, i, k\n        \n        if (present(separator)) then\n            sep = separator\n        else\n            sep = \",\"\n        end if\n        \n        n = len(line)\n        m = 0\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                p = p + 1\n                m = max(m, i - k)\n                k = i + 1\n            end if\n        end do\n        m = max(m, n - k + 1)\n        \n        if (allocated(array)) deallocate(array)\n        allocate(character(m) :: array(p))\n\n        p = 1\n        k = 1\n        do i = 1, n\n            if (line(i:i) == sep) then\n                array(p) = line(k:i-1)\n                p = p + 1\n                k = i + 1\n            end if\n        end do\n        array(p) = line(k:n)\n    end subroutine\nend program\n", "target": "import fileinput\n\nchangerow, changecolumn, changevalue = 2, 4, '\"Spam\"'\n\nwith fileinput.input('csv_data_manipulation.csv', inplace=True) as f:\n    for line in f:\n        if fileinput.filelineno() == changerow:\n            fields = line.rstrip().split(',')\n            fields[changecolumn-1] = changevalue\n            line = ','.join(fields) + '\\n'\n        print(line, end='')\n"}
{"id": 4959, "name": "Read entire file", "source": "Translate Fortran to C#: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var fileContents = File.ReadAllText(\"c:\\\\autoexec.bat\");  \n        \n    }\n}\n"}
{"id": 4962, "name": "Read entire file", "source": "Translate Fortran to Java: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "static Byte[] contentsOf(File file)\n    {\n    return file.contents;\n    }\n"}
{"id": 4963, "name": "Read entire file", "source": "Translate Fortran to Python: program read_file\n    implicit none\n    integer :: n\n    character(:), allocatable :: s\n    \n    open(unit=10, file=\"read_file.f90\", action=\"read\", &\n         form=\"unformatted\", access=\"stream\")\n    inquire(unit=10, size=n)\n    allocate(character(n) :: s)\n    read(10) s\n    close(10)\n    \n    print \"(A)\", s\nend program\n", "target": "open(filename).read()\n"}
{"id": 5144, "name": "Undefined values", "source": "Translate Fortran to Python: IsNaN(x)\n", "target": "\ntry: name\nexcept NameError: print \"name is undefined at first check\"\n\n\nname = \"Chocolate\"\n\n\ntry: name\nexcept NameError: print \"name is undefined at second check\"\n\n\ndel name\n\n\ntry: name\nexcept NameError: print \"name is undefined at third check\"\n\n\nname = 42\n\n\ntry: name\nexcept NameError: print \"name is undefined at fourth check\"\n\n\n\nprint \"Done\"\n"}
{"id": 5656, "name": "SHA-1", "source": "Translate Fortran to C#: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5657, "name": "SHA-1", "source": "Translate Fortran to C#: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "using System;\nusing System.Security.Cryptography;\nusing System.Text;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace RosettaCode.SHA1\n{\n    [TestClass]\n    public class SHA1CryptoServiceProviderTest\n    {\n        [TestMethod]\n        public void TestComputeHash()\n        {\n            var input = new UTF8Encoding().GetBytes(\"Rosetta Code\");\n            var output = new SHA1CryptoServiceProvider().ComputeHash(input);\n            Assert.AreEqual(\n                \"48-C9-8F-7E-5A-6E-73-6D-79-0A-B7-40-DF-C3-F5-1A-61-AB-E2-B5\",\n                BitConverter.ToString(output));\n        }\n    }\n}\n"}
{"id": 5663, "name": "SHA-1", "source": "Translate Fortran to Python: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 5664, "name": "SHA-1", "source": "Translate Fortran to Python: module sha1_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: SHA1LEN = 20\ncontains\n    subroutine sha1hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(SHA1LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_SHA1, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n \n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = SHA1LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram sha1\n    use sha1_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(SHA1LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call sha1hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, SHA1LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n", "target": "import crypto { sha1 }\nlet hash = sha1.hexdigest('Ars longa, vita brevis')\nprint hash\n"}
{"id": 6083, "name": "Man or boy test", "source": "Translate Fortran to C#: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "using System;\n \ndelegate T Func<T>();\n \nclass ManOrBoy\n{\n    static void Main()\n    {\n        Console.WriteLine(A(10, C(1), C(-1), C(-1), C(1), C(0)));\n    }\n \n    static Func<int> C(int i)\n    {\n        return delegate { return i; };\n    }\n \n    static int A(int k, Func<int> x1, Func<int> x2, Func<int> x3, Func<int> x4, Func<int> x5)\n    {\n        Func<int> b = null;\n        b = delegate { k--; return A(k, b, x1, x2, x3, x4); };\n        return k <= 0 ? x4() + x5() : b();\n    }\n}\n"}
{"id": 6086, "name": "Man or boy test", "source": "Translate Fortran to Java: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "import java.util.function.DoubleSupplier;\n\npublic class ManOrBoy {\n    \n    static double A(int k, DoubleSupplier x1, DoubleSupplier x2,\n                 DoubleSupplier x3, DoubleSupplier x4, DoubleSupplier x5) {\n        \n        DoubleSupplier B = new DoubleSupplier() {\n            int m = k;\n            public double getAsDouble() {\n                return A(--m, this, x1, x2, x3, x4);\n            }\n        };\n                \n        return k <= 0 ? x4.getAsDouble() + x5.getAsDouble() : B.getAsDouble();\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(A(10, () -> 1.0, () -> -1.0, () -> -1.0, () -> 1.0, () -> 0.0));\n    }\n}\n"}
{"id": 6087, "name": "Man or boy test", "source": "Translate Fortran to Python: module man_or_boy\n\nimplicit none\n\ncontains\n\n  recursive integer function A(k,x1,x2,x3,x4,x5) result(res)\n    integer, intent(in) :: k\n    interface\n      recursive integer function x1()\n      end function\n      recursive integer function x2()\n      end function\n      recursive integer function x3()\n      end function\n      recursive integer function x4()\n      end function\n      recursive integer function x5()\n      end function\n    end interface\n    integer :: m\n    if ( k <= 0 ) then\n      res = x4()+x5()\n    else\n      m = k\n      res = B()\n    end if\n  \n  contains\n  \n    recursive integer function B() result(res)    \n      m = m-1\n      res = A(m,B,x1,x2,x3,x4)\n    end function B\n  \n  end function A\n\n\n  recursive integer function one() result(res)\n    res = 1\n  end function\n\n  recursive integer function minus_one() result(res)\n    res = -1\n  end function\n\n  recursive integer function zero() result(res)\n    res = 0\n  end function\n\nend module man_or_boy\n\nprogram test\n  use man_or_boy\n  write (*,*) A(10,one,minus_one,minus_one,one,zero)\nend program test\n", "target": "\nimport sys\nsys.setrecursionlimit(1025)\n\ndef a(in_k, x1, x2, x3, x4, x5):\n    k = [in_k]\n    def b():\n        k[0] -= 1\n        return a(k[0], b, x1, x2, x3, x4)\n    return x4() + x5() if k[0] <= 0 else b()\n\nx = lambda i: lambda: i\nprint(a(10, x(1), x(-1), x(-1), x(1), x(0)))\n"}
{"id": 6556, "name": "Collections", "source": "Translate Fortran to C#:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n"}
{"id": 6559, "name": "Collections", "source": "Translate Fortran to Java:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "List arrayList = new ArrayList();\narrayList.add(new Integer(0));\n\narrayList.add(0); \n\n\n\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n"}
{"id": 6560, "name": "Collections", "source": "Translate Fortran to Python:  REAL A(36)   \n  A(1) = 1           \n  A(2) = 3*A(1) + 5  \n", "target": "collection = [0, '1']                 \nx = collection[0]                     \ncollection.append(2)                  \ncollection.insert(0, '-1')            \ny = collection[0]                     \ncollection.extend([2,'3'])            \ncollection += [2,'3']                 \ncollection[2:6]                       \nlen(collection)                       \ncollection = (0, 1)                   \ncollection[:]                         \ncollection[-4:-1]                     \ncollection[::2]                       \ncollection=\"some string\"              \nx = collection[::-1]                  \ncollection[::2] == \"some string\"[::2] \ncollection.__getitem__(slice(0,len(collection),2))  \ncollection = {0: \"zero\", 1: \"one\"}    \ncollection['zero'] = 2                \ncollection = set([0, '1'])            \n"}
{"id": 6777, "name": "Matrix-exponentiation operator", "source": "Translate Fortran to C#: module matmod\n  implicit none\n   \n\n\n\n  interface operator (.matpow.)\n    module procedure matrix_exp\n  end interface\n\ncontains\n\nfunction matrix_exp(m, n) result (res)\n  real, intent(in)  :: m(:,:)\n  integer, intent(in)  :: n\n  real :: res(size(m,1),size(m,2))\n  integer :: i\n   \n  if(n == 0) then\n    res = 0\n    do i = 1, size(m,1)\n      res(i,i) = 1\n    end do\n    return\n  end if\n\n  res = m\n  do i = 2, n\n    res = matmul(res, m)\n  end do\n  \nend function matrix_exp\nend module matmod\n\nprogram Matrix_exponentiation\n  use matmod\n  implicit none\n\n  integer, parameter :: n = 3\n  real, dimension(n,n) :: m1, m2\n  integer :: i, j\n  \n  m1 = reshape((/ (i, i = 1, n*n) /), (/ n, n /), order = (/ 2, 1 /))\n \n  do i = 0, 4\n    m2 = m1 .matpow. i\n    do j = 1, size(m2,1)\n      write(*,*) m2(j,:)\n    end do\n    write(*,*)\n  end do\n\nend program Matrix_exponentiation\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class MatrixExponentation\n{\n    public static double[,] Identity(int size) {\n        double[,] matrix = new double[size, size];\n        for (int i = 0; i < size; i++) matrix[i, i] = 1;\n        return matrix;\n    }\n\n    public static double[,] Multiply(this double[,] left, double[,] right) {\n        if (left.ColumnCount() != right.RowCount()) throw new ArgumentException();\n        double[,] m = new double[left.RowCount(), right.ColumnCount()];\n        foreach (var (row, column) in from r in Range(0, m.RowCount()) from c in Range(0, m.ColumnCount()) select (r, c)) {\n            m[row, column] = Range(0, m.RowCount()).Sum(i => left[row, i] * right[i, column]);\n        }\n        return m;\n    }\n\n    public static double[,] Pow(this double[,] matrix, int exp) {\n        if (matrix.RowCount() != matrix.ColumnCount()) throw new ArgumentException(\"Matrix must be square.\");\n        double[,] accumulator = Identity(matrix.RowCount());\n        for (int i = 0; i < exp; i++) {\n            accumulator = accumulator.Multiply(matrix);\n        }\n        return accumulator;\n    }\n\n    private static int RowCount(this double[,] matrix) => matrix.GetLength(0);\n    private static int ColumnCount(this double[,] matrix) => matrix.GetLength(1);\n\n    private static void Print(this double[,] m) {\n        foreach (var row in Rows()) {\n            Console.WriteLine(\"[ \" + string.Join(\"   \", row) + \" ]\");\n        }\n        Console.WriteLine();\n\n        IEnumerable<IEnumerable<double>> Rows() =>\n            Range(0, m.RowCount()).Select(row => Range(0, m.ColumnCount()).Select(column => m[row, column]));\n    }\n\n    public static void Main() {\n        var matrix = new double[,] {\n            { 3, 2 },\n            { 2, 1 }\n        };\n        \n        matrix.Pow(0).Print();\n        matrix.Pow(1).Print();\n        matrix.Pow(2).Print();\n        matrix.Pow(3).Print();\n        matrix.Pow(4).Print();\n        matrix.Pow(50).Print();\n    }\n\n}\n"}
{"id": 6780, "name": "Matrix-exponentiation operator", "source": "Translate Fortran to Python: module matmod\n  implicit none\n   \n\n\n\n  interface operator (.matpow.)\n    module procedure matrix_exp\n  end interface\n\ncontains\n\nfunction matrix_exp(m, n) result (res)\n  real, intent(in)  :: m(:,:)\n  integer, intent(in)  :: n\n  real :: res(size(m,1),size(m,2))\n  integer :: i\n   \n  if(n == 0) then\n    res = 0\n    do i = 1, size(m,1)\n      res(i,i) = 1\n    end do\n    return\n  end if\n\n  res = m\n  do i = 2, n\n    res = matmul(res, m)\n  end do\n  \nend function matrix_exp\nend module matmod\n\nprogram Matrix_exponentiation\n  use matmod\n  implicit none\n\n  integer, parameter :: n = 3\n  real, dimension(n,n) :: m1, m2\n  integer :: i, j\n  \n  m1 = reshape((/ (i, i = 1, n*n) /), (/ n, n /), order = (/ 2, 1 /))\n \n  do i = 0, 4\n    m2 = m1 .matpow. i\n    do j = 1, size(m2,1)\n      write(*,*) m2(j,:)\n    end do\n    write(*,*)\n  end do\n\nend program Matrix_exponentiation\n", "target": ">>> from operator import mul\n>>> def matrixMul(m1, m2):\n  return map(\n    lambda row:\n      map(\n        lambda *column:\n          sum(map(mul, row, column)),\n        *m2),\n    m1)\n\n>>> def identity(size):\n\tsize = range(size)\n\treturn [[(i==j)*1 for i in size] for j in size]\n\n>>> def matrixExp(m, pow):\n\tassert pow>=0 and int(pow)==pow, \"Only non-negative, integer powers allowed\"\n\taccumulator = identity(len(m))\n\tfor i in range(pow):\n\t\taccumulator = matrixMul(accumulator, m)\n\treturn accumulator\n\n>>> def printtable(data):\n\tfor row in data:\n\t\tprint ' '.join('%-5s' % ('%s' % cell) for cell in row)\n\n\t\t\n>>> m = [[3,2], [2,1]]\n>>> for i in range(5):\n\tprint '\\n%i:' % i\n\tprinttable( matrixExp(m, i) )\n\n\t\n\n0:\n1     0    \n0     1    \n\n1:\n3     2    \n2     1    \n\n2:\n13    8    \n8     5    \n\n3:\n55    34   \n34    21   \n\n4:\n233   144  \n144   89   \n>>> printtable( matrixExp(m, 10) )\n1346269 832040\n832040 514229\n>>>\n"}
{"id": 6949, "name": "Tree traversal", "source": "Translate Fortran to C#:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Node\n{\n    int Value;\n    Node Left;\n    Node Right;\n\n    Node(int value = default(int), Node left = default(Node), Node right = default(Node))\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    IEnumerable<int> Preorder()\n    {\n        yield return Value;\n        if (Left != null)\n            foreach (var value in Left.Preorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Preorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Inorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Inorder())\n                yield return value;\n        yield return Value;\n        if (Right != null)\n            foreach (var value in Right.Inorder())\n                yield return value;\n    }\n\n    IEnumerable<int> Postorder()\n    {\n        if (Left != null)\n            foreach (var value in Left.Postorder())\n                yield return value;\n        if (Right != null)\n            foreach (var value in Right.Postorder())\n                yield return value;\n        yield return Value;\n    }\n\n    IEnumerable<int> LevelOrder()\n    {\n        var queue = new Queue<Node>();\n        queue.Enqueue(this);\n        while (queue.Any())\n        {\n            var node = queue.Dequeue();\n            yield return node.Value;\n            if (node.Left != null)\n                queue.Enqueue(node.Left);\n            if (node.Right != null)\n                queue.Enqueue(node.Right);\n        }\n    }\n\n    static void Main()\n    {\n        var tree = new Node(1, new Node(2, new Node(4, new Node(7)), new Node(5)), new Node(3, new Node(6, new Node(8), new Node(9))));\n        foreach (var traversal in new Func<IEnumerable<int>>[] { tree.Preorder, tree.Inorder, tree.Postorder, tree.LevelOrder })\n            Console.WriteLine(\"{0}:\\t{1}\", traversal.Method.Name, string.Join(\" \", traversal()));\n    }\n}\n"}
{"id": 6952, "name": "Tree traversal", "source": "Translate Fortran to Java:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "import java.util.*;\n\npublic class TreeTraversal {\n\n        static class Node<T> {\n\t\tT value;\n\t\tNode<T> left;\n\t\tNode<T> right;\n\n\t\tNode(T value) {\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tvoid visit() {\n\t\t\tSystem.out.print(this.value + \" \");\n\t\t}\n\t}\n\n\tstatic enum ORDER {\n\t\tPREORDER, INORDER, POSTORDER, LEVEL\n\t}\n        \n        static <T> void traverse(Node<T> node, ORDER order) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (order) {\n\t\tcase PREORDER:\n\t\t\tnode.visit();\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase INORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\tnode.visit();\n\t\t\ttraverse(node.right, order);\n\t\t\tbreak;\n\t\tcase POSTORDER:\n\t\t\ttraverse(node.left, order);\n\t\t\ttraverse(node.right, order);\n\t\t\tnode.visit();\n\t\t\tbreak;\n\t\tcase LEVEL:\n\t\t\tQueue<Node<T>> queue = new LinkedList<>();\n\t\t\tqueue.add(node);\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tNode<T> next = queue.remove();\n\t\t\t\tnext.visit();\n\t\t\t\tif(next.left!=null)\n\t\t\t\t\tqueue.add(next.left);\n\t\t\t\tif(next.right!=null)\n\t\t\t\t\tqueue.add(next.right);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tpublic static void main(String[] args) {\n\n\t\tNode<Integer> one = new Node<Integer>(1);\n\t\tNode<Integer> two = new Node<Integer>(2);\n\t\tNode<Integer> three = new Node<Integer>(3);\n\t\tNode<Integer> four = new Node<Integer>(4);\n\t\tNode<Integer> five = new Node<Integer>(5);\n\t\tNode<Integer> six = new Node<Integer>(6);\n\t\tNode<Integer> seven = new Node<Integer>(7);\n\t\tNode<Integer> eight = new Node<Integer>(8);\n\t\tNode<Integer> nine = new Node<Integer>(9);\n\t\t\n\t\tone.left = two;\n\t\tone.right = three;\n\t\ttwo.left = four;\n\t\ttwo.right = five;\n\t\tthree.left = six;\n\t\tfour.left = seven;\n\t\tsix.left = eight;\n\t\tsix.right = nine;\n\n\t\ttraverse(one, ORDER.PREORDER);\n\t\tSystem.out.println(); \n\t\ttraverse(one, ORDER.INORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.POSTORDER);\n\t\tSystem.out.println();\n\t\ttraverse(one, ORDER.LEVEL);\n\t\t\n\t}\n}\n"}
{"id": 6953, "name": "Tree traversal", "source": "Translate Fortran to Python:       IF (STYLE.EQ.\"PRE\")  CALL OUT(HAS)\n      IF (LINKL(HAS).GT.0) CALL TARZAN(LINKL(HAS),STYLE)\n      IF (STYLE.EQ.\"IN\")   CALL OUT(HAS)\n      IF (LINKR(HAS).GT.0) CALL TARZAN(LINKR(HAS),STYLE)\n      IF (STYLE.EQ.\"POST\") CALL OUT(HAS)\n", "target": "from collections import namedtuple\n \nNode = namedtuple('Node', 'data, left, right')\ntree = Node(1,\n            Node(2,\n                 Node(4,\n                      Node(7, None, None),\n                      None),\n                 Node(5, None, None)),\n            Node(3,\n                 Node(6,\n                      Node(8, None, None),\n                      Node(9, None, None)),\n                 None))\n \ndef printwithspace(i):\n    print(i, end=' ')\n\ndef dfs(order, node, visitor):\n    if node is not None:\n        for action in order:\n            if action == 'N':\n                visitor(node.data)\n            elif action == 'L':\n                dfs(order, node.left, visitor)\n            elif action == 'R':\n                dfs(order, node.right, visitor)\n                \ndef preorder(node, visitor = printwithspace):\n    dfs('NLR', node, visitor)\n \ndef inorder(node, visitor = printwithspace):\n    dfs('LNR', node, visitor)\n \ndef postorder(node, visitor = printwithspace):\n    dfs('LRN', node, visitor)\n \ndef ls(node, more, visitor, order='TB'):\n    \"Level-based Top-to-Bottom or Bottom-to-Top tree search\"\n    if node:\n        if more is None:\n            more = []\n        more += [node.left, node.right]\n    for action in order:\n        if action == 'B' and more:\n            ls(more[0], more[1:], visitor, order)\n        elif action == 'T' and node:\n            visitor(node.data)\n\ndef levelorder(node, more=None, visitor = printwithspace):\n    ls(node, more, visitor, 'TB') \n \n\ndef reverse_preorder(node, visitor = printwithspace):\n    dfs('RLN', node, visitor)\n    \ndef bottom_up_order(node, more=None, visitor = printwithspace, order='BT'):\n    ls(node, more, visitor, 'BT')\n\n\nif __name__ == '__main__':\n    w = 10\n    for traversal in [preorder, inorder, postorder, levelorder, \n                      reverse_preorder, bottom_up_order]:\n        if traversal == reverse_preorder:\n            w = 20\n            print('\\nThe generalisation of function dfs allows:')\n        if traversal == bottom_up_order:\n            print('The generalisation of function ls allows:')\n        print(f\"{traversal.__name__:>{w}}:\", end=' ')\n        traversal(tree)\n        print()\n"}
{"id": 7167, "name": "List comprehensions", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "using System.Linq;\n\nstatic class Program\n{\n  static void Main()\n  {\n    var ts =\n      from a in Enumerable.Range(1, 20)\n      from b in Enumerable.Range(a, 21 - a)\n      from c in Enumerable.Range(b, 21 - b)\n      where a * a + b * b == c * c\n      select new { a, b, c };\n\n      foreach (var t in ts)\n        System.Console.WriteLine(\"{0}, {1}, {2}\", t.a, t.b, t.c);\n  }\n}\n"}
{"id": 7170, "name": "List comprehensions", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "\nimport java.util.Arrays;\nimport java.util.List;\nimport static java.util.function.Function.identity;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\npublic interface PythagComp{\n    static void main(String... args){\n        System.out.println(run(20));\n    }\n\n    static List<List<Integer>> run(int n){\n        return\n            \n            \n            range(1, n).mapToObj(\n                x -> range(x, n).mapToObj(\n                    y -> range(y, n).mapToObj(\n                        z -> new Integer[]{x, y, z}\n                    )\n                )\n            )\n                .flatMap(identity())\n                .flatMap(identity())\n                \n                .filter(a -> a[0]*a[0] + a[1]*a[1] == a[2]*a[2])\n                \n                .map(Arrays::asList)\n                \n                .collect(toList())\n        ;\n    }\n}\n"}
{"id": 7171, "name": "List comprehensions", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n \nprogram list_comprehension\n  integer, parameter :: n = 20\n  integer, parameter :: m = n*(n+1)/2\n  integer :: i, j\n  complex, dimension(m) :: a\n  real, dimension(m) :: b\n  logical, dimension(m) :: c\n  integer, dimension(3, m) :: d\n  a = [ ( ( cmplx(i,j), i=j,n), j=1,n) ] \n  b = abs(a)\n  c = (b .eq. int(b)) .and. (b .le. n)\n  i = sum(merge(1,0,c))\n  d(2,:i) = int(real(pack(a, c))) \n  d(1,:i) = int(imag(pack(a, c))) \n  d(3,:i) = int(pack(b,c))\n  print '(3i4)',d(:,:i)\nend program list_comprehension\n", "target": "[(x,y,z) for x in xrange(1,n+1) for y in xrange(x,n+1) for z in xrange(y,n+1) if x**2 + y**2 == z**2]\n"}
{"id": 7549, "name": "Abundant odd numbers", "source": "Translate Fortran to C#: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7550, "name": "Abundant odd numbers", "source": "Translate Fortran to C#: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class AbundantOddNumbers\n{\n    public static void Main() {\n        WriteLine(\"First 25 abundant odd numbers:\");\n        foreach (var x in AbundantNumbers().Take(25)) WriteLine(x.Format());\n        WriteLine();\n        WriteLine($\"The 1000th abundant odd number: {AbundantNumbers().ElementAt(999).Format()}\");\n        WriteLine();\n        WriteLine($\"First abundant odd number > 1b: {AbundantNumbers(1_000_000_001).First().Format()}\");\n    }\n\n    static IEnumerable<(int n, int sum)> AbundantNumbers(int start = 3) =>\n        start.UpBy(2).Select(n => (n, sum: n.DivisorSum())).Where(x => x.sum > x.n);\n\n    static int DivisorSum(this int n) => 3.UpBy(2).TakeWhile(i => i * i <= n).Where(i => n % i == 0)\n        .Select(i => (a:i, b:n/i)).Sum(p => p.a == p.b ? p.a : p.a + p.b) + 1;\n\n    static IEnumerable<int> UpBy(this int n, int step) {\n        for (int i = n; ; i+=step) yield return i;\n    }\n\n    static string Format(this (int n, int sum) pair) => $\"{pair.n:N0} with sum {pair.sum:N0}\";\n}\n"}
{"id": 7555, "name": "Abundant odd numbers", "source": "Translate Fortran to Java: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7556, "name": "Abundant odd numbers", "source": "Translate Fortran to Java: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class AbundantOddNumbers {\n    private static List<Integer> list = new ArrayList<>();\n    private static List<Integer> result = new ArrayList<>();\n\n    public static void main(String[] args) {\n        System.out.println(\"First 25: \");\n        abundantOdd(1,100000, 25, false);\n\n        System.out.println(\"\\n\\nThousandth: \");\n        abundantOdd(1,2500000, 1000, true);\n\n        System.out.println(\"\\n\\nFirst over 1bn:\"); \n        abundantOdd(1000000001, 2147483647, 1, false);\n    }\n    private static void abundantOdd(int start, int finish, int listSize, boolean printOne) {\n        for (int oddNum = start; oddNum < finish; oddNum += 2) {\n            list.clear();\n            for (int toDivide = 1; toDivide < oddNum; toDivide+=2) {\n                if (oddNum % toDivide == 0)\n                    list.add(toDivide);\n            }\n            if (sumList(list) > oddNum) {\n                if(!printOne)\n                    System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n                result.add(oddNum);\n            }\n            if(printOne && result.size() >= listSize)\n                System.out.printf(\"%5d <= %5d \\n\",oddNum, sumList(list) );\n\n            if(result.size() >= listSize) break;\n        }\n    }\n    private static int sumList(List list) {\n        int sum = 0;\n        for (int i = 0; i < list.size(); i++) {\n            String temp = list.get(i).toString();\n            sum += Integer.parseInt(temp);\n        }\n        return sum;\n    }\n}\n"}
{"id": 7557, "name": "Abundant odd numbers", "source": "Translate Fortran to Python: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 7558, "name": "Abundant odd numbers", "source": "Translate Fortran to Python: program main\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger,parameter          :: dp=kind(0.0d0)\ncharacter(len=*),parameter :: g='(*(g0,1x))'\ninteger                    :: j, icount\ninteger,allocatable        :: list(:)\nreal(kind=dp)              :: tally\n\n   write(*,*)'N sum'\n   icount=0                       \n   do j=1,huge(0)-1,2             \n      list=divisors(j)            \n      tally= sum([real(list,kind=dp)]) \n      if(tally>2*j .and. iand(j,1) /= 0) then \n         icount=icount+1\n         select case(icount)  \n         case(1:25,1000);write(*,g)icount,':',j\n         end select\n      endif\n      if(icount.gt.1000)exit \n   enddo\n\n   do j=1000000001,huge(0),2\n      list=divisors(j)\n      tally= sum([real(list,kind=dp)])\n      if(tally>2*j .and. iand(j,1) /= 0) then\n         write(*,g)'First abundant odd number greater than one billion:',j\n\n         exit\n      endif\n   enddo\n\ncontains\n\nfunction divisors(num) result (numbers)\n\ninteger,intent(in) :: num\ninteger :: i\ninteger,allocatable :: numbers(:)\n   numbers=[integer :: ]\n   do i=1 , int(sqrt(real(num)))\n      if (mod(num , i)  .eq. 0) numbers=[numbers, i,num/i]\n   enddo\nend function divisors\n\nend program main\n", "target": "\n\n\noddNumber  = 1\naCount  = 0\ndSum  = 0\n \nfrom math import sqrt\n \ndef divisorSum(n):\n    sum = 1\n    i = int(sqrt(n)+1)\n \n    for d in range (2, i):\n        if n % d == 0:\n            sum += d\n            otherD = n // d\n            if otherD != d:\n                sum += otherD\n    return sum\n \nprint (\"The first 25 abundant odd numbers:\")\nwhile aCount  < 25:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n        print(\"{0:5} proper divisor sum: {1}\". format(oddNumber ,dSum ))\n    oddNumber  += 2\n \nwhile aCount  < 1000:\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        aCount  += 1\n    oddNumber  += 2\nprint (\"\\n1000th abundant odd number:\")\nprint (\"    \",(oddNumber - 2),\" proper divisor sum: \",dSum)\n \noddNumber  = 1000000001\nfound  = False\nwhile not found :\n    dSum  = divisorSum(oddNumber )\n    if dSum  > oddNumber :\n        found  = True\n        print (\"\\nFirst abundant odd number > 1 000 000 000:\")\n        print (\"    \",oddNumber,\" proper divisor sum: \",dSum)\n    oddNumber  += 2\n"}
{"id": 8081, "name": "Combinations", "source": "Translate Fortran to C#: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static IEnumerable<int[]> Combinations(int m, int n)\n    {\n            int[] result = new int[m];\n            Stack<int> stack = new Stack<int>();\n            stack.Push(0);\n\n            while (stack.Count > 0)\n           {\n                int index = stack.Count - 1;\n                int value = stack.Pop();\n\n                while (value < n) \n               {\n                    result[index++] = ++value;\n                    stack.Push(value);\n\n                    if (index == m) \n                    {\n                        yield return result;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void Main()\n    {\n        foreach (int[] c in Combinations(3, 5))\n        {\n            Console.WriteLine(string.Join(\",\", c));\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 8085, "name": "Combinations", "source": "Translate Fortran to Java: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": "import java.util.Collections;\nimport java.util.LinkedList;\n\npublic class Comb{\n\n        public static void main(String[] args){\n                System.out.println(comb(3,5));\n        }\n\n        public static String bitprint(int u){\n                String s= \"\";\n                for(int n= 0;u > 0;++n, u>>= 1)\n                        if((u & 1) > 0) s+= n + \" \";\n                return s;\n        }\n\n        public static int bitcount(int u){\n                int n;\n                for(n= 0;u > 0;++n, u&= (u - 1));\n                return n;\n        }\n\n        public static LinkedList<String> comb(int c, int n){\n                LinkedList<String> s= new LinkedList<String>();\n                for(int u= 0;u < 1 << n;u++)\n                        if(bitcount(u) == c) s.push(bitprint(u));\n                Collections.sort(s);\n                return s;\n        }\n}\n"}
{"id": 8086, "name": "Combinations", "source": "Translate Fortran to Python: program Combinations\n  use iso_fortran_env\n  implicit none\n\n  type comb_result\n     integer, dimension(:), allocatable :: combs\n  end type comb_result\n\n  type(comb_result), dimension(:), pointer :: r\n  integer :: i, j\n\n  call comb(5, 3, r)\n  do i = 0, choose(5, 3) - 1\n     do j = 2, 0, -1\n        write(*, \"(I4, ' ')\", advance=\"no\") r(i)%combs(j)\n     end do\n     deallocate(r(i)%combs)\n     write(*,*) \"\"\n  end do\n  deallocate(r)\n\ncontains\n\n  function choose(n, k, err)\n    integer :: choose\n    integer, intent(in) :: n, k\n    integer, optional, intent(out) :: err\n\n    integer :: imax, i, imin, ie\n\n    ie = 0\n    if ( (n < 0 ) .or. (k < 0 ) ) then\n       write(ERROR_UNIT, *) \"negative in choose\"\n       choose = 0\n       ie = 1\n    else\n       if ( n < k ) then\n          choose = 0\n       else if ( n == k ) then\n          choose = 1\n       else\n          imax = max(k, n-k)\n          imin = min(k, n-k)\n          choose = 1\n          do i = imax+1, n\n             choose = choose * i\n          end do\n          do i = 2, imin\n             choose = choose / i\n          end do\n       end if\n    end if\n    if ( present(err) ) err = ie\n  end function choose\n\n  subroutine comb(n, k, co)\n    integer, intent(in) :: n, k\n    type(comb_result), dimension(:), pointer, intent(out) :: co\n\n    integer :: i, j, s, ix, kx, hm, t\n    integer :: err\n   \n    hm = choose(n, k, err)\n    if ( err /= 0 ) then\n       nullify(co)\n       return\n    end if\n\n    allocate(co(0:hm-1))\n    do i = 0, hm-1\n       allocate(co(i)%combs(0:k-1))\n    end do\n    do i = 0, hm-1\n       ix = i; kx = k\n       do s = 0, n-1\n          if ( kx == 0 ) exit\n          t = choose(n-(s+1), kx-1)\n          if ( ix < t ) then\n             co(i)%combs(kx-1) = s\n             kx = kx - 1\n          else\n             ix = ix - t\n          end if\n       end do\n    end do\n\n  end subroutine comb\n\nend program Combinations\n", "target": ">>> from itertools import combinations\n>>> list(combinations(range(5),3))\n[(0, 1, 2), (0, 1, 3), (0, 1, 4), (0, 2, 3), (0, 2, 4), (0, 3, 4), (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n"}
{"id": 8628, "name": "Department numbers", "source": "Translate Fortran to C#:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8629, "name": "Department numbers", "source": "Translate Fortran to C#:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "using System;\npublic class Program\n{\n    public static void Main() {\n        for (int p = 2; p <= 7; p+=2) {\n            for (int s = 1; s <= 7; s++) {\n                int f = 12 - p - s;\n                if (s >= f) break;\n                if (f > 7) continue;\n                if (s == p || f == p) continue; \n                Console.WriteLine($\"Police:{p}, Sanitation:{s}, Fire:{f}\");\n                Console.WriteLine($\"Police:{p}, Sanitation:{f}, Fire:{s}\");\n            }\n        }\n    }\n}\n"}
{"id": 8634, "name": "Department numbers", "source": "Translate Fortran to Java:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8635, "name": "Department numbers", "source": "Translate Fortran to Java:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "public class DepartmentNumbers {\n    public static void main(String[] args) {\n        System.out.println(\"Police  Sanitation  Fire\");\n        System.out.println(\"------  ----------  ----\");\n        int count = 0;\n        for (int i = 2; i <= 6; i += 2) {\n            for (int j = 1; j <= 7; ++j) {\n                if (j == i) continue;\n                for (int k = 1; k <= 7; ++k) {\n                    if (k == i || k == j) continue;\n                    if (i + j + k != 12) continue;\n                    System.out.printf(\"  %d         %d         %d\\n\", i, j, k);\n                    count++;\n                }\n            }\n        }\n        System.out.printf(\"\\n%d valid combinations\", count);\n    }\n}\n"}
{"id": 8636, "name": "Department numbers", "source": "Translate Fortran to Python:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 8637, "name": "Department numbers", "source": "Translate Fortran to Python:       INTEGER P,S,F\t\n    1  PP:DO P = 2,7,2\t\n    2   SS:DO S = 1,7\t\t\n    3        IF (P.EQ.S) CYCLE SS\t\n    4        F = 12 - (P + S)\t\t\n    5        IF (F.LE.0 .OR. F.GT.7) CYCLE SS\t\n    6        IF ((F - S)*(F - P)) 7,8,7\t\t\n    7        WRITE (6,\"(3I2)\") P,S,F\t\t\n    8      END DO SS\t\t\n    9    END DO PP\t\n      END\t\n", "target": "from itertools import permutations\n \ndef solve():\n    c, p, f, s = \"\\\\,Police,Fire,Sanitation\".split(',')\n    print(f\"{c:>3}  {p:^6} {f:^4} {s:^10}\")\n    c = 1\n    for p, f, s in permutations(range(1, 8), r=3):\n        if p + s + f == 12 and p % 2 == 0:\n            print(f\"{c:>3}: {p:^6} {f:^4} {s:^10}\")\n            c += 1\n \nif __name__ == '__main__':\n    solve()\n"}
{"id": 9345, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to C#: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "var current = [head of list to traverse]\nwhile(current != null)\n{\n    \n\n    current = current.Next;\n}\n"}
{"id": 9348, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to Java: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "LinkedList<Type> list = new LinkedList<Type>();\n\nfor(Type i: list){\n  \n  System.out.println(i);\n}\n"}
{"id": 9349, "name": "Singly-linked list_Traversal", "source": "Translate Fortran to Python: subroutine traversal(list,proc)\n   type(node), target    :: list\n   type(node), pointer   :: current\n   interface\n      subroutine proc(node)\n         real, intent(in) :: node\n      end subroutine proc\n   end interface\n   current => list\n   do while ( associated(current) )\n      call proc(current%data)\n      current => current%next\n   end do\nend subroutine traversal\n", "target": "for node in lst:\n    print node.value\n"}
{"id": 9648, "name": "Haversine formula", "source": "Translate Fortran to C#: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9649, "name": "Haversine formula", "source": "Translate Fortran to C#: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n"}
{"id": 9654, "name": "Haversine formula", "source": "Translate Fortran to Java: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9655, "name": "Haversine formula", "source": "Translate Fortran to Java: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "public class Haversine {\n    public static final double R = 6372.8; \n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n"}
{"id": 9656, "name": "Haversine formula", "source": "Translate Fortran to Python: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 9657, "name": "Haversine formula", "source": "Translate Fortran to Python: program example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) \nprint '(A,F9.4,A)', 'distance: ',d,' km' \n\ncontains\n\n      function to_radian(degree) result(rad)\n          \n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 \n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n", "target": "from math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  \n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n"}
{"id": 10417, "name": "Nth root", "source": "Translate Fortran to C#: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n"}
{"id": 10421, "name": "Nth root", "source": "Translate Fortran to Java: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "public static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  \n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n"}
{"id": 10422, "name": "Nth root", "source": "Translate Fortran to Python: program NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       \n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   \n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n", "target": "from decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n \n    x_1 = 1     \n    while True:\n        \n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n"}
{"id": 10760, "name": "Priority queue", "source": "Translate Fortran to C#: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10761, "name": "Priority queue", "source": "Translate Fortran to C#: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PriorityQueueExample\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\t\n\t\t\tvar p = new PriorityQueue<string, int>();\n\t\t\tp.Enqueue(\"Clear drains\", 3);\n\t\t\tp.Enqueue(\"Feed cat\", 4);\n\t\t\tp.Enqueue(\"Make tea\", 5);\n\t\t\tp.Enqueue(\"Solve RC tasks\", 1);\n\t\t\tp.Enqueue(\"Tax return\", 2);\n\t\t\twhile (p.TryDequeue(out string task, out int priority))\n\t\t\t{\n\t\t\t\tConsole.WriteLine($\"{priority}\\t{task}\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n"}
{"id": 10766, "name": "Priority queue", "source": "Translate Fortran to Java: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10767, "name": "Priority queue", "source": "Translate Fortran to Java: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": "import java.util.PriorityQueue;\n\nclass Task implements Comparable<Task> {\n    final int priority;\n    final String name;\n\n    public Task(int p, String n) {\n        priority = p;\n        name = n;\n    }\n\n    public String toString() {\n        return priority + \", \" + name;\n    }\n\n    public int compareTo(Task other) {\n        return priority < other.priority ? -1 : priority > other.priority ? 1 : 0;\n    }\n\n    public static void main(String[] args) {\n        PriorityQueue<Task> pq = new PriorityQueue<Task>();\n        pq.add(new Task(3, \"Clear drains\"));\n        pq.add(new Task(4, \"Feed cat\"));\n        pq.add(new Task(5, \"Make tea\"));\n        pq.add(new Task(1, \"Solve RC tasks\"));\n        pq.add(new Task(2, \"Tax return\"));\n\n        while (!pq.isEmpty())\n            System.out.println(pq.remove());\n    }\n}\n"}
{"id": 10768, "name": "Priority queue", "source": "Translate Fortran to Python: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 10769, "name": "Priority queue", "source": "Translate Fortran to Python: module priority_queue_mod\nimplicit none\n\ntype node\n  character (len=100)              :: task\n  integer                          :: priority\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: top\n  procedure :: enqueue\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%priority > x(child)%priority ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%priority < x(child)%priority) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction top(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine enqueue(this, priority, task)\n  class(queue), intent(inout) :: this\n  integer                     :: priority\n  character(len=*)            :: task\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  x%priority = priority\n  x%task = task\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\nend module \n\nprogram main\n  use priority_queue_mod\n\n  type (queue) :: q\n  type (node)  :: x \n\n  call q%enqueue(3, \"Clear drains\")\n  call q%enqueue(4, \"Feed cat\")\n  call q%enqueue(5, \"Make Tea\")\n  call q%enqueue(1, \"Solve RC tasks\")\n  call q%enqueue(2, \"Tax return\")\n\n  do while (q%n >0) \n    x = q%top()\n    print \"(g0,a,a)\", x%priority, \" -> \", trim(x%task)\n  end do\n\nend program\n\n\n\n\n\n\n\n", "target": ">>> import queue\n>>> pq = queue.PriorityQueue()\n>>> for item in ((3, \"Clear drains\"), (4, \"Feed cat\"), (5, \"Make tea\"), (1, \"Solve RC tasks\"), (2, \"Tax return\")):\n  pq.put(item)\n\n  \n>>> while not pq.empty():\n  print(pq.get_nowait())\n\n  \n(1, 'Solve RC tasks')\n(2, 'Tax return')\n(3, 'Clear drains')\n(4, 'Feed cat')\n(5, 'Make tea')\n>>>\n"}
{"id": 11282, "name": "Hailstone sequence", "source": "Translate Fortran to C#: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11283, "name": "Hailstone sequence", "source": "Translate Fortran to C#: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Hailstone\n{\n    class Program\n    {\n        public static List<int> hs(int n,List<int> seq)\n        {\n            List<int> sequence = seq;\n            sequence.Add(n);\n            if (n == 1)\n            {\n                return sequence;\n            }else{\n                int newn = (n % 2 == 0) ? n / 2 : (3 * n) + 1;\n                return hs(newn, sequence);\n            }                        \n        }\n\n        static void Main(string[] args)\n        {\n            int n = 27;\n            List<int> sequence = hs(n,new List<int>());\n            Console.WriteLine(sequence.Count + \" Elements\");\n            List<int> start = sequence.GetRange(0, 4);\n            List<int> end = sequence.GetRange(sequence.Count - 4, 4);\n            Console.WriteLine(\"Starting with\u00a0: \" + string.Join(\",\", start) + \" and ending with\u00a0: \" + string.Join(\",\", end));            \n            int number = 0, longest = 0;            \n            for (int i = 1; i < 100000; i++)\n            {\n                int count = (hs(i, new List<int>())).Count;\n                if (count > longest)\n                {\n                    longest = count;\n                    number = i;\n                }\n            }\n            Console.WriteLine(\"Number < 100000 with longest Hailstone seq.: \" + number + \" with length of \" + longest);\n       }\n    }\n}\n"}
{"id": 11288, "name": "Hailstone sequence", "source": "Translate Fortran to Java: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11289, "name": "Hailstone sequence", "source": "Translate Fortran to Java: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Hailstone {\n\n  public static List<Long> getHailstoneSequence(long n) {\n    if (n <= 0)\n      throw new IllegalArgumentException(\"Invalid starting sequence number\");\n    List<Long> list = new ArrayList<Long>();\n    list.add(Long.valueOf(n));\n    while (n != 1) {\n      if ((n & 1) == 0)\n        n = n / 2;\n      else\n        n = 3 * n + 1;\n      list.add(Long.valueOf(n));\n    }\n    return list;\n  }\n  \n  public static void main(String[] args) {\n    List<Long> sequence27 = getHailstoneSequence(27);\n    System.out.println(\"Sequence for 27 has \" + sequence27.size() + \" elements: \" + sequence27);\n    \n    long MAX = 100000;\n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = getHailstoneSequence(i).size();\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 1, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      int highestCount = 1;\n      for (long i = 2; i < MAX; i++) {\n        int count = 1;\n        long n = i;\n        while (n != 1) {\n          if ((n & 1) == 0)\n            n = n / 2;\n          else\n            n = 3 * n + 1;\n          count++;\n        }\n        if (count > highestCount) {\n          highestCount = count;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 2, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    \n    \n    {\n      long highestNumber = 1;\n      long highestCount = 1;\n      Map<Long, Integer> sequenceMap = new HashMap<Long, Integer>();\n      sequenceMap.put(Long.valueOf(1), Integer.valueOf(1));\n      \n      List<Long> currentList = new ArrayList<Long>();\n      for (long i = 2; i < MAX; i++) {\n        currentList.clear();\n        Long n = Long.valueOf(i);\n        Integer count = null;\n        while ((count = sequenceMap.get(n)) == null) {\n          currentList.add(n);\n          long nValue = n.longValue();\n          if ((nValue & 1) == 0)\n            n = Long.valueOf(nValue / 2);\n          else\n            n = Long.valueOf(3 * nValue + 1);\n        }\n        int curCount = count.intValue();\n        for (int j = currentList.size() - 1; j >= 0; j--)\n          sequenceMap.put(currentList.get(j), Integer.valueOf(++curCount));\n        if (curCount > highestCount) {\n          highestCount = curCount;\n          highestNumber = i;\n        }\n      }\n      System.out.println(\"Method 3, number \" + highestNumber + \" has the longest sequence, with a length of \" + highestCount);\n    }\n    return;\n  }\n}\n"}
{"id": 11290, "name": "Hailstone sequence", "source": "Translate Fortran to Python: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "def hailstone(n):\n    seq = [n]\n    while n>1:\n        n = 3*n + 1 if n & 1 else n//2\n        seq.append(n)\n    return seq\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]\n    print(\"Maximum length %i was found for hailstone(%i) for numbers <100,000\" %\n          max((len(hailstone(i)), i) for i in range(1,100000)))\n"}
{"id": 11291, "name": "Hailstone sequence", "source": "Translate Fortran to Python: program Hailstone\n  implicit none\n\n  integer :: i, maxn\n  integer :: maxseqlen = 0, seqlen\n  integer, allocatable :: seq(:)\n\n  call hs(27, seqlen)\n  allocate(seq(seqlen))\n  call hs(27, seqlen, seq)\n  write(*,\"(a,i0,a)\") \"Hailstone sequence for 27 has \", seqlen, \" elements\"\n  write(*,\"(a,4(i0,a),3(i0,a),i0)\") \"Sequence = \", seq(1), \", \", seq(2), \", \", seq(3), \", \", seq(4), \" ...., \",  &\n                                     seq(seqlen-3), \", \", seq(seqlen-2), \", \", seq(seqlen-1), \", \", seq(seqlen) \n  \n  do i = 1, 99999\n    call hs(i, seqlen)\n    if (seqlen > maxseqlen) then\n      maxseqlen = seqlen\n      maxn = i\n    end if\n  end do\n  write(*,*)\n  write(*,\"(a,i0,a,i0,a)\") \"Longest sequence under 100000 is for \", maxn, \" with \", maxseqlen, \" elements\"\n\n  deallocate(seq)\n  \ncontains\n\nsubroutine hs(number, length, seqArray)\n  integer, intent(in)  :: number\n  integer, intent(out) :: length  \n  integer, optional, intent(inout) :: seqArray(:)\n  integer :: n\n\n  n = number\n  length = 1\n  if(present(seqArray)) seqArray(1) = n\n  do while(n /= 1)\n    if(mod(n,2) == 0) then\n      n = n / 2\n    else\n      n = n * 3 + 1\n    end if\n    length = length + 1\n    if(present(seqArray)) seqArray(length) = n\n  end do\nend subroutine\n\nend program\n", "target": "def hailstone(n):\n    seq = [n]\n    while n>1:\n        n = 3*n + 1 if n & 1 else n//2\n        seq.append(n)\n    return seq\n\nif __name__ == '__main__':\n    h = hailstone(27)\n    assert len(h)==112 and h[:4]==[27, 82, 41, 124] and h[-4:]==[8, 4, 2, 1]\n    print(\"Maximum length %i was found for hailstone(%i) for numbers <100,000\" %\n          max((len(hailstone(i)), i) for i in range(1,100000)))\n"}
{"id": 11814, "name": "Multifactorial", "source": "Translate Fortran to C#: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11815, "name": "Multifactorial", "source": "Translate Fortran to C#: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "namespace RosettaCode.Multifactorial\n{\n    using System;\n    using System.Linq;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            Console.WriteLine(string.Join(Environment.NewLine,\n                                          Enumerable.Range(1, 5)\n                                                    .Select(\n                                                        degree =>\n                                                        string.Join(\" \",\n                                                                    Enumerable.Range(1, 10)\n                                                                              .Select(\n                                                                                  number =>\n                                                                                  Multifactorial(number, degree))))));\n        }\n\n        private static int Multifactorial(int number, int degree)\n        {\n            if (degree < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"degree\");\n            }\n\n            var count = 1 + (number - 1) / degree;\n            if (count < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"number\");\n            }\n\n            return Enumerable.Range(0, count)\n                             .Aggregate(1, (accumulator, index) => accumulator * (number - degree * index));\n        }\n    }\n}\n"}
{"id": 11820, "name": "Multifactorial", "source": "Translate Fortran to Java: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11821, "name": "Multifactorial", "source": "Translate Fortran to Java: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": "public class MultiFact {\n\tprivate static long multiFact(long n, int deg){\n\t\tlong ans = 1;\n\t\tfor(long i = n; i > 0; i -= deg){\n\t\t\tans *= i;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int deg = 1; deg <= 5; deg++){\n\t\t\tSystem.out.print(\"degree \" + deg + \":\");\n\t\t\tfor(long n = 1; n <= 10; n++){\n\t\t\t\tSystem.out.print(\" \" + multiFact(n, deg));\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 11822, "name": "Multifactorial", "source": "Translate Fortran to Python: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 11823, "name": "Multifactorial", "source": "Translate Fortran to Python: program test\n  implicit none\n  integer :: i, j, n\n\n  do i = 1, 5\n    write(*, \"(a, i0, a)\", advance = \"no\") \"Degree \", i, \": \"\n    do j = 1, 10\n      n = multifactorial(j, i)\n      write(*, \"(i0, 1x)\", advance = \"no\") n\n    end do\n    write(*,*)\n  end do\n   \ncontains\n\nfunction multifactorial (range, degree)\n  integer :: multifactorial, range, degree\n  integer :: k\n   \n  multifactorial = product((/(k, k=range, 1, -degree)/))\n\nend function multifactorial\nend program test\n", "target": ">>> from functools import reduce\n>>> from operator import mul\n>>> def mfac(n, m): return reduce(mul, range(n, 0, -m))\n\n>>> for m in range(1, 11): print(\"%2i: %r\" % (m, [mfac(n, m) for n in range(1, 11)]))\n\n 1: [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n 2: [1, 2, 3, 8, 15, 48, 105, 384, 945, 3840]\n 3: [1, 2, 3, 4, 10, 18, 28, 80, 162, 280]\n 4: [1, 2, 3, 4, 5, 12, 21, 32, 45, 120]\n 5: [1, 2, 3, 4, 5, 6, 14, 24, 36, 50]\n 6: [1, 2, 3, 4, 5, 6, 7, 16, 27, 40]\n 7: [1, 2, 3, 4, 5, 6, 7, 8, 18, 30]\n 8: [1, 2, 3, 4, 5, 6, 7, 8, 9, 20]\n 9: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>>\n"}
{"id": 12208, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to C#:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12209, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to C#:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ShoelaceFormula {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double ShoelaceArea(List<Point> v) {\n            int n = v.Count;\n            double a = 0.0;\n            for (int i = 0; i < n - 1; i++) {\n                a += v[i].Item1 * v[i + 1].Item2 - v[i + 1].Item1 * v[i].Item2;\n            }\n            return Math.Abs(a + v[n - 1].Item1 * v[0].Item2 - v[0].Item1 * v[n - 1].Item2) / 2.0;\n        }\n\n        static void Main(string[] args) {\n            List<Point> v = new List<Point>() {\n                new Point(3,4),\n                new Point(5,11),\n                new Point(12,8),\n                new Point(9,5),\n                new Point(5,6),\n            };\n            double area = ShoelaceArea(v);\n            Console.WriteLine(\"Given a polygon with vertices [{0}],\", string.Join(\", \", v));\n            Console.WriteLine(\"its area is {0}.\", area);\n        }\n    }\n}\n"}
{"id": 12214, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Java:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12215, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Java:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": "import java.util.List;\n\npublic class ShoelaceFormula {\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%d, %d)\", x, y);\n        }\n    }\n\n    private static double shoelaceArea(List<Point> v) {\n        int n = v.size();\n        double a = 0.0;\n        for (int i = 0; i < n - 1; i++) {\n            a += v.get(i).x * v.get(i + 1).y - v.get(i + 1).x * v.get(i).y;\n        }\n        return Math.abs(a + v.get(n - 1).x * v.get(0).y - v.get(0).x * v.get(n - 1).y) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        List<Point> v = List.of(\n            new Point(3, 4),\n            new Point(5, 11),\n            new Point(12, 8),\n            new Point(9, 5),\n            new Point(5, 6)\n        );\n        double area = shoelaceArea(v);\n        System.out.printf(\"Given a polygon with vertices %s,%n\", v);\n        System.out.printf(\"its area is %f,%n\", area);\n    }\n}\n"}
{"id": 12216, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Python:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12217, "name": "Shoelace formula for polygonal area", "source": "Translate Fortran to Python:       DOUBLE PRECISION FUNCTION AREA(N,P)\t\nC   Uses the mid-point rule for integration. Consider the line joining (x1,y1) to (x2,y2)\nC The area under that line (down to the x-axis) is the y-span midpoint (y1 + y2)/2 times the width (x2 - x1)\nC This is the trapezoidal rule for a single interval, and follows from simple geometry.\nC Now consider a sequence of such points heading in the +x direction: each successive interval's area is positive.\nC Follow with a sequence of points heading in the -x direction, back to the first point: their areas are all negative.\nC The resulting sum is the area below the +x sequence and above the -x sequence: the area of the polygon.\nC   The point sequence can wobble as it wishes and can meet the other side, but it must not cross itself\nc as would be done in a figure 8 drawn with a crossover instead of a meeting.\nC   A clockwise traversal (as for an island) gives a positive area; use anti-clockwise for a lake.\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE COMPLEX PP,PC\t\n       DOUBLE COMPLEX W\t\t\n       DOUBLE PRECISION A\t\n       INTEGER I\t\t\n        IF (N.LT.3) STOP \"Area: at least three points are needed\n        W = (P(1) + P(N/3) + P(2*N/3))/3\t\n        W = SUM(P(1:N) - W)/N + W\t\n        A = 0\t\t\t\n        PC = P(N) - W\t\t\n        DO I = 1,N\t\t\n          PP = PC\t\t\t\n          PC = P(I) - W\t\t\t\n          A = (DIMAG(PC) + DIMAG(PP))*(DBLE(PC) - DBLE(PP)) + A\t\n        END DO\t\t\t\n        AREA = A/2\t\t\n      END FUNCTION AREA\t\t\n\n      DOUBLE PRECISION FUNCTION AREASL(N,P)\t\n       INTEGER N\t\t\n       DOUBLE COMPLEX P(N)\t\n       DOUBLE PRECISION A\t\n        A = SUM(DBLE(P(1:N - 1)*DIMAG(P(2:N)))) + DBLE(P(N))*DIMAG(P(1))\n     1    - SUM(DBLE(P(2:N)*DIMAG(P(1:N - 1)))) - DBLE(P(1))*DIMAG(P(N))\n        AREASL = A/2\t\t\n      END FUNCTION AREASL\t\n\n      INTEGER ENUFF\n      DOUBLE PRECISION AREA,AREASL\t\n      DOUBLE PRECISION A1,A2\t\t\n      PARAMETER (ENUFF = 5)\t\t\n      DOUBLE COMPLEX POINT(ENUFF)\t\n      DATA POINT/(3D0,4D0),(5D0,11D0),(12D0,8D0),(9D0,5D0),(5D0,6D0)/\t\n\n      WRITE (6,*) POINT\n      A1 = AREA(5,POINT)\n      A2 = AREASL(5,POINT)\n      WRITE (6,*) \"A=\",A1,A2\n      END\n", "target": ">>> def area_by_shoelace(x, y):\n    \"Assumes x,y points go around the polygon in one direction\"\n    return abs( sum(i * j for i, j in zip(x,             y[1:] + y[:1]))\n               -sum(i * j for i, j in zip(x[1:] + x[:1], y            ))) / 2\n\n>>> points = [(3,4), (5,11), (12,8), (9,5), (5,6)]\n>>> x, y = zip(*points)\n>>> area_by_shoelace(x, y)\n30.0\n>>>\n"}
{"id": 12661, "name": "Sudoku", "source": "Translate Fortran to C#: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "using System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n"}
{"id": 12664, "name": "Sudoku", "source": "Translate Fortran to Java: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "public class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n"}
{"id": 12665, "name": "Sudoku", "source": "Translate Fortran to Python: program sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n", "target": "def initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n"}
{"id": 12871, "name": "Hello world_Newline omission", "source": "Translate Fortran to C#: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        Console.WriteLine(\"Goodbye, World!\");\n\n        \n        Console.Write(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 12875, "name": "Hello world_Newline omission", "source": "Translate Fortran to Java: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "public class HelloWorld\n{\n public static void main(String[] args)\n {\n  System.out.print(\"Goodbye, World!\");\n }\n}\n"}
{"id": 12876, "name": "Hello world_Newline omission", "source": "Translate Fortran to Python: program bye\n  write (*,'(a)',advance='no') 'Goodbye, World\nend program bye\n", "target": "import sys\nsys.stdout.write(\"Goodbye, World!\")\n"}
{"id": 13195, "name": "Vector products", "source": "Translate Fortran to C#: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13196, "name": "Vector products", "source": "Translate Fortran to C#: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "using System;\nusing System.Windows.Media.Media3D;\n\nclass VectorProducts\n{\n    static double ScalarTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.DotProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static Vector3D VectorTripleProduct(Vector3D a, Vector3D b, Vector3D c)\n    {\n        return Vector3D.CrossProduct(a, Vector3D.CrossProduct(b, c));\n    }\n\n    static void Main()\n    {\n        var a = new Vector3D(3, 4, 5);\n        var b = new Vector3D(4, 3, 5);\n        var c = new Vector3D(-5, -12, -13);\n\n        Console.WriteLine(Vector3D.DotProduct(a, b));\n        Console.WriteLine(Vector3D.CrossProduct(a, b));\n        Console.WriteLine(ScalarTripleProduct(a, b, c));\n        Console.WriteLine(VectorTripleProduct(a, b, c));\n    }\n}\n"}
{"id": 13201, "name": "Vector products", "source": "Translate Fortran to Java: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13202, "name": "Vector products", "source": "Translate Fortran to Java: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "public class VectorProds{\n    public static class Vector3D<T extends Number>{\n        private T a, b, c;\n\n        public Vector3D(T a, T b, T c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n        public double dot(Vector3D<?> vec){\n            return (a.doubleValue() * vec.a.doubleValue() +\n                    b.doubleValue() * vec.b.doubleValue() +\n                    c.doubleValue() * vec.c.doubleValue());\n        }\n\n        public Vector3D<Double> cross(Vector3D<?> vec){\n            Double newA = b.doubleValue()*vec.c.doubleValue() - c.doubleValue()*vec.b.doubleValue();\n            Double newB = c.doubleValue()*vec.a.doubleValue() - a.doubleValue()*vec.c.doubleValue();\n            Double newC = a.doubleValue()*vec.b.doubleValue() - b.doubleValue()*vec.a.doubleValue();\n            return new Vector3D<Double>(newA, newB, newC);\n        }\n\n        public double scalTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.dot(vecB.cross(vecC));\n        }\n\n        public Vector3D<Double> vecTrip(Vector3D<?> vecB, Vector3D<?> vecC){\n            return this.cross(vecB.cross(vecC));\n        }\n\n        @Override\n        public String toString(){\n            return \"<\" + a.toString() + \", \" + b.toString() + \", \" + c.toString() + \">\";\n        }\n    }\n\n    public static void main(String[] args){\n        Vector3D<Integer> a = new Vector3D<Integer>(3, 4, 5);\n        Vector3D<Integer> b = new Vector3D<Integer>(4, 3, 5);\n        Vector3D<Integer> c = new Vector3D<Integer>(-5, -12, -13);\n\n        System.out.println(a.dot(b));\n        System.out.println(a.cross(b));\n        System.out.println(a.scalTrip(b, c));\n        System.out.println(a.vecTrip(b, c));\n    }\n}\n"}
{"id": 13203, "name": "Vector products", "source": "Translate Fortran to Python: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13204, "name": "Vector products", "source": "Translate Fortran to Python: program VectorProducts\n\n  real, dimension(3)  :: a, b, c\n\n  a = (/ 3, 4, 5 /)\n  b = (/ 4, 3, 5 /)\n  c = (/ -5, -12, -13 /)\n\n  print *, dot_product(a, b)\n  print *, cross_product(a, b)\n  print *, s3_product(a, b, c)\n  print *, v3_product(a, b, c)\n\ncontains\n\n  function cross_product(a, b)\n    real, dimension(3) :: cross_product\n    real, dimension(3), intent(in) :: a, b\n\n    cross_product(1) = a(2)*b(3) - a(3)*b(2)\n    cross_product(2) = a(3)*b(1) - a(1)*b(3)\n    cross_product(3) = a(1)*b(2) - b(1)*a(2)\n  end function cross_product\n\n  function s3_product(a, b, c)\n    real :: s3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    s3_product = dot_product(a, cross_product(b, c))\n  end function s3_product\n\n  function v3_product(a, b, c)\n    real, dimension(3) :: v3_product\n    real, dimension(3), intent(in) :: a, b, c\n\n    v3_product = cross_product(a, cross_product(b, c))\n  end function v3_product\n\nend program VectorProducts\n", "target": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n"}
{"id": 13623, "name": "Hello world_Standard error", "source": "Translate Fortran to C#: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "static class StdErr\n{\n    static void Main(string[] args)\n    {\n        Console.Error.WriteLine(\"Goodbye, World!\");\n    }\n}\n"}
{"id": 13626, "name": "Hello world_Standard error", "source": "Translate Fortran to Java: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "public class Err{\n   public static void main(String[] args){\n      System.err.println(\"Goodbye, World!\");\n   }\n}\n"}
{"id": 13627, "name": "Hello world_Standard error", "source": "Translate Fortran to Python: program StdErr\n  \n  use iso_fortran_env\n\n  \n  \n  \n  write (ERROR_UNIT, *) \"Goodbye, World\nend program StdErr\n", "target": "import sys\n\nprint >> sys.stderr, \"Goodbye, World!\"\n"}
{"id": 13832, "name": "SEDOLs", "source": "Translate Fortran to C#: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "static int[] sedol_weights = { 1, 3, 1, 7, 3, 9 };\nstatic int sedolChecksum(string sedol)\n{\n    int len = sedol.Length;\n    int sum = 0;\n\n    if (len == 7) \n        return (int)sedol[6];\n\n    if ((len > 7) || (len < 6) || System.Text.RegularExpressions.Regex.IsMatch(sedol, \"[AEIOUaeiou]+\")) \n        return -1;\n\n    for (int i = 0; i < 6; i++)\n    {\n        if (Char.IsDigit(sedol[i]))\n            sum += (((int)sedol[i] - 48) * sedol_weights[i]);\n\n        else if (Char.IsLetter(sedol[i]))\n            sum += (((int)Char.ToUpper(sedol[i]) - 55) * sedol_weights[i]);\n\n        else\n            return -1;\n\n    }\n\n    return (10 - (sum % 10)) % 10;\n}\n"}
{"id": 13835, "name": "SEDOLs", "source": "Translate Fortran to Java: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "import java.util.Scanner;\n\npublic class SEDOL{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tString sedol = sc.next();\n\t\t\tSystem.out.println(sedol + getSedolCheckDigit(sedol));\n\t\t}\n\t}\n\t\n\tprivate static final int[] mult = {1, 3, 1, 7, 3, 9};\n\t\n\tpublic static int getSedolCheckDigit(String str){\n\t    if(!validateSedol(str)){\n\t    \tSystem.err.println(\"SEDOL strings must contain six characters with no vowels.\");\n\t    \treturn -1;\n\t    }\n\t    str = str.toUpperCase();\n\t    int total = 0;\n\t    for(int i = 0;i < 6; i++){\n\t        char s = str.charAt(i);\n\t        total += Character.digit(s, 36) * mult[i];\n\t    }\n\t    return (10 - (total % 10)) % 10;\n\t}\n\n\tpublic static boolean validateSedol(String str){\n\t\treturn (str.length() == 6) && !str.toUpperCase().matches(\".*?[AEIOU].*?\");\n\t}\n}\n"}
{"id": 13836, "name": "SEDOLs", "source": "Translate Fortran to Python: MODULE SEDOL_CHECK\n  IMPLICIT NONE\n  CONTAINS\n \n  FUNCTION Checkdigit(c)\n    CHARACTER :: Checkdigit\n    CHARACTER(6), INTENT(IN) :: c\n    CHARACTER(36) :: alpha = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    INTEGER, DIMENSION(6) :: weights = (/ 1, 3, 1, 7, 3, 9 /), temp\n    INTEGER :: i, n\n\n    DO i = 1, 6\n      temp(i) = INDEX(alpha, c(i:i)) - 1\n    END DO\n    temp = temp * weights\n    n = MOD(10 - (MOD(SUM(temp), 10)), 10)  \n    Checkdigit = ACHAR(n + 48)\n  END FUNCTION Checkdigit\n \nEND MODULE SEDOL_CHECK\n\nPROGRAM SEDOLTEST\n  USE SEDOL_CHECK\n  IMPLICIT NONE\n \n  CHARACTER(31) :: valid = \"0123456789BCDFGHJKLMNPQRSTVWXYZ\"\n  CHARACTER(6) :: codes(10) = (/ \"710889\", \"B0YBKJ\", \"406566\", \"B0YBLH\", \"228276\" ,  &\n                                 \"B0YBKL\", \"557910\", \"B0YBKR\", \"585284\", \"B0YBKT\" /)\n  CHARACTER(7) :: sedol\n  INTEGER :: i, invalid\n\n  DO i = 1, 10\n    invalid = VERIFY(codes(i), valid)\n    IF (invalid == 0) THEN\n      sedol = codes(i)\n      sedol(7:7) = Checkdigit(codes(i))\n    ELSE\n      sedol = \"INVALID\"\n    END IF\n    WRITE(*, \"(2A9)\") codes(i), sedol\n  END DO\n   \nEND PROGRAM SEDOLTEST\n", "target": "def char2value(c):\n  assert c not in 'AEIOU', \"No vowels\"\n  return int(c, 36)\n\nsedolweight = [1,3,1,7,3,9]\n\ndef checksum(sedol):\n    tmp = sum(map(lambda ch, weight: char2value(ch) * weight,\n                  sedol, sedolweight)\n               )\n    return str((10 - (tmp % 10)) % 10)\n\nfor sedol in .split():\n    print sedol + checksum(sedol)\n"}
{"id": 14089, "name": "Determine if a string is squeezable", "source": "Translate Fortran to C#: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14090, "name": "Determine if a string is squeezable", "source": "Translate Fortran to C#: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main()\n    {\n        SqueezeAndPrint(\"\", ' ');\n        SqueezeAndPrint(\"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", '-');\n        SqueezeAndPrint(\"..1111111111111111111111111111111111111111111111111111111111111117777888\", '7');\n        SqueezeAndPrint(\"I never give 'em hell, I just tell the truth, and they think it's hell. \", '.');\n        string s = \"                                                    --- Harry S Truman  \";\n        SqueezeAndPrint(s, ' ');\n        SqueezeAndPrint(s, '-');\n        SqueezeAndPrint(s, 'r');\n    }\n\n    static void SqueezeAndPrint(string s, char c) {\n        Console.WriteLine($\"squeeze: '{c}'\");\n        Console.WriteLine($\"old: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n        s = Squeeze(s, c);\n        Console.WriteLine($\"new: {s.Length} \u00ab\u00ab\u00ab{s}\u00bb\u00bb\u00bb\");\n    }\n\n    static string Squeeze(string s, char c) => string.IsNullOrEmpty(s) ? \"\" :\n        s[0] + new string(Range(1, s.Length - 1).Where(i => s[i] != c || s[i] != s[i - 1]).Select(i => s[i]).ToArray());\n}\n"}
{"id": 14096, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Java: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14097, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Java: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "\n\npublic class StringSqueezable {\n\n    public static void main(String[] args) {\n        String[] testStrings = new String[] {\n                \"\", \n                \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n                \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n                \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n                \"                                                    --- Harry S Truman  \",\n                \"122333444455555666666777777788888888999999999\",\n                \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n                \"headmistressship\"};\n\n        String[] testChar = new String[] {\n                \" \", \n                \"-\", \n                \"7\", \n                \".\", \n                \" -r\",\n                \"5\",\n                \"e\",\n                \"s\"};\n        for ( int testNum = 0 ; testNum < testStrings.length ; testNum++ ) {\n            String s = testStrings[testNum];\n            for ( char c : testChar[testNum].toCharArray() ) {\n                String result = squeeze(s, c);\n                System.out.printf(\"use: '%c'%nold:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", c, s.length(), s, result.length(), result);\n            }\n        }\n    }\n    \n    private static String squeeze(String in, char include) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) || (in.charAt(i-1) == in.charAt(i) && in.charAt(i) != include)) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 14098, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Python: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14099, "name": "Determine if a string is squeezable", "source": "Translate Fortran to Python: program main\nimplicit none\ncharacter(len=:),allocatable :: strings(:)\n\nstrings=[ character(len=72) :: &\n'', &\n'\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln',  &\n'..1111111111111111111111111111111111111111111111111111111111111117777888', &\n'I never give ''em hell, I just tell the truth, and they think it''s hell.',&\n'                                                    --- Harry S Truman'    &\n]\n\n   call printme( trim(strings(1)), ' ' )\n   call printme( strings(2:4),     ['-','7','.'] )\n   call printme( strings(5),       [' ','-','r'] )\n\ncontains\n\nimpure elemental subroutine printme(str,chr)\ncharacter(len=*),intent(in) :: str\ncharacter(len=1),intent(in) :: chr\ncharacter(len=:),allocatable :: answer\n   write(*,'(a)')repeat('=',9)\n   write(*,'(\"IN:   <<<\",g0,\">>>\")')str\n   answer=compact(str,chr)\n   write(*,'(\"OUT:  <<<\",g0,\">>>\")')answer\n   write(*,'(\"LENS: \",*(g0,1x))')\"from\",len(str),\"to\",len(answer),\"for a change of\",len(str)-len(answer)\n   write(*,'(\"CHAR: \",g0)')chr\nend subroutine printme\n\nelemental function compact(str,charp) result (outstr)\n\ncharacter(len=*),intent(in)  :: str\ncharacter(len=1),intent(in)  :: charp\ncharacter(len=:),allocatable :: outstr\ncharacter(len=1)             :: ch, last_one\ninteger                      :: i, pio \n\n   outstr=repeat(' ',len(str))      \n   if(len(outstr)==0)return         \n   last_one=str(1:1)                \n   outstr(1:1)=last_one\n   pio=1\n\n   do i=2,len(str)\n      ch=str(i:i)\n      pio=pio+merge(0,1, ch.eq.last_one.and.ch.eq.charp) \n      outstr(pio:pio)=ch  \n      last_one=ch\n   enddo\n\n   outstr=outstr(:pio)              \nend function compact\n\nend program main\n}\n", "target": "from itertools import groupby\n\ndef squeezer(s, txt):\n    return ''.join(item if item == s else ''.join(grp)\n                   for item, grp in groupby(txt))\n\nif __name__ == '__main__':\n    strings = [\n            \"\",\n            '\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln ',\n            \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n            \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n            \"                                                   ---  Harry S Truman  \",\n            \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n            \"headmistressship\",\n            \"aardvark\",\n            \"\ud83d\ude0d\ud83d\ude00\ud83d\ude4c\ud83d\udc83\ud83d\ude0d\ud83d\ude0d\ud83d\ude0d\ud83d\ude4c\",\n            ]\n    squeezers = ' ,-,7,., -r,e,s,a,\ud83d\ude0d'.split(',')\n    for txt, chars in zip(strings, squeezers):\n        this = \"Original\"\n        print(f\"\\n{this:14} Size: {len(txt)} \u00ab\u00ab\u00ab{txt}\u00bb\u00bb\u00bb\" )\n        for ch in chars:\n            this = f\"Squeezer '{ch}'\"\n            sqz = squeezer(ch, txt)\n            print(f\"{this:>14} Size: {len(sqz)} \u00ab\u00ab\u00ab{sqz}\u00bb\u00bb\u00bb\" )\n"}
{"id": 14467, "name": "Create a file", "source": "Translate Fortran to C#: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "using System;\nusing System.IO;\n\nclass Program {\n    static void Main(string[] args) {\n        File.Create(\"output.txt\");\n        File.Create(@\"\\output.txt\");\n\n        Directory.CreateDirectory(\"docs\");\n        Directory.CreateDirectory(@\"\\docs\");\n    }\n}\n"}
{"id": 14470, "name": "Create a file", "source": "Translate Fortran to Java: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "import java.io.*;\npublic class CreateFileTest {\n\tpublic static void main(String args[]) {\n\t\ttry {\n\t\t\tnew File(\"output.txt\").createNewFile();\n\t\t\tnew File(File.separator + \"output.txt\").createNewFile();\n\t\t\tnew File(\"docs\").mkdir();\n\t\t\tnew File(File.separator + \"docs\").mkdir();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 14471, "name": "Create a file", "source": "Translate Fortran to Python: PROGRAM CREATION\nOPEN (UNIT=5, FILE=\"output.txt\", STATUS=\"NEW\")   \nCLOSE (UNIT=5)\nOPEN (UNIT=5, FILE=\"/output.txt\", STATUS=\"NEW\")  \nCLOSE (UNIT=5)\n\n\n\ncall system(\"mkdir docs/\")\ncall system(\"mkdir ~/docs/\")\n\nEND PROGRAM\n", "target": "import os\nfor directory in ['/', './']:\n  open(directory + 'output.txt', 'w').close()  \n  os.mkdir(directory + 'docs')                 \n"}
{"id": 14696, "name": "Cholesky decomposition", "source": "Translate Fortran to C#: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Cholesky\n{\n    class Program\n    {\n        \n        \n        \n        \n        static void Main(string[] args)\n        {\n            double[,] test1 = new double[,]\n            {\n                {25, 15, -5},\n                {15, 18, 0},\n                {-5, 0, 11},\n            };\n\n            double[,] test2 = new double[,]\n            {\n                {18, 22, 54, 42},\n                {22, 70, 86, 62},\n                {54, 86, 174, 134},\n                {42, 62, 134, 106},\n            };\n\n            double[,] chol1 = Cholesky(test1);\n            double[,] chol2 = Cholesky(test2);\n\n            Console.WriteLine(\"Test 1: \");\n            Print(test1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 1: \");\n            Print(chol1);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Test 2: \");\n            Print(test2);\n            Console.WriteLine(\"\");\n            Console.WriteLine(\"Lower Cholesky 2: \");\n            Print(chol2);\n\n        }\n\n        public static void Print(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            StringBuilder sb = new StringBuilder();\n            for (int r = 0; r < n; r++)\n            {\n                string s = \"\";\n                for (int c = 0; c < n; c++)\n                {\n                    s += a[r, c].ToString(\"f5\").PadLeft(9) + \",\";\n                }\n                sb.AppendLine(s);\n            }\n\n            Console.WriteLine(sb.ToString());\n        }\n\n        \n        \n        \n        \n        \n        \n        \n        \n        public static double[,] Cholesky(double[,] a)\n        {\n            int n = (int)Math.Sqrt(a.Length);\n\n            double[,] ret = new double[n, n];\n            for (int r = 0; r < n; r++)\n                for (int c = 0; c <= r; c++)\n                {\n                    if (c == r)\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                        {\n                            sum += ret[c, j] * ret[c, j];\n                        }\n                        ret[c, c] = Math.Sqrt(a[c, c] - sum);\n                    }\n                    else\n                    {\n                        double sum = 0;\n                        for (int j = 0; j < c; j++)\n                            sum += ret[r, j] * ret[c, j];\n                        ret[r, c] = 1.0 / ret[c, c] * (a[r, c] - sum);\n                    }\n                }\n\n            return ret;\n        }\n    }\n}\n"}
{"id": 14699, "name": "Cholesky decomposition", "source": "Translate Fortran to Java: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "import java.util.Arrays;\n\npublic class Cholesky {\n\tpublic static double[][] chol(double[][] a){\n\t\tint m = a.length;\n\t\tdouble[][] l = new double[m][m]; \n\t\tfor(int i = 0; i< m;i++){\n\t\t\tfor(int k = 0; k < (i+1); k++){\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor(int j = 0; j < k; j++){\n\t\t\t\t\tsum += l[i][j] * l[k][j];\n\t\t\t\t}\n\t\t\t\tl[i][k] = (i == k) ? Math.sqrt(a[i][i] - sum) :\n\t\t\t\t\t(1.0 / l[k][k] * (a[i][k] - sum));\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tdouble[][] test1 = {{25, 15, -5},\n\t\t\t\t\t\t\t{15, 18, 0},\n\t\t\t\t\t\t\t{-5, 0, 11}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test1)));\n\t\tdouble[][] test2 = {{18, 22, 54, 42},\n\t\t\t\t\t\t\t{22, 70, 86, 62},\n\t\t\t\t\t\t\t{54, 86, 174, 134},\n\t\t\t\t\t\t\t{42, 62, 134, 106}};\n\t\tSystem.out.println(Arrays.deepToString(chol(test2)));\n\t}\n}\n"}
{"id": 14700, "name": "Cholesky decomposition", "source": "Translate Fortran to Python: Program Cholesky_decomp\n\n\n\n\n\n\n\n\n\nimplicit none\n\nINTEGER, PARAMETER :: m=3 \nINTEGER, PARAMETER :: n=3 \nCOMPLEX, DIMENSION(m,n) :: A \nREAL, DIMENSION(m,n) :: L\nREAL :: sum1, sum2\nINTEGER i,j,k\n\n\nA(1,:)=(/ 25,  15,  -5 /)   \nA(2,:)=(/ 15,  18,   0 /)  \nA(3,:)=(/ -5,   0,  11 /)\n\n\n\n\n\n\n\n\n\n\n\nL(1,1)=real(sqrt(A(1,1)))\nL(2,1)=A(2,1)/L(1,1)\nL(2,2)=real(sqrt(A(2,2)-L(2,1)*L(2,1)))\nL(3,1)=A(3,1)/L(1,1)\n\n\n\n\n\n\n\n\ndo i=1,n\n    do k=1,i\n        sum1=0\n        sum2=0\n        do j=1,k-1\n        if (i==k) then\n            sum1=sum1+(L(k,j)*L(k,j))\n            L(k,k)=real(sqrt(A(k,k)-sum1))  \n        elseif (i > k) then\n            sum2=sum2+(L(i,j)*L(k,j))\n            L(i,k)=(1/L(k,k))*(A(i,k)-sum2)\n        else\n            L(i,k)=0\n        end if\n        end do\n    end do\nend do\n\n\ndo i=1,m\n    print \"(3(1X,F6.1))\",L(i,:)\nend do\n\nEnd program Cholesky_decomp\n", "target": "from __future__ import print_function\n\nfrom pprint import pprint\nfrom math import sqrt\n\n\ndef cholesky(A):\n    L = [[0.0] * len(A) for _ in xrange(len(A))]\n    for i in xrange(len(A)):\n        for j in xrange(i+1):\n            s = sum(L[i][k] * L[j][k] for k in xrange(j))\n            L[i][j] = sqrt(A[i][i] - s) if (i == j) else \\\n                      (1.0 / L[j][j] * (A[i][j] - s))\n    return L\n\nif __name__ == \"__main__\":\n    m1 = [[25, 15, -5],\n          [15, 18,  0],\n          [-5,  0, 11]]\n    pprint(cholesky(m1))\n    print()\n    \n    m2 = [[18, 22,  54,  42],\n          [22, 70,  86,  62],\n          [54, 86, 174, 134],\n          [42, 62, 134, 106]]\n    pprint(cholesky(m2), width=120)\n"}
{"id": 14924, "name": "Almost prime", "source": "Translate Fortran to C#: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AlmostPrime\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            foreach (int k in Enumerable.Range(1, 5))\n            {\n                KPrime kprime = new KPrime() { K = k };\n                Console.WriteLine(\"k = {0}: {1}\",\n                    k, string.Join<int>(\" \", kprime.GetFirstN(10)));\n            }\n        }\n    }\n\n    class KPrime\n    {\n        public int K { get; set; }\n\n        public bool IsKPrime(int number)\n        {\n            int primes = 0;\n            for (int p = 2; p * p <= number && primes < K; ++p)\n            {\n                while (number % p == 0 && primes < K)\n                {\n                    number /= p;\n                    ++primes;\n                }\n            }\n            if (number > 1)\n            {\n                ++primes;\n            }\n            return primes == K;\n        }\n\n        public List<int> GetFirstN(int n)\n        {\n            List<int> result = new List<int>();\n            for (int number = 2; result.Count < n; ++number)\n            {\n                if (IsKPrime(number))\n                {\n                    result.Add(number);\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 14928, "name": "Almost prime", "source": "Translate Fortran to Java: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "public class AlmostPrime {\n    public static void main(String[] args) {\n        for (int k = 1; k <= 5; k++) {\n            System.out.print(\"k = \" + k + \":\");\n\n            for (int i = 2, c = 0; c < 10; i++) {\n                if (kprime(i, k)) {\n                    System.out.print(\" \" + i);\n                    c++;\n                }\n            }\n\n            System.out.println(\"\");\n        }\n    }\n\n    public static boolean kprime(int n, int k) {\n        int f = 0;\n        for (int p = 2; f < k && p * p <= n; p++) {\n            while (n % p == 0) {\n                n /= p;\n                f++;\n            }\n        }\n        return f + ((n > 1) ? 1 : 0) == k;\n    }\n}\n"}
{"id": 14929, "name": "Almost prime", "source": "Translate Fortran to Python: program almost_prime\n    use iso_fortran_env, only: output_unit\n    implicit none\n\n    integer :: i, c, k\n\n    do k = 1, 5\n        write(output_unit,'(A3,x,I0,x,A1,x)', advance=\"no\") \"k =\", k, \":\"\n        i = 2\n        c = 0\n        do\n            if (c >= 10) exit\n\n            if (kprime(i, k)) then\n                write(output_unit,'(I0,x)', advance=\"no\") i\n                c = c + 1\n            end if\n            i = i + 1\n        end do\n        write(output_unit,*)\n    end do\ncontains\n    pure function kprime(n, k)\n        integer, intent(in) :: n, k\n        logical             :: kprime\n        integer             :: p, f, i\n\n        kprime = .false.\n\n        f = 0\n        i = n\n\n        do p = 2, n\n            do\n                if (modulo(i, p) /= 0) exit\n\n                if (f == k) return\n                f = f + 1\n                i = i / p\n            end do\n        end do\n\n        kprime = f==k\n    end function kprime\nend program almost_prime\n", "target": "from prime_decomposition import decompose\nfrom itertools import islice, count\ntry: \n    from functools import reduce\nexcept: \n    pass\n\n\ndef almostprime(n, k=2):\n    d = decompose(n)\n    try:\n        terms = [next(d) for i in range(k)]\n        return reduce(int.__mul__, terms, 1) == n\n    except:\n        return False\n\nif __name__ == '__main__':\n    for k in range(1,6):\n        print('%i: %r' % (k, list(islice((n for n in count() if almostprime(n, k)), 10))))\n"}
{"id": 15178, "name": "Integer comparison", "source": "Translate Fortran to C#: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int a = int.Parse(Console.ReadLine());\n        int b = int.Parse(Console.ReadLine());\n        if (a < b)\n            Console.WriteLine(\"{0} is less than {1}\", a, b);\n        if (a == b)\n            Console.WriteLine(\"{0} equals {1}\", a, b);\n        if (a > b)\n            Console.WriteLine(\"{0} is greater than {1}\", a, b);\n    }\n}\n"}
{"id": 15181, "name": "Integer comparison", "source": "Translate Fortran to Java: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "import java.io.*;\n\npublic class compInt {\n   public static void main(String[] args) {\n       try {\n           BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n           int nbr1 = Integer.parseInt(in.readLine());\n           int nbr2 = Integer.parseInt(in.readLine());\n\n           if(nbr1<nbr2)\n               System.out.println(nbr1 + \" is less than \" + nbr2);\n\n           if(nbr1>nbr2)\n                System.out.println(nbr1 + \" is greater than \" + nbr2);\n\n           if(nbr1==nbr2)\n                System.out.println(nbr1 + \" is equal to \" + nbr2);\n       } catch(IOException e) { }\n   }\n}\n"}
{"id": 15182, "name": "Integer comparison", "source": "Translate Fortran to Python: program arithif\ninteger a, b\n\nc        fortran 77 I/O statements, for simplicity\nread(*,*) a, b\n\nif ( a - b ) 10, 20, 30\n10 write(*,*) a, ' is less than ', b\n   goto 40\n\n20 write(*,*) a, ' is equal to ', b\n   goto 40\n\n30 write(*,*) a, ' is greater than ', b\n40 continue\n\nend\n", "target": "let a = input('Enter value of a: ')\nlet b = input('Enter value of b: ')\n\nif a < b:\n    print 'a is less than b'\nelif a > b:\n    print 'a is greater than b'\nelif a == b:\n    print 'a is equal to b'\n"}
{"id": 15434, "name": "Environment variables", "source": "Translate Fortran to C#: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "using System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string temp = Environment.GetEnvironmentVariable(\"TEMP\");\n            Console.WriteLine(\"TEMP is \" + temp);\n        }\n    }\n}\n"}
{"id": 15438, "name": "Environment variables", "source": "Translate Fortran to Java: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "System.getenv(\"HOME\") \nSystem.getenv()       \n"}
{"id": 15439, "name": "Environment variables", "source": "Translate Fortran to Python: program show_home\nimplicit none\ncharacter(len=32) :: home_val  \ninteger           :: home_len  \ninteger           :: stat      \n                               \n                               \n                               \ncall get_environment_variable('HOME', home_val, home_len, stat)\nif (stat == 0) then\n    write(*,'(a)') 'HOME = '//trim(home_val)\nelse\n    write(*,'(a)') 'No HOME to go to\nend if\nend program show_home\n", "target": "import os\nos.environ['HOME']\n"}
{"id": 15635, "name": "Substring", "source": "Translate Fortran to C#: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": "using System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            \n            Console.WriteLine(s.Substring(n, m));\n            \n            Console.WriteLine(s.Substring(n, s.Length - n));\n            \n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            \n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n"}
{"id": 15639, "name": "Substring", "source": "Translate Fortran to Java: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": "public static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n"}
{"id": 15640, "name": "Substring", "source": "Translate Fortran to Python: program test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n\n  write (*, '(a)') string (n : n + m - 1)\n\n  write (*, '(a)') string (n :)\n\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n", "target": ">>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> \n>>> s[n-1:n+m-1]\n'bcd'\n>>> \n>>> s[n-1:]\n'bcdefgh'\n>>> \n>>> s[:-1]\n'abcdefg'\n>>> \n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n"}
{"id": 15926, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to C#: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "using System;\n\nnamespace BinomialCoefficients\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ulong n = 1000000, k = 3;\n            ulong result = biCoefficient(n, k);\n            Console.WriteLine(\"The Binomial Coefficient of {0}, and {1}, is equal to: {2}\", n, k, result);\n            Console.ReadLine();\n        }\n\n        static int fact(int n)\n        {\n            if (n == 0) return 1;\n            else return n * fact(n - 1);\n        }\n\n        static ulong biCoefficient(ulong n, ulong k)\n        {\n            if (k > n - k)\n            {\n                k = n - k;\n            }\n\n            ulong c = 1;\n            for (uint i = 0; i < k; i++)\n            {\n                c = c * (n - i);\n                c = c / (i + 1);\n            }\n            return c;\n        }\n    }\n}\n"}
{"id": 15930, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to Java: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "public class Binomial {\n\n    \n    private static long binomialInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static Object binomialIntReliable(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        long binom = 1;\n        for (int i = 1; i <= k; i++) {\n            try {\n                binom = Math.multiplyExact(binom, n + 1 - i) / i;\n            } catch (ArithmeticException e) {\n                return \"overflow\";\n            }\n        }\n        return binom;\n    }\n\n    \n    \n    private static double binomialFloat(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        double binom = 1.0;\n        for (int i = 1; i <= k; i++)\n            binom = binom * (n + 1 - i) / i;\n        return binom;\n    }\n\n    \n    private static BigInteger binomialBigInt(int n, int k) {\n        if (k > n - k)\n            k = n - k;\n\n        BigInteger binom = BigInteger.ONE;\n        for (int i = 1; i <= k; i++) {\n            binom = binom.multiply(BigInteger.valueOf(n + 1 - i));\n            binom = binom.divide(BigInteger.valueOf(i));\n        }\n        return binom;\n    }\n\n    private static void demo(int n, int k) {\n        List<Object> data = Arrays.asList(\n                n,\n                k,\n                binomialInt(n, k),\n                binomialIntReliable(n, k),\n                binomialFloat(n, k),\n                binomialBigInt(n, k));\n\n        System.out.println(data.stream().map(Object::toString).collect(Collectors.joining(\"\\t\")));\n    }\n\n    public static void main(String[] args) {\n        demo(5, 3);\n        demo(1000, 300);\n    }\n}\n"}
{"id": 15931, "name": "Evaluate binomial coefficients", "source": "Translate Fortran to Python: program test_choose\n\n  implicit none\n\n  write (*, '(i0)') choose (5, 3)\n\ncontains\n\n  function factorial (n) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer :: res\n    integer :: i\n\n    res = product ((/(i, i = 1, n)/))\n\n  end function factorial\n\n  function choose (n, k) result (res)\n\n    implicit none\n    integer, intent (in) :: n\n    integer, intent (in) :: k\n    integer :: res\n\n    res = factorial (n) / (factorial (k) * factorial (n - k))\n\n  end function choose\n\nend program test_choose\n", "target": "def binomialCoeff(n, k):\n    result = 1\n    for i in range(1, k+1):\n        result = result * (n-i+1) / i\n    return result\n\nif __name__ == \"__main__\":\n    print(binomialCoeff(5, 3))\n"}
{"id": 16151, "name": "Append a record to the end of a text file", "source": "Translate Fortran to C#:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "using System;\nusing System.IO;\n\nnamespace AppendPwdRosetta\n{\n    class PasswordRecord\n    {\n        public string account, password, fullname, office, extension, homephone, email, directory, shell;\n        public int UID, GID;\n        public PasswordRecord(string account, string password, int UID, int GID, string fullname, string office, string extension, string homephone, \n            string email, string directory, string shell)\n        {\n            this.account = account; this.password = password; this.UID = UID; this.GID = GID; this.fullname = fullname; this.office = office;\n            this.extension = extension; this.homephone = homephone; this.email = email; this.directory = directory; this.shell = shell;\n        }\n        public override string ToString()\n        {\n            var gecos = string.Join(\",\", new string[] { fullname, office, extension, homephone, email });\n            return string.Join(\":\", new string[] { account, password, UID.ToString(), GID.ToString(), gecos, directory, shell });\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var jsmith = new PasswordRecord(\"jsmith\", \"x\", 1001, 1000, \"Joe Smith\", \"Room 1007\", \"(234)555-8917\", \"(234)555-0077\", \"jsmith@rosettacode.org\", \n                \"/home/jsmith\", \"/bin/bash\");\n            var jdoe = new PasswordRecord(\"jdoe\", \"x\", 1002, 1000, \"Jane Doe\", \"Room 1004\", \"(234)555-8914\", \"(234)555-0044\", \"jdoe@rosettacode.org\", \"/home/jdoe\", \n                \"/bin/bash\");\n            var xyz = new PasswordRecord(\"xyz\", \"x\", 1003, 1000, \"X Yz\", \"Room 1003\", \"(234)555-8913\", \"(234)555-0033\", \"xyz@rosettacode.org\", \"/home/xyz\", \"/bin/bash\");\n\n            \n            File.WriteAllLines(\"passwd.txt\", new string[] { jsmith.ToString(), jdoe.ToString() });\n\n            \n            File.AppendAllText(\"passwd.txt\", xyz.ToString());\n\n            \n            string[] lines = File.ReadAllLines(\"passwd.txt\");\n            Console.WriteLine(\"Appended record: \" + lines[2]);\n        }\n    }\n}\n"}
{"id": 16154, "name": "Append a record to the end of a text file", "source": "Translate Fortran to Java:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "import static java.util.Objects.requireNonNull;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class RecordAppender {\n    static class Record {\n        private final String account;\n        private final String password;\n        private final int uid;\n        private final int gid;\n        private final List<String> gecos;\n        private final String directory;\n        private final String shell;\n\n        public Record(String account, String password, int uid, int gid, List<String> gecos, String directory, String shell) {\n            this.account = requireNonNull(account);\n            this.password = requireNonNull(password);\n            this.uid = uid;\n            this.gid = gid;\n            this.gecos = requireNonNull(gecos);\n            this.directory = requireNonNull(directory);\n            this.shell = requireNonNull(shell);\n        }\n\n        @Override\n        public String toString() {\n            return account + ':' + password + ':' + uid + ':' + gid + ':' + String.join(\",\", gecos) + ':' + directory + ':' + shell;\n        }\n\n        public static Record parse(String text) {\n            String[] tokens = text.split(\":\");\n            return new Record(\n                    tokens[0],\n                    tokens[1],\n                    Integer.parseInt(tokens[2]),\n                    Integer.parseInt(tokens[3]),\n                    Arrays.asList(tokens[4].split(\",\")),\n                    tokens[5],\n                    tokens[6]);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<String> rawData = Arrays.asList(\n                \"jsmith:x:1001:1000:Joe Smith,Room 1007,(234)555-8917,(234)555-0077,[email protected]:/home/jsmith:/bin/bash\",\n                \"jdoe:x:1002:1000:Jane Doe,Room 1004,(234)555-8914,(234)555-0044,[email protected]:/home/jdoe:/bin/bash\",\n                \"xyz:x:1003:1000:X Yz,Room 1003,(234)555-8913,(234)555-0033,[email protected]:/home/xyz:/bin/bash\"\n        );\n\n        List<Record> records = rawData.stream().map(Record::parse).collect(Collectors.toList());\n\n        Path tmp = Paths.get(\"_rosetta\", \".passwd\");\n        Files.createDirectories(tmp.getParent());\n        Files.write(tmp, (Iterable<String>) records.stream().limit(2).map(Record::toString)::iterator);\n\n        Files.write(tmp, Collections.singletonList(records.get(2).toString()), StandardOpenOption.APPEND);\n\n        try (Stream<String> lines = Files.lines(tmp)) {\n            lines.map(Record::parse).forEach(System.out::println);\n        }\n    }\n}\n"}
{"id": 16155, "name": "Append a record to the end of a text file", "source": "Translate Fortran to Python:       PROGRAM DEMO\t\n      TYPE DETAILS\t\t\n       CHARACTER*28 FULLNAME\n       CHARACTER*12 OFFICE\n       CHARACTER*16 EXTENSION\n       CHARACTER*16 HOMEPHONE\n       CHARACTER*88 EMAIL\n      END TYPE DETAILS\n      TYPE USERSTUFF\t\t\n       CHARACTER*8 ACCOUNT\n       CHARACTER*8 PASSWORD\t\n       INTEGER*2 UID\n       INTEGER*2 GID\n       TYPE(DETAILS) PERSON\n       CHARACTER*18 DIRECTORY\n       CHARACTER*12 SHELL\n      END TYPE USERSTUFF\n      TYPE(USERSTUFF) NOTE\t\n      NAMELIST /STUFF/ NOTE\t\n      INTEGER F,MSG,N\n      MSG = 6\t\n      F = 10\t\n      OPEN(MSG, DELIM = \"QUOTE\")\t\n\nCreate the file and supply its initial content.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666)\t\n\n      WRITE (F,*) USERSTUFF(\"jsmith\",\"x\",1001,1000,\n     1 DETAILS(\"Joe Smith\",\"Room 1007\",\"(234)555-8917\",\n     2  \"(234)555-0077\",\"jsmith@rosettacode.org\"),\n     2 \"/home/jsmith\",\"/bin/bash\")\n\n      WRITE (F,*) USERSTUFF(\"jdoe\",\"x\",1002,1000,\n     1 DETAILS(\"Jane Doe\",\"Room 1004\",\"(234)555-8914\",\n     2  \"(234)555-0044\",\"jdoe@rosettacode.org\"),\n     3 \"home/jdoe\",\"/bin/bash\")\n      CLOSE (F)\t\t\n\nChoose the existing file, and append a further record to it.\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"WRITE\",\n     1 DELIM=\"QUOTE\",RECL=666,ACCESS=\"APPEND\")\n\n      NOTE = USERSTUFF(\"xyz\",\"x\",1003,1000,\t\t\n     1 DETAILS(\"X Yz\",\"Room 1003\",\"(234)555-8193\",\n     2  \"(234)555-033\",\"xyz@rosettacode.org\"),\n     3 \"/home/xyz\",\"/bin/bash\")\n      WRITE (F,*) NOTE\t\t\t\t\t\n      CLOSE (F)\n\nChase through the file, revealing what had been written..\n      OPEN (F, FILE=\"Staff.txt\",STATUS=\"OLD\",ACTION=\"READ\",\n     1 DELIM=\"QUOTE\",RECL=666)\n      N = 0\n   10 READ (F,*,END = 20) NOTE\t\n      N = N + 1\t\t\t\n      WRITE (MSG,11) N\t\t\n   11 FORMAT (/,\"Record \",I0)\t\n      WRITE (MSG,STUFF)\t\t\n      GO TO 10\t\t\t\n\nClosedown.\n   20 CLOSE (F)\n      END\n", "target": "\n\n\n\npasswd_list=[\n  dict(account='jsmith', password='x', UID=1001, GID=1000, \n       GECOS=dict(fullname='Joe Smith', office='Room 1007', extension='(234)555-8917',\n                  homephone='(234)555-0077', email='jsmith@rosettacode.org'),\n                  directory='/home/jsmith', shell='/bin/bash'),\n  dict(account='jdoe', password='x', UID=1002, GID=1000,\n       GECOS=dict(fullname='Jane Doe', office='Room 1004', extension='(234)555-8914',\n                  homephone='(234)555-0044', email='jdoe@rosettacode.org'),\n       directory='/home/jdoe', shell='/bin/bash')\n]\n\npasswd_fields=\"account password UID GID GECOS directory shell\".split()\nGECOS_fields=\"fullname office extension homephone email\".split()\n\ndef passwd_text_repr(passwd_rec):\n\n  passwd_rec[\"GECOS\"]=\",\".join([ passwd_rec[\"GECOS\"][field] for field in GECOS_fields])\n  for field in passwd_rec: \n    if not isinstance(passwd_rec[field], str):\n      passwd_rec[field]=`passwd_rec[field]`\n  return \":\".join([ passwd_rec[field] for field in passwd_fields ])\n\npasswd_text=open(\"passwd.txt\",\"w\")\nfor passwd_rec in passwd_list:\n  print >> passwd_text,passwd_text_repr(passwd_rec)\npasswd_text.close()\n\n\n\n\npasswd_text=open(\"passwd.txt\",\"a+\")\nnew_rec=dict(account='xyz', password='x', UID=1003, GID=1000,\n             GECOS=dict(fullname='X Yz', office='Room 1003', extension='(234)555-8913',\n                        homephone='(234)555-0033', email='xyz@rosettacode.org'),\n             directory='/home/xyz', shell='/bin/bash')\nprint >> passwd_text,  passwd_text_repr(new_rec)\npasswd_text.close()\n\n\n\n\npasswd_list=list(open(\"passwd.txt\",\"r\"))\nif \"xyz\" in passwd_list[-1]:\n  print \"Appended record:\",passwd_list[-1][:-1]\n"}
{"id": 16355, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to C#: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int mp = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Select(x => x - '0').Aggregate((a, b) => a * b);\n            mp++;\n        }\n        return new Tuple<int, int>(mp, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 123321, 7739, 893, 899998 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has multiplicative persistence {1} and multiplicative digital root {2}\", num, t.Item1, t.Item2);\n        }\n\n        const int twidth = 5;\n        List<long>[] table = new List<long>[10];\n        for (int i = 0; i < 10; i++)\n            table[i] = new List<long>();\n        long number = -1;\n        while (table.Any(x => x.Count < twidth)) \n        {\n            var t = DigitalRoot(++number);\n            if (table[t.Item2].Count < twidth)\n                table[t.Item2].Add(number);\n        }\n        for (int i = 0; i < 10; i++)\n            Console.WriteLine(\" {0}\u00a0: [{1}]\", i, string.Join(\", \", table[i]));\n    }\n}\n"}
{"id": 16358, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to Java: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "import java.util.*;\n\npublic class MultiplicativeDigitalRoot {\n\n    public static void main(String[] args) {\n\n        System.out.println(\"NUMBER  MDR   MP\");\n        for (long n : new long[]{123321, 7739, 893, 899998}) {\n            long[] a = multiplicativeDigitalRoot(n);\n            System.out.printf(\"%6d %4d %4d%n\", a[0], a[1], a[2]);\n        }\n\n        System.out.println();\n\n        Map<Long, List<Long>> table = new HashMap<>();\n        for (long i = 0; i < 10; i++)\n            table.put(i, new ArrayList<>());\n\n        for (long cnt = 0, n = 0; cnt < 10;) {\n            long[] res = multiplicativeDigitalRoot(n++);\n            List<Long> list = table.get(res[1]);\n            if (list.size() < 5) {\n                list.add(res[0]);\n                cnt = list.size() == 5 ? cnt + 1 : cnt;\n            }\n        }\n\n        System.out.println(\"MDR: first five numbers with same MDR\");\n        table.forEach((key, lst) -> {\n            System.out.printf(\"%3d: \", key);\n            lst.forEach(e -> System.out.printf(\"%6s \", e));\n            System.out.println();\n        });\n    }\n\n    public static long[] multiplicativeDigitalRoot(long n) {\n        int mp = 0;\n        long mdr = n;\n        while (mdr > 9) {\n            long m = mdr;\n            long total = 1;\n            while (m > 0) {\n                total *= m % 10;\n                m /= 10;\n            }\n            mdr = total;\n            mp++;\n        }\n        return new long[]{n, mdr, mp};\n    }\n}\n"}
{"id": 16359, "name": "Digital root_Multiplicative digital root", "source": "Translate Fortran to Python: \nprogram mdr\nimplicit none\ninteger :: i, mdr, mp, n, j\ncharacter(len=*), parameter :: hfmt = '(A18)', nfmt = '(I6)'\ncharacter(len=*), parameter :: cfmt = '(A3)', rfmt = '(I3)', ffmt = '(I9)'\n\nwrite(*,hfmt) 'Number   MDR   MP '\nwrite(*,*) '------------------'\n\ni = 123321\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 3939\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 8822\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\ni = 39398\ncall root_pers(i,mdr,mp)\nwrite(*,nfmt,advance='no') i\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt,advance='no') mdr\nwrite(*,cfmt,advance='no') '   '\nwrite(*,rfmt) mp\n\nwrite(*,*)\nwrite(*,*)\nwrite(*,*) 'First five numbers with MDR in first column: '\nwrite(*,*) '---------------------------------------------'\n\ndo i = 0,9\n  n = 0\n  j = 0\n  write(*,rfmt,advance='no') i\n  do\n    call root_pers(j,mdr,mp)\n    if(mdr.eq.i) then\n      n = n+1\n      if(n.eq.5) then\n        write(*,ffmt) j\n        exit\n      else\n        write(*,ffmt,advance='no') j\n      end if\n    end if\n    j = j+1\n  end do\nend do\n\nend program\n\nsubroutine root_pers(i,mdr,mp)\nimplicit none\ninteger :: N, s, a, i, mdr, mp\nn = i\na = 0\nif(n.lt.10) then\n  mdr = n\n  mp = 0\n  return\nend if\ndo while(n.ge.10)\n  a = a + 1\n  s = 1\n  do while(n.gt.0)\n    s = s * mod(n,10)\n    n = int(real(n)/10.0D0)\n  end do\n  n = s\nend do\nmdr = s\nmp = a\nend subroutine\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndef mdroot(n):\n    'Multiplicative digital root'\n    mdr = [n]\n    while mdr[-1] > 9:\n        mdr.append(reduce(int.__mul__, (int(dig) for dig in str(mdr[-1])), 1))\n    return len(mdr) - 1, mdr[-1]\n\nif __name__ == '__main__':\n    print('Number: (MP, MDR)\\n======  =========')\n    for n in (123321, 7739, 893, 899998):\n        print('%6i: %r' % (n, mdroot(n)))\n        \n    table, n = {i: [] for i in range(10)}, 0\n    while min(len(row) for row in table.values()) < 5:\n        mpersistence, mdr = mdroot(n)\n        table[mdr].append(n)\n        n += 1\n    print('\\nMP: [n0..n4]\\n==  ========')\n    for mp, val in sorted(table.items()):\n        print('%2i: %r' % (mp, val[:5]))\n"}
{"id": 16523, "name": "Perfect numbers", "source": "Translate Fortran to C#: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"Perfect numbers from 1 to 33550337:\");\n\n\tfor (int x = 0; x < 33550337; x++)\n\t{\n\t\tif (IsPerfect(x))\n\t\t\tConsole.WriteLine(x + \" is perfect.\");\n\t}\n\n\tConsole.ReadLine();\n}\n\nstatic bool IsPerfect(int num) \n{\n\tint sum = 0;\n\tfor (int i = 1; i < num; i++)\n\t{\n\t\tif (num % i == 0)\n\t\t\tsum += i;\n\t}\n\n\treturn sum == num ;\n}\n"}
{"id": 16526, "name": "Perfect numbers", "source": "Translate Fortran to Java: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "public static boolean perf(int n){\n\tint sum= 0;\n\tfor(int i= 1;i < n;i++){\n\t\tif(n % i == 0){\n\t\t\tsum+= i;\n\t\t}\n\t}\n\treturn sum == n;\n}\n"}
{"id": 16527, "name": "Perfect numbers", "source": "Translate Fortran to Python: FUNCTION isPerfect(n)\n  LOGICAL :: isPerfect\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: i, factorsum\n\n  isPerfect = .FALSE.\n  factorsum = 1\n  DO i = 2, INT(SQRT(REAL(n)))\n     IF(MOD(n, i) == 0) factorsum = factorsum + i + (n / i)\n  END DO\n  IF (factorsum == n) isPerfect = .TRUE.\nEND FUNCTION isPerfect\n", "target": "def perf1(n):\n    sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            sum += i\n    return sum == n\n"}
{"id": 17417, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to C#: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "using System;\nusing System.IO;\nclass PPMWriter\n{\n    public static void WriteBitmapToPPM(string file, Bitmap bitmap)\n        {\n            \n            var writer = new StreamWriter(file);\n            writer.WriteLine(\"P6\");\n            writer.WriteLine($\"{bitmap.Width}  {bitmap.Height}\");\n            writer.WriteLine(\"255\");\n            writer.Close();\n            \n            var writerB = new BinaryWriter(new FileStream(file, FileMode.Append));\n            for (int x = 0; x < bitmap.Height; x++)\n                for (int y = 0; y < bitmap.Width; y++)\n                {\n                    Color color = bitmap.GetPixel(y, x);\n                    writerB.Write(color.R);\n                    writerB.Write(color.G);\n                    writerB.Write(color.B);\n                }\n            writerB.Close();\n        }\n}\n"}
{"id": 17421, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to Java: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "import java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class PPMWriter {\n\n    public void bitmapToPPM(File file, BasicBitmapStorage bitmap) throws IOException {\n        file.delete();\n\n        try (var os = new FileOutputStream(file, true);\n             var bw = new BufferedOutputStream(os)) {\n            var header = String.format(\"P6\\n%d %d\\n255\\n\",\n                    bitmap.getWidth(), bitmap.getHeight());\n\n            bw.write(header.getBytes(StandardCharsets.US_ASCII));\n\n            for (var y = 0; y < bitmap.getHeight(); y++) {\n                for (var x = 0; x < bitmap.getWidth(); x++) {\n                    var pixel = bitmap.getPixel(x, y);\n                    bw.write(pixel.getRed());\n                    bw.write(pixel.getGreen());\n                    bw.write(pixel.getBlue());\n                }\n            }\n        }\n    }\n}\n"}
{"id": 17422, "name": "Bitmap_Write a PPM file", "source": "Translate Fortran to Python: program main\n\n  use rgbimage_m\n\n  implicit none\n\n  integer :: nx, ny, i, j, k\n\n  type(rgbimage) :: im\n\n  \n  nx = 400\n  ny = 300\n  call im%init(nx, ny)\n\n  \n  do i = 1, nx\n    do j = 1, ny\n      call im%set_pixel(i, j, [(nint(rand()*255), k=1,3)])\n    end do\n  end do\n\n  \n  call im%write('fig.ppm')\n\nend program\n", "target": "\nimport io\nppmfileout = io.StringIO('')\n\ndef writeppmp3(self, f):\n    self.writeppm(f, ppmformat='P3')\n        \ndef writeppm(self, f, ppmformat='P6'):\n    assert ppmformat in ['P3', 'P6'], 'Format wrong'\n    magic = ppmformat + '\\n'\n    comment = '\n    maxval = max(max(max(bit) for bit in row) for row in self.map)\n    assert ppmformat == 'P3' or 0 <= maxval < 256, 'R,G,B must fit in a byte'\n    if ppmformat == 'P6':\n        fwrite = lambda s: f.write(bytes(s, 'UTF-8'))\n        maxval = 255\n    else:\n        fwrite = f.write\n        numsize=len(str(maxval))\n    fwrite(magic)\n    fwrite(comment)\n    fwrite('%i %i\\n%i\\n' % (self.width, self.height, maxval))\n    for h in range(self.height-1, -1, -1):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            if ppmformat == 'P3':\n                fwrite('   %*i %*i %*i' % (numsize, r, numsize, g, numsize, b))\n            else:\n                fwrite('%c%c%c' % (r, g, b))\n        if ppmformat == 'P3':\n            fwrite('\\n')\n\nBitmap.writeppmp3 = writeppmp3\nBitmap.writeppm = writeppm\n\n\nbitmap = Bitmap(4, 4, black)\nbitmap.fillrect(1, 0, 1, 2, white)\nbitmap.set(3, 3, Colour(127, 0, 63))\n\nbitmap.writeppmp3(ppmfileout)\n\nprint(ppmfileout.getvalue())\n\n\n\n\nppmfileout = open('tmp.ppm', 'wb')\nbitmap.writeppm(ppmfileout)\nppmfileout.close()\n"}
{"id": 17659, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to C#: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Enter two integers. Space delimited please: \");\n            string s = Console.ReadLine();\n            \n            int[,] myArray=new int[(int)s[0],(int)s[2]];\n            myArray[0, 0] = 2;\n            Console.WriteLine(myArray[0, 0]);\n\n            Console.ReadLine();\n        }\n    }\n"}
{"id": 17662, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to Java: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "import java.util.Scanner;\n\npublic class twoDimArray {\n  public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        int nbr1 = in.nextInt();\n        int nbr2 = in.nextInt();\n        \n        double[][] array = new double[nbr1][nbr2];\n        array[0][0] = 42.0;\n        System.out.println(\"The number at place [0 0] is \" + array[0][0]);\n  }\n}\n"}
{"id": 17663, "name": "Create a two-dimensional array at runtime", "source": "Translate Fortran to Python: PROGRAM Example\n\n  IMPLICIT NONE\n  INTEGER :: rows, columns, errcheck\n  INTEGER, ALLOCATABLE :: array(:,:)\n\n  WRITE(*,*) \"Enter number of rows\"\n  READ(*,*) rows\n  WRITE(*,*) \"Enter number of columns\"\n  READ(*,*) columns\n \n  ALLOCATE (array(rows,columns), STAT=errcheck) \n \n  array(1,1) = 42\n \n  WRITE(*,*) array(1,1)\n \n  DEALLOCATE (array, STAT=errcheck)\n\nEND PROGRAM Example\n", "target": "width = int(raw_input(\"Width of myarray: \"))\nheight = int(raw_input(\"Height of Array: \"))\nmyarray = [[0] * width for i in range(height)]\nmyarray[0][0] = 3.5\nprint (myarray[0][0])\n"}
{"id": 17957, "name": "Munchausen numbers", "source": "Translate Fortran to C#: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 17958, "name": "Munchausen numbers", "source": "Translate Fortran to C#: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "Func<char, int> toInt = c => c-'0';\n\nforeach (var i in Enumerable.Range(1,5000)\n\t.Where(n => n == n.ToString()\n\t\t.Sum(x => Math.Pow(toInt(x), toInt(x)))))\n\tConsole.WriteLine(i);\n"}
{"id": 17964, "name": "Munchausen numbers", "source": "Translate Fortran to Java: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 17965, "name": "Munchausen numbers", "source": "Translate Fortran to Java: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "public class Main {\n    public static void main(String[] args) {\n        for(int i = 0 ; i <= 5000 ; i++ ){\n            int val = String.valueOf(i).chars().map(x -> (int) Math.pow( x-48 ,x-48)).sum();\n            if( i == val){\n                System.out.println( i + \" (munchausen)\");\n            }\n        }\n    }\n}\n"}
{"id": 17966, "name": "Munchausen numbers", "source": "Translate Fortran to Python: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 17967, "name": "Munchausen numbers", "source": "Translate Fortran to Python: C MUNCHAUSEN NUMBERS - FORTRAN IV\n      DO 2 I=1,5000\n        IS=0\n        II=I\n        DO 1 J=1,4\n          ID=10**(4-J)\n          N=II/ID\n          IR=MOD(II,ID)\n          IF(N.NE.0) IS=IS+N**N\n  1       II=IR\n  2     IF(IS.EQ.I) WRITE(*,*) I\n      END\n", "target": "for i in range(5000):\n    if i == sum(int(x) ** int(x) for x in str(i)):\n        print(i)\n"}
{"id": 18296, "name": "Strip block comments", "source": "Translate Fortran to C#:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "using System;\n\n    class Program\n    {\n        private static string BlockCommentStrip(string commentStart, string commentEnd, string sampleText)\n        {\n            while (sampleText.IndexOf(commentStart) > -1 && sampleText.IndexOf(commentEnd, sampleText.IndexOf(commentStart) + commentStart.Length) > -1)\n            {\n                int start = sampleText.IndexOf(commentStart);\n                int end = sampleText.IndexOf(commentEnd, start + commentStart.Length);\n                sampleText = sampleText.Remove(\n                    start,\n                    (end + commentEnd.Length) - start\n                    );\n            }\n            return sampleText;\n        }\n    }\n"}
{"id": 18299, "name": "Strip block comments", "source": "Translate Fortran to Java:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "import java.io.*;\n\npublic class StripBlockComments{\n    public static String readFile(String filename) {\n\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\ttry {\n\t    StringBuilder fileContents = new StringBuilder();\n\t    char[] buffer = new char[4096];\n\t    while (reader.read(buffer, 0, 4096) > 0) {\n\t\tfileContents.append(buffer);\n\t    }\n\t    return fileContents.toString();\n\t} finally {\n\t    reader.close();\n\t}\n    }\n\n    public static String stripComments(String beginToken, String endToken,\n\t\t\t\t       String input) {\n\tStringBuilder output = new StringBuilder();\n\twhile (true) {\n\t    int begin = input.indexOf(beginToken);\n\t    int end = input.indexOf(endToken, begin+beginToken.length());\n\t    if (begin == -1 || end == -1) {\n\t\toutput.append(input);\n\t\treturn output.toString();\n\t    }\n\t    output.append(input.substring(0, begin));\n\t    input = input.substring(end + endToken.length());\n\t}\n    }\n\n    public static void main(String[] args) {\n\tif (args.length < 3) {\n\t    System.out.println(\"Usage: BeginToken EndToken FileToProcess\");\n\t    System.exit(1);\n\t}\n\n\tString begin = args[0];\n\tString end = args[1];\n\tString input = args[2];\n\n\ttry {\n\t    System.out.println(stripComments(begin, end, readFile(input)));\n\t} catch (Exception e) {\n\t    e.printStackTrace();\n\t    System.exit(1);\n\t}\n    }\n}\n"}
{"id": 18300, "name": "Strip block comments", "source": "Translate Fortran to Python:       SUBROUTINE UNBLOCK(THIS,THAT)\t\nCopies from file INF to file OUT, record by record, except skipping null output records.\n       CHARACTER*(*) THIS,THAT\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 6666)\t\t\n       CHARACTER*(LOTS) ACARD,ALINE\t\n       INTEGER LC,LL,L\t\t\n       INTEGER L1,L2\t\t\n       INTEGER NC,NL\t\t\n       LOGICAL BLAH\t\t\n       INTEGER MSG,KBD,INF,OUT\t\t\n       COMMON /IODEV/MSG,KBD,INF,OUT\t\n        NC = 0\t\t\n        NL = 0\t\t\n        BLAH = .FALSE.\t\nChug through the input.\n   10   READ(INF,11,END = 100) LC,ACARD(1:MIN(LC,LOTS))\t\n   11   FORMAT (Q,A)\t\t\n        NC = NC + 1\t\t\n        IF (LC.GT.LOTS) THEN\t\n          WRITE (MSG,12) NC,LC,LOTS\t\n   12     FORMAT (\"Record \",I0,\" has length \",I0,\"\n          LC = LOTS\t\t\t\n        END IF\t\t\t\nChew through ACARD according to mood.\n        LL = 0\t\t\n        L2 = 0\t\t\n   20   L1 = L2 + 1\t\n        IF (L1.LE.LC) THEN\t\n          L2 = L1\t\t\n          IF (BLAH) THEN\t\n   21       IF (L2 + LEN(THAT) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THAT) - 1).EQ.THAT) THEN\t\n                BLAH = .FALSE.\t\t\n                L2 = L2 + LEN(THAT) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 21\t\t\n            END IF\t\n           ELSE\t\t\n   22       IF (L2 + LEN(THIS) - 1 .LE. LC) THEN\t\n              IF (ACARD(L2:L2 + LEN(THIS) - 1).EQ.THIS) THEN\t\n                BLAH = .TRUE.\t\t\n                L = L2 - L1\t\t\n                ALINE(LL + 1:LL + L) = ACARD(L1:L2 - 1)\t\n                LL = LL + L\t\t\n                L2 = L2 + LEN(THIS) - 1\t\n                GO TO 20\t\t\n              END IF\t\t\n              L2 = L2 + 1\t\n              GO TO 22\t\t\n            END IF\t\n            L = LC - L1 + 1\t\n            ALINE(LL + 1:LL + L) = ACARD(L1:LC)\t\n            LL = LL + L\t\t\n          END IF\t\n        END IF\t\nCast forth some output.\n        IF (LL.GT.0) THEN\t\n          WRITE (OUT,23) ALINE(1:LL)\t\n   23     FORMAT (\">\",A,\"<\") \t\t\n          NL = NL + 1\t\t\t\n        END IF        \t\t\n        GO TO 10\t\nCompleted.\n  100   WRITE (MSG,101) NC,NL\t\n  101   FORMAT (I0,\" read, \",I0,\" written.\")\n      END       \n\n      PROGRAM TEST\n      INTEGER MSG,KBD,INF,OUT\n      COMMON /IODEV/MSG,KBD,INF,OUT\n      KBD = 5\n      MSG = 6\n      INF = 10\n      OUT = 11\n      OPEN (INF,FILE=\"Source.txt\",STATUS=\"OLD\",ACTION=\"READ\")\n      OPEN (OUT,FILE=\"Src.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\")\n\n      CALL UNBLOCK(\"/*\",\"*/\")\n\n      END\t\n", "target": "def _commentstripper(txt, delim):\n    'Strips first nest of block comments'\n    \n    deliml, delimr = delim\n    out = ''\n    if deliml in txt:\n        indx = txt.index(deliml)\n        out += txt[:indx]\n        txt = txt[indx+len(deliml):]\n        txt = _commentstripper(txt, delim)\n        assert delimr in txt, 'Cannot find closing comment delimiter in ' + txt\n        indx = txt.index(delimr)\n        out += txt[(indx+len(delimr)):]\n    else:\n        out = txt\n    return out\n\ndef commentstripper(txt, delim=('/*', '*/')):\n    'Strips nests of block comments'\n    \n    deliml, delimr = delim\n    while deliml in txt:\n        txt = _commentstripper(txt, delim)\n    return txt\n"}
{"id": 18615, "name": "Arithmetic_Complex", "source": "Translate Fortran to C#: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": "namespace RosettaCode.Arithmetic.Complex\n{\n    using System;\n    using System.Numerics;\n\n    internal static class Program\n    {\n        private static void Main()\n        {\n            var number = Complex.ImaginaryOne;\n            foreach (var result in new[] { number + number, number * number, -number, 1 / number, Complex.Conjugate(number) })\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 18618, "name": "Arithmetic_Complex", "source": "Translate Fortran to Java: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": "public class Complex {\n    public final double real;\n    public final double imag;\n\n    public Complex() {\n        this(0, 0);\n    }\n\n    public Complex(double r, double i) {\n        real = r;\n        imag = i;\n    }\n\n    public Complex add(Complex b) {\n        return new Complex(this.real + b.real, this.imag + b.imag);\n    }\n\n    public Complex mult(Complex b) {\n        \n        return new Complex(this.real * b.real - this.imag * b.imag,\n                this.real * b.imag + this.imag * b.real);\n    }\n\n    public Complex inv() {\n        \n        double denom = real * real + imag * imag;\n        return new Complex(real / denom, -imag / denom);\n    }\n\n    public Complex neg() {\n        return new Complex(-real, -imag);\n    }\n\n    public Complex conj() {\n        return new Complex(real, -imag);\n    }\n\n    @Override\n    public String toString() {\n        return real + \" + \" + imag + \" * i\";\n    }\n\n    public static void main(String[] args) {\n        Complex a = new Complex(Math.PI, -5); \n        Complex b = new Complex(-1, 2.5);\n        System.out.println(a.neg());\n        System.out.println(a.add(b));\n        System.out.println(a.inv());\n        System.out.println(a.mult(b));\n        System.out.println(a.conj());\n    }\n}\n"}
{"id": 18619, "name": "Arithmetic_Complex", "source": "Translate Fortran to Python: program cdemo\n    complex :: a = (5,3), b = (0.5, 6.0)      \n    complex :: absum, abprod, aneg, ainv\n    \n    absum  = a + b\n    abprod = a * b\n    aneg   = -a\n    ainv   = 1.0 / a\nend program cdemo\n", "target": ">>> z1 = 1.5 + 3j\n>>> z2 = 1.5 + 1.5j\n>>> z1 + z2\n(3+4.5j)\n>>> z1 - z2\n1.5j\n>>> z1 * z2\n(-2.25+6.75j)\n>>> z1 / z2\n(1.5+0.5j)\n>>> - z1\n(-1.5-3j)\n>>> z1.conjugate()\n(1.5-3j)\n>>> abs(z1)\n3.3541019662496847\n>>> z1 ** z2\n(-1.1024829553277784-0.38306415117199333j)\n>>> z1.real\n1.5\n>>> z1.imag\n3.0\n>>>\n"}
{"id": 19176, "name": "Deal cards for FreeCell", "source": "Translate Fortran to C#: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class RNG\n    {\n        private int _state;\n\n        public RNG()\n        {\n            _state = (int)DateTime.Now.Ticks;\n        }\n\n        public RNG(int n)\n        {\n            _state = n;\n        }\n        public int Next()\n        {\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n    }\n\n    public enum Rank\n    {\n        Ace,\n        One,\n        Two,\n        Three,\n        Four,\n        Five,\n        Six,\n        Seven,\n        Eight,\n        Nine,\n        Ten,\n        Jack,\n        Queen,\n        King\n    }\n\n    public enum Suit\n    {\n        Clubs,\n        Diamonds,\n        Hearts,\n        Spades\n    }\n\n    public class Card\n    {\n        private const string Ranks = \"A23456789TJQK\";\n        private const string Suits = \"CDHS\";\n\n        private Rank _rank;\n        public Rank Rank\n        {\n            get\n            {\n                return _rank;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 12)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _rank = value;\n            }\n        }\n\n        private Suit _suit;\n        public Suit Suit\n        {\n            get\n            {\n                return _suit;\n            }\n            set\n            {\n                if ((int)value < 0 || (int)value > 3)\n                {\n                    throw new InvalidOperationException(\"Setting card rank out of range\");\n                }\n                _suit = value;\n            }\n        }\n\n        public Card(Rank rank, Suit suit)\n        {\n            Rank = rank;\n            Suit = suit;\n        }\n\n        public int NRank()\n        {\n            return (int) Rank;\n        }\n\n        public int NSuit()\n        {\n            return (int) Suit;\n        }\n\n        public override string ToString()\n        {\n            return new string(new[] {Ranks[NRank()], Suits[NSuit()]});\n        }\n    }\n\n    public class FreeCellDeal\n    {\n        public List<Card> Deck { get; private set; }\n\n        public FreeCellDeal(int iDeal)\n        {\n            RNG rng = new RNG(iDeal);\n\n            List<Card> rDeck = new List<Card>();\n            Deck = new List<Card>();\n\n            for (int rank = 0; rank < 13; rank++)\n            {\n                for (int suit = 0; suit < 4; suit++)\n                {\n                    rDeck.Add(new Card((Rank)rank, (Suit)suit));\n                }\n            }\n\n            \n            \n            for (int iCard = 51; iCard >= 0; iCard--)\n            {\n                int iSwap = rng.Next() % (iCard + 1);\n                Deck.Add(rDeck[iSwap]);\n                rDeck[iSwap] = rDeck[iCard];\n            }\n        }\n\n        public override string ToString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (int iRow = 0; iRow < 6; iRow++ )\n            {\n                for (int iCol = 0; iCol < 8; iCol++)\n                {\n                    sb.AppendFormat(\"{0} \", Deck[iRow * 8 + iCol]);\n                }\n                sb.Append(\"\\n\");\n            }\n            for (int iCard = 48; iCard < 52; iCard++)\n            {\n                sb.AppendFormat(\"{0} \", Deck[iCard]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            Console.WriteLine(new FreeCellDeal(1));\n            Console.WriteLine();\n            Console.WriteLine(new FreeCellDeal(617));\n        }\n    }\n}\n"}
{"id": 19180, "name": "Deal cards for FreeCell", "source": "Translate Fortran to Java: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "import java.util.Arrays;\n\npublic class Shuffler {\n\t\n\tprivate int seed;\n\t\n\tprivate String[] deck = {\n\t\t\t\"AC\", \"AD\", \"AH\", \"AS\",\n\t\t\t\"2C\", \"2D\", \"2H\", \"2S\",\n\t\t\t\"3C\", \"3D\", \"3H\", \"3S\",\n\t\t\t\"4C\", \"4D\", \"4H\", \"4S\",\n\t\t\t\"5C\", \"5D\", \"5H\", \"5S\",\n\t\t\t\"6C\", \"6D\", \"6H\", \"6S\",\n\t\t\t\"7C\", \"7D\", \"7H\", \"7S\",\n\t\t\t\"8C\", \"8D\", \"8H\", \"8S\",\n\t\t\t\"9C\", \"9D\", \"9H\", \"9S\",\n\t\t\t\"TC\", \"TD\", \"TH\", \"TS\",\n\t\t\t\"JC\", \"JD\", \"JH\", \"JS\",\n\t\t\t\"QC\", \"QD\", \"QH\", \"QS\",\n\t\t\t\"KC\", \"KD\", \"KH\", \"KS\",\n\t};\n\t\n\tprivate int random() {\n\t\tseed = (214013 * seed + 2531011) & Integer.MAX_VALUE;\n\t\treturn seed >> 16;\n\t}\n\t\n\t\n\tprivate String[] getShuffledDeck() {\n\t\tString[] deck = Arrays.copyOf(this.deck, this.deck.length);\n\t\tfor(int i = deck.length - 1; i > 0; i--) {\n\t\t\tint r = random() % (i + 1);\n\t\t\tString card = deck[r];\n\t\t\tdeck[r] = deck[i];\n\t\t\tdeck[i] = card;\n\t\t}\n\t\treturn deck;\n\t}\n\t\n\t\n\tpublic void dealGame(int seed) {\n\t\tthis.seed = seed;\n\t\tString[] shuffledDeck = getShuffledDeck();\n\t\tfor(int count = 1, i = shuffledDeck.length - 1; i >= 0; count++, i--) {\n\t\t\tSystem.out.print(shuffledDeck[i]);\n\t\t\tif(count % 8 == 0) {\n\t\t\t\tSystem.out.println();\n\t\t\t} else {\n\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tShuffler s = new Shuffler();\n\t\ts.dealGame(1);\n\t\tSystem.out.println();\n\t\ts.dealGame(617);\n\t}\n\t\n}\n"}
{"id": 19181, "name": "Deal cards for FreeCell", "source": "Translate Fortran to Python: module Freecell\n  use lcgs\n  implicit none\n\n  character(4)  :: suit = \"CDHS\"\n  character(13) :: rank = \"A23456789TJQK\"\n  character(2) :: deck(0:51)\n\ncontains\n\nsubroutine Createdeck()\n  integer :: i, j, n\n\n  n = 0\n  do i = 1, 13\n    do j = 1, 4\n      deck(n) = rank(i:i) // suit(j:j)\n      n = n + 1\n    end do\n  end do\n\nend subroutine\n \nsubroutine Freecelldeal(game)\n  integer, intent(in) :: game\n  integer(i64) :: rnum\n  integer :: i, n\n  character(2) :: tmp\n\n  call Createdeck()\n  rnum = msrand(game)\n\n  do i = 51, 1, -1\n    n = mod(rnum, i+1)\n    tmp = deck(n)\n    deck(n) = deck(i)\n    deck(i) = tmp\n    rnum = msrand()\n  end do\n\n  write(*, \"(a, i0)\") \"Game #\", game\n  write(*, \"(8(a, tr1))\") deck(51:0:-1)\n  write(*,*)\n\nend subroutine  \nend module Freecell\n\nprogram Freecell_test\n  use Freecell\n  implicit none\n\n  call Freecelldeal(1)\n  call Freecelldeal(617)\n   \nend program\n", "target": "def randomGenerator(seed=1):\n    max_int32 = (1 << 31) - 1\n    seed = seed & max_int32\n\n    while True:\n        seed = (seed * 214013 + 2531011) & max_int32\n        yield seed >> 16\n\ndef deal(seed):\n    nc = 52\n    cards = list(range(nc - 1, -1, -1))\n    rnd = randomGenerator(seed)\n    for i, r in zip(range(nc), rnd):\n        j = (nc - 1) - r % (nc - i)\n        cards[i], cards[j] = cards[j], cards[i]\n    return cards\n\ndef show(cards):\n    l = [\"A23456789TJQK\"[int(c/4)] + \"CDHS\"[c%4] for c in cards]\n    for i in range(0, len(cards), 8):\n        print(\" \".join(l[i : i+8]))\n\nif __name__ == '__main__':\n    from sys import argv\n    seed = int(argv[1]) if len(argv) == 2 else 11982\n    print(\"Hand {}\".format(seed))\n    deck = deal(seed)\n    show(deck)\n"}
{"id": 19383, "name": "Handle a signal", "source": "Translate Fortran to C#: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "using System; \nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        \n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n"}
{"id": 19386, "name": "Handle a signal", "source": "Translate Fortran to Java: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "import sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n"}
{"id": 19387, "name": "Handle a signal", "source": "Translate Fortran to Python: program signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  \n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  \n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    \n    \n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n", "target": "import time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n"}
{"id": 19585, "name": "Non-decimal radices_Output", "source": "Translate Fortran to C#: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": "using System;\n\nnamespace NonDecimalRadicesOutput\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i < 42; i++)\n            {\n                string binary = Convert.ToString(i, 2);\n                string octal = Convert.ToString(i, 8);\n                string hexadecimal = Convert.ToString(i, 16);\n                Console.WriteLine(string.Format(\"Decimal: {0}, Binary: {1}, Octal: {2}, Hexadecimal: {3}\", i, binary, octal, hexadecimal));\n            }\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 19588, "name": "Non-decimal radices_Output", "source": "Translate Fortran to Java: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": "public static void main(String args[]){\n   for(int a= 0;a < 33;a++){\n      System.out.println(Integer.toBinaryString(a));\n      System.out.println(Integer.toOctalString(a));\n      System.out.println(Integer.toHexString(a));\n      \n      \n\n      System.out.printf(\"%3o %2d %2x\\n\",a ,a ,a); \n   }\n}\n"}
{"id": 19589, "name": "Non-decimal radices_Output", "source": "Translate Fortran to Python: do n = 1, 33\n  write(*, \"(b6, o4, i4, z4)\") n, n, n, n\nend do\n", "target": ">>> for n in range(34):\n  print \" {0:6b} {1:3o} {2:2d} {3:2X}\".format(n, n, n, n)\n  \n  \n  \n\n  \n      0   0  0  0\n      1   1  1  1\n     10   2  2  2\n     11   3  3  3\n    100   4  4  4\n    101   5  5  5\n    110   6  6  6\n    111   7  7  7\n   1000  10  8  8\n   1001  11  9  9\n   1010  12 10  A\n   1011  13 11  B\n   1100  14 12  C\n   1101  15 13  D\n   1110  16 14  E\n   1111  17 15  F\n  10000  20 16 10\n  10001  21 17 11\n  10010  22 18 12\n  10011  23 19 13\n  10100  24 20 14\n  10101  25 21 15\n  10110  26 22 16\n  10111  27 23 17\n  11000  30 24 18\n  11001  31 25 19\n  11010  32 26 1A\n  11011  33 27 1B\n  11100  34 28 1C\n  11101  35 29 1D\n  11110  36 30 1E\n  11111  37 31 1F\n 100000  40 32 20\n 100001  41 33 21\n>>>\n"}
{"id": 19938, "name": "Huffman coding", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 19942, "name": "Huffman coding", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "import java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; \n    public HuffmanTree(int freq) { frequency = freq; }\n\n    \n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; \n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; \n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    \n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        \n        \n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        \n        while (trees.size() > 1) {\n            \n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            \n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            \n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            \n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            \n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        \n        \n        int[] charFreqs = new int[256];\n        \n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        \n        HuffmanTree tree = buildTree(charFreqs);\n\n        \n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n"}
{"id": 19943, "name": "Huffman coding", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n", "target": "from heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n\n\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n"}
{"id": 20500, "name": "Parallel calculations", "source": "Translate Fortran to C#: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    public static List<int> PrimeFactors(int number)\n    {\n        var primes = new List<int>();\n        for (int div = 2; div <= number; div++)\n        {\n            while (number % div == 0)\n            {\n                primes.Add(div);\n                number = number / div;\n            }\n        }\n        return primes;\n    }\n\n    static void Main(string[] args)\n    {\n        int[] n = { 12757923, 12878611, 12757923, 15808973, 15780709, 197622519 };\n        \n        var factors = n.AsParallel().Select(PrimeFactors).ToList();\n        \n        var smallestFactors = factors.Select(thisNumbersFactors => thisNumbersFactors.Min()).ToList();\n        \n        int biggestFactor = smallestFactors.Max();\n        int whatIndexIsThat = smallestFactors.IndexOf(biggestFactor);\n        Console.WriteLine(\"{0} has the largest minimum prime factor: {1}\", n[whatIndexIsThat], biggestFactor);\n        Console.WriteLine(string.Join(\" \", factors[whatIndexIsThat]));\n    }\n}\n"}
{"id": 20503, "name": "Parallel calculations", "source": "Translate Fortran to Java: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "import static java.lang.System.out; \nimport static java.util.Arrays.stream;\nimport static java.util.Comparator.comparing;\n \npublic interface ParallelCalculations {\n    public static final long[] NUMBERS = {\n      12757923,\n      12878611,\n      12878893,\n      12757923,\n      15808973,\n      15780709,\n      197622519\n    };\n \n    public static void main(String... arguments) {\n      stream(NUMBERS)\n        .unordered()\n        .parallel()\n        .mapToObj(ParallelCalculations::minimalPrimeFactor)\n        .max(comparing(a -> a[0]))\n        .ifPresent(res -> out.printf(\n          \"%d has the largest minimum prime factor: %d%n\",\n          res[1],\n          res[0]\n        ));\n    }\n \n    public static long[] minimalPrimeFactor(long n) {\n      for (long i = 2; n >= i * i; i++) {\n        if (n % i == 0) {\n          return new long[]{i, n};\n        }\n      }\n      return new long[]{n, n};\n    }\n}\n"}
{"id": 20504, "name": "Parallel calculations", "source": "Translate Fortran to Python: program Primes\n\n    use ISO_FORTRAN_ENV\n\n    implicit none\n\n    integer(int64), dimension(7) :: data = (/2099726827, 15780709, 1122725370, 15808973, 576460741, 12878611, 12757923/)\n    integer(int64), dimension(100) :: outprimes\n    integer(int64) :: largest_factor = 0, largest = 0, minim = 0, val = 0\n    integer(int16) :: count = 0, OMP_GET_THREAD_NUM\n\n    call omp_set_num_threads(4);\n    \n    do val = 1, 7\n        outprimes = 0\n        call find_factors(data(val), outprimes, count)\n        minim = minval(outprimes(1:count))\n        if (minim > largest_factor) then\n            largest_factor = minim\n            largest = data(val)\n        end if\n        write(*, fmt = '(A7,i0,A2,i12,100i12)') 'Thread ', OMP_GET_THREAD_NUM(), ': ', data(val), outprimes(1:count)\n    end do\n    \n\n    write(*, fmt = '(i0,A26,i0)') largest, ' have the Largest factor: ', largest_factor\n\n    return\n\ncontains\n\n    subroutine find_factors(n, d, count)\n        integer(int64), intent(in) :: n\n        integer(int64), dimension(:), intent(out) :: d\n        integer(int16), intent(out) :: count\n        integer(int16) :: i\n        integer(int64) :: div, next, rest\n\n        i = 1\n        div = 2; next = 3; rest = n\n\n        do while (rest /= 1)\n            do while (mod(rest, div) == 0)\n                d(i) = div\n                i = i + 1\n                rest = rest / div\n            end do\n            div = next\n            next = next + 2\n        end do\n        count = i - 1\n    end subroutine find_factors\n\nend program Primes\n", "target": "from concurrent import futures\nfrom math import floor, sqrt\n \nNUMBERS = [\n    112272537195293,\n    112582718962171,\n    112272537095293,\n    115280098190773,\n    115797840077099,\n    1099726829285419]\n\n \ndef lowest_factor(n, _start=3):\n    if n % 2 == 0:\n        return 2\n    search_max = int(floor(sqrt(n))) + 1\n    for i in range(_start, search_max, 2):\n        if n % i == 0:\n            return i\n    return n\n\ndef prime_factors(n, lowest):\n    pf = []\n    while n > 1:\n        pf.append(lowest)\n        n //= lowest\n        lowest = lowest_factor(n, max(lowest, 3))\n    return pf\n\ndef prime_factors_of_number_with_lowest_prime_factor(NUMBERS):\n    with futures.ProcessPoolExecutor() as executor:\n        low_factor, number = max( (l, f) for l, f in zip(executor.map(lowest_factor, NUMBERS), NUMBERS) )\n        all_factors = prime_factors(number, low_factor)\n        return number, all_factors\n\n \ndef main():\n    print('For these numbers:')\n    print('\\n  '.join(str(p) for p in NUMBERS))\n    number, all_factors = prime_factors_of_number_with_lowest_prime_factor(NUMBERS)\n    print('    The one with the largest minimum prime factor is {}:'.format(number))\n    print('      All its prime factors in order are: {}'.format(all_factors))\n \nif __name__ == '__main__':\n    main()\n"}
{"id": 20630, "name": "Call a function in a shared library", "source": "Translate Fortran to C#: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "using System.Runtime.InteropServices;\n\nclass Program {\n    [DllImport(\"fakelib.dll\")]\n    public static extern int fakefunction(int args);\n\n    static void Main(string[] args) {\n        int r = fakefunction(10);\n    }\n}\n"}
{"id": 20632, "name": "Call a function in a shared library", "source": "Translate Fortran to Java: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "\n\nimport java.util.Collections;\nimport java.util.Random;\n\npublic class TrySort {\n    static boolean useC;\n    static {\n\ttry {\n\t    System.loadLibrary(\"TrySort\");\n\t    useC = true;\n\t} catch(UnsatisfiedLinkError e) {\n\t    useC = false;\n\t}\n    }\n    \n    static native void sortInC(int[] ary);\n    \n    static class IntList extends java.util.AbstractList<Integer> {\n\tint[] ary;\n\tIntList(int[] ary) { this.ary = ary; }\n\tpublic Integer get(int i) { return ary[i]; }\n\tpublic Integer set(int i, Integer j) {\n\t    Integer o = ary[i]; ary[i] = j; return o;\n\t}\n\tpublic int size() { return ary.length; }\n    }\n\n    static class ReverseAbsCmp\n\timplements java.util.Comparator<Integer>\n    {\n\tpublic int compare(Integer pa, Integer pb) {\n\t    \n\t    int a = pa > 0 ? -pa : pa;\n\t    int b = pb > 0 ? -pb : pb;\n\t    return a < b ? -1 : a > b ? 1 : 0;\n\t}\n    }\n    \n    static void sortInJava(int[] ary) {\n\tCollections.sort(new IntList(ary), new ReverseAbsCmp());\n    }\n\n    public static void main(String[] args) {\n\t\n\tint[] ary = new int[1000000];\n\tRandom rng = new Random();\n\tfor (int i = 0; i < ary.length; i++)\n\t    ary[i] = rng.nextInt();\n\n\t\n\tif (useC) {\n\t    System.out.print(\"Sorting in C...  \");\n\t    sortInC(ary);\n\t} else {\n\t    System.out.print\n\t\t(\"Missing library for C!  Sorting in Java...  \");\n\t    sortInJava(ary);\n\t}\n\n\tfor (int i = 0; i < ary.length - 1; i++) {\n\t    int a = ary[i];\n\t    int b = ary[i + 1];\n\t    if ((a > 0 ? -a : a) > (b > 0 ? -b : b)) {\n\t\tSystem.out.println(\"*BUG IN SORT*\");\n\t\tSystem.exit(1);\n\t    }\n\t}\n\tSystem.out.println(\"ok\");\n    }\n}\n"}
{"id": 20633, "name": "Call a function in a shared library", "source": "Translate Fortran to Python: function  add_nf(a,b) bind(c, name='add_nf')\nuse, intrinsic :: iso_c_binding\nimplicit none\nreal(c_double), intent(in) :: a,b\nreal(c_double) :: add_nf\n\nadd_nf = a + b\nend function add_nf\n", "target": "import ctypes\n  \nuser32_dll = ctypes.cdll.LoadLibrary('User32.dll')\nprint user32_dll.GetDoubleClickTime()\n"}
{"id": 20766, "name": "Reduced row echelon form", "source": "Translate Fortran to C#: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "using System;\n\nnamespace rref\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[,] matrix = new int[3, 4]{\n                {  1, 2, -1,  -4 },\n                {  2, 3, -1, -11 },\n                { -2, 0, -3,  22 }\n            };\n            matrix = rref(matrix);   \n        }\n\n        private static int[,] rref(int[,] matrix)\n        {            \n            int lead = 0, rowCount = matrix.GetLength(0), columnCount = matrix.GetLength(1);\n            for (int r = 0; r < rowCount; r++)\n            {\n                if (columnCount <= lead) break;\n                int i = r;\n                while (matrix[i, lead] == 0)\n                {\n                    i++;\n                    if (i == rowCount)\n                    {\n                        i = r;\n                        lead++;\n                        if (columnCount == lead)\n                        {\n                        lead--;\n                        break;\n                        }\n                    }\n                }\n                for (int j = 0; j < columnCount; j++)\n                {\n                    int temp = matrix[r, j];\n                    matrix[r, j] = matrix[i, j];\n                    matrix[i, j] = temp;\n                }\n                int div = matrix[r, lead];\n                if(div != 0)\n                    for (int j = 0; j < columnCount; j++) matrix[r, j] /= div;                \n                for (int j = 0; j < rowCount; j++)\n                {\n                    if (j != r)\n                    {\n                        int sub = matrix[j, lead];\n                        for (int k = 0; k < columnCount; k++) matrix[j, k] -= (sub * matrix[r, k]);\n                    }\n                }\n                lead++;\n            }\n            return matrix;\n        }\n    }\n}\n"}
{"id": 20769, "name": "Reduced row echelon form", "source": "Translate Fortran to Java: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "import java.util.*;\nimport java.lang.Math;\nimport org.apache.commons.math.fraction.Fraction;\nimport org.apache.commons.math.fraction.FractionConversionException;\n\n\nclass Matrix {\n\tLinkedList<LinkedList<Fraction>> matrix;\n\tint numRows;\n\tint numCols;\t\n\t\n\tstatic class Coordinate {\n\t\tint row;\n\t\tint col;\n\n\t\tCoordinate(int r, int c) {\n\t\t\trow = r;\n\t\t\tcol = c;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + row + \", \" + col + \")\";\n\t\t}\n\t}\n\n\tMatrix(double [][] m) {\n\t\tnumRows = m.length;\t\n\t\tnumCols = m[0].length;\n\n\t\tmatrix = new LinkedList<LinkedList<Fraction>>();\n\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tmatrix.add(new LinkedList<Fraction>());\n\t\t\tfor (int j = 0; j < numCols; j++) {\n\t\t\t\ttry {\n\t\t\t\t\tmatrix.get(i).add(new Fraction(m[i][j]));\n\t\t\t\t} catch (FractionConversionException e) {\n\t\t\t\t\tSystem.err.println(\"Fraction could not be converted from double by apache commons . . .\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void Interchange(Coordinate a, Coordinate b) {\n\t\tLinkedList<Fraction> temp = matrix.get(a.row);\n\t\tmatrix.set(a.row, matrix.get(b.row));\t\t\n\t\tmatrix.set(b.row, temp);\n\n\t\tint t = a.row;\n\t\ta.row = b.row;\n\t\tb.row = t;\n\t} \n\n\tpublic void Scale(Coordinate x, Fraction d) {\n\t\tLinkedList<Fraction> row = matrix.get(x.row);\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).multiply(d));\n\t\t}\n\t}\n\n\tpublic void MultiplyAndAdd(Coordinate to, Coordinate from, Fraction scalar) {\n\t\tLinkedList<Fraction> row = matrix.get(to.row);\n\t\tLinkedList<Fraction> rowMultiplied = matrix.get(from.row);\n\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\trow.set(i, row.get(i).add((rowMultiplied.get(i).multiply(scalar))));\n\t\t}\n\t}\n\n\tpublic void RREF() {\n\t\tCoordinate pivot = new Coordinate(0,0);\n\n\t\tint submatrix = 0;\n\t\tfor (int x = 0; x < numCols; x++) {\n\t\t\tpivot = new Coordinate(pivot.row, x);\n\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = x; i < numCols; i++) {\n\t\t\t\t\tif (isColumnZeroes(pivot) == false) {\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpivot.col = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\tpivot = findPivot(pivot);\n\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() == 0.0) {\n\t\t\t\t\tpivot.row++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pivot.row != submatrix) {\n\t\t\t\t\tInterchange(new Coordinate(submatrix, pivot.col), pivot);\n\t\t\t\t}\n\t\t\n\t\t\t\t\n\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1) {\n\t\t\t\t\t\n\t\t\t\t\tFraction scalar = getCoordinate(pivot).reciprocal();\n\t\t\t\t\tScale(pivot, scalar);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i < numRows; i++) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tCoordinate belowPivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(belowPivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(belowPivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tfor (int i = pivot.row; i >= 0; i--) {\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tif (getCoordinate(pivot).doubleValue() != 1.0) {\n\t\t\t\t\t\t\tScale(pivot, getCoordinate(pivot).reciprocal());\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i == pivot.row) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tCoordinate abovePivot = new Coordinate(i, pivot.col);\n\t\t\t\t\tFraction complement = (getCoordinate(abovePivot).negate().divide(getCoordinate(pivot)));\n\t\t\t\t\tMultiplyAndAdd(abovePivot, pivot, complement);\n\t\t\t\t}\n\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif ((pivot.row + 1) >= numRows || isRowZeroes(new Coordinate(pivot.row+1, pivot.col))) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsubmatrix++;\n\t\t\t\tpivot.row++;\n\t\t}\n\t}\n\t\n\tpublic boolean isColumnZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numRows; i++) {\n\t\t\tif (matrix.get(i).get(a.col).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic boolean isRowZeroes(Coordinate a) {\n\t\tfor (int i = 0; i < numCols; i++) {\n\t\t\tif (matrix.get(a.row).get(i).doubleValue() != 0.0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic Coordinate findPivot(Coordinate a) {\n\t\tint first_row = a.row;\n\t\tCoordinate pivot = new Coordinate(a.row, a.col);\n\t\tCoordinate current = new Coordinate(a.row, a.col);\t\n\n\t\tfor (int i = a.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() == 1.0) {\n\t\t\t\tInterchange(current, a);\n\t\t\t}\n\t\t}\n\n\t\tcurrent.row = a.row;\n\t\tfor (int i = current.row; i < (numRows - first_row); i++) {\n\t\t\tcurrent.row = i;\n\t\t\tif (getCoordinate(current).doubleValue() != 0) {\n\t\t\t\tpivot.row = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\t\n\t\treturn pivot;\t\n\t}\t\n\n\tpublic Fraction getCoordinate(Coordinate a) {\n\t\treturn matrix.get(a.row).get(a.col);\n\t}\n\n\tpublic String toString() {\n\t\treturn matrix.toString().replace(\"], \", \"]\\n\");\n\t}\n\n\tpublic static void main (String[] args) {\n        \tdouble[][] matrix_1 = {\n\t\t\t{1, 2, -1, -4},\n\t\t\t{2, 3, -1, -11},\n\t\t\t{-2, 0, -3, 22}\n\t\t};\n\n\t\tMatrix x = new Matrix(matrix_1);\n\t\tSystem.out.println(\"before\\n\" + x.toString() + \"\\n\");\n\t\tx.RREF();\n\t\tSystem.out.println(\"after\\n\" + x.toString() + \"\\n\");\n\n\t\tdouble matrix_2 [][] = {\n\t\t\t{2, 0, -1, 0, 0},\n\t\t\t{1, 0, 0, -1, 0},\n\t\t\t{3, 0, 0, -2, -1},\n\t\t\t{0, 1, 0, 0, -2},\n\t\t\t{0, 1, -1, 0, 0}\n\t\t};\n\t\n\t\tMatrix y = new Matrix(matrix_2);\n\t\tSystem.out.println(\"before\\n\" + y.toString() + \"\\n\");\n\t\ty.RREF();\n\t\tSystem.out.println(\"after\\n\" + y.toString() + \"\\n\");\n\n\t\tdouble matrix_3 [][] = {\n\t\t\t{1, 2, 3, 4, 3, 1},\n\t\t\t{2, 4, 6, 2, 6, 2},\n\t\t\t{3, 6, 18, 9, 9, -6},\n\t\t\t{4, 8, 12, 10, 12, 4},\n\t\t\t{5, 10, 24, 11, 15, -4}\n\t\t};\n\n\t\tMatrix z = new Matrix(matrix_3);\n\t\tSystem.out.println(\"before\\n\" + z.toString() + \"\\n\");\n\t\tz.RREF();\n\t\tSystem.out.println(\"after\\n\" + z.toString() + \"\\n\");\n\n\t\tdouble matrix_4 [][] = {\n\t\t\t{0, 1},\n\t\t\t{1, 2},\n\t\t\t{0,5}\n\t\t};\n\n\t\tMatrix a = new Matrix(matrix_4);\n\t\tSystem.out.println(\"before\\n\" + a.toString() + \"\\n\");\n\t\ta.RREF();\n\t\tSystem.out.println(\"after\\n\" + a.toString() + \"\\n\");\n\t}\t\n}\n"}
{"id": 20770, "name": "Reduced row echelon form", "source": "Translate Fortran to Python: module Rref\n  implicit none\ncontains\n  subroutine to_rref(matrix)\n    real, dimension(:,:), intent(inout) :: matrix\n\n    integer :: pivot, norow, nocolumn\n    integer :: r, i\n    real, dimension(:), allocatable :: trow\n\n    pivot = 1\n    norow = size(matrix, 1)\n    nocolumn = size(matrix, 2)\n\n    allocate(trow(nocolumn))\n    \n    do r = 1, norow\n       if ( nocolumn <= pivot ) exit\n       i = r\n       do while ( matrix(i, pivot) == 0 )\n          i = i + 1\n          if ( norow == i ) then\n             i = r\n             pivot = pivot + 1\n             if ( nocolumn == pivot ) return\n          end if\n       end do\n       trow = matrix(i, :)\n       matrix(i, :) = matrix(r, :)\n       matrix(r, :) = trow\n       matrix(r, :) = matrix(r, :) / matrix(r, pivot)\n       do i = 1, norow\n          if ( i /= r ) matrix(i, :) = matrix(i, :) - matrix(r, :) * matrix(i, pivot) \n       end do\n       pivot = pivot + 1\n    end do\n    deallocate(trow)\n  end subroutine to_rref\nend module Rref\n", "target": "def ToReducedRowEchelonForm( M):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / float(lv) for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n\n\nmtx = [\n   [ 1, 2, -1, -4],\n   [ 2, 3, -1, -11],\n   [-2, 0, -3, 22],]\n\nToReducedRowEchelonForm( mtx )\n\nfor rw in mtx:\n  print ', '.join( (str(rv) for rv in rw) )\n"}
{"id": 21269, "name": "Hamming numbers", "source": "Translate Fortran to C#: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "using System;\nusing System.Numerics;\nusing System.Linq;\n\nnamespace Hamming {\n\n    class MainClass {\n\n        public static BigInteger Hamming(int n) {\n            BigInteger two = 2, three = 3, five = 5;\n            var h = new BigInteger[n];\n            h[0] = 1;\n            BigInteger x2 = 2, x3 = 3, x5 = 5;\n            int i = 0, j = 0, k = 0;\n            \n            for (int index = 1; index < n; index++) {\n                h[index] = BigInteger.Min(x2, BigInteger.Min(x3, x5));\n                if (h[index] == x2) x2 = two * h[++i];\n                if (h[index] == x3) x3 = three * h[++j];\n                if (h[index] == x5) x5 = five * h[++k];\n            }\n            return h[n - 1];\n        }\n\n        public static void Main(string[] args) {\n            Console.WriteLine(string.Join(\" \", Enumerable.Range(1, 20).ToList().Select(x => Hamming(x))));\n            Console.WriteLine(Hamming(1691));\n            Console.WriteLine(Hamming(1000000));\n        }\n    }\n}\n"}
{"id": 21272, "name": "Hamming numbers", "source": "Translate Fortran to Java: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "import java.math.BigInteger;\nimport java.util.PriorityQueue;\n\nfinal class Hamming {\n    private static BigInteger THREE = BigInteger.valueOf(3);\n    private static BigInteger FIVE = BigInteger.valueOf(5);\n\n    private static void updateFrontier(BigInteger x,\n                                       PriorityQueue<BigInteger> pq) {\n        pq.offer(x.shiftLeft(1));\n        pq.offer(x.multiply(THREE));\n        pq.offer(x.multiply(FIVE));\n    }\n\n    public static BigInteger hamming(int n) {\n        if (n <= 0)\n            throw new IllegalArgumentException(\"Invalid parameter\");\n        PriorityQueue<BigInteger> frontier = new PriorityQueue<BigInteger>();\n        updateFrontier(BigInteger.ONE, frontier);\n        BigInteger lowest = BigInteger.ONE;\n        for (int i = 1; i < n; i++) {\n            lowest = frontier.poll();\n            while (frontier.peek().equals(lowest))\n                frontier.poll();\n            updateFrontier(lowest, frontier);\n        }\n        return lowest;\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"Hamming(1 .. 20) =\");\n        for (int i = 1; i < 21; i++)\n             System.out.print(\" \" + hamming(i));\n        System.out.println(\"\\nHamming(1691) = \" + hamming(1691));\n        System.out.println(\"Hamming(1000000) = \" + hamming(1000000));\n    }\n}\n"}
{"id": 21273, "name": "Hamming numbers", "source": "Translate Fortran to Python: program Hamming_Test\n  use big_integer_module\n  implicit none\n  \n  call Hamming(1,20)\n  write(*,*)\n  call Hamming(1691)\n  write(*,*)\n  call Hamming(1000000)\n   \ncontains\n\nsubroutine Hamming(first, last)\n\n  integer, intent(in) :: first\n  integer, intent(in), optional :: last\n  integer :: i, n, i2, i3, i5, lim\n  type(big_integer), allocatable :: hnums(:)\n\n  if(present(last)) then\n    lim = last\n  else\n    lim = first\n  end if\n\n  if(first < 1 .or. lim > 2500000 ) then\n    write(*,*) \"Invalid input\"\n    return\n  end if\n  \n  allocate(hnums(lim))\n  \n  i2 = 1 ;  i3 = 1 ; i5 = 1  \n  hnums(1) = 1\n  n = 1\n  do while(n < lim)\n    n = n + 1\n    hnums(n) = mini(2*hnums(i2), 3*hnums(i3), 5*hnums(i5))\n    if(2*hnums(i2) == hnums(n)) i2 = i2 + 1\n    if(3*hnums(i3) == hnums(n)) i3 = i3 + 1\n    if(5*hnums(i5) == hnums(n)) i5 = i5 + 1\n  end do\n  \n  if(present(last)) then\n    do i = first, last\n      call print_big(hnums(i))\n      write(*, \"(a)\", advance=\"no\") \" \"\n    end do\n  else\n    call print_big(hnums(first))\n  end if\n  \n  deallocate(hnums)\nend subroutine\n \nfunction mini(a, b, c)\n  type(big_integer) :: mini\n  type(big_integer), intent(in) :: a, b, c\n   \n  if(a < b ) then \n    if(a < c) then\n      mini = a\n    else\n      mini = c\n    end if\n  else if(b < c) then\n    mini = b\n  else\n    mini = c\n  end if \nend function mini \nend program\n", "target": "from itertools import islice\n\ndef hamming2():\n    \n    h = 1\n    _h=[h]    \n    multipliers  = (2, 3, 5)\n    multindeces  = [0 for i in multipliers] \n    multvalues   = [x * _h[i] for x,i in zip(multipliers, multindeces)]\n    yield h\n    while True:\n        h = min(multvalues)\n        _h.append(h)\n        for (n,(v,x,i)) in enumerate(zip(multvalues, multipliers, multindeces)):\n            if v == h:\n                i += 1\n                multindeces[n] = i\n                multvalues[n]  = x * _h[i]\n        \n        mini = min(multindeces)\n        if mini >= 1000:\n            del _h[:mini]\n            multindeces = [i - mini for i in multindeces]\n        \n        yield h\n"}
{"id": 21442, "name": "Topological sort", "source": "Translate Fortran to C#:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "namespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    \n                new Task{ Message = \"B - depends on none\" },       \n                new Task{ Message = \"C - depends on D and E\" },    \n                new Task{ Message = \"D - depends on none\" },       \n                new Task{ Message = \"E - depends on F, G and H\" }, \n                new Task{ Message = \"F - depends on I\" },          \n                new Task{ Message = \"G - depends on none\" },       \n                new Task{ Message = \"H - depends on none\" },       \n                new Task{ Message = \"I - depends on none\" },       \n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            \n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            \n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            \n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            \n            \n\n            \n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n"}
{"id": 21446, "name": "Topological sort", "source": "Translate Fortran to Java:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "import java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         \n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 21447, "name": "Topological sort", "source": "Translate Fortran to Python:       SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n", "target": "try:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) \n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n"}
{"id": 21652, "name": "Formatted numeric output", "source": "Translate Fortran to C#: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "class Program\n    {\n\n\n        static void Main(string[] args)\n        {\n\n            float myNumbers = 7.125F;\n            \n            string strnumber = Convert.ToString(myNumbers);\n                       \n            Console.WriteLine(strnumber.PadLeft(9, '0'));\n           \n            Console.ReadLine();\n        }\n        \n\n             \n       \n    }\n"}
{"id": 21655, "name": "Formatted numeric output", "source": "Translate Fortran to Java: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "public class Printing{\n\tpublic static void main(String[] args){\n\t\tdouble value = 7.125;\n\t\tSystem.out.printf(\"%09.3f\",value); \n\t\tSystem.out.println(String.format(\"%09.3f\",value));\n\t}\n}\n"}
{"id": 21656, "name": "Formatted numeric output", "source": "Translate Fortran to Python: INTEGER :: number = 7125\nWRITE(*,\"(I8.8)\") number   \n", "target": "from math import pi, exp\nr = exp(pi)-pi\nprint r\nprint \"e=%e f=%f g=%g G=%G s=%s r=%r!\"%(r,r,r,r,r,r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(-r,-r,-r)\nprint \"e=%9.4e f=%9.4f g=%9.4g!\"%(r,r,r)\nprint \"e=%-9.4e f=%-9.4f g=%-9.4g!\"%(r,r,r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(-r,-r,-r)\nprint \"e=%09.4e f=%09.4f g=%09.4g!\"%(r,r,r)\nprint \"e=%-09.4e f=%-09.4f g=%-09.4g!\"%(r,r,r)\n"}
{"id": 21875, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to C#: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "class Link\n{\n    public int Item { get; set; }\n    public Link Prev { get; set; }\n    public Link Next { get; set; }\n\n    \n    public Link(int item, Link prev = null, Link next = null) {\n        Item = item;\n        Prev = prev;\n        Next = next;\n    }\n}\n"}
{"id": 21878, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to Java: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "public class Node<T> {\n   private T element;\n   private Node<T> next, prev;\n\n   public Node<T>(){\n      next = prev = element = null;\n   }\n\n   public Node<T>(Node<T> n, Node<T> p, T elem){\n      next = n;\n      prev = p;\n      element = elem;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> getNext(){\n      return next;\n   }\n\n   public void setElem(T elem){\n      element = elem;\n   }\n\n   public T getElem(){\n      return element;\n   }\n\n   public void setNext(Node<T> n){\n      next = n;\n   }\n\n   public Node<T> setPrev(Node<T> p){\n      prev = p;\n   }\n\n   public getPrev(){\n      return prev;\n   }\n}\n"}
{"id": 21879, "name": "Doubly-linked list_Element definition", "source": "Translate Fortran to Python: type node\n   real :: data\n   type(node), pointer :: next => null(), previous => null()\nend type node\n\n\n\ntype( node ), target :: head\n", "target": "class Node(object):\n     def __init__(self, data = None, prev = None, next = None):\n         self.prev = prev\n         self.next = next\n         self.data = data\n     def __str__(self):\n         return str(self.data)\n     def __repr__(self):\n         return repr(self.data)\n     def iter_forward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.next\n     def iter_backward(self):\n         c = self\n         while c != None:\n             yield c\n             c = c.prev\n"}
{"id": 22183, "name": "Dot product", "source": "Translate Fortran to C#: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22184, "name": "Dot product", "source": "Translate Fortran to C#: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n"}
{"id": 22190, "name": "Dot product", "source": "Translate Fortran to Java: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22191, "name": "Dot product", "source": "Translate Fortran to Java: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "public class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"}
{"id": 22192, "name": "Dot product", "source": "Translate Fortran to Python: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22193, "name": "Dot product", "source": "Translate Fortran to Python: program test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n", "target": "def dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n"}
{"id": 22630, "name": "Count in factors", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=1; i<=22; i++ )\n\t\t\t{\t\t\t\t\n\t\t\t\tList<int> f = Factorize(i);\n\t\t\t\tConsole.Write( i + \":  \" + f[0] );\n\t\t\t\tfor( int j=1; j<f.Count; j++ )\n\t\t\t\t{\n\t\t\t\t\tConsole.Write( \" * \" + f[j] );\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static List<int> Factorize( int n )\n\t\t{\n\t\t\tList<int> l = new List<int>();\n\t\t    \n\t\t\tif ( n == 1 )\n\t\t\t{\n\t\t\t\tl.Add(1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k = 2;\n\t\t\t\twhile( n > 1 ) \n\t\t\t\t{\n\t\t\t\t\twhile( n % k == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tl.Add( k );\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\treturn l;\n\t\t}\t\n\t}\n}\n"}
{"id": 22633, "name": "Count in factors", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "public class CountingInFactors{ \n    public static void main(String[] args){\n        for(int i = 1; i<= 10; i++){\n            System.out.println(i + \" = \"+ countInFactors(i));\n        }\n \n        for(int i = 9991; i <= 10000; i++){\n        \tSystem.out.println(i + \" = \"+ countInFactors(i));\n        }\n    }\n \n    private static String countInFactors(int n){\n        if(n == 1) return \"1\";\n \n        StringBuilder sb = new StringBuilder();\n \n        n = checkFactor(2, n, sb);\n        if(n == 1) return sb.toString();\n \n        n = checkFactor(3, n, sb);\n        if(n == 1) return sb.toString();\n \n        for(int i = 5; i <= n; i+= 2){\n            if(i % 3 == 0)continue;\n \n            n = checkFactor(i, n, sb);\n            if(n == 1)break;\n        }\n \n        return sb.toString();\n    }\n \n    private static int checkFactor(int mult, int n, StringBuilder sb){\n        while(n % mult == 0 ){\n            if(sb.length() > 0) sb.append(\" x \");\n            sb.append(mult);\n            n /= mult;\n        }\n        return n;\n    }\n}\n"}
{"id": 22634, "name": "Count in factors", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule prime_mod\n\n  \n  integer, dimension(:), allocatable :: sieve_table\n  private :: PrimeQ\n\ncontains\n\n  \n  subroutine sieve(n) \n    integer, intent(in) :: n\n    integer :: status, i, j\n    if ((n .lt. 1) .or. allocated(sieve_table)) deallocate(sieve_table)\n    if (n .lt. 1) return\n    allocate(sieve_table(n), stat=status)\n    if (status .ne. 0) stop 'cannot allocate space'\n    sieve_table(1) = 1\n    do i=2,int(sqrt(real(n)))+1\n       if (sieve_table(i) .eq. 0) then\n          do j = i*i, n, i\n             sieve_table(j) = i\n          end do\n       end if\n    end do\n  end subroutine sieve\n\n  subroutine check_sieve(n)\n    integer, intent(in) :: n\n    if (.not. (allocated(sieve_table) .and. ((1 .le. n) .and. (n .le. size(sieve_table))))) stop 'Call sieve first'\n  end subroutine check_sieve\n\n  logical function isPrime(p)\n    integer, intent(in) :: p\n    call check_sieve(p)\n    isPrime = PrimeQ(p)\n  end function isPrime\n\n  logical function isComposite(p)\n    integer, intent(in) :: p\n    isComposite = .not. isPrime(p)\n  end function isComposite\n\n  logical function PrimeQ(p)\n    integer, intent(in) :: p\n    PrimeQ = sieve_table(p) .eq. 0\n  end function PrimeQ\n\n  subroutine prime_factors(p, rv, n)\n    integer, intent(in) :: p \n    integer, dimension(:), intent(out) :: rv \n    integer, intent(out) :: n \n    integer :: i, m\n    call check_sieve(p)\n    m = p\n    i = 1\n    if (p .ne. 1) then\n       do while ((.not. PrimeQ(m)) .and. (i .lt. size(rv)))\n          rv(i) = sieve_table(m)\n          m = m/rv(i)\n          i = i+1\n       end do\n    end if\n    if (i .le. size(rv)) rv(i) = m\n    n = i\n  end subroutine prime_factors\n\nend module prime_mod\n\nprogram count_in_factors\n  use prime_mod\n  integer :: i, n\n  integer, dimension(8) :: factors\n  call sieve(40)                \n  do i=1,40\n     factors = 0\n     call prime_factors(i, factors, n)\n     write(6,*)'assert',i,'= */',factors(:n)\n  end do\n  call sieve(0)                 \nend program count_in_factors\n", "target": "from functools import lru_cache\n\nprimes = [2, 3, 5, 7, 11, 13, 17]    \n\n@lru_cache(maxsize=2000)\ndef pfactor(n):\n    if n == 1:\n        return [1]\n    n2 = n // 2 + 1\n    for p in primes:\n        if p <= n2:\n            d, m = divmod(n, p)\n            if m == 0:\n                if d > 1:\n                    return [p] + pfactor(d)\n                else:\n                    return [p]\n        else:\n            if n > primes[-1]:\n                primes.append(n)\n            return [n]\n        \nif __name__ == '__main__':\n    mx = 5000\n    for n in range(1, mx + 1):\n        factors = pfactor(n)\n        if n <= 10 or n >= mx - 20:\n            print( '%4i %5s %s' % (n,\n                                   '' if factors != [n] or n == 1 else 'prime',\n                                   'x'.join(str(i) for i in factors)) )\n        if n == 11:\n            print('...')\n            \n    print('\\nNumber of primes gathered up to', n, 'is', len(primes))\n    print(pfactor.cache_info())\n"}
{"id": 22859, "name": "Queue_Definition", "source": "Translate Fortran to C#: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "public class FIFO<T>\n{\n  class Node\n  {\n    public T Item { get; set; }\n    public Node Next { get; set; }\n  }\n  Node first = null;\n  Node last = null;\n  public void push(T item)\n  {\n    if (empty())\n    {\n      \n      first = new Node() { Item = item, Next = null };\n      last = first;\n    }\n    else\n    {\n      last.Next = new Node() { Item = item, Next = null };\n      last = last.Next;\n    }\n  }\n  public T pop()\n  {\n    if (first == null)\n      throw new System.Exception(\"No elements\"); \n    if (last == first)\n      last = null;\n    T temp = first.Item;\n    first = first.Next;\n    return temp;\n  }\n  public bool empty()\n  {\n    return first == null;\n  }\n}\n"}
{"id": 22862, "name": "Queue_Definition", "source": "Translate Fortran to Java: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "public class Queue<E>{\n    Node<E> head = null, tail = null;\n\n    static class Node<E>{\n        E value;\n        Node<E> next;\n\n        Node(E value, Node<E> next){\n            this.value= value;\n            this.next= next;\n        }\n\n    }\n\n    public Queue(){\n    }\n\n    public void enqueue(E value){ \n        Node<E> newNode= new Node<E>(value, null);\n        if(empty()){\n            head= newNode;\n        }else{\n            tail.next = newNode;\n        }\n        tail= newNode;\n    }\n\n    public E dequeue() throws java.util.NoSuchElementException{\n        if(empty()){\n            throw new java.util.NoSuchElementException(\"No more elements.\");\n        }\n        E retVal= head.value;\n        head= head.next;\n        return retVal;\n    } \n\n    public boolean empty(){\n        return head == null;\n    }\n}\n"}
{"id": 22863, "name": "Queue_Definition", "source": "Translate Fortran to Python: module FIFO\n  use fifo_nodes\n\n\n\n\n\n\n\n\n\n\n  type fifo_head\n     type(fifo_node), pointer :: head, tail\n  end type fifo_head\n\ncontains\n\n  subroutine new_fifo(h)\n    type(fifo_head), intent(out) :: h\n    nullify(h%head)\n    nullify(h%tail)\n  end subroutine new_fifo\n\n  subroutine fifo_enqueue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(inout), target :: n\n\n    if ( associated(h%tail) ) then\n       h%tail%next => n\n       h%tail => n\n    else\n       h%tail => n\n       h%head => n\n    end if\n\n    nullify(n%next)\n  end subroutine fifo_enqueue\n\n  subroutine fifo_dequeue(h, n)\n    type(fifo_head), intent(inout) :: h\n    type(fifo_node), intent(out), target :: n\n\n    if ( associated(h%head) ) then\n       n = h%head\n       if ( associated(n%next) ) then\n          h%head => n%next\n       else\n          nullify(h%head)\n          nullify(h%tail)\n       end if\n       n%valid = .true.\n    else\n       n%valid = .false.\n    end if\n    nullify(n%next)\n  end subroutine fifo_dequeue\n\n  function fifo_isempty(h) result(r)\n    logical :: r\n    type(fifo_head), intent(in) :: h\n    if ( associated(h%head) ) then\n       r = .false.\n    else\n       r = .true.\n    end if\n  end function fifo_isempty\n\nend module FIFO\n", "target": "   class FIFO(object):\n       def __init__(self, *args):\n           self.contents = list(args)\n       def __call__(self):\n           return self.pop()\n       def __len__(self):\n           return len(self.contents)\n       def pop(self):\n           return self.contents.pop(0)\n       def push(self, item):\n           self.contents.append(item)\n       def extend(self,*itemlist):\n           self.contents += itemlist\n       def empty(self):\n           return bool(self.contents)\n       def __iter__(self):\n           return self\n       def next(self):\n           if self.empty():\n               raise StopIteration\n           return self.pop()\n\nif __name__ == \"__main__\":\n    \n    f = FIFO()\n    f.push(3)\n    f.push(2)\n    f.push(1)\n    while not f.empty():\n        print f.pop(),\n    \n    \n    f = FIFO(3,2,1)\n    while not f.empty():\n        print f(),\n    \n    \n    \n    f = FIFO(3,2,1)\n    while f:\n        print f(),\n    \n    f = FIFO(3,2,1)\n    for i in f:\n        print i,\n"}
{"id": 23163, "name": "Remove lines from a file", "source": "Translate Fortran to C#:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23164, "name": "Remove lines from a file", "source": "Translate Fortran to C#:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\n\npublic class Rosetta\n{\n    public static void Main() => RemoveLines(\"foobar.txt\", start: 1, count: 2);\n\n    static void RemoveLines(string filename, int start, int count = 1) =>\n        File.WriteAllLines(filename, File.ReadAllLines(filename)\n            .Where((line, index) => index < start - 1 || index >= start + count - 1));\n}\n"}
{"id": 23170, "name": "Remove lines from a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class RemoveLines\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString filename=\"foobar.txt\";\n\t\t\n\t\tint startline=1;\n\t\t\n\t\tint numlines=2;\n\t\t\n\t\tRemoveLines now=new RemoveLines();\n\t\tnow.delete(filename,startline,numlines);\n\t}\n\tvoid delete(String filename, int startline, int numlines)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\t\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\t\n\t\t\t\n\t\t\tint linenumber=1;\n\t\t\tString line;\n\t\t\t\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(linenumber<startline||linenumber>=startline+numlines)\n\t\t\t\t\tsb.append(line+\"\\n\");\n\t\t\t\tlinenumber++;\n\t\t\t}\n\t\t\tif(startline+numlines>linenumber)\n\t\t\t\tSystem.out.println(\"End of file reached.\");\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(filename));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 23171, "name": "Remove lines from a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class RemoveLines\n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString filename=\"foobar.txt\";\n\t\t\n\t\tint startline=1;\n\t\t\n\t\tint numlines=2;\n\t\t\n\t\tRemoveLines now=new RemoveLines();\n\t\tnow.delete(filename,startline,numlines);\n\t}\n\tvoid delete(String filename, int startline, int numlines)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\t\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\t\n\t\t\t\n\t\t\tint linenumber=1;\n\t\t\tString line;\n\t\t\t\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(linenumber<startline||linenumber>=startline+numlines)\n\t\t\t\t\tsb.append(line+\"\\n\");\n\t\t\t\tlinenumber++;\n\t\t\t}\n\t\t\tif(startline+numlines>linenumber)\n\t\t\t\tSystem.out.println(\"End of file reached.\");\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(filename));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 23172, "name": "Remove lines from a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23173, "name": "Remove lines from a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,IST,N)\n       CHARACTER*(*) FNAME\t\n       INTEGER IST\t\t\n       INTEGER N\t\t\n       INTEGER ENUFF,L\t\t\n       PARAMETER (ENUFF = 66666)\n       CHARACTER*(ENUFF) ALINE\t\n       INTEGER NREC\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (IST.LE.0)    CALL CROAK(\"First record must be positive\n        IF (N.LE.0)      CALL CROAK(\"Remove count must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\")\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"FORMATTED\")\t\n        NREC = 0\t\t\nCopy the desired records to a temporary file.\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11   FORMAT (Q,A)\t\t\n        IF (L.GT.ENUFF) CALL CROAK(\"Ow\n        NREC = NREC + 1\t\t\n        IF (NREC.LT.IST .OR. NREC.GE.IST + N) WRITE (T,12) ALINE(1:L)\t\n   12   FORMAT (A)\t\t\n        GO TO 10\t\t\nConvert from input to output...\n   20   IF (NREC.LT.IST + N) CALL CROAK(\"Insufficient records\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n   21   READ (T,11,END = 30) L,ALINE(1:L)\t\n        WRITE (F,12) ALINE(1:L)\t\t\t\n        GO TO 21\t\t\nCompleted.\n   30   CLOSE(T)\t\t\n        CLOSE(F)\t\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",1,2)\n      END\n", "target": "\n\nimport fileinput, sys\n\nfname, start, count = sys.argv[1:4]\nstart, count = int(start), int(count)\n\nfor line in fileinput.input(fname, inplace=1, backup='.orig'):\n    if start <= fileinput.lineno() < start + count:\n        pass\n    else:\n        print line.rstrip(\"\\n\")\nfileinput.close()\n"}
{"id": 23508, "name": "String case", "source": "Translate Fortran to C#:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "using System;\n\nnamespace StringCase\n{\n  class Program\n  {\n    public static void Main()\n    {\n      String input = scope .(\"alphaBETA\");\n      input.ToUpper();\n      Console.WriteLine(input);\n      input.ToLower();\n      Console.WriteLine(input);\n    }\n  }\n}\n"}
{"id": 23511, "name": "String case", "source": "Translate Fortran to Java:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "String str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); \n"}
{"id": 23512, "name": "String case", "source": "Translate Fortran to Python:  program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n", "target": "s = \"alphaBETA\"\nprint s.upper() \nprint s.lower() \n\nprint s.swapcase() \n\nprint \"fOo bAR\".capitalize() \nprint \"fOo bAR\".title() \n\nimport string\nprint string.capwords(\"fOo bAR\") \n"}
{"id": 23730, "name": "Cramer's rule", "source": "Translate Fortran to C#:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class CramersRule\n{\n    public static void Main() {\n        var equations = new [] {\n            new [] { 2, -1,  5,  1,  -3 },\n            new [] { 3,  2,  2, -6, -32 },\n            new [] { 1,  3,  3, -1, -47 },\n            new [] { 5, -2, -3,  3,  49 }\n        };\n        var solution = SolveCramer(equations);\n        Console.WriteLine(solution.DelimitWith(\", \"));\n    }\n\n    public static int[] SolveCramer(int[][] equations) {\n        int size = equations.Length;\n        if (equations.Any(eq => eq.Length != size + 1)) throw new ArgumentException($\"Each equation must have {size+1} terms.\");\n        int[,] matrix = new int[size, size];\n        int[] column = new int[size];\n        for (int r = 0; r < size; r++) {\n            column[r] = equations[r][size];\n            for (int c = 0; c < size; c++) {\n                matrix[r, c] = equations[r][c];\n            }\n        }\n        return Solve(new SubMatrix(matrix, column));\n    }\n\n    private static int[] Solve(SubMatrix matrix) {\n        int det = matrix.Det();\n        if (det == 0) throw new ArgumentException(\"The determinant is zero.\");\n\n        int[] answer = new int[matrix.Size];\n        for (int i = 0; i < matrix.Size; i++) {\n            matrix.ColumnIndex = i;\n            answer[i] = matrix.Det() / det;\n        }\n        return answer;\n    }\n\n    \n    static string DelimitWith<T>(this IEnumerable<T> source, string separator = \" \") =>\n        string.Join(separator ?? \" \", source ?? Empty<T>());\n\n    private class SubMatrix\n    {\n        private int[,] source;\n        private SubMatrix prev;\n        private int[] replaceColumn;\n\n        public SubMatrix(int[,] source, int[] replaceColumn) {\n            this.source = source;\n            this.replaceColumn = replaceColumn;\n            this.prev = null;\n            this.ColumnIndex = -1;\n            Size = replaceColumn.Length;\n        }\n\n        private SubMatrix(SubMatrix prev, int deletedColumnIndex = -1) {\n            this.source = null;\n            this.prev = prev;\n            this.ColumnIndex = deletedColumnIndex;\n            Size = prev.Size - 1;\n        }\n\n        public int ColumnIndex { get; set; }\n        public int Size { get; }\n\n        public int this[int row, int column] {\n            get {\n                if (source != null) return column == ColumnIndex ? replaceColumn[row] : source[row, column];\n                return prev[row + 1, column < ColumnIndex ? column : column + 1];\n            }\n        }\n\n        public int Det() {\n            if (Size == 1) return this[0, 0];\n            if (Size == 2) return this[0, 0] * this[1, 1] - this[0, 1] * this[1, 0];\n            SubMatrix m = new SubMatrix(this);\n            int det = 0;\n            int sign = 1;\n            for (int c = 0; c < Size; c++) {\n                m.ColumnIndex = c;\n                int d = m.Det();\n                det += this[0, c] * d * sign;\n                sign = -sign;\n            }\n            return det;\n        }\n\n        public void Print() {\n            for (int r = 0; r < Size; r++) {\n                Console.WriteLine(Range(0, Size).Select(c => this[r, c]).DelimitWith(\", \"));\n            }\n            Console.WriteLine();\n        }\n    }\n\n}\n"}
{"id": 23733, "name": "Cramer's rule", "source": "Translate Fortran to Java:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class CramersRule {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(2d, -1d, 5d, 1d), \n                                Arrays.asList(3d, 2d, 2d, -6d), \n                                Arrays.asList(1d, 3d, 3d, -1d),\n                                Arrays.asList(5d, -2d, -3d, 3d));\n        List<Double> b = Arrays.asList(-3d, -32d, -47d, 49d);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 23734, "name": "Cramer's rule", "source": "Translate Fortran to Python:       DATA A/2, -1,  5,  1\n     1       3,  2,  2, -6\n     2       1,  3,  3, -1\n     3       5, -2, -3,  3/\n", "target": "def det(m,n):\n if n==1: return m[0][0]\n z=0\n for r in range(n):\n  k=m[:]\n  del k[r]\n  z+=m[r][0]*(-1)**r*det([p[1:]for p in k],n-1)\n return z\nw=len(t)\nd=det(h,w)\nif d==0:r=[]\nelse:r=[det([r[0:i]+[s]+r[i+1:]for r,s in zip(h,t)],w)/d for i in range(w)]\nprint(r)\n"}
{"id": 23894, "name": "Euler's identity", "source": "Translate Fortran to C#: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 23895, "name": "Euler's identity", "source": "Translate Fortran to C#: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "using System;\nusing System.Numerics;\n\npublic class Program\n{\n    static void Main() {\n        Complex e = Math.E;\n        Complex i = Complex.ImaginaryOne;\n        Complex \u03c0 = Math.PI;\n        Console.WriteLine(Complex.Pow(e, i * \u03c0) + 1);\n    }\n}\n"}
{"id": 23900, "name": "Euler's identity", "source": "Translate Fortran to Java: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "public class EulerIdentity {\n\n    public static void main(String[] args) {\n        System.out.println(\"e ^ (i*Pi) + 1 = \" + (new Complex(0, Math.PI).exp()).add(new Complex(1, 0)));\n    }\n\n    public static class Complex {\n\n        private double x, y;\n        \n        public Complex(double re, double im) {\n            x = re;\n            y = im;\n        }\n        \n        public Complex exp() {\n            double exp = Math.exp(x);\n            return new Complex(exp * Math.cos(y), exp * Math.sin(y));\n        }\n        \n        public Complex add(Complex a) {\n            return new Complex(x + a.x, y + a.y);\n        }\n        \n        @Override\n        public String toString() {\n            return x + \" + \" + y + \"i\";\n        }\n    }\n}\n"}
{"id": 23901, "name": "Euler's identity", "source": "Translate Fortran to Java: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": "public class EulerIdentity {\n\n    public static void main(String[] args) {\n        System.out.println(\"e ^ (i*Pi) + 1 = \" + (new Complex(0, Math.PI).exp()).add(new Complex(1, 0)));\n    }\n\n    public static class Complex {\n\n        private double x, y;\n        \n        public Complex(double re, double im) {\n            x = re;\n            y = im;\n        }\n        \n        public Complex exp() {\n            double exp = Math.exp(x);\n            return new Complex(exp * Math.cos(y), exp * Math.sin(y));\n        }\n        \n        public Complex add(Complex a) {\n            return new Complex(x + a.x, y + a.y);\n        }\n        \n        @Override\n        public String toString() {\n            return x + \" + \" + y + \"i\";\n        }\n    }\n}\n"}
{"id": 23902, "name": "Euler's identity", "source": "Translate Fortran to Python: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 23903, "name": "Euler's identity", "source": "Translate Fortran to Python: program euler\n    use iso_fortran_env, only: output_unit, REAL64\n    implicit none\n\n    integer, parameter              :: d=REAL64\n    real(kind=d), parameter         :: e=exp(1._d), pi=4._d*atan(1._d)\n    complex(kind=d), parameter      :: i=(0._d,1._d)\n\n    write(output_unit,*) e**(pi*i) + 1\nend program euler\n", "target": ">>> import math\n>>> math.e ** (math.pi * 1j) + 1\n1.2246467991473532e-16j\n"}
{"id": 24249, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to C#:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24250, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to C#:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "namespace RosettaCode.ArithmeticGeometricMean\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Globalization;\n\n    internal static class Program\n    {\n        private static double ArithmeticGeometricMean(double number,\n                                                      double otherNumber,\n                                                      IEqualityComparer<double>\n                                                          comparer)\n        {\n            return comparer.Equals(number, otherNumber)\n                       ? number\n                       : ArithmeticGeometricMean(\n                           ArithmeticMean(number, otherNumber),\n                           GeometricMean(number, otherNumber), comparer);\n        }\n\n        private static double ArithmeticMean(double number, double otherNumber)\n        {\n            return 0.5 * (number + otherNumber);\n        }\n\n        private static double GeometricMean(double number, double otherNumber)\n        {\n            return Math.Sqrt(number * otherNumber);\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                ArithmeticGeometricMean(1, 0.5 * Math.Sqrt(2),\n                                        new RelativeDifferenceComparer(1e-5)).\n                    ToString(CultureInfo.InvariantCulture));\n        }\n\n        private class RelativeDifferenceComparer : IEqualityComparer<double>\n        {\n            private readonly double _maximumRelativeDifference;\n\n            internal RelativeDifferenceComparer(double maximumRelativeDifference)\n            {\n                _maximumRelativeDifference = maximumRelativeDifference;\n            }\n\n            public bool Equals(double number, double otherNumber)\n            {\n                return RelativeDifference(number, otherNumber) <=\n                       _maximumRelativeDifference;\n            }\n\n            public int GetHashCode(double number)\n            {\n                return number.GetHashCode();\n            }\n\n            private static double RelativeDifference(double number,\n                                                     double otherNumber)\n            {\n                return AbsoluteDifference(number, otherNumber) /\n                       Norm(number, otherNumber);\n            }\n\n            private static double AbsoluteDifference(double number,\n                                                     double otherNumber)\n            {\n                return Math.Abs(number - otherNumber);\n            }\n\n            private static double Norm(double number, double otherNumber)\n            {\n                return 0.5 * (Math.Abs(number) + Math.Abs(otherNumber));\n            }\n        }\n    }\n}\n"}
{"id": 24255, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Java:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24256, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Java:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "\npublic class ArithmeticGeometricMean {\n\n    public static double agm(double a, double g) {\n        double a1 = a;\n        double g1 = g;\n        while (Math.abs(a1 - g1) >= 1.0e-14) {\n            double arith = (a1 + g1) / 2.0;\n            double geom = Math.sqrt(a1 * g1);\n            a1 = arith;\n            g1 = geom;\n        }\n        return a1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(agm(1.0, 1.0 / Math.sqrt(2.0)));\n    }\n}\n"}
{"id": 24257, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Python:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 24258, "name": "Arithmetic-geometric mean", "source": "Translate Fortran to Python:       function agm(a,b)\n      implicit none\n      double precision agm,a,b,eps,c\n      parameter(eps=1.0d-15)\n   10 c=0.5d0*(a+b)\n      b=sqrt(a*b)\n      a=c\n      if(a-b.gt.eps*a) go to 10\n      agm=0.5d0*(a+b)\n      end\n      program test\n      implicit none\n      double precision agm\n      print*,agm(1.0d0,1.0d0/sqrt(2.0d0))\n      end\n", "target": "from math import sqrt\n\ndef agm(a0, g0, tolerance=1e-10):\n    \n    an, gn = (a0 + g0) / 2.0, sqrt(a0 * g0)\n    while abs(an - gn) > tolerance:\n        an, gn = (an + gn) / 2.0, sqrt(an * gn)\n    return an\n\nprint agm(1, 1 / sqrt(2))\n"}
{"id": 25511, "name": "Day of the week", "source": "Translate Fortran to C#: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n"}
{"id": 25514, "name": "Day of the week", "source": "Translate Fortran to Java: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "import java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tfor(int i = 2008;i<=2121;i++){\n\t\t\tCalendar cal = new GregorianCalendar(i, Calendar.DECEMBER,\n\t\t\t\t\t25);\n\t\t\tif(cal.get(Calendar.DAY_OF_WEEK)==Calendar.SUNDAY){\n\t\t\t\tSystem.out.println(cal.getTime());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 25515, "name": "Day of the week", "source": "Translate Fortran to Python: PROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n", "target": "from calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n"}
{"id": 26231, "name": "Short-circuit evaluation", "source": "Translate Fortran to C#: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": "using System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 26234, "name": "Short-circuit evaluation", "source": "Translate Fortran to Java: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": "module test\n    {\n    @Inject Console console;\n\n    static Boolean show(String name, Boolean value)\n        {\n        console.print($\"{name}()={value}\");\n        return value;\n        }\n\n    void run()\n        {\n        val a = show(\"a\", _);\n        val b = show(\"b\", _);\n\n        for (Boolean v1 : False..True)\n            {\n            for (Boolean v2 : False..True)\n                {\n                console.print($\"a({v1}) && b({v2}) == {a(v1) && b(v2)}\");\n                console.print();\n                console.print($\"a({v1}) || b({v2}) == {a(v1) || b(v2)}\");\n                console.print();\n                }\n            }\n        }\n    }\n"}
{"id": 26235, "name": "Short-circuit evaluation", "source": "Translate Fortran to Python: program Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      \n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      \n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n", "target": ">>> def a(answer):\n\tprint(\"  \n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  \n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \nCalculating: y = a(i) or  b(j)\n  \n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n\nCalculating: x = a(i) and b(j)\n  \n  \nCalculating: y = a(i) or  b(j)\n  \n"}
{"id": 26548, "name": "ISBN13 check digit", "source": "Translate Fortran to C#: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26549, "name": "ISBN13 check digit", "source": "Translate Fortran to C#: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(CheckISBN13(\"978-1734314502\"));\n        Console.WriteLine(CheckISBN13(\"978-1734314509\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399081\"));\n        Console.WriteLine(CheckISBN13(\"978-1788399083\"));\n\n        static bool CheckISBN13(string code) {\n            code = code.Replace(\"-\", \"\").Replace(\" \", \"\");\n            if (code.Length != 13) return false;\n            int sum = 0;\n            foreach (var (index, digit) in code.Select((digit, index) => (index, digit))) {\n                if (char.IsDigit(digit)) sum += (digit - '0') * (index % 2 == 0 ? 1 : 3);\n                else return false;\n            }\n            return sum % 10 == 0;\n        }\n    }\n}\n"}
{"id": 26554, "name": "ISBN13 check digit", "source": "Translate Fortran to Java: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26555, "name": "ISBN13 check digit", "source": "Translate Fortran to Java: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "public static void main(){\n        System.out.println(isISBN13(\"978-1734314502\"));\n        System.out.println(isISBN13(\"978-1734314509\"));\n        System.out.println(isISBN13(\"978-1788399081\"));\n        System.out.println(isISBN13(\"978-1788399083\"));\n    }\npublic static boolean isISBN13(String in){\n        int pre = Integer.parseInt(in.substring(0,3));\n        if (pre!=978)return false;\n        String postStr = in.substring(4);\n        if (postStr.length()!=10)return false;\n        int post = Integer.parseInt(postStr);\n        int sum = 38;\n        for(int x = 0; x<10;x+=2)\n        sum += (postStr.charAt(x)-48)*3 + ((postStr.charAt(x+1)-48));\n        if(sum%10==0) return true;\n        return false;\n    }\n"}
{"id": 26556, "name": "ISBN13 check digit", "source": "Translate Fortran to Python: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 26557, "name": "ISBN13 check digit", "source": "Translate Fortran to Python: program isbn13\n    implicit none\n\n    character(len=14), dimension(4), parameter  :: isbns=[\"978-1734314502\", \"978-1734314509\", \"978-1788399081\", \"978-1788399083\"]\n    integer                                     :: i\n\n    do i = 1, ubound(isbns, 1)\n        if (check_isbn13(isbns(i))) then\n            print*, isbns(i), \"\u00a0: \", \"good\"\n        else\n            print*, isbns(i), \"\u00a0: \", \"bad\"\n        end if\n    end do\ncontains\n    pure function check_isbn13(isbn)\n        character(len=*), intent(in)    :: isbn\n        logical                         :: check_isbn13\n        integer                         :: summ, counter, i, digit\n\n        check_isbn13 = .false.\n        counter = 0\n        summ = 0\n\n        do i = 1, len(isbn)\n            if (isbn(i:i) == ' ' .or. isbn(i:i) == '-') cycle\n            counter = counter + 1\n            read(isbn(i:i), '(I1)') digit\n            if (modulo(counter, 2) == 0) then\n                summ = summ + 3*digit\n            else\n                summ = summ + digit\n            end if\n        end do\n        if (counter == 13 .and. modulo(summ, 10) == 0) check_isbn13 = .true.\n    end function check_isbn13\nend program isbn13\n", "target": "def is_isbn13(n):\n    n = n.replace('-','').replace(' ', '')\n    if len(n) != 13:\n        return False\n    product = (sum(int(ch) for ch in n[::2]) \n               + sum(int(ch) * 3 for ch in n[1::2]))\n    return product % 10 == 0\n\nif __name__ == '__main__':\n    tests = .strip().split()\n    for t in tests:\n        print(f\"ISBN13 {t} validates {is_isbn13(t)}\")\n"}
{"id": 27166, "name": "Look-and-say sequence", "source": "Translate Fortran to C#: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "using System;\nusing System.Text;\nusing System.Linq;\n\nclass Program\n{\n    static string lookandsay(string number)\n    {\n        StringBuilder result = new StringBuilder();\n\n        char repeat = number[0];\n        number = number.Substring(1, number.Length-1)+\" \";\n        int times = 1;\n      \n        foreach (char actual in number)\n        {\n            if (actual != repeat)\n            {\n                result.Append(Convert.ToString(times)+repeat);\n                times = 1;\n                repeat = actual;\n            }\n            else\n            {\n                times += 1;\n            }\n        }\n        return result.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        string num = \"1\"; \n\n        foreach (int i in Enumerable.Range(1, 10)) {\n             Console.WriteLine(num);\n             num = lookandsay(num);             \n        }\n    }\n}\n"}
{"id": 27169, "name": "Look-and-say sequence", "source": "Translate Fortran to Java: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "public static String lookandsay(String number){\n\tStringBuilder result= new StringBuilder();\n\n\tchar repeat= number.charAt(0);\n\tnumber= number.substring(1) + \" \";\n\tint times= 1;\n\n\tfor(char actual: number.toCharArray()){\n\t\tif(actual != repeat){\n\t\t\tresult.append(times + \"\" + repeat);\n\t\t\ttimes= 1;\n\t\t\trepeat= actual;\n\t\t}else{\n\t\t\ttimes+= 1;\n\t\t}\n\t}\n\treturn result.toString();\n}\n"}
{"id": 27170, "name": "Look-and-say sequence", "source": "Translate Fortran to Python: module LookAndSay\n  implicit none\n\ncontains\n\n  subroutine look_and_say(in, out)\n    character(len=*), intent(in) :: in\n    character(len=*), intent(out) :: out\n\n    integer :: i, c\n    character(len=1) :: x\n    character(len=2) :: d\n\n    out = \"\"\n    c = 1\n    x = in(1:1)\n    do i = 2, len(trim(in))\n       if ( x == in(i:i) ) then\n          c = c + 1\n       else\n          write(d, \"(I2)\") c\n          out = trim(out) // trim(adjustl(d)) // trim(x)\n          c = 1\n          x = in(i:i)\n       end if\n    end do\n    write(d, \"(I2)\") c\n    out = trim(out) // trim(adjustl(d)) // trim(x)\n  end subroutine look_and_say\n\nend module LookAndSay\n", "target": "def lookandsay(number):\n    result = \"\"\n\n    repeat = number[0]\n    number = number[1:]+\" \"\n    times = 1\n\n    for actual in number:\n        if actual != repeat:\n            result += str(times)+repeat\n            times = 1\n            repeat = actual\n        else:\n            times += 1\n\n    return result\n\nnum = \"1\"\n\nfor i in range(10):\n    print num\n    num = lookandsay(num)\n"}
{"id": 27805, "name": "Send email", "source": "Translate Fortran to C#: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "static void Main(string[] args)\n{\n    \n\n    SmtpClient SMTP = new SmtpClient(\"smtp.gmail.com\", 587); \n    SMTP.EnableSsl = true; \n    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;\n    SMTP.Credentials = new NetworkCredential(\"YourUserName\", \"YourPassword\");\n    MailMessage Mail = new MailMessage(\"yourEmail@address.com\", \"theirEmail@address.com\");\n\n\n    \n\n    Mail.Subject = \"Important Message\";\n    Mail.Body = \"Hello over there\"; \n    \n\n    \n\n    SMTP.Send(Mail);\n\n    Console.WriteLine(\"Message Sent\");\n}\n"}
{"id": 27808, "name": "Send email", "source": "Translate Fortran to Java: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "import java.util.Properties;\n\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\n\npublic class Mail\n{\n \n protected Session session;\n\n \n public Mail(String host)\n {\n  Properties properties = new Properties();\n  properties.put(\"mail.smtp.host\", host);\n  session = Session.getDefaultInstance(properties);\n }\n\n \n public void send(String from, String tos[], String ccs[], String subject,\n        String text)\n        throws MessagingException\n {\n  MimeMessage message = new MimeMessage(session);\n  message.setFrom(new InternetAddress(from));\n  for (String to : tos)\n   message.addRecipient(RecipientType.TO, new InternetAddress(to));\n  for (String cc : ccs)\n   message.addRecipient(RecipientType.TO, new InternetAddress(cc));\n  message.setSubject(subject);\n  message.setText(text);\n  Transport.send(message);\n }\n}\n"}
{"id": 27809, "name": "Send email", "source": "Translate Fortran to Python: program sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n", "target": "import smtplib\n\ndef sendemail(from_addr, to_addr_list, cc_addr_list,\n              subject, message,\n              login, password,\n              smtpserver='smtp.gmail.com:587'):\n    header  = 'From: %s\\n' % from_addr\n    header += 'To: %s\\n' % ','.join(to_addr_list)\n    header += 'Cc: %s\\n' % ','.join(cc_addr_list)\n    header += 'Subject: %s\\n\\n' % subject\n    message = header + message\n    \n    server = smtplib.SMTP(smtpserver)\n    server.starttls()\n    server.login(login,password)\n    problems = server.sendmail(from_addr, to_addr_list, message)\n    server.quit()\n    return problems\n"}
{"id": 28254, "name": "Caesar cipher", "source": "Translate Fortran to C#: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "using System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 28258, "name": "Caesar cipher", "source": "Translate Fortran to Java: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "public class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n"}
{"id": 28259, "name": "Caesar cipher", "source": "Translate Fortran to Python: program Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n", "target": "fun caesar(s, k, decode: false):\n    if decode:\n        k = 26 - k\n    result = ''\n    for i in s.uppercase() where 65 <= ord(i) <= 90:\n        result.push! char(ord(i) - 65 + k) mod 26 + 65\n    return result\n\nlet message = \"The quick brown fox jumped over the lazy dogs\"\nlet encrypted = caesar(msg, 11)\nlet decrypted = caesar(enc, 11, decode: true)\n\nprint(message, encrypted, decrypted, sep: '\\n')\n"}
{"id": 28627, "name": "Lucas-Lehmer test", "source": "Translate Fortran to C#: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Threading.Tasks;\n\nnamespace LucasLehmerTestForRosettaCode\n{\n    public class LucasLehmerTest\n    {\n        static BigInteger ZERO = new BigInteger(0);\n        static BigInteger ONE = new BigInteger(1);\n        static BigInteger TWO = new BigInteger(2);\n        static BigInteger FOUR = new BigInteger(4);\n\n        private static bool isMersennePrime(int p) \n        {\n            if (p % 2 == 0) return (p == 2);\n            else {\n                for (int i = 3; i <= (int)Math.Sqrt(p); i += 2)\n                    if (p % i == 0) return false; \n                BigInteger m_p = BigInteger.Pow(TWO, p) - ONE;\n                BigInteger s = FOUR;\n                for (int i = 3; i <= p; i++)\n                    s = (s * s - TWO) % m_p;\n                return s == ZERO;\n            } \n        }\n\n        public static int[] GetMersennePrimeNumbers(int upTo)\n        {\n            List<int> response = new List<int>();\n            Parallel.For(2, upTo + 1, i => {\n                if (isMersennePrime(i)) response.Add(i);\n            });\n            response.Sort();\n            return response.ToArray();\n        }\n\n        static void Main(string[] args)\n        {\n            int[] mersennePrimes = LucasLehmerTest.GetMersennePrimeNumbers(11213);\n            foreach (int mp in mersennePrimes)\n                Console.Write(\"M\" + mp+\" \");\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 28630, "name": "Lucas-Lehmer test", "source": "Translate Fortran to Java: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "import java.math.BigInteger;\npublic class Mersenne\n{\n\n    public static boolean isPrime(int p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            int to = (int)Math.sqrt(p);\n            for (int i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    public static boolean isMersennePrime(int p) {\n        if (p == 2)\n            return true;\n        else {\n            BigInteger m_p = BigInteger.ONE.shiftLeft(p).subtract(BigInteger.ONE);\n            BigInteger s = BigInteger.valueOf(4);\n            for (int i = 3; i <= p; i++)\n                s = s.multiply(s).subtract(BigInteger.valueOf(2)).mod(m_p);\n            return s.equals(BigInteger.ZERO);\n        }\n    }\n\n    \n    public static void main(String[] args) {\n        int upb;\n        if (args.length == 0)\n            upb = 500;\n        else\n            upb = Integer.parseInt(args[0]);\n\n        System.out.print(\" Finding Mersenne primes in M[2..\" + upb + \"]:\\nM2 \");\n        for (int p = 3; p <= upb; p += 2)\n            if (isPrime(p) && isMersennePrime(p))\n                System.out.print(\" M\" + p);\n        System.out.println();\n    }\n}\n"}
{"id": 28631, "name": "Lucas-Lehmer test", "source": "Translate Fortran to Python: PROGRAM LUCAS_LEHMER\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: i64 = SELECTED_INT_KIND(18)\n  INTEGER(i64) :: s, n\n  INTEGER :: i, exponent\n  \n  DO exponent = 2, 31\n     IF (exponent == 2) THEN\n        s = 0\n     ELSE\n        s = 4\n     END IF\n     n = 2_i64**exponent - 1\n     DO i = 1, exponent-2\n        s = MOD(s*s - 2, n)\n     END DO\n     IF (s==0) WRITE(*,\"(A,I0,A)\") \"M\", exponent, \" is PRIME\"\n  END DO\n \nEND PROGRAM LUCAS_LEHMER\n", "target": "from sys import stdout\nfrom math import sqrt, log\n\ndef is_prime ( p ):\n  if p == 2: return True \n  elif p <= 1 or p % 2 == 0: return False\n  else:\n    for i in range(3, int(sqrt(p))+1, 2 ): \n      if p % i == 0: return False\n    return True\n\ndef is_mersenne_prime ( p ):\n  if p == 2:\n    return True\n  else:\n    m_p = ( 1 << p ) - 1\n    s = 4\n    for i in range(3, p+1): \n      s = (s ** 2 - 2) % m_p\n    return s == 0\n\nprecision = 20000   \nlong_bits_width = precision * log(10, 2)\nupb_prime = int( long_bits_width - 1 ) / 2    \nupb_count = 45      \n\nprint (\" Finding Mersenne primes in M[2..%d]:\"%upb_prime)\n\ncount=0\nfor p in range(2, int(upb_prime+1)): \n  if is_prime(p) and is_mersenne_prime(p):\n    print(\"M%d\"%p),\n    stdout.flush()\n    count += 1\n  if count >= upb_count: break\nprint\n"}
{"id": 28829, "name": "FizzBuzz", "source": "Translate Fortran to C#: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "class Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n"}
{"id": 28833, "name": "FizzBuzz", "source": "Translate Fortran to Java: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "module FizzBuzz\n    {\n    void run()\n        {\n        @Inject Console console;\n        for (Int x : 1..100)\n            {\n            console.print(switch (x % 3, x % 5)\n                {\n                case (0, 0): \"FizzBuzz\";\n                case (0, _): \"Fizz\";\n                case (_, 0): \"Buzz\";\n                case (_, _): x.toString();\n                });\n            }\n        }\n    }\n"}
{"id": 28834, "name": "FizzBuzz", "source": "Translate Fortran to Python: program fizzbuzz_if\n   integer :: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n", "target": "for i in xrange(1, 101):\n    if i % 15 == 0:\n        print \"FizzBuzz\"\n    elif i % 3 == 0:\n        print \"Fizz\"\n    elif i % 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\n"}
{"id": 29088, "name": "Monty Hall problem", "source": "Translate Fortran to C#: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int switchWins = 0;\n        int stayWins = 0;\n\n        Random gen = new Random();\n\t\t    \n        for(int plays = 0; plays < 1000000; plays++ )\n        {\n            int[] doors = {0,0,0};\n\n            var winner = gen.Next(3);\n            doors[winner] = 1; \n                \n\t    int choice = gen.Next(3); \n\t    int shown; \n\t    do\n            {\n\t        shown = gen.Next(3);\n\t    }\n            while (doors[shown] == 1 || shown == choice); \n     \n\t    stayWins += doors[choice]; \n     \n            \n            switchWins += doors[3 - choice - shown];\n        }\n\n        Console.Out.WriteLine(\"Staying wins \" + stayWins + \" times.\");\n        Console.Out.WriteLine(\"Switching wins \" + switchWins + \" times.\");\n    }\n}\n"}
{"id": 29092, "name": "Monty Hall problem", "source": "Translate Fortran to Java: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "import java.util.Random;\npublic class Monty{\n\tpublic static void main(String[] args){\n\t\tint switchWins = 0;\n\t\tint stayWins = 0;\n\t\tRandom gen = new Random();\n\t\tfor(int plays = 0;plays < 32768;plays++ ){\n\t\t\tint[] doors = {0,0,0};\n\t\t\tdoors[gen.nextInt(3)] = 1;\n\t\t\tint choice = gen.nextInt(3); \n\t\t\tint shown; \n\t\t\tdo{\n\t\t\t\tshown = gen.nextInt(3);\n\t\t\t\n\t\t\t}while(doors[shown] == 1 || shown == choice);\n\t\t\t\n\t\t\tstayWins += doors[choice];\n\t\t\t\n\t\t\t\n\t\t\tswitchWins += doors[3 - choice - shown];\n\t\t}\n\t\tSystem.out.println(\"Switching wins \" + switchWins + \" times.\");\n\t\tSystem.out.println(\"Staying wins \" + stayWins + \" times.\");\n\t}\n}\n"}
{"id": 29093, "name": "Monty Hall problem", "source": "Translate Fortran to Python: PROGRAM MONTYHALL\n                            \n  IMPLICIT NONE  \n\n  INTEGER, PARAMETER :: trials = 10000\n  INTEGER :: i, choice, prize, remaining, show, staycount = 0, switchcount = 0\n  LOGICAL :: door(3)\n  REAL :: rnum\n\n  CALL RANDOM_SEED\n  DO i = 1, trials\n     door = .FALSE.\n     CALL RANDOM_NUMBER(rnum)\n     prize = INT(3*rnum) + 1\n     door(prize) = .TRUE.              \n    \n     CALL RANDOM_NUMBER(rnum)   \n     choice = INT(3*rnum) + 1          \n\n     DO\n        CALL RANDOM_NUMBER(rnum)   \n        show = INT(3*rnum) + 1 \n        IF (show /= choice .AND. show /= prize) EXIT       \n     END DO\n\n     SELECT CASE(choice+show)          \n       CASE(3)\n          remaining = 3\n       CASE(4)\n          remaining = 2\n       CASE(5)\n          remaining = 1\n     END SELECT\n\n     IF (door(choice)) THEN           \n        staycount = staycount + 1\n     ELSE IF (door(remaining)) THEN   \n        switchcount = switchcount + 1\n     END IF\n    \n  END DO\n\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by not switching is\", real(staycount)/trials*100, \"%\"\n  WRITE(*, \"(A,F6.2,A)\") \"Chance of winning by switching is\", real(switchcount)/trials*100, \"%\" \n\nEND PROGRAM MONTYHALL\n", "target": "\nfrom random import randrange\n\ndoors, iterations = 3,100000  \n\ndef monty_hall(choice, switch=False, doorCount=doors):\n  \n  door = [False]*doorCount\n  \n  door[randrange(doorCount)] = True\n\n  chosen = door[choice]\n\n  unpicked = door\n  del unpicked[choice]\n\n  \n  \n  \n  alternative = True in unpicked\n\n  if switch:\n    return alternative\n  else:\n    return chosen\n\nprint \"\\nMonty Hall problem simulation:\"\nprint doors, \"doors,\", iterations, \"iterations.\\n\"\n\nprint \"Not switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=False)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\"\nprint \"Switching allows you to win\",\nprint sum(monty_hall(randrange(3), switch=True)\n          for x in range(iterations)),\nprint \"out of\", iterations, \"times.\\n\"\n"}
{"id": 29295, "name": "Polymorphic copy", "source": "Translate Fortran to C#: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "using System;\n\nclass T\n{\n    public virtual string Name()\n    {\n        return \"T\";\n    }\n\n    public virtual T Clone()\n    {\n        return new T();\n    }\n}\n\nclass S : T\n{\n    public override string Name()\n    {\n        return \"S\";\n    }\n\n    public override T Clone()\n    {\n        return new S();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        T original = new S();\n        T clone = original.Clone();\n\n        Console.WriteLine(original.Name());\n        Console.WriteLine(clone.Name());\n    }\n}\n"}
{"id": 29299, "name": "Polymorphic copy", "source": "Translate Fortran to Java: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "class T implements Cloneable {\n    public String name() { return \"T\"; }\n    public T copy() {\n        try {\n            return (T)super.clone();\n        } catch (CloneNotSupportedException e) {\n            return null;\n        }\n    }\n}\n\nclass S extends T {\n    public String name() { return \"S\"; }\n}\n\npublic class PolymorphicCopy {\n    public static T copier(T x) { return x.copy(); }\n    public static void main(String[] args) {\n        T obj1 = new T();\n        S obj2 = new S();\n        System.out.println(copier(obj1).name()); \n        System.out.println(copier(obj2).name()); \n    }\n}\n"}
{"id": 29300, "name": "Polymorphic copy", "source": "Translate Fortran to Python: \n\n\nmodule polymorphic_copy_example_module\n   implicit none\n   private \n   public :: T,S\n\n   type, abstract :: T\n   contains\n      procedure (T_procedure1), deferred, pass :: identify\n      procedure (T_procedure2), deferred, pass :: duplicate\n   end type T\n\n\n   abstract interface\n      subroutine T_procedure1(this)\n         import  :: T\n         class(T), intent(inout) :: this\n      end subroutine T_procedure1\n      function T_procedure2(this) result(Tobj)\n         import  :: T\n         class(T), intent(inout) :: this\n         class(T), allocatable :: Tobj\n      end function T_procedure2\n   end interface\n\n   type, extends(T) :: S\n   contains\n      procedure, pass :: identify\n      procedure, pass :: duplicate\n   end type S\n\n contains\n\n   subroutine  identify(this)\n      implicit none\n      class(S), intent(inout) :: this\n      write(*,*) \"S\"\n   end subroutine identify\n\n   function duplicate(this) result(obj)\n      class(S), intent(inout) :: this\n      class(T), allocatable :: obj\n      allocate(obj, source = S())\n   end function duplicate\n\nend module polymorphic_copy_example_module\n\n\n\n\nprogram    test\n   use polymorphic_copy_example_module\n   implicit none\n\n   class(T), allocatable :: Sobj\n   class(T), allocatable :: Sclone\n\n   allocate(Sobj, source = S())\n   allocate(Sclone, source = Sobj % duplicate())\n\n   call Sobj % identify()\n   call Sclone % identify()\n\nend program test\n", "target": "import copy\n\nclass T:\n   def classname(self): \n      return self.__class__.__name__\n\n   def __init__(self):\n      self.myValue = \"I'm a T.\"\n\n   def speak(self):\n      print self.classname(), 'Hello', self.myValue\n\n   def clone(self):\n      return copy.copy(self)\n\nclass S1(T):\n   def speak(self):\n      print self.classname(),\"Meow\", self.myValue\n\nclass S2(T):\n   def speak(self):\n      print self.classname(),\"Woof\", self.myValue\n\n\nprint \"creating initial objects of types S1, S2, and T\"\na = S1()\na.myValue = 'Green'\na.speak()\n\nb = S2()\nb.myValue = 'Blue'\nb.speak()\n\nu = T()\nu.myValue = 'Purple'\nu.speak()\n\nprint \"Making copy of a as u, colors and types should match\"\nu = a.clone()\nu.speak()\na.speak()\nprint \"Assigning new color to u, A's color should be unchanged.\"\nu.myValue = \"Orange\"\nu.speak()\na.speak()\n\nprint \"Assigning u to reference same object as b, colors and types should match\"\nu = b\nu.speak()\nb.speak()\nprint \"Assigning new color to u. Since u,b references same object b's color changes as well\"\nu.myValue = \"Yellow\"\nu.speak()\nb.speak()\n"}
{"id": 29479, "name": "User input_Text", "source": "Translate Fortran to C#: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "using System;\n\nnamespace C_Sharp_Console {\n\n    class example {\n\n        static void Main() {\n            string word;\n            int num;\n            \n            Console.Write(\"Enter an integer: \");\n            num = Console.Read();\n            Console.Write(\"Enter a String: \");\n            word = Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 29482, "name": "User input_Text", "source": "Translate Fortran to Java: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "import java.util.Scanner;\n\npublic class GetInput {\n    public static void main(String[] args) throws Exception {\n        Scanner s = new Scanner(System.in);\n        System.out.print(\"Enter a string: \");\n        String str = s.nextLine();\n        System.out.print(\"Enter an integer: \");\n        int i = Integer.parseInt(s.next());\n    }\n}\n"}
{"id": 29483, "name": "User input_Text", "source": "Translate Fortran to Python: character(20) :: s\ninteger :: i\n\nprint*, \"Enter a string (max 20 characters)\"\nread*, s\nprint*, \"Enter the integer 75000\"\nread*, i\n", "target": "   string = raw_input(\"Input a string: \")\n"}
{"id": 30218, "name": "File size", "source": "Translate Fortran to C#:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Console.WriteLine(new FileInfo(\"/input.txt\").Length);\n        Console.WriteLine(new FileInfo(\"input.txt\").Length);\n    }\n}\n"}
{"id": 30222, "name": "File size", "source": "Translate Fortran to Java:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "import java.io.File;\n\npublic class FileSize\n{\n    public static void main ( String[] args )\n    {\n        System.out.println(\"input.txt \u00a0: \" + new File(\"input.txt\").length() + \" bytes\");\n        System.out.println(\"/input.txt\u00a0: \" + new File(\"/input.txt\").length() + \" bytes\");\n    }\n}\n"}
{"id": 30223, "name": "File size", "source": "Translate Fortran to Python:     use :: iso_fortran_env, only : FILE_STORAGE_SIZE\n    implicit none\n    character(len=*),parameter :: filename(*)=[character(len=256) :: 'input.txt', '/input.txt']\n    integer                    :: file_size, i\n    do i=1,size(filename)\n       INQUIRE(FILE=filename(i), SIZE=file_size)  \n       write(*,*)'size of file '//trim(filename(i))//' is ',file_size * FILE_STORAGE_SIZE /8,' bytes'\n    enddo\n    end\n", "target": "import os\n\nsize = os.path.getsize('input.txt')\nsize = os.path.getsize('/input.txt')\n"}
{"id": 30559, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to C#: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\n\nclass Program\n{\n    static void ThreadStart(object item)\n    {\n        Thread.Sleep(1000 * (int)item);\n        Console.WriteLine(item);\n    }\n\n    static void SleepSort(IEnumerable<int> items)\n    {\n        foreach (var item in items)\n        {\n            new Thread(ThreadStart).Start(item);\n        }\n    }\n\n    static void Main(string[] arguments)\n    {\n        SleepSort(arguments.Select(int.Parse));\n    }\n}\n"}
{"id": 30562, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to Java: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "import java.util.concurrent.CountDownLatch;\n\npublic class SleepSort {\n\tpublic static void sleepSortAndPrint(int[] nums) {\n\t\tfinal CountDownLatch doneSignal = new CountDownLatch(nums.length);\n\t\tfor (final int num : nums) {\n\t\t\tnew Thread(new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tdoneSignal.countDown();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdoneSignal.await();\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tThread.sleep(num * 1000);\n\t\t\t\t\t\tSystem.out.println(num);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).start();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tint[] nums = new int[args.length];\n\t\tfor (int i = 0; i < args.length; i++)\n\t\t\tnums[i] = Integer.parseInt(args[i]);\n\t\tsleepSortAndPrint(nums);\n\t}\n}\n"}
{"id": 30563, "name": "Sorting algorithms_Sleep sort", "source": "Translate Fortran to Python: program sleepSort\n    use omp_lib\n    implicit none\n    integer::nArgs,myid,i,stat\n    integer,allocatable::intArg(:)\n    character(len=5)::arg\n\n    \n    nArgs=command_argument_count()\n    if(nArgs==0)stop '\u00a0: No argument is given\u00a0\n    allocate(intArg(nArgs))\n    do i=1,nArgs\n        call get_command_argument(i, arg)\n\tread(arg,'(I5)',iostat=stat)intArg(i)\n\tif(intArg(i)<0 .or. stat/=0) stop&\n        &' :Only 0 or positive integer allowed\u00a0\n    end do\n    call omp_set_num_threads(nArgs)\n    \n \n\n    \n    myid =omp_get_thread_num()\n    call sleepNprint(intArg(myid+1))\n    \n\n  contains\n\tsubroutine sleepNprint(nSeconds)\n\t    integer::nSeconds\n            call sleep(nSeconds)\n\t    print*,nSeconds\n\tend subroutine sleepNprint\nend program sleepSort\n", "target": "from time import sleep\nfrom threading import Timer\n\ndef sleepsort(values):\n    sleepsort.result = []\n    def add1(x):\n        sleepsort.result.append(x)\n    mx = values[0]\n    for v in values:\n        if mx < v: mx = v\n        Timer(v, add1, [v]).start()\n    sleep(mx+1)\n    return sleepsort.result\n\nif __name__ == '__main__':\n    x = [3,2,4,7,3,6,9,1]\n    if sleepsort(x) == sorted(x):\n        print('sleep sort worked for:',x)\n    else:\n        print('sleep sort FAILED for:',x)\n"}
{"id": 30788, "name": "Random number generator (device)", "source": "Translate Fortran to C#: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30789, "name": "Random number generator (device)", "source": "Translate Fortran to C#: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "using System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n"}
{"id": 30794, "name": "Random number generator (device)", "source": "Translate Fortran to Java: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30795, "name": "Random number generator (device)", "source": "Translate Fortran to Java: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    \n    System.out.println(rng.nextInt());\n  }\n}\n"}
{"id": 30796, "name": "Random number generator (device)", "source": "Translate Fortran to Python: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 30797, "name": "Random number generator (device)", "source": "Translate Fortran to Python: \n\n\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n", "target": "import random\nrand = random.SystemRandom()\nrand.randint(1,10)\n"}
{"id": 31387, "name": "Remove vowels from a string", "source": "Translate Fortran to C#: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31388, "name": "Remove vowels from a string", "source": "Translate Fortran to C#: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "static string remove_vowels(string value)\n{\n    var stripped = from c in value.ToCharArray()\n                   where !\"aeiouAEIOU\".Contains(c)\n                   select c;\n\n    return new string(stripped.ToArray());\n}\n\nstatic void test(string value)\n{\n    Console.WriteLine(\"Input:  \" + value);\n    Console.WriteLine(\"Output: \" + remove_vowels(value));\n}\n\nstatic void Main(string[] args)\n{\n    test(\"CSharp Programming Language\");\n}\n"}
{"id": 31394, "name": "Remove vowels from a string", "source": "Translate Fortran to Java: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31395, "name": "Remove vowels from a string", "source": "Translate Fortran to Java: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "public static String removeVowelse(String str){\n    String re = \"\";\n    char c;\n    for(int x = 0; x<str.length(); x++){\n        c = str.charAt(x);\n        if(!(c=='a'||c=='e'||c=='i'||c=='o'||c=='u'))\n        re+=c;\n    }\n    return re;\n}\n"}
{"id": 31396, "name": "Remove vowels from a string", "source": "Translate Fortran to Python: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31397, "name": "Remove vowels from a string", "source": "Translate Fortran to Python: program remove_vowels\n    implicit none\n\n    character(len=*), parameter :: string1=\"The quick brown fox jumps over the lazy dog.\"\n    character(len=*), parameter :: string2=\"Fortran programming language\"\n\n    call print_no_vowels(string1)\n    call print_no_vowels(string2)\ncontains\n    subroutine print_no_vowels(string)\n        character(len=*), intent(in)    :: string\n        integer                         :: i\n\n        do i = 1, len(string)\n            select case (string(i:i))\n            case('A','E','I','O','U','a','e','i','o','u')\n                cycle\n            case default\n                write(*,'(A1)',advance=\"no\") string(i:i)\n            end select\n        end do\n        write(*,*) new_line('A') \n    end subroutine print_no_vowels\nend program remove_vowels\n", "target": "\n\n\n\ndef exceptGlyphs(exclusions):\n    \n    def go(s):\n        return ''.join(\n            c for c in s if c not in exclusions\n        )\n    return go\n\n\n\n\ndef main():\n    \n\n    txt = \n\n    print(\n        exceptGlyphs('eau')(txt)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 31675, "name": "Forward difference", "source": "Translate Fortran to C#: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static IEnumerable<int> ForwardDifference(IEnumerable<int> sequence, uint order = 1u)\n    {\n        switch (order)\n        {\n            case 0u:\n                return sequence;\n            case 1u:\n                return sequence.Skip(1).Zip(sequence, (next, current) => next - current);\n            default:\n                return ForwardDifference(ForwardDifference(sequence), order - 1u);\n        }\n    }\n\n    static void Main()\n    {\n        IEnumerable<int> sequence = new[] { 90, 47, 58, 29, 22, 32, 55, 5, 55, 73 };\n        do\n        {\n            Console.WriteLine(string.Join(\", \", sequence));\n        } while ((sequence = ForwardDifference(sequence)).Any());\n    }\n}\n"}
{"id": 31678, "name": "Forward difference", "source": "Translate Fortran to Java: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": "import java.util.Arrays;\npublic class FD {\n    public static void main(String args[]) {\n        double[] a = {90, 47, 58, 29, 22, 32, 55, 5, 55, 73};\n        System.out.println(Arrays.toString(dif(a, 1)));\n        System.out.println(Arrays.toString(dif(a, 2)));\n        System.out.println(Arrays.toString(dif(a, 9)));\n        System.out.println(Arrays.toString(dif(a, 10)));      \n        System.out.println(Arrays.toString(dif(a, 11)));\n        System.out.println(Arrays.toString(dif(a, -1)));\n        System.out.println(Arrays.toString(dif(a, 0)));\n    }\n\n    public static double[] dif(double[] a, int n) {\n        if (n < 0)\n            return null; \n\n        for (int i = 0; i < n && a.length > 0; i++) {\n            double[] b = new double[a.length - 1];\n            for (int j = 0; j < b.length; j++){\n                b[j] = a[j+1] - a[j];\n            }\n            a = b; \n        }\n        return a;\n    }\n}\n"}
{"id": 31679, "name": "Forward difference", "source": "Translate Fortran to Python: MODULE DIFFERENCE\n  IMPLICIT NONE\n\n  CONTAINS\n \n  SUBROUTINE Fdiff(a, n)\n    INTEGER, INTENT(IN) :: a(:), n\n    INTEGER :: b(SIZE(a))  \n    INTEGER :: i, j, arraysize\n  \n    b = a\n    arraysize = SIZE(b)\n    DO i = arraysize-1, arraysize-n, -1\n      DO j = 1, i\n        b(j) = b(j+1) - b(j)\n      END DO\n    END DO\n    WRITE (*,*) b(1:arraysize-n)\n  END SUBROUTINE Fdiff\nEND MODULE DIFFERENCE\n", "target": ">>> dif = lambda s: [x-s[i] for i,x in enumerate(s[1:])]\n>>> \n>>> difn = lambda s, n: difn(dif(s), n-1) if n else s\n\n>>> s = [90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 0)\n[90, 47, 58, 29, 22, 32, 55, 5, 55, 73]\n>>> difn(s, 1)\n[-43, 11, -29, -7, 10, 23, -50, 50, 18]\n>>> difn(s, 2)\n[54, -40, 22, 17, 13, -73, 100, -32]\n\n>>> from pprint import pprint\n>>> pprint( [difn(s, i) for i in xrange(10)] )\n[[90, 47, 58, 29, 22, 32, 55, 5, 55, 73],\n [-43, 11, -29, -7, 10, 23, -50, 50, 18],\n [54, -40, 22, 17, 13, -73, 100, -32],\n [-94, 62, -5, -4, -86, 173, -132],\n [156, -67, 1, -82, 259, -305],\n [-223, 68, -83, 341, -564],\n [291, -151, 424, -905],\n [-442, 575, -1329],\n [1017, -1904],\n [-2921]]\n"}
{"id": 31937, "name": "Guess the number_With feedback", "source": "Translate Fortran to C#: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int from = 1;\n        const int to = 10;\n\n        int randomNumber = new Random().Next(from, to);\n        int guessedNumber;\n\n        Console.Write(\"The number is between {0} and {1}. \", from, to);\n        while (true)\n        {\n            Console.Write(\"Make a guess: \");\n            if (int.TryParse(Console.ReadLine(), out guessedNumber))\n            {\n                if (guessedNumber == randomNumber)\n                {\n                    Console.WriteLine(\"You guessed the right number!\");\n                    break;\n                }\n                else\n                {\n                    Console.WriteLine(\"Your guess was too {0}.\", (guessedNumber > randomNumber) ? \"high\" : \"low\");\n                }\n            }\n            else\n            {\n                Console.WriteLine(\"Input was not an integer.\");\n            }\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(\"Press any key to exit.\");\n        Console.ReadKey();\n    }\n}\n"}
{"id": 31941, "name": "Guess the number_With feedback", "source": "Translate Fortran to Java: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "import java.util.Random;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Scanner scan = new Scanner(System.in);\n        Random random = new Random();\n        long from = 1;\n        long to = 100;\n        int randomNumber = random.nextInt(to - from + 1) + from;\n        int guessedNumber = 0;\n\n        System.out.printf(\"The number is between %d and %d.\\n\", from, to);\n\n        do\n        {\n            System.out.print(\"Guess what the number is: \");\n            guessedNumber = scan.nextInt();\n            if (guessedNumber > randomNumber)\n                System.out.println(\"Your guess is too high!\");\n            else if (guessedNumber < randomNumber)\n                System.out.println(\"Your guess is too low!\");\n            else\n                System.out.println(\"You got it!\");\n        } while (guessedNumber != randomNumber);\n    }\n}\n"}
{"id": 31942, "name": "Guess the number_With feedback", "source": "Translate Fortran to Python: program Guess_a_number\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, number\n  real :: rnum\n  \n  write(*, \"(a, i0, a)\") \"I have chosen a number between 1 and \", limit, &\n                         \" and you have to try to guess it.\" \n  write(*, \"(a/)\")  \"I will score your guess by indicating whether it is higher, lower or the same as that number\"\n \n  call random_seed\n  call random_number(rnum)\n  number = rnum * limit + 1\n  do\n    write(*, \"(a)\", advance=\"no\") \"Enter quess: \"\n    read*, guess\n    if(guess < number) then\n      write(*, \"(a/)\") \"That is lower\"\n    else if(guess > number) then\n      write(*, \"(a/)\") \"That is higher\"\n    else\n      write(*, \"(a)\") \"That is correct\"\n      exit\n    end if\n  end do\nend program\n", "target": "import random\n\ninclusive_range = (1, 100)\n\nprint(\"Guess my target number that is between %i and %i (inclusive).\\n\"\n      % inclusive_range)\ntarget = random.randint(*inclusive_range)\nanswer, i = None, 0\nwhile answer != target:\n    i += 1\n    txt = input(\"Your guess(%i): \" % i)\n    try:\n        answer = int(txt)\n    except ValueError:\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if answer < inclusive_range[0] or answer > inclusive_range[1]:\n        print(\"  Out of range!\")\n        continue\n    if answer == target:\n        print(\"  Ye-Haw!!\")\n        break\n    if answer < target: print(\"  Too low.\")\n    if answer > target: print(\"  Too high.\")\n\nprint(\"\\nThanks for playing.\")\n"}
{"id": 32193, "name": "Compound data type", "source": "Translate Fortran to C#: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "struct Point\n{\n  public int x, y;\n  public Point(int x, int y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n"}
{"id": 32197, "name": "Compound data type", "source": "Translate Fortran to Java: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "public class Point\n{\n  public int x, y;\n  public Point() { this(0); }\n  public Point(int x0) { this(x0,0); }\n  public Point(int x0, int y0) { x = x0; y = y0; }\n\n  public static void main(String args[])\n  {\n    Point point = new Point(1,2);\n    System.out.println(\"x = \" + point.x );\n    System.out.println(\"y = \" + point.y );\n  }\n}\n"}
{"id": 32198, "name": "Compound data type", "source": "Translate Fortran to Python: program typedemo\n    type rational                                           \n        integer :: numerator\n        integer :: denominator\n    end type rational\n    \n    type( rational ), parameter :: zero = rational( 0, 1 )  \n    type( rational ), parameter :: one  = rational( 1, 1 )  \n    type( rational ), parameter :: half = rational( 1, 2 )\n    integer :: n, halfd, halfn\n    type( rational ) :: &\n        one_over_n(20) = (/ (rational( 1, n ), n = 1, 20) /) \n                                                             \n                                                             \n    integer :: oon_denoms(20)                                \n    \n    halfd = half%denominator                       \n    halfn = half%numerator\n    \n    oon_denoms = one_over_n%denominator            \n                                                   \nend program typedemo                               \n", "target": "X, Y = 0, 1\np = (3, 4)\np = [3, 4]\n\nprint p[X]\n"}
{"id": 32432, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to C#: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BogoSort\n{\n    public static class BogoSorter\n    {\n        public static void Sort<T>(List<T> list) where T:IComparable\n        {\n            while (!list.isSorted())\n            {\n                list.Shuffle();\n            }\n        }\n\n        private static bool isSorted<T>(this IList<T> list) where T:IComparable\n        {\n            if(list.Count<=1)\n                return true;\n            for (int i = 1 ; i < list.Count; i++)\n                if(list[i].CompareTo(list[i-1])<0) return false;\n            return true;\n        }\n\n        private static void Shuffle<T>(this IList<T> list)\n        {\n            Random rand = new Random();\n            for (int i = 0; i < list.Count; i++)\n            {\n                int swapIndex = rand.Next(list.Count);\n                T temp = list[swapIndex];\n                list[swapIndex] = list[i];\n                list[i] = temp;\n            }\n        }\n    }\n\n    class TestProgram\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 4, 1, 8, 7, 4, -2 };\n            BogoSorter.Sort(testList);\n            foreach (int i in testList) Console.Write(i + \" \");\n        }\n\n    }\n}\n"}
{"id": 32436, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to Java: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "public class BogoSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tint[] arr={4,5,6,0,7,8,9,1,2,3};\n\t\t\n\t\tBogoSort now=new BogoSort();\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tnow.bogo(arr);\n\t\t\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(arr);\n\t}\n\tvoid bogo(int[] arr)\n\t{\n\t\t\n\t\tint shuffle=1;\n\t\tfor(;!isSorted(arr);shuffle++)\n\t\t\tshuffle(arr);\n\t\t\n\t\tSystem.out.println(\"This took \"+shuffle+\" shuffles.\");\n\t}\n\tvoid shuffle(int[] arr)\n\t{\n\t\t\n\t\tint i=arr.length-1;\n\t\twhile(i>0)\n\t\t\tswap(arr,i--,(int)(Math.random()*i));\n\t}\n\tvoid swap(int[] arr,int i,int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n\tboolean isSorted(int[] arr)\n\t{\n\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]<arr[i-1])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n}\n"}
{"id": 32437, "name": "Sorting algorithms_Bogosort", "source": "Translate Fortran to Python: MODULE BOGO\nIMPLICIT NONE\nCONTAINS\n  FUNCTION Sorted(a)\n    LOGICAL :: Sorted\n    INTEGER, INTENT(IN) :: a(:)\n    INTEGER :: i\n\n    Sorted = .TRUE.  \n    DO i = 1, SIZE(a)-1\n      IF(a(i) > a(i+1)) THEN\n        Sorted = .FALSE.\n        EXIT\n      END IF\n    END DO\n  END FUNCTION Sorted\n\n  SUBROUTINE SHUFFLE(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, rand, temp\n    REAL :: x\n\n    DO i = SIZE(a), 1, -1\n       CALL RANDOM_NUMBER(x)\n       rand = INT(x * i) + 1\n       temp = a(rand)\n       a(rand) = a(i)\n       a(i) = temp\n    END DO\n  END SUBROUTINE\nEND MODULE\n\nPROGRAM BOGOSORT\n\n  USE BOGO\n  IMPLICIT NONE\n  INTEGER :: iter = 0\n  INTEGER :: array(8) = (/2, 7, 5, 3, 4, 8, 6, 1/)\n  LOGICAL :: s\n \n  DO\n    s = Sorted(array)\n    IF (s) EXIT\n    CALL SHUFFLE(array)\n    iter = iter + 1\n  END DO\n  WRITE (*,*) \"Array required\", iter, \" shuffles to sort\"\n \nEND PROGRAM BOGOSORT\n", "target": "import random\n\ndef bogosort(l):\n    while not in_order(l):\n        random.shuffle(l)\n    return l\n\ndef in_order(l):\n    if not l:\n        return True\n    last = l[0]\n    for x in l[1:]:\n        if x < last:\n            return False\n        last = x\n    return True\n"}
{"id": 32710, "name": "Cumulative standard deviation", "source": "Translate Fortran to C#: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace standardDeviation\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<double> nums = new List<double> { 2, 4, 4, 4, 5, 5, 7, 9 };\n            for (int i = 1; i <= nums.Count; i++)            \n                Console.WriteLine(sdev(nums.GetRange(0, i)));\n        }\n\n        static double sdev(List<double> nums)\n        {\n            List<double> store = new List<double>();\n            foreach (double n in nums)\n                store.Add((n - nums.Average()) * (n - nums.Average()));           \n\n            return Math.Sqrt(store.Sum() / store.Count);\n        }\n    }\n}\n"}
{"id": 32714, "name": "Cumulative standard deviation", "source": "Translate Fortran to Java: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": "public class StdDev {\n    int n = 0;\n    double sum = 0;\n    double sum2 = 0;\n\n    public double sd(double x) {\n\tn++;\n\tsum += x;\n\tsum2 += x*x;\n\n\treturn Math.sqrt(sum2/n - sum*sum/n/n);\n    }\n\n    public static void main(String[] args) {\n        double[] testData = {2,4,4,4,5,5,7,9};\n        StdDev sd = new StdDev();\n\n        for (double x : testData) {\n            System.out.println(sd.sd(x));\n        }\n    }\n}\n"}
{"id": 32715, "name": "Cumulative standard deviation", "source": "Translate Fortran to Python: program standard_deviation\n  implicit none\n  integer(kind=4), parameter :: dp = kind(0.0d0)\n\n  real(kind=dp), dimension(:), allocatable :: vals\n  integer(kind=4) :: i\n\n  real(kind=dp), dimension(8) :: sample_data = (/ 2, 4, 4, 4, 5, 5, 7, 9 /)\n\n  do i = lbound(sample_data, 1), ubound(sample_data, 1)\n    call sample_add(vals, sample_data(i))\n    write(*, fmt='(''#'',I1,1X,''value = '',F3.1,1X,''stddev ='',1X,F10.8)') &\n      i, sample_data(i), stddev(vals)\n  end do\n\n  if (allocated(vals)) deallocate(vals)\ncontains\n  \n  subroutine sample_add(population, val)\n    real(kind=dp), dimension(:), allocatable, intent (inout) :: population\n    real(kind=dp), intent (in) :: val\n\n    real(kind=dp), dimension(:), allocatable :: tmp\n    integer(kind=4) :: n\n\n    if (.not. allocated(population)) then\n      allocate(population(1))\n      population(1) = val\n    else\n      n = size(population)\n      call move_alloc(population, tmp)\n\n      allocate(population(n + 1))\n      population(1:n) = tmp\n      population(n + 1) = val\n    endif\n  end subroutine sample_add\n\n  \n  real(kind=dp) function stddev(vals)\n    real(kind=dp), dimension(:), intent(in) :: vals\n    real(kind=dp) :: mean\n    integer(kind=4) :: n\n\n    n = size(vals)\n    mean = sum(vals)/n\n    stddev = sqrt(sum((vals - mean)**2)/n)\n  end function stddev\nend program standard_deviation\n", "target": ">>> from math import sqrt\n>>> def sd(x):\n    sd.sum  += x\n    sd.sum2 += x*x\n    sd.n    += 1.0\n    sum, sum2, n = sd.sum, sd.sum2, sd.n\n    return sqrt(sum2/n - sum*sum/n/n)\n\n>>> sd.sum = sd.sum2 = sd.n = 0\n>>> for value in (2,4,4,4,5,5,7,9):\n    print (value, sd(value))\n\n    \n(2, 0.0)\n(4, 1.0)\n(4, 0.94280904158206258)\n(4, 0.8660254037844386)\n(5, 0.97979589711327075)\n(5, 1.0)\n(7, 1.3997084244475311)\n(9, 2.0)\n>>>\n"}
{"id": 32995, "name": "Palindrome detection", "source": "Translate Fortran to C#: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "using System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n"}
{"id": 32998, "name": "Palindrome detection", "source": "Translate Fortran to Java: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "public static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n"}
{"id": 32999, "name": "Palindrome detection", "source": "Translate Fortran to Python: program palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n", "target": "def is_palindrome(s):\n  return s == s[::-1]\n"}
{"id": 33276, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to C#: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        char[] a = { 'a', 'b', 'c' };\n        char[] b = { 'A', 'B', 'C' };\n        int[] c = { 1, 2, 3 };\n        int min = Math.Min(a.Length, b.Length);\n        min = Math.Min(min, c.Length);\n        for (int i = 0; i < min; i++)\n            Console.WriteLine(\"{0}{1}{2}\", a[i], b[i], c[i]);\n    }             \n}\n"}
{"id": 33279, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to Java: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"}
{"id": 33280, "name": "Loop over multiple arrays simultaneously", "source": "Translate Fortran to Python: program main\n implicit none\n\n integer,parameter :: n_vals = 3\n character(len=*),dimension(n_vals),parameter :: ls = ['a','b','c']\n character(len=*),dimension(n_vals),parameter :: us = ['A','B','C']\n integer,dimension(n_vals),parameter          :: ns = [1,2,3]\n\n integer :: i  \n\n do i=1,n_vals\n      write(*,'(A1,A1,I1)') ls(i),us(i),ns(i)\n end do\n\nend program main\n", "target": ">>> print ( '\\n'.join(''.join(x) for x in \nzip('abc', 'ABC', '123')) )\naA1\nbB2\ncC3\n>>>\n"}
{"id": 33526, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to C#: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "public static void cocktailSort(int[] A)\n    {\n        bool swapped;\n        do\n        {\n            swapped = false;\n            for (int i = 0; i <= A.Length - 2; i++)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    \n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            if (!swapped)\n            {\n                \n                break;\n            }\n            swapped = false;\n            for (int i = A.Length - 2; i >= 0; i--)\n            {\n                if (A[i] > A[i + 1])\n                {\n                    int temp = A[i];\n                    A[i] = A[i + 1];\n                    A[i + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n        } while (swapped);\n    }\n"}
{"id": 33530, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to Java: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "public static void cocktailSort( int[] A ){\n\tboolean swapped;\n\tdo {\n\t\tswapped = false;\n\t\tfor (int i =0; i<=  A.length  - 2;i++) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\t\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\tif (!swapped) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tswapped = false;\n\t\tfor (int i= A.length - 2;i>=0;i--) {\n\t\t\tif (A[ i ] > A[ i + 1 ]) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i+1];\n\t\t\t\tA[i+1]=temp;\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t\t\n\t} while (swapped);\n}\n"}
{"id": 33531, "name": "Sorting algorithms_Cocktail sort", "source": "Translate Fortran to Python: PROGRAM COCKTAIL\n  IMPLICIT NONE\n\n  INTEGER :: intArray(10) = (/ 4, 9, 3, -2, 0, 7, -5, 1, 6, 8 /)\n\n  WRITE(*,\"(A,10I5)\") \"Unsorted array:\", intArray\n  CALL Cocktail_sort(intArray)\n  WRITE(*,\"(A,10I5)\") \"Sorted array \u00a0:\", intArray\n  \nCONTAINS\n\n  SUBROUTINE Cocktail_sort(a)\n    INTEGER, INTENT(IN OUT) :: a(:)\n    INTEGER :: i, bottom, top, temp \n    LOGICAL :: swapped\n \n    bottom = 1\n    top = SIZE(a) - 1\n    DO WHILE (bottom < top )\n       swapped = .FALSE.\n       DO i = bottom, top\n          IF (array(i) > array(i+1)) THEN\n              temp = array(i)\n              array(i) = array(i+1)\n              array(i+1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       DO i = top, bottom + 1, -1\n          IF (array(i) < array(i-1)) THEN\n              temp = array(i)\n              array(i) = array(i-1)\n              array(i-1) = temp\n              swapped = .TRUE.\n          END IF\n       END DO\n       IF (.NOT. swapped) EXIT\n       bottom = bottom + 1\n       top = top - 1\n    END DO\n  END SUBROUTINE Cocktail_sort\n\nEND PROGRAM COCKTAIL\n", "target": "def cocktailSort(A):\n    up = range(len(A)-1)\n    while True:\n        for indices in (up, reversed(up)):\n            swapped = False\n            for i in indices:\n                if A[i] > A[i+1]:  \n                    A[i], A[i+1] =  A[i+1], A[i]\n                    swapped = True\n            if not swapped:\n                return\n"}
{"id": 33760, "name": "Animate a pendulum", "source": "Translate Fortran to C#: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass CSharpPendulum\n{\n    Form _form;\n    Timer _timer;\n    \n    double _angle = Math.PI / 2, \n           _angleAccel, \n           _angleVelocity = 0, \n           _dt = 0.1;\n    \n    int _length = 50;\n\n    [STAThread]\n    static void Main()\n    {\n        var p = new CSharpPendulum();\n    }\n\n    public CSharpPendulum()\n    {\n        _form = new Form() { Text = \"Pendulum\", Width = 200, Height = 200 };\n        _timer = new Timer() { Interval = 30 };\n\n        _timer.Tick += delegate(object sender, EventArgs e)\n        {\n            int anchorX = (_form.Width / 2) - 12,\n                anchorY = _form.Height / 4,\n                ballX = anchorX + (int)(Math.Sin(_angle) * _length),\n                ballY = anchorY + (int)(Math.Cos(_angle) * _length);\n\n            _angleAccel = -9.81 / _length * Math.Sin(_angle);\n            _angleVelocity += _angleAccel * _dt;\n            _angle += _angleVelocity * _dt;\n          \n            Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);\n            Graphics g = Graphics.FromImage(dblBuffer);\n            Graphics f = Graphics.FromHwnd(_form.Handle);\n\n            g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));\n            g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);\n            g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);\n            \n            f.Clear(Color.White);\n            f.DrawImage(dblBuffer, new Point(0, 0));    \n        };\n\n        _timer.Start();\n        Application.Run(_form);\n    }     \n}\n"}
{"id": 33763, "name": "Animate a pendulum", "source": "Translate Fortran to Java: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class Pendulum extends JPanel implements Runnable {\n\n    private double angle = Math.PI / 2;\n    private int length;\n\n    public Pendulum(int length) {\n        this.length = length;\n        setDoubleBuffered(true);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.WHITE);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.setColor(Color.BLACK);\n        int anchorX = getWidth() / 2, anchorY = getHeight() / 4;\n        int ballX = anchorX + (int) (Math.sin(angle) * length);\n        int ballY = anchorY + (int) (Math.cos(angle) * length);\n        g.drawLine(anchorX, anchorY, ballX, ballY);\n        g.fillOval(anchorX - 3, anchorY - 4, 7, 7);\n        g.fillOval(ballX - 7, ballY - 7, 14, 14);\n    }\n\n    public void run() {\n        double angleAccel, angleVelocity = 0, dt = 0.1;\n        while (true) {\n            angleAccel = -9.81 / length * Math.sin(angle);\n            angleVelocity += angleAccel * dt;\n            angle += angleVelocity * dt;\n            repaint();\n            try { Thread.sleep(15); } catch (InterruptedException ex) {}\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension(2 * length + 50, length / 2 * 3);\n    }\n\n    public static void main(String[] args) {\n        JFrame f = new JFrame(\"Pendulum\");\n        Pendulum p = new Pendulum(200);\n        f.add(p);\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.pack();\n        f.setVisible(true);\n        new Thread(p).start();\n    }\n}\n"}
{"id": 33764, "name": "Animate a pendulum", "source": "Translate Fortran to Python: \nprogram animated_pendulum\nimplicit none\ndouble precision, parameter :: pi = 4.0D0*atan(1.0D0), l = 1.0D-1, dt = 1.0D-2, g = 9.8D0\ninteger :: io\ndouble precision :: s_ang, c_ang, p_ang, n_ang\n\nwrite(*,*) 'Enter starting angle (in degrees):'\ndo\n  read(*,*,iostat=io) s_ang\n  if(io.ne.0 .or. s_ang.lt.-90.0D0 .or. s_ang.gt.90.0D0) then\n    write(*,*) 'Please enter an angle between 90 and -90 degrees:'\n  else\n    exit\n  end if\nend do\ncall execute_command_line('cls')\n\nc_ang = s_ang*pi/180.0D0\np_ang = c_ang\n\ncall display(c_ang)\ndo\n  call next_time_step(c_ang,p_ang,g,l,dt,n_ang)\n  if(abs(c_ang-p_ang).ge.0.05D0) then\n    call execute_command_line('cls')\n    call display(c_ang)\n  end if\nend do\nend program\n\nsubroutine next_time_step(c_ang,p_ang,g,l,dt,n_ang)\ndouble precision :: c_ang, p_ang, g, l, dt, n_ang\nn_ang = (-g*sin(c_ang)/l)*2.0D0*dt**2 + 2.0D0*c_ang - p_ang\np_ang = c_ang\nc_ang = n_ang\nend subroutine\n\nsubroutine display(c_ang)\ndouble precision :: c_ang\ncharacter (len=*), parameter :: cfmt = '(A1)'\ndouble precision :: rx, ry\ninteger :: x, y, i, j\nrx = 45.0D0*sin(c_ang)\nry = 22.5D0*cos(c_ang)\nx = int(rx)+51\ny = int(ry)+2\ndo i = 1,32\n  do j = 1,100\n    if(i.eq.y .and. j.eq.x) then\n      write(*,cfmt,advance='no') 'O'\n    else if(i.eq.y .and. (j.eq.(x-1).or.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(j.eq.x .and. (i.eq.(y-1).or.i.eq.(y+1))) then\n      write(*,cfmt,advance='no') 'G'\n    else if(i.eq.y .and. (j.eq.(x-2).or.j.eq.(x+2))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.x .and. (i.eq.(y-2).or.i.eq.(y+2))) then\n      write(*,cfmt,advance='no') 'G'\n    else if((i.eq.(y+1).and.j.eq.(x+1)) .or. (i.eq.(y-1).and.j.eq.(x-1))) then\n      write(*,cfmt,advance='no') '#'\n    else if((i.eq.(y+1).and.j.eq.(x-1)) .or. (i.eq.(y-1).and.j.eq.(x+1))) then\n      write(*,cfmt,advance='no') '#'\n    else if(j.eq.50) then\n      write(*,cfmt,advance='no') '|'\n    else if(i.eq.2) then\n      write(*,cfmt,advance='no') '-'\n    else\n      write(*,cfmt,advance='no') ' '\n    end if\n  end do\n  write(*,*)\nend do\nend subroutine\n", "target": "import pygame, sys\nfrom pygame.locals import *\nfrom math import sin, cos, radians\n\npygame.init()\n\nWINDOWSIZE = 250\nTIMETICK = 100\nBOBSIZE = 15\n\nwindow = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))\npygame.display.set_caption(\"Pendulum\")\n\nscreen = pygame.display.get_surface()\nscreen.fill((255,255,255))\n\nPIVOT = (WINDOWSIZE/2, WINDOWSIZE/10)\nSWINGLENGTH = PIVOT[1]*4\n\nclass BobMass(pygame.sprite.Sprite):\n    def __init__(self):\n        pygame.sprite.Sprite.__init__(self)\n        self.theta = 45\n        self.dtheta = 0\n        self.rect = pygame.Rect(PIVOT[0]-SWINGLENGTH*cos(radians(self.theta)),\n                                PIVOT[1]+SWINGLENGTH*sin(radians(self.theta)),\n                                1,1)\n        self.draw()\n\n    def recomputeAngle(self):\n        scaling = 3000.0/(SWINGLENGTH**2)\n\n        firstDDtheta = -sin(radians(self.theta))*scaling\n        midDtheta = self.dtheta + firstDDtheta\n        midtheta = self.theta + (self.dtheta + midDtheta)/2.0\n\n        midDDtheta = -sin(radians(midtheta))*scaling\n        midDtheta = self.dtheta + (firstDDtheta + midDDtheta)/2\n        midtheta = self.theta + (self.dtheta + midDtheta)/2\n\n        midDDtheta = -sin(radians(midtheta)) * scaling\n        lastDtheta = midDtheta + midDDtheta\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n        \n        lastDDtheta = -sin(radians(lasttheta)) * scaling\n        lastDtheta = midDtheta + (midDDtheta + lastDDtheta)/2.0\n        lasttheta = midtheta + (midDtheta + lastDtheta)/2.0\n\n        self.dtheta = lastDtheta\n        self.theta = lasttheta\n        self.rect = pygame.Rect(PIVOT[0]-\n                                SWINGLENGTH*sin(radians(self.theta)), \n                                PIVOT[1]+\n                                SWINGLENGTH*cos(radians(self.theta)),1,1)\n\n\n    def draw(self):\n        pygame.draw.circle(screen, (0,0,0), PIVOT, 5, 0)\n        pygame.draw.circle(screen, (0,0,0), self.rect.center, BOBSIZE, 0)\n        pygame.draw.aaline(screen, (0,0,0), PIVOT, self.rect.center)\n        pygame.draw.line(screen, (0,0,0), (0, PIVOT[1]), (WINDOWSIZE, PIVOT[1]))\n\n    def update(self):\n        self.recomputeAngle()\n        screen.fill((255,255,255))\n        self.draw()\n\nbob = BobMass()\n\nTICK = USEREVENT + 2\npygame.time.set_timer(TICK, TIMETICK)\n\ndef input(events):\n    for event in events:\n        if event.type == QUIT:\n            sys.exit(0)\n        elif event.type == TICK:\n            bob.update()\n\nwhile True:\n    input(pygame.event.get())\n    pygame.display.flip()\n"}
{"id": 33930, "name": "Non-decimal radices_Input", "source": "Translate Fortran to C#: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var value = \"100\";\n        var fromBases = new[] { 2, 8, 10, 16 };\n        var toBase = 10;\n        foreach (var fromBase in fromBases)\n        {\n            Console.WriteLine(\"{0} in base {1} is {2} in base {3}\",\n                value, fromBase, Convert.ToInt32(value, fromBase), toBase);\n        }\n    }\n}\n"}
{"id": 33933, "name": "Non-decimal radices_Input", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": "Scanner sc = new Scanner(System.in); \nsc.useRadix(base); \nsc.nextInt(); \n"}
{"id": 33934, "name": "Non-decimal radices_Input", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  integer :: num\n  character(32) :: str\n\n  str = \"0123459\"\n  read(str, \"(i10)\") num   \n  write(*,*) num           \n\n  str = \"abcf123\"\n  read(str, \"(z8)\") num    \n  write(*,*) num           \n\n  str = \"7651\"\n  read(str, \"(o11)\") num   \n  write(*,*) num           \n\n  str = \"1010011010\"\n  read(str, \"(b32)\") num   \n  write(*,*) num           \n\nend program\n", "target": ">>> text = '100'\n>>> for base in range(2,21):\n    print (\"String '%s' in base %i is  %i in base 10\" \n           % (text, base, int(text, base)))\n\n  \nString '100' in base 2 is  4 in base 10\nString '100' in base 3 is  9 in base 10\nString '100' in base 4 is  16 in base 10\nString '100' in base 5 is  25 in base 10\nString '100' in base 6 is  36 in base 10\nString '100' in base 7 is  49 in base 10\nString '100' in base 8 is  64 in base 10\nString '100' in base 9 is  81 in base 10\nString '100' in base 10 is  100 in base 10\nString '100' in base 11 is  121 in base 10\nString '100' in base 12 is  144 in base 10\nString '100' in base 13 is  169 in base 10\nString '100' in base 14 is  196 in base 10\nString '100' in base 15 is  225 in base 10\nString '100' in base 16 is  256 in base 10\nString '100' in base 17 is  289 in base 10\nString '100' in base 18 is  324 in base 10\nString '100' in base 19 is  361 in base 10\nString '100' in base 20 is  400 in base 10\n"}
{"id": 34146, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to C#: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "using System;\n\npublic class SevenSidedDice\n{\n    Random random = new Random();\n\t\t\n        static void Main(string[] args)\n\t\t{\n\t\t\tSevenSidedDice sevenDice = new SevenSidedDice();\n\t\t\tConsole.WriteLine(\"Random number from 1 to 7: \"+ sevenDice.seven());\n            Console.Read();\n\t\t}\n\t\t\n\t\tint seven()\n\t\t{\n\t\t\tint v=21;\n\t\t\twhile(v>20)\n\t\t\t\tv=five()+five()*5-6;\n\t\t\treturn 1+v%7;\n\t\t}\n\t\t\n\t\tint five()\n\t\t{\n        return 1 + random.Next(5);\n\t\t}\n}\n"}
{"id": 34150, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to Java: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "import java.util.Random;\npublic class SevenSidedDice \n{\n\tprivate static final Random rnd = new Random();\n\tpublic static void main(String[] args)\n\t{\n\t\tSevenSidedDice now=new SevenSidedDice();\n\t\tSystem.out.println(\"Random number from 1 to 7: \"+now.seven());\n\t}\n\tint seven()\n\t{\n\t\tint v=21;\n\t\twhile(v>20)\n\t\t\tv=five()+five()*5-6;\n\t\treturn 1+v%7;\n\t}\n\tint five()\n\t{\n\t\treturn 1+rnd.nextInt(5);\n\t}\n}\n"}
{"id": 34151, "name": "Seven-sided dice from five-sided dice", "source": "Translate Fortran to Python: module rand_mod\n  implicit none\n\ncontains\n\nfunction rand5()\n  integer :: rand5\n  real :: r\n\n  call random_number(r)\n  rand5 = 5*r + 1\nend function\n  \nfunction rand7()\n  integer :: rand7\n  \n  do\n    rand7 = 5*rand5() + rand5() - 6\n    if (rand7 < 21) then\n      rand7 = rand7 / 3 + 1\n      return\n    end if\n  end do\nend function\nend module\n\nprogram Randtest\n  use rand_mod\n  implicit none\n  \n  integer, parameter :: samples = 1000000\n \n  call distcheck(rand7, samples, 0.005)\n  write(*,*)\n  call distcheck(rand7, samples, 0.001)\n\nend program\n", "target": "from random import randint\n\ndef dice5():\n    return randint(1, 5)\n\ndef dice7():\n    r = dice5() + dice5() * 5 - 6\n    return (r % 7) + 1 if r < 21 else dice7()\n"}
{"id": 34339, "name": "Heronian triangles", "source": "Translate Fortran to C#:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34340, "name": "Heronian triangles", "source": "Translate Fortran to C#:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace heron\n{\n    class Program{\n        static void Main(string[] args){           \n            List<int[]> list = new List<int[]>();\n            for (int c = 1; c <= 200; c++)\n                for (int b = 1; b <= c; b++)\n                    for (int a = 1; a <= b; a++)\n                        if (gcd(a, gcd(b, c)) == 1 && isHeron(heronArea(a, b, c)))\n                            list.Add(new int[] { a, b, c, a + b + c, (int)heronArea(a, b, c)});\n            sort(list);\n            Console.WriteLine(\"Number of primitive Heronian triangles with sides up to 200: \" + list.Count + \"\\n\\nFirst ten when ordered by increasing area, then perimeter,then maximum sides:\\nSides\\t\\t\\tPerimeter\\tArea\");\n            for(int i = 0; i < 10; i++)\n                Console.WriteLine(list[i][0] + \"\\t\" + list[i][1] + \"\\t\" + list[i][2] + \"\\t\" + list[i][3] + \"\\t\\t\" + list[i][4]);\n            Console.WriteLine(\"\\nPerimeter = 210\\nSides\\t\\t\\tPerimeter\\tArea\");\n            foreach (int[] i in list)\n                if (i[4] == 210)\n                    Console.WriteLine(i[0] + \"\\t\" + i[1] + \"\\t\" + i[2] + \"\\t\" + i[3] + \"\\t\\t\" + i[4]);     \n        }\n        static bool isHeron(double heronArea){\n            return heronArea % 1 == 0 && heronArea != 0;\n        }\n        static double heronArea(int a, int b, int c){\n            double s = (a + b + c) / 2d;\n            return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n        }\n        static int gcd(int a, int b){\n            int remainder = 1, dividend, divisor;\n            dividend = a > b ? a : b;\n            divisor = a > b ? b : a;\n            while (remainder != 0){\n                remainder = dividend % divisor;\n                if (remainder != 0){\n                    dividend = divisor;\n                    divisor = remainder;\n                }\n            }\n            return divisor;\n        }\n        static void sort(List<int[]> list){\n            int[] temp = new int[5];\n            bool changed = true;\n            while(changed){\n                changed = false;\n                for (int i = 1; i < list.Count; i++)\n                    if (list[i][4] < list[i - 1][4] || list[i][4] == list[i - 1][4] && list[i][3] < list[i - 1][3]){\n                        temp = list[i];\n                        list[i] = list[i - 1];\n                        list[i - 1] = temp;\n                        changed = true;\n                    }                \n            }\n        }\n    }\n}\n"}
{"id": 34345, "name": "Heronian triangles", "source": "Translate Fortran to Java:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34346, "name": "Heronian triangles", "source": "Translate Fortran to Java:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "import java.util.ArrayList;\n\npublic class Heron {\n    public static void main(String[] args) {\n        ArrayList<int[]> list = new ArrayList<>();\n\n        for (int c = 1; c <= 200; c++) {\n            for (int b = 1; b <= c; b++) {\n                for (int a = 1; a <= b; a++) {\n\n                    if (gcd(gcd(a, b), c) == 1 && isHeron(heronArea(a, b, c))){\n                        int area = (int) heronArea(a, b, c);\n                        list.add(new int[]{a, b, c, a + b + c, area});\n                    }\n                }\n            }\n        }\n        sort(list);\n\n        System.out.printf(\"Number of primitive Heronian triangles with sides up \"\n                + \"to 200: %d\\n\\nFirst ten when ordered by increasing area, then\"\n                + \" perimeter:\\nSides       Perimeter   Area\", list.size());\n\n        for (int i = 0; i < 10; i++) {\n            System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                    list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                    list.get(i)[3], list.get(i)[4]);\n        }\n\n        System.out.printf(\"\\n\\nArea = 210\\nSides        Perimeter   Area\");\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[4] == 210)\n                System.out.printf(\"\\n%d x %d x %d   %d      %d\",\n                        list.get(i)[0], list.get(i)[1], list.get(i)[2],\n                        list.get(i)[3], list.get(i)[4]);\n        }\n    }\n\n    public static double heronArea(int a, int b, int c) {\n        double s = (a + b + c) / 2f;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    public static boolean isHeron(double h) {\n        return h % 1 == 0 && h > 0;\n    }\n\n    public static int gcd(int a, int b) {\n        int leftover = 1, dividend = a > b ? a : b, divisor = a > b ? b : a;\n        while (leftover != 0) {\n            leftover = dividend % divisor;\n            if (leftover > 0) {\n                dividend = divisor;\n                divisor = leftover;\n            }\n        }\n        return divisor;\n    }\n\n    public static void sort(ArrayList<int[]> list) {\n        boolean swapped = true;\n        int[] temp;\n        while (swapped) {\n            swapped = false;\n            for (int i = 1; i < list.size(); i++) {\n                if (list.get(i)[4] < list.get(i - 1)[4] ||\n                        list.get(i)[4] == list.get(i - 1)[4] &&\n                        list.get(i)[3] < list.get(i - 1)[3]) {\n                    temp = list.get(i);\n                    list.set(i, list.get(i - 1));\n                    list.set(i - 1, temp);\n                    swapped = true;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 34347, "name": "Heronian triangles", "source": "Translate Fortran to Python:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34348, "name": "Heronian triangles", "source": "Translate Fortran to Python:  \n      MODULE GREEK MATHEMATICIANS\t\n       CONTAINS\n        INTEGER FUNCTION GCD(I,J)\t\n         INTEGER I,J\t\n         INTEGER N,M,R\t\n          N = MAX(I,J)\t\n          M = MIN(I,J)\t\n    1     R = MOD(N,M)\t\t\nc          write (6,*) \"M,N,R\",M,N,R\n          IF (R.GT.0) THEN\t\n            N = M\t\t\t\n            M = R\t\t\t\n            IF (R .GT. 1) GO TO 1\t\n          END IF\t\t\t\n          GCD = M\t\t\t\n        END FUNCTION GCD\t\n        FUNCTION GCD3(I,J,K)\t\n         INTEGER I,J,K\t\n         INTEGER R\t\n          R = GCD(I,J)\t\t\n          IF (R .GT. 1) R = GCD(R,K)\t\n          GCD3 = R\t\t\n        END FUNCTION GCD3\n\n        REAL*8 FUNCTION HERO(SIDE)\t\nCalculations could proceed with non-integer sides.\n         INTEGER SIDE(3)\t\n         REAL*8 S\t\t\n          S = SUM(SIDE)\t\t\n          S = S/2\t\t\n          S = S*PRODUCT(S - SIDE)\t\n          HERO = SIGN(SQRT(ABS(S)),S)\t\n        END FUNCTION HERO\t\t\n      END MODULE GREEK MATHEMATICIANS\t\n\n      PROGRAM TEST\t\t\n      USE GREEK MATHEMATICIANS\t\n      INTEGER LIMIT,LOTS\t\n      PARAMETER (LIMIT = 200, LOTS = 666)\t\n      INTEGER I,J,K,SIDE(3)\t\n      EQUIVALENCE (SIDE(1),I),(SIDE(2),J),(SIDE(3),K)\t\n      REAL*8 A\t\t\t\n      TYPE ABLOB\t\t\n       INTEGER SIDE(3)\t\t\n       INTEGER PERIMETER\t\n       INTEGER AREA\t\t\n      END TYPE ABLOB\t\t\n      TYPE(ABLOB) STASH(LOTS)\t\n      INTEGER N,XNDX(LOTS)\t\n      INTEGER H,T\t\t\n      LOGICAL CURSE\t\t\n      INTEGER TASTE,CHOICE\t\n      PARAMETER (TASTE = 10, CHOICE = 210)\t\n\nCollect some triangles.\n      N = 0\t\n      DO K = 1,LIMIT\t\n        DO J = 1,K\t\t\n          DO I = 1,J\t\t\t\n            IF (GCD3(I,J,K).GT.1) CYCLE\t\n            A = HERO(SIDE)\t\t\n            IF (A.LE.0) CYCLE\t\t\n            IF (A .NE. INT(A)) CYCLE\t\n            N = N + 1\t\t\t\n            IF (N.GT.LOTS) STOP \"Too many\n            XNDX(N) = N\t\t\t\n            STASH(N).SIDE = SIDE\t\t\n            STASH(N).PERIMETER = SUM(SIDE)\t\n            STASH(N).AREA = A\t\t\t\nc            WRITE (6,10) N,STASH(N)\n   10       FORMAT (I4,\":\",3I4,I7,I8)\t\n          END DO\n        END DO\n      END DO\n      WRITE (6,11) N,LIMIT\t\n   11 FORMAT (I0,\" triangles of integral area. Sides up to \",I0)\n\nComb sort involves coding only one test, and the comparison is to be compound...\n      H = N - 1\t\n   20 H = MAX(1,H*10/13)\t\n      IF (H.EQ.9 .OR. H.EQ.10) H = 11\t\n      CURSE = .FALSE.\t\t\n      DO 24 I = N - H,1,-1\t\n        IF (STASH(XNDX(I)).AREA - STASH(XNDX(I + H)).AREA) 24,21,23 \t\n   21   IF (STASH(XNDX(I)).PERIMETER-STASH(XNDX(I+H)).PERIMETER)24,22,23 \t\n   22   IF (MAXVAL(STASH(XNDX(I)).SIDE)\t\t\t\n     1    - MAXVAL(STASH(XNDX(I+H)).SIDE)) 24,24,23\t\n   23     T=XNDX(I); XNDX(I)=XNDX(I+H); XNDX(I+H)=T\t\n          CURSE = .TRUE.\t\t\t\n   24 CONTINUE\t\t\t\t\n      IF (CURSE .OR. H.GT.1) GO TO 20\t\n\nCast forth the results, as per the specification.\n      WRITE (6,30) TASTE\n   30 FORMAT (\"First \",I0,\", ordered by area, perimeter, longest side.\",\n     1 /,\"Index ---Sides--- Perimeter Area\")\n      DO I = 1,TASTE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\n      END DO\n\n      WRITE (6,31) CHOICE\n   31 FORMAT (\"Those triangles with area\",I7)\n      DO I = 1,N\t\n        IF (STASH(XNDX(I)).AREA.NE.CHOICE) CYCLE\n        WRITE (6,10) XNDX(I),STASH(XNDX(I))\t\n      END DO\t\t\n      END\n", "target": "from __future__ import division, print_function\nfrom math import gcd, sqrt\n\n\ndef hero(a, b, c):\n    s = (a + b + c) / 2\n    a2 = s * (s - a) * (s - b) * (s - c)\n    return sqrt(a2) if a2 > 0 else 0\n\n\ndef is_heronian(a, b, c):\n    a = hero(a, b, c)\n    return a > 0 and a.is_integer()\n\n\ndef gcd3(x, y, z):\n    return gcd(gcd(x, y), z)\n\n\nif __name__ == '__main__':\n    MAXSIDE = 200\n\n    N = 1 + MAXSIDE\n    h = [(x, y, z)\n         for x in range(1, N)\n         for y in range(x, N)\n         for z in range(y, N) if (x + y > z) and\n         1 == gcd3(x, y, z) and\n         is_heronian(x, y, z)]\n\n    \n    h.sort(key=lambda x: (hero(*x), sum(x), x[::-1]))\n\n    print(\n        'Primitive Heronian triangles with sides up to %i:' % MAXSIDE, len(h)\n    )\n    print('\\nFirst ten when ordered by increasing area, then perimeter,',\n          'then maximum sides:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h[:10]))\n    print('\\nAll with area 210 subject to the previous ordering:')\n    print('\\n'.join('  %14r perim: %3i area: %i'\n                    % (sides, sum(sides), hero(*sides)) for sides in h\n                    if hero(*sides) == 210))\n"}
{"id": 34901, "name": "Averages_Median", "source": "Translate Fortran to C#: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "using System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            \n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                \n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                \n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 34905, "name": "Averages_Median", "source": "Translate Fortran to Java: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "\npublic static double median(List<Double> list) {\n    Collections.sort(list);\n    return (list.get(list.size() / 2) + list.get((list.size() - 1) / 2)) / 2;\n}\n"}
{"id": 34906, "name": "Averages_Median", "source": "Translate Fortran to Python: program Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      \n      \n      \n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       \n       \n       \n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n", "target": "def median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n"}
{"id": 35104, "name": "Pointers and references", "source": "Translate Fortran to C#: real, pointer :: pointertoreal\n", "target": "static void Main(string[] args)\n{\n\tint p;\n\n\tp = 1;\n\tConsole.WriteLine(\"Ref Before: \" + p);\n\tValue(ref p);\n\tConsole.WriteLine(\"Ref After\u00a0: \" + p);\n\n\tp = 1;\n\tConsole.WriteLine(\"Val Before: \" + p);\n\tValue(p);\n\tConsole.WriteLine(\"Val After\u00a0: \" + p);\n\n\tConsole.ReadLine();\n}\n\nprivate static void Value(ref int Value)\n{\n\tValue += 1;\n}\nprivate static void Value(int Value)\n{\n\tValue += 1;\n}\n"}
{"id": 35105, "name": "Pointers and references", "source": "Translate Fortran to Java: real, pointer :: pointertoreal\n", "target": " public class Foo { public int x = 0; }\n\n void somefunction() {\n     Foo a; \n     a = new Foo(); \n     Foo b = a; \n     a.x = 5; \n     System.out.println(b.x); \n }\n"}
{"id": 35106, "name": "Pointers and references", "source": "Translate Fortran to Python: real, pointer :: pointertoreal\n", "target": " \n a = \"foo\"\n \n b = []\n \n class Foo(object):\n     pass\n c = Foo()\n \n class Bar(object):\n     def __init__(self, initializer = None)\n         \n         if initializer is not None:\n            self.value = initializer\n d = Bar(10)\n print d.value\n \n if a is b: pass\n \n if id(a) == id(b): pass\n \n def a(fmt, *args):\n     if fmt is None:\n         fmt = \"%s\"\n      print fmt % (args)\n \n b.append(a)\n \n del(a)\n \n b[0](\"foo\")  \n              \n"}
{"id": 35310, "name": "Sierpinski triangle", "source": "Translate Fortran to C#: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "using System;\nusing System.Collections;\n\nnamespace RosettaCode {\n    class SierpinskiTriangle {\n        int len;\n        BitArray b;\n\n        public SierpinskiTriangle(int n) {\n            if (n < 1) {\n                throw new ArgumentOutOfRangeException(\"Order must be greater than zero\");\n            }\n            len = 1 << (n+1);\n            b = new BitArray(len+1, false);\n            b[len>>1] = true;\n        }\n\n        public void Display() {\n            for (int j = 0; j < len / 2; j++) {\n                for (int i = 0; i < b.Count; i++) {\n                    Console.Write(\"{0}\", b[i] ? \"*\" : \" \");\n                }\n                Console.WriteLine();\n                NextGen();\n            }\n        }\n\n        private void NextGen() {\n            BitArray next = new BitArray(b.Count, false);\n            for (int i = 0; i < b.Count; i++) {\n                if (b[i]) {\n                    next[i - 1] = next[i - 1] ^ true;\n                    next[i + 1] = next[i + 1] ^ true;\n                }\n            }\n            b = next;\n        }\n    }\n}\n"}
{"id": 35313, "name": "Sierpinski triangle", "source": "Translate Fortran to Java: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "public class SierpinskiTriangle {\n\n    public static void main(String[] args) {\n        System.out.println(getSierpinskiTriangle(4));\n    }\n    \n    private static final String getSierpinskiTriangle(int n) {\n        if ( n == 0 ) {\n            return \"*\";\n        }\n\n        String s = getSierpinskiTriangle(n-1);\n        String [] split = s.split(\"\\n\");\n        int length = split.length;\n\n        \n        StringBuilder sb = new StringBuilder();\n        String top = buildSpace((int)Math.pow(2, n-1));\n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(top);\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        \n        \n        for ( int i = 0 ; i < length ;i++ ) {\n            sb.append(split[i]);\n            sb.append(buildSpace(length-i));\n            sb.append(split[i]);\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n    \n    private static String buildSpace(int n) {\n        StringBuilder sb = new StringBuilder();\n        while ( n > 0 ) {\n            sb.append(\" \");\n            n--;\n        }\n        return sb.toString();\n    }\n    \n}\n"}
{"id": 35314, "name": "Sierpinski triangle", "source": "Translate Fortran to Python: program Sierpinski_triangle\n  implicit none\n  \n  call Triangle(4)\n\ncontains\n\nsubroutine Triangle(n)\n  implicit none\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, intent(in) :: n\n  integer :: i, k\n  integer(i64) :: c\n  \n  do i = 0, n*4-1\n    c = 1\n    write(*, \"(a)\", advance=\"no\") repeat(\" \", 2 * (n*4 - 1 - i))\n    do k = 0, i\n      if(mod(c, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"    \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"  * \"\n      end if\n      c = c * (i - k) / (k + 1)\n    end do\n    write(*,*)\n  end do\nend subroutine Triangle\nend program Sierpinski_triangle\n", "target": "def sierpinski(n):\n    d = [\"*\"]\n    for i in xrange(n):\n        sp = \" \" * (2 ** i)\n        d = [sp+x+sp for x in d] + [x+\" \"+x for x in d]\n    return d\n\nprint \"\\n\".join(sierpinski(4))\n"}
{"id": 35631, "name": "Globally replace text in several files", "source": "Translate Fortran to C#:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35632, "name": "Globally replace text in several files", "source": "Translate Fortran to C#:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "using System.Collections.Generic;\nusing System.IO;\n\nclass Program {\n    static void Main() {\n        var files = new List<string> {\n            \"test1.txt\",\n            \"test2.txt\"\n        };\n        foreach (string file in files) {\n            File.WriteAllText(file, File.ReadAllText(file).Replace(\"Goodbye London!\", \"Hello New York!\"));\n        }\n    }\n}\n"}
{"id": 35637, "name": "Globally replace text in several files", "source": "Translate Fortran to Java:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35638, "name": "Globally replace text in several files", "source": "Translate Fortran to Java:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import java.io.*;\nimport java.nio.file.*;\n\npublic class GloballyReplaceText {\n\n    public static void main(String[] args) throws IOException {\n\n        for (String fn : new String[]{\"test1.txt\", \"test2.txt\"}) {\n            String s = new String(Files.readAllBytes(Paths.get(fn)));\n            s = s.replace(\"Goodbye London!\", \"Hello New York!\");\n            try (FileWriter fw = new FileWriter(fn)) {\n                fw.write(s);\n            }\n        }\n    }\n}\n"}
{"id": 35639, "name": "Globally replace text in several files", "source": "Translate Fortran to Python:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 35640, "name": "Globally replace text in several files", "source": "Translate Fortran to Python:       SUBROUTINE FILEHACK(FNAME,THIS,THAT)\t\n       CHARACTER*(*) FNAME\t\n       CHARACTER*(*) THIS\t\n       CHARACTER*(*) THAT\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       INTEGER L\t\t\n       CHARACTER*6666 ALINE\t\n       LOGICAL AHIT\t\t\n        INQUIRE(FILE = FNAME, EXIST = AHIT)\t\n        IF (.NOT.AHIT) RETURN\t\t\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\")\t\n        OPEN (T,STATUS=\"SCRATCH\")\t\n        AHIT = .FALSE.\t\t\nChew through the input, replacing THIS by THAT while writing to the temporary file..\n   10   READ (F,11,END = 20) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n        IF (L.GT.LEN(ALINE)) STOP \"Monster record\n   11   FORMAT (Q,A)\t\t\n        L1 = 1\t\t\t\n   12   L2 = INDEX(ALINE(L1:L),THIS)\t\n        IF (L2.LE.0) THEN\t\t\n          WRITE (T,13) ALINE(L1:L)\t\n   13     FORMAT (A)\t\t\t\n          GO TO 10\t\t\t\n        END IF\t\t\t\t\n   14   L2 = L1 + L2 - 2\t\n        WRITE (T,15) ALINE(L1:L2)\t\n   15   FORMAT (A,$)\t\t\t\n        WRITE (T,15) THAT\t\t\n        AHIT = .TRUE.\t\t\t\n        L1 = L2 + LEN(THIS) + 1\t\t\n        IF (L - L1 + 1 .GE. LEN(THIS)) GO TO 12\t\n        WRITE (T,13) ALINE(L1:L)\t\n        GO TO 10\t\t\nCopy the temporary file back over the source file. Hope for no mishap and data loss\n   20   IF (AHIT) THEN\t\n          CLOSE (F)\t\t\n          REWIND T\t\t\n          OPEN (F,FILE=\"new\"//FNAME,STATUS = \"REPLACE\",ACTION = \"WRITE\")\t\n   21     READ (T,11,END = 22) L,ALINE(1:MIN(L,LEN(ALINE)))\t\n          IF (L.GT.LEN(ALINE)) STOP \"Monster changed record\n          WRITE (F,13) ALINE(1:L) \t\t\n          GO TO 21\t\t\t\n        END IF\t\t\n   22   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\n\n      PROGRAM ATTACK\n      INTEGER N\n      PARAMETER (N = 6)\t\t\n      CHARACTER*48 VICTIM(N)\t\n      DATA VICTIM/\t\t\n     1 \"StaffStory.txt\",\n     2 \"Accounts.dat\",\n     3 \"TravelAgent.txt\",\n     4 \"RemovalFirm.dat\",\n     5 \"Addresses.txt\",\n     6 \"SongLyrics.txt\"/\t\n\n      DO I = 1,N\t\n        CALL FILEHACK(VICTIM(I),\"Goodbye London\n      END DO\t\t\n\n      END\n", "target": "import fileinput\n\nfor line in fileinput.input(inplace=True):\n    print(line.replace('Goodbye London!', 'Hello New York!'), end='')\n"}
{"id": 35974, "name": "Continued fraction", "source": "Translate Fortran to C#: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 35975, "name": "Continued fraction", "source": "Translate Fortran to C#: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ContinuedFraction {\n    class Program {\n        static double Calc(Func<int, int[]> f, int n) {\n            double temp = 0.0;\n            for (int ni = n; ni >= 1; ni--) {\n                int[] p = f(ni);\n                temp = p[1] / (p[0] + temp);\n            }\n            return f(0)[0] + temp;\n        }\n\n        static void Main(string[] args) {\n            List<Func<int, int[]>> fList = new List<Func<int, int[]>>();\n            fList.Add(n => new int[] { n > 0 ? 2 : 1, 1 });\n            fList.Add(n => new int[] { n > 0 ? n : 2, n > 1 ? (n - 1) : 1 });\n            fList.Add(n => new int[] { n > 0 ? 6 : 3, (int) Math.Pow(2 * n - 1, 2) });\n\n            foreach (var f in fList) {\n                Console.WriteLine(Calc(f, 200));\n            }\n        }\n    }\n}\n"}
{"id": 35981, "name": "Continued fraction", "source": "Translate Fortran to Java: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 35982, "name": "Continued fraction", "source": "Translate Fortran to Java: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "import static java.lang.Math.pow;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Test {\n    static double calc(Function<Integer, Integer[]> f, int n) {\n        double temp = 0;\n\n        for (int ni = n; ni >= 1; ni--) {\n            Integer[] p = f.apply(ni);\n            temp = p[1] / (double) (p[0] + temp);\n        }\n        return f.apply(0)[0] + temp;\n    }\n\n    public static void main(String[] args) {\n        List<Function<Integer, Integer[]>> fList = new ArrayList<>();\n        fList.add(n -> new Integer[]{n > 0 ? 2 : 1, 1});\n        fList.add(n -> new Integer[]{n > 0 ? n : 2, n > 1 ? (n - 1) : 1});\n        fList.add(n -> new Integer[]{n > 0 ? 6 : 3, (int) pow(2 * n - 1, 2)});\n\n        for (Function<Integer, Integer[]> f : fList)\n            System.out.println(calc(f, 200));\n    }\n}\n"}
{"id": 35983, "name": "Continued fraction", "source": "Translate Fortran to Python: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 35984, "name": "Continued fraction", "source": "Translate Fortran to Python: module continued_fractions\n  implicit none\n  \n  integer, parameter :: long = selected_real_kind(7,99)\n\n  type continued_fraction\n    integer                            :: a0, b1\n    procedure(series), pointer, nopass :: a, b\n  end type\n\n  interface\n    pure function series (n)\n      integer, intent(in) :: n\n      integer             :: series\n    end function\n  end interface\n\ncontains\n\n  pure function define_cf (a0,a,b1,b) result(x)\n    integer, intent(in)           :: a0\n    procedure(series)             :: a\n    integer, intent(in), optional :: b1\n    procedure(series),   optional :: b\n    type(continued_fraction)      :: x\n    x%a0 = a0\n    x%a => a\n    if ( present(b1) ) then\n       x%b1 = b1\n    else\n       x%b1 = 1\n    end if\n    if ( present(b) ) then\n       x%b => b\n    else\n       x%b => const_1\n    end if\n  end function define_cf\n\n  pure integer function const_1(n)\n    integer,intent(in) :: n\n    const_1 = 1  \n  end function\n\n  pure real(kind=long) function output(x,iterations)\n    type(continued_fraction), intent(in) :: x\n    integer,                  intent(in) :: iterations\n    integer                              :: i\n    output = x%a(iterations)\n    do i = iterations-1,1,-1\n      output = x%a(i) + (x%b(i+1) / output)\n    end do\n    output = x%a0 + (x%b1 / output)\n  end function output\n  \nend module continued_fractions\n\n\nprogram examples\n  use continued_fractions\n\n  type(continued_fraction) :: sqr2,napier,pi\n\n  sqr2   = define_cf(1,a_sqr2)\n  napier = define_cf(2,a_napier,1,b_napier)\n  pi     = define_cf(3,a=a_pi,b=b_pi)\n\n  write (*,*) output(sqr2,10000)\n  write (*,*) output(napier,10000)\n  write (*,*) output(pi,10000)\n\ncontains\n\n  pure integer function a_sqr2(n)\n    integer,intent(in) :: n\n    a_sqr2 = 2\n  end function\n\n  pure integer function a_napier(n)\n    integer,intent(in) :: n\n    a_napier = n\n  end function\n\n  pure integer function b_napier(n)\n    integer,intent(in) :: n\n    b_napier = n-1\n  end function\n\n  pure integer function a_pi(n)\n    integer,intent(in) :: n\n    a_pi = 6\n  end function\n\n  pure integer function b_pi(n)\n    integer,intent(in) :: n\n    b_pi = (2*n-1)*(2*n-1)\n  end function\n\nend program examples\n", "target": "from fractions import Fraction\nimport itertools\ntry: zip = itertools.izip\nexcept: pass\n \n\ndef CF(a, b, t):\n  terms = list(itertools.islice(zip(a, b), t))\n  z = Fraction(1,1)\n  for a, b in reversed(terms):\n    z = a + b / z\n  return z\n \n\ndef pRes(x, d):\n  q, x = divmod(x, 1)\n  res = str(q)\n  res += \".\"\n  for i in range(d):\n    x *= 10\n    q, x = divmod(x, 1)\n    res += str(q)\n  return res\n \n\ndef sqrt2_a():\n  yield 1\n  for x in itertools.repeat(2):\n    yield x\n \ndef sqrt2_b():\n  for x in itertools.repeat(1):\n    yield x\n \ncf = CF(sqrt2_a(), sqrt2_b(), 950)\nprint(pRes(cf, 200))\n\n \n \n\ndef Napier_a():\n  yield 2\n  for x in itertools.count(1):\n    yield x\n \ndef Napier_b():\n  yield 1\n  for x in itertools.count(1):\n    yield x\n \ncf = CF(Napier_a(), Napier_b(), 950)\nprint(pRes(cf, 200))\n\n \n\ndef Pi_a():\n  yield 3\n  for x in itertools.repeat(6):\n    yield x\n \ndef Pi_b():\n  for x in itertools.count(1,2):\n    yield x*x\n \ncf = CF(Pi_a(), Pi_b(), 950)\nprint(pRes(cf, 10))\n\n"}
{"id": 36431, "name": "Quine", "source": "Translate Fortran to C#: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36432, "name": "Quine", "source": "Translate Fortran to C#: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "class Program { static void Main() { var s = \"class Program {{ static void Main() {{ var s = {0}{1}{0}; System.Console.WriteLine(s, (char)34, s); }} }}\"; System.Console.WriteLine(s, (char)34, s); } }\n"}
{"id": 36438, "name": "Quine", "source": "Translate Fortran to Java: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36439, "name": "Quine", "source": "Translate Fortran to Java: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "module test\n    {\n    @Inject Console console;\n    void run()\n        {\n        console.print($./test.x);\n        }\n    }\n"}
{"id": 36440, "name": "Quine", "source": "Translate Fortran to Python: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 36441, "name": "Quine", "source": "Translate Fortran to Python: character*46::s='(\"character*46::s=\",3a,\";print s,39,s,39;end\")';print s,39,s,39;end\n", "target": "w = \"print('w = ' + chr(34) + w + chr(34) + chr(10) + w)\"\nprint('w = ' + chr(34) + w + chr(34) + chr(10) + w)\n"}
{"id": 37022, "name": "Problem of Apollonius", "source": "Translate Fortran to C#: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "using System;\n\nnamespace ApolloniusProblemCalc\n{\n    class Program\n    {\n        static float rs = 0;\n        static float xs = 0;\n        static float ys = 0;\n\n        public static void Main(string[] args)\n        {\n            float gx1;\n            float gy1;\n            float gr1;\n            float gx2;\n            float gy2;\n            float gr2;\n            float gx3;\n            float gy3;\n            float gr3;\n\n            \n            gx1 = 0;\n            gy1 = 0;\n            gr1 = 1;\n            gx2 = 4;\n            gy2 = 0;\n            gr2 = 1;\n            gx3 = 2;\n            gy3 = 4;\n            gr3 = 2;\n            \n\n            for (int i = 1; i <= 8; i++)\n            {\n                SolveTheApollonius(i, gx1, gy1, gr1, gx2, gy2, gr2, gx3, gy3, gr3);\n\n\n                if (i == 1)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"st solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"st solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"st Solution circle's radius: \" + rs.ToString());\n                }\n                else if (i == 2)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"ed solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"ed solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"ed Solution circle's radius: \" + rs.ToString());\n                }\n                else if(i == 3)\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"rd solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"rd solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"rd Solution circle's radius: \" + rs.ToString());\n                }\n                else\n                {\n                    Console.WriteLine(\"X of point of the \" + i + \"th solution: \" + xs.ToString());\n                    Console.WriteLine(\"Y of point of the \" + i + \"th solution: \" + ys.ToString());\n                    Console.WriteLine(i + \"th Solution circle's radius: \" + rs.ToString());\n                }\n\n                Console.WriteLine();\n            }\n\n\n            Console.ReadKey(true);\n        }\n\n        private static void SolveTheApollonius(int calcCounter, float x1, float y1, float r1, float x2, float y2, float r2, float x3, float y3, float r3)\n        {\n            float s1 = 1;\n            float s2 = 1;\n            float s3 = 1;\n\n            if (calcCounter == 2)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 3)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = -1;\n            }\n            else if (calcCounter == 4)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 5)\n            {\n                s1 = -1;\n                s2 = -1;\n                s3 = 1;\n            }\n            else if (calcCounter == 6)\n            {\n                s1 = 1;\n                s2 = 1;\n                s3 = -1;\n            }\n            else if (calcCounter == 7)\n            {\n                s1 = -1;\n                s2 = 1;\n                s3 = 1;\n            }\n            else if (calcCounter == 8)\n            {\n                s1 = 1;\n                s2 = -1;\n                s3 = 1;\n            }\n\n            \n            float v11 = 2 * x2 - 2 * x1;\n            float v12 = 2 * y2 - 2 * y1;\n            float v13 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 - r1 * r1 + r2 * r2;\n            float v14 = 2 * s2 * r2 - 2 * s1 * r1;\n\n            float v21 = 2 * x3 - 2 * x2;\n            float v22 = 2 * y3 - 2 * y2;\n            float v23 = x2 * x2 - x3 * x3 + y2 * y2 - y3 * y3 - r2 * r2 + r3 * r3;\n            float v24 = 2 * s3 * r3 - 2 * s2 * r2;\n\n            float w12 = v12 / v11;\n            float w13 = v13 / v11;\n            float w14 = v14 / v11;\n\n            float w22 = v22 / v21 - w12;\n            float w23 = v23 / v21 - w13;\n            float w24 = v24 / v21 - w14;\n\n            float P = -w23 / w22;\n            float Q = w24 / w22;\n            float M = -w12 * P - w13;\n            float N = w14 - w12 * Q;\n\n            float a = N * N + Q * Q - 1;\n            float b = 2 * M * N - 2 * N * x1 + 2 * P * Q - 2 * Q * y1 + 2 * s1 * r1;\n            float c = x1 * x1 + M * M - 2 * M * x1 + P * P + y1 * y1 - 2 * P * y1 - r1 * r1;\n\n            float D = b * b - 4 * a * c;\n\n            rs = (-b - float.Parse(Math.Sqrt(D).ToString())) / (2 * float.Parse(a.ToString()));\n            xs = M + N * rs;\n            ys = P + Q * rs;\n        }\n    }\n}\n"}
{"id": 37025, "name": "Problem of Apollonius", "source": "Translate Fortran to Java: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "public class Circle\n{\n public double[] center;\n public double radius;\n public Circle(double[] center, double radius)\n {\n  this.center = center;\n  this.radius = radius;\n }\n public String toString()\n {\n  return String.format(\"Circle[x=%.2f,y=%.2f,r=%.2f]\",center[0],center[1],\n\t\t       radius);\n }\n}\n\npublic class ApolloniusSolver\n{\n\n public static Circle solveApollonius(Circle c1, Circle c2, Circle c3, int s1,\n\t\t\t\t      int s2, int s3)\n {\n  float x1 = c1.center[0];\n  float y1 = c1.center[1];\n  float r1 = c1.radius;\n  float x2 = c2.center[0];\n  float y2 = c2.center[1];\n  float r2 = c2.radius;\n  float x3 = c3.center[0];\n  float y3 = c3.center[1];\n  float r3 = c3.radius;\n\n  \n  \n  float v11 = 2*x2 - 2*x1;\n  float v12 = 2*y2 - 2*y1;\n  float v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2;\n  float v14 = 2*s2*r2 - 2*s1*r1;\n\n  float v21 = 2*x3 - 2*x2;\n  float v22 = 2*y3 - 2*y2;\n  float v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3;\n  float v24 = 2*s3*r3 - 2*s2*r2;\n\n  float w12 = v12/v11;\n  float w13 = v13/v11;\n  float w14 = v14/v11;\n\n  float w22 = v22/v21-w12;\n  float w23 = v23/v21-w13;\n  float w24 = v24/v21-w14;\n\n  float P = -w23/w22;\n  float Q = w24/w22;\n  float M = -w12*P-w13;\n  float N = w14 - w12*Q;\n\n  float a = N*N + Q*Q - 1;\n  float b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1;\n  float c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1;\n\n  \n  \n  float D = b*b-4*a*c;\n  float rs = (-b-Math.sqrt(D))/(2*a);\n  float xs = M + N * rs;\n  float ys = P + Q * rs;\n  return new Circle(new double[]{xs,ys}, rs);\n }\n public static void main(final String[] args)\n {\n  Circle c1 = new Circle(new double[]{0,0}, 1);\n  Circle c2 = new Circle(new double[]{4,0}, 1);\n  Circle c3 = new Circle(new double[]{2,4}, 2);\n  \n  System.out.println(solveApollonius(c1,c2,c3,1,1,1));\n  \n  System.out.println(solveApollonius(c1,c2,c3,-1,-1,-1));\n }\n}\n"}
{"id": 37026, "name": "Problem of Apollonius", "source": "Translate Fortran to Python: program Apollonius\n  implicit none\n\n  integer, parameter :: dp = selected_real_kind(15)\n\n  type circle\n    real(dp) :: x\n    real(dp) :: y\n    real(dp) :: radius\n  end type\n       \n  type(circle) :: c1 , c2, c3, r\n\n  c1 = circle(0.0, 0.0, 1.0)\n  c2 = circle(4.0, 0.0, 1.0)\n  c3 = circle(2.0, 4.0, 2.0)\n\n  write(*, \"(a,3f12.8))\") \"External tangent:\", SolveApollonius(c1, c2, c3, 1, 1, 1)\n  write(*, \"(a,3f12.8))\") \"Internal tangent:\", SolveApollonius(c1, c2, c3, -1, -1, -1)\n \ncontains\n\nfunction SolveApollonius(c1, c2, c3, s1, s2, s3) result(res)\n  type(circle) :: res\n  type(circle), intent(in) :: c1, c2, c3\n  integer, intent(in) :: s1, s2, s3\n \n  real(dp) :: x1, x2, x3, y1, y2, y3, r1, r2, r3\n  real(dp) :: v11, v12, v13, v14\n  real(dp) :: v21, v22, v23, v24\n  real(dp) :: w12, w13, w14\n  real(dp) :: w22, w23, w24\n  real(dp) :: p, q, m, n, a, b, c, det\n  \n  x1 = c1%x; x2 = c2%x; x3 = c3%x\n  y1 = c1%y; y2 = c2%y; y3 = c3%y\n  r1 = c1%radius; r2 = c2%radius; r3 = c3%radius\n\n  v11 = 2*x2 - 2*x1\n  v12 = 2*y2 - 2*y1\n  v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n  v14 = 2*s2*r2 - 2*s1*r1\n \n  v21 = 2*x3 - 2*x2\n  v22 = 2*y3 - 2*y2\n  v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n  v24 = 2*s3*r3 - 2*s2*r2\n \n  w12 = v12/v11\n  w13 = v13/v11\n  w14 = v14/v11\n \n  w22 = v22/v21-w12\n  w23 = v23/v21-w13\n  w24 = v24/v21-w14\n \n  p = -w23/w22\n  q = w24/w22\n  m = -w12*P - w13\n  n = w14 - w12*q\n \n  a = n*n + q*q - 1\n  b = 2*m*n - 2*n*x1 + 2*p*q - 2*q*y1 + 2*s1*r1\n  c = x1*x1 + m*m - 2*m*x1 + p*p + y1*y1 - 2*p*y1 - r1*r1\n \n  det = b*b - 4*a*c\n  res%radius = (-b-sqrt(det)) / (2*a)\n  res%x = m + n*res%radius\n  res%y = p + q*res%radius\n\nend function\nend program\n", "target": "from collections import namedtuple\nimport math\n\nCircle = namedtuple('Circle', 'x, y, r')\n \ndef solveApollonius(c1, c2, c3, s1, s2, s3):\n    \n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    x3, y3, r3 = c3\n\n    v11 = 2*x2 - 2*x1\n    v12 = 2*y2 - 2*y1\n    v13 = x1*x1 - x2*x2 + y1*y1 - y2*y2 - r1*r1 + r2*r2\n    v14 = 2*s2*r2 - 2*s1*r1\n \n    v21 = 2*x3 - 2*x2\n    v22 = 2*y3 - 2*y2\n    v23 = x2*x2 - x3*x3 + y2*y2 - y3*y3 - r2*r2 + r3*r3\n    v24 = 2*s3*r3 - 2*s2*r2\n \n    w12 = v12/v11\n    w13 = v13/v11\n    w14 = v14/v11\n \n    w22 = v22/v21-w12\n    w23 = v23/v21-w13\n    w24 = v24/v21-w14\n \n    P = -w23/w22\n    Q = w24/w22\n    M = -w12*P-w13\n    N = w14 - w12*Q\n \n    a = N*N + Q*Q - 1\n    b = 2*M*N - 2*N*x1 + 2*P*Q - 2*Q*y1 + 2*s1*r1\n    c = x1*x1 + M*M - 2*M*x1 + P*P + y1*y1 - 2*P*y1 - r1*r1\n \n    \n    D = b*b-4*a*c\n    rs = (-b-math.sqrt(D))/(2*a)\n \n    xs = M+N*rs\n    ys = P+Q*rs\n \n    return Circle(xs, ys, rs)\n\nif __name__ == '__main__':\n    c1, c2, c3 = Circle(0, 0, 1), Circle(4, 0, 1), Circle(2, 4, 2)\n    print(solveApollonius(c1, c2, c3, 1, 1, 1))    \n    print(solveApollonius(c1, c2, c3, -1, -1, -1)) \n"}
{"id": 37198, "name": "Sequence of non-squares", "source": "Translate Fortran to C#: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": "using System;\nusing System.Diagnostics;\n\nnamespace sons\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i < 23; i++)            \n                Console.WriteLine(nonsqr(i));            \n\n            for (int i = 1; i < 1000000; i++)\n            {\n                double j = Math.Sqrt(nonsqr(i));\n                Debug.Assert(j != Math.Floor(j),\"Square\");\n            }            \n        }\n\n        static int nonsqr(int i)\n        {\n            return (int)(i + Math.Floor(0.5 + Math.Sqrt(i)));\n        }\n    }\n}\n"}
{"id": 37201, "name": "Sequence of non-squares", "source": "Translate Fortran to Java: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": "public class SeqNonSquares {\n    public static int nonsqr(int n) {\n        return n + (int)Math.round(Math.sqrt(n));\n    }\n    \n    public static void main(String[] args) {\n        \n        for (int i = 1; i < 23; i++)\n            System.out.print(nonsqr(i) + \" \");\n        System.out.println();\n        \n        \n        for (int i = 1; i < 1000000; i++) {\n            double j = Math.sqrt(nonsqr(i));\n            assert j != Math.floor(j);\n        }\n    }\n}\n"}
{"id": 37202, "name": "Sequence of non-squares", "source": "Translate Fortran to Python: PROGRAM NONSQUARES\n\n  IMPLICIT NONE\n\n  INTEGER :: m, n, nonsqr\n      \n  DO n = 1, 22\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))  \n    WRITE(*,*) nonsqr\n  END DO\n\n  DO n = 1, 1000000\n    nonsqr =  n + FLOOR(0.5 + SQRT(REAL(n)))\n    m = INT(SQRT(REAL(nonsqr)))\n    IF (m*m == nonsqr) THEN\n      WRITE(*,*) \"Square found, n=\", n\n    END IF\n  END DO\n\nEND PROGRAM NONSQUARES\n", "target": ">>> from math import floor, sqrt\n>>> def non_square(n):\n        return n + floor(1/2 + sqrt(n))\n\n>>> \n>>> print(*map(non_square, range(1, 23)))\n2 3 5 6 7 8 10 11 12 13 14 15 17 18 19 20 21 22 23 24 26 27\n\n>>> \n>>> def is_square(n):\n        return sqrt(n).is_integer()\n\n>>> non_squares = map(non_square, range(1, 10 ** 6))\n>>> next(filter(is_square, non_squares))\nStopIteration                             Traceback (most recent call last)\n<ipython-input-45-f32645fc1c0a> in <module>()\n      1 non_squares = map(non_square, range(1, 10 ** 6))\n----> 2 next(filter(is_square, non_squares))\n\nStopIteration:\n"}
{"id": 37508, "name": "Quaternion type", "source": "Translate Fortran to C#: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37509, "name": "Quaternion type", "source": "Translate Fortran to C#: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "using System;\n\nstruct Quaternion : IEquatable<Quaternion>\n{\n    public readonly double A, B, C, D;\n\n    public Quaternion(double a, double b, double c, double d)\n    {\n        this.A = a;\n        this.B = b;\n        this.C = c;\n        this.D = d;\n    }\n\n    public double Norm()\n    {\n        return Math.Sqrt(A * A + B * B + C * C + D * D);\n    }\n\n    public static Quaternion operator -(Quaternion q)\n    {\n        return new Quaternion(-q.A, -q.B, -q.C, -q.D);\n    }\n\n    public Quaternion Conjugate()\n    {\n        return new Quaternion(A, -B, -C, -D);\n    }\n\n    \n    public static implicit operator Quaternion(double d)\n    {\n        return new Quaternion(d, 0, 0, 0);\n    }\n\n    public static Quaternion operator +(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(q1.A + q2.A, q1.B + q2.B, q1.C + q2.C, q1.D + q2.D);\n    }\n\n    public static Quaternion operator *(Quaternion q1, Quaternion q2)\n    {\n        return new Quaternion(\n            q1.A * q2.A - q1.B * q2.B - q1.C * q2.C - q1.D * q2.D,\n            q1.A * q2.B + q1.B * q2.A + q1.C * q2.D - q1.D * q2.C,\n            q1.A * q2.C - q1.B * q2.D + q1.C * q2.A + q1.D * q2.B,\n            q1.A * q2.D + q1.B * q2.C - q1.C * q2.B + q1.D * q2.A);\n    }\n\n    public static bool operator ==(Quaternion q1, Quaternion q2)\n    {\n        return q1.A == q2.A && q1.B == q2.B && q1.C == q2.C && q1.D == q2.D;\n    }\n\n    public static bool operator !=(Quaternion q1, Quaternion q2)\n    {\n        return !(q1 == q2);\n    }\n\n    #region Object Members\n\n    public override bool Equals(object obj)\n    {\n        if (obj is Quaternion)\n            return Equals((Quaternion)obj);\n\n        return false;\n    }\n\n    public override int GetHashCode()\n    {\n        return A.GetHashCode() ^ B.GetHashCode() ^ C.GetHashCode() ^ D.GetHashCode();\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"Q({0}, {1}, {2}, {3})\", A, B, C, D);\n    }\n\n    #endregion\n\n    #region IEquatable<Quaternion> Members\n\n    public bool Equals(Quaternion other)\n    {\n        return other == this;\n    }\n\n    #endregion\n}\n"}
{"id": 37516, "name": "Quaternion type", "source": "Translate Fortran to Java: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37517, "name": "Quaternion type", "source": "Translate Fortran to Java: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "public class Quaternion {\n    private final double a, b, c, d;\n\n    public Quaternion(double a, double b, double c, double d) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n    public Quaternion(double r) {\n        this(r, 0.0, 0.0, 0.0);\n    }\n\n    public double norm() {\n        return Math.sqrt(a * a + b * b + c * c + d * d);\n    }\n\n    public Quaternion negative() {\n        return new Quaternion(-a, -b, -c, -d);\n    }\n\n    public Quaternion conjugate() {\n        return new Quaternion(a, -b, -c, -d);\n    }\n\n    public Quaternion add(double r) {\n        return new Quaternion(a + r, b, c, d);\n    }\n    public static Quaternion add(Quaternion q, double r) {\n        return q.add(r);\n    }\n    public static Quaternion add(double r, Quaternion q) {\n        return q.add(r);\n    }\n    public Quaternion add(Quaternion q) {\n        return new Quaternion(a + q.a, b + q.b, c + q.c, d + q.d);\n    }\n    public static Quaternion add(Quaternion q1, Quaternion q2) {\n        return q1.add(q2);\n    }\n\n    public Quaternion times(double r) {\n        return new Quaternion(a * r, b * r, c * r, d * r);\n    }\n    public static Quaternion times(Quaternion q, double r) {\n        return q.times(r);\n    }\n    public static Quaternion times(double r, Quaternion q) {\n        return q.times(r);\n    }\n    public Quaternion times(Quaternion q) {\n        return new Quaternion(\n            a * q.a - b * q.b - c * q.c - d * q.d,\n            a * q.b + b * q.a + c * q.d - d * q.c,\n            a * q.c - b * q.d + c * q.a + d * q.b,\n            a * q.d + b * q.c - c * q.b + d * q.a\n        );\n    }\n    public static Quaternion times(Quaternion q1, Quaternion q2) {\n        return q1.times(q2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof Quaternion)) return false;\n        final Quaternion other = (Quaternion) obj;\n        if (Double.doubleToLongBits(this.a) != Double.doubleToLongBits(other.a)) return false;\n        if (Double.doubleToLongBits(this.b) != Double.doubleToLongBits(other.b)) return false;\n        if (Double.doubleToLongBits(this.c) != Double.doubleToLongBits(other.c)) return false;\n        if (Double.doubleToLongBits(this.d) != Double.doubleToLongBits(other.d)) return false;\n        return true;\n    }\n    @Override\n    public String toString() {\n        return String.format(\"%.2f +\u00a0%.2fi +\u00a0%.2fj +\u00a0%.2fk\", a, b, c, d).replaceAll(\"\\\\+ -\", \"- \");\n    }\n\n    public String toQuadruple() {\n        return String.format(\"(%.2f,\u00a0%.2f,\u00a0%.2f,\u00a0%.2f)\", a, b, c, d);\n    }\n\n    public static void main(String[] args) {\n        Quaternion q = new Quaternion(1.0, 2.0, 3.0, 4.0);\n        Quaternion q1 = new Quaternion(2.0, 3.0, 4.0, 5.0);\n        Quaternion q2 = new Quaternion(3.0, 4.0, 5.0, 6.0);\n        double r = 7.0;\n        System.out.format(\"q       = %s%n\", q);\n        System.out.format(\"q1      = %s%n\", q1);\n        System.out.format(\"q2      = %s%n\", q2);\n        System.out.format(\"r       =\u00a0%.2f%n%n\", r);\n        System.out.format(\"\\u2016q\\u2016     =\u00a0%.2f%n\", q.norm());\n        System.out.format(\"-q      = %s%n\", q.negative());\n        System.out.format(\"q*      = %s%n\", q.conjugate());\n        System.out.format(\"q + r   = %s%n\", q.add(r));\n        System.out.format(\"q1 + q2 = %s%n\", q1.add(q2));\n        System.out.format(\"q \\u00d7 r   = %s%n\", q.times(r));\n        Quaternion q1q2 = q1.times(q2);\n        Quaternion q2q1 = q2.times(q1);\n        System.out.format(\"q1 \\u00d7 q2 = %s%n\", q1q2);\n        System.out.format(\"q2 \\u00d7 q1 = %s%n\", q2q1);\n        System.out.format(\"q1 \\u00d7 q2 %s q2 \\u00d7 q1%n\", (q1q2.equals(q2q1) ? \"=\" : \"\\u2260\"));\n    }\n}\n"}
{"id": 37518, "name": "Quaternion type", "source": "Translate Fortran to Python: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37519, "name": "Quaternion type", "source": "Translate Fortran to Python: module Q_mod\n  implicit none\n\n  type quaternion\n    real :: a, b, c, d\n  end type\n\n  public :: norm, neg, conj\n  public :: operator (+)\n  public :: operator (*)\n  \n  private ::  q_plus_q, q_plus_r, r_plus_q, &\n              q_mult_q, q_mult_r, r_mult_q, &\n              norm_q, neg_q, conj_q\n\n  interface norm\n    module procedure norm_q\n  end interface\n\n  interface neg\n    module procedure neg_q\n  end interface\n\n  interface conj\n    module procedure conj_q\n  end interface\n\n  interface operator (+)\n    module procedure q_plus_q, q_plus_r, r_plus_q\n  end interface\n\n  interface operator (*)\n    module procedure q_mult_q, q_mult_r, r_mult_q\n  end interface\n\ncontains\n\nfunction norm_q(x) result(res)\n  real :: res\n  type (quaternion), intent (in) :: x\n\n  res = sqrt(x%a*x%a + x%b*x%b + x%c*x%c + x%d*x%d)\n  \nend function norm_q\n\nfunction neg_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = -x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function neg_q\n\nfunction conj_q(x) result(res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x\n\n  res%a = x%a\n  res%b = -x%b\n  res%c = -x%c\n  res%d = -x%d\n  \nend function conj_q\n\nfunction q_plus_q(x, y) result (res)\n  type (quaternion) :: res\n  type (quaternion), intent (in) :: x, y\n   \n  res%a = x%a + y%a\n  res%b = x%b + y%b\n  res%c = x%c + y%c\n  res%d = x%d + y%d\n   \nend function q_plus_q\n\nfunction q_plus_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function q_plus_r\n\nfunction r_plus_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) :: r\n   \n   res = x\n   res%a = x%a + r\n   \nend function r_plus_q\n\nfunction q_mult_q(x, y) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x, y\n   \n   res%a = x%a*y%a - x%b*y%b - x%c*y%c - x%d*y%d\n   res%b = x%a*y%b + x%b*y%a + x%c*y%d - x%d*y%c\n   res%c = x%a*y%c - x%b*y%d + x%c*y%a + x%d*y%b\n   res%d = x%a*y%d + x%b*y%c - x%c*y%b + x%d*y%a\n   \nend function q_mult_q\n\nfunction q_mult_r(x, r) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function q_mult_r\n\nfunction r_mult_q(r, x) result (res)\n  type (quaternion) :: res \n  type (quaternion), intent (in) :: x\n  real, intent(in) ::  r\n   \n   res%a = x%a*r\n   res%b = x%b*r\n   res%c = x%c*r  \n   res%d = x%d*r \n   \nend function r_mult_q\nend module Q_mod\n\nprogram Quaternions\n  use Q_mod\n  implicit none\n\n  real :: r = 7.0\n  type(quaternion) :: q, q1, q2\n\n  q  = quaternion(1, 2, 3, 4)\n  q1 = quaternion(2, 3, 4, 5)\n  q2 = quaternion(3, 4, 5, 6)\n\n  write(*, \"(a, 4f8.3)\") \"             q = \", q\n  write(*, \"(a, 4f8.3)\") \"            q1 = \", q1\n  write(*, \"(a, 4f8.3)\") \"            q2 = \", q2\n  write(*, \"(a, f8.3)\")  \"             r = \", r\n  write(*, \"(a, f8.3)\")  \"     Norm of q = \", norm(q) \n  write(*, \"(a, 4f8.3)\") \" Negative of q = \", neg(q)\n  write(*, \"(a, 4f8.3)\") \"Conjugate of q = \", conj(q) \n  write(*, \"(a, 4f8.3)\") \"         q + r = \", q + r\n  write(*, \"(a, 4f8.3)\") \"         r + q = \", r + q\n  write(*, \"(a, 4f8.3)\") \"       q1 + q2 = \", q1 + q2\n  write(*, \"(a, 4f8.3)\") \"         q * r = \", q * r  \n  write(*, \"(a, 4f8.3)\") \"         r * q = \", r * q \n  write(*, \"(a, 4f8.3)\") \"       q1 * q2 = \", q1 * q2 \n  write(*, \"(a, 4f8.3)\") \"       q2 * q1 = \", q2 * q1 \n\nend program\n", "target": "from collections import namedtuple\nimport math\n\nclass Q(namedtuple('Quaternion', 'real, i, j, k')):\n    'Quaternion type: Q(real=0.0, i=0.0, j=0.0, k=0.0)' \n\n    __slots__ = () \n\n    def __new__(_cls, real=0.0, i=0.0, j=0.0, k=0.0):\n        'Defaults all parts of quaternion to zero'\n        return super().__new__(_cls, float(real), float(i), float(j), float(k))\n\n    def conjugate(self):\n        return Q(self.real, -self.i, -self.j, -self.k)\n\n    def _norm2(self):\n        return sum( x*x for x in self)\n\n    def norm(self):\n        return math.sqrt(self._norm2())\n\n    def reciprocal(self):\n        n2 = self._norm2()\n        return Q(*(x / n2 for x in self.conjugate())) \n\n    def __str__(self):\n        'Shorter form of Quaternion as string'\n        return 'Q(%g, %g, %g, %g)' % self\n\n    def __neg__(self):\n        return Q(-self.real, -self.i, -self.j, -self.k)\n\n    def __add__(self, other):\n        if type(other) == Q:\n            return Q( *(s+o for s,o in zip(self, other)) )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real + f, self.i, self.j, self.k)\n\n    def __radd__(self, other):\n        return Q.__add__(self, other)\n\n    def __mul__(self, other):\n        if type(other) == Q:\n            a1,b1,c1,d1 = self\n            a2,b2,c2,d2 = other\n            return Q(\n                 a1*a2 - b1*b2 - c1*c2 - d1*d2,\n                 a1*b2 + b1*a2 + c1*d2 - d1*c2,\n                 a1*c2 - b1*d2 + c1*a2 + d1*b2,\n                 a1*d2 + b1*c2 - c1*b2 + d1*a2 )\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real * f, self.i * f, self.j * f, self.k * f)\n\n    def __rmul__(self, other):\n        return Q.__mul__(self, other)\n\n    def __truediv__(self, other):\n        if type(other) == Q:\n            return self.__mul__(other.reciprocal())\n        try:\n            f = float(other)\n        except:\n            return NotImplemented\n        return Q(self.real / f, self.i / f, self.j / f, self.k / f)\n\n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n\n    __div__, __rdiv__ = __truediv__, __rtruediv__\n\nQuaternion = Q       \n\nq  = Q(1, 2, 3, 4)\nq1 = Q(2, 3, 4, 5)\nq2 = Q(3, 4, 5, 6)\nr  = 7\n"}
{"id": 37792, "name": "QR decomposition", "source": "Translate Fortran to C#: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "using System;\nusing MathNet.Numerics.LinearAlgebra;\nusing MathNet.Numerics.LinearAlgebra.Double;\n\n\nclass Program\n{\n\n    static void Main(string[] args)\n    {\n        Matrix<double> A = DenseMatrix.OfArray(new double[,]\n        {\n                {  12,  -51,    4 },\n                {   6,  167,  -68 },\n                {  -4,   24,  -41 }\n        });\n        Console.WriteLine(\"A:\");\n        Console.WriteLine(A);\n        var qr = A.QR();\n        Console.WriteLine();\n        Console.WriteLine(\"Q:\");\n        Console.WriteLine(qr.Q);\n        Console.WriteLine();\n        Console.WriteLine(\"R:\");\n        Console.WriteLine(qr.R);\n    }\n}\n"}
{"id": 37795, "name": "QR decomposition", "source": "Translate Fortran to Java: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "import Jama.Matrix;\nimport Jama.QRDecomposition;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var matrix = new Matrix(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41},\n        });\n\n        var qr = new QRDecomposition(matrix);\n        qr.getQ().print(10, 4);\n        qr.getR().print(10, 4);\n    }\n}\n"}
{"id": 37796, "name": "QR decomposition", "source": "Translate Fortran to Python: program qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n", "target": "\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n"}
{"id": 37972, "name": "Character codes", "source": "Translate Fortran to C#: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "using System;\n\nnamespace RosettaCode.CharacterCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine((int) 'a');   \n            Console.WriteLine((char) 97);   \n        }\n    }\n}\n"}
{"id": 37976, "name": "Character codes", "source": "Translate Fortran to Java: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "module CharacterCodes\n    {\n    @Inject Console console;\n    void run()\n        {\n        for (Char char : ['\\0', '\\d', 'A', '$', '\u00a2', '~', '\u02dc'])\n            {\n            \n            UInt32 codepoint = char.codepoint;\n\n            \n            Char fromCodePoint = codepoint.toChar();   \n\n            console.print($|Character {char.quoted()}:\\\n                           | Unicode codepoint={char.codepoint},\\\n                           | ASCII={char.ascii},\\\n                           | UTF8 bytes={char.utf8()},\\\n                           | char from codepoint={fromCodePoint.quoted()}\n                         );\n            }\n        }\n    }\n"}
{"id": 37977, "name": "Character codes", "source": "Translate Fortran to Python: WRITE(*,*) ACHAR(97), IACHAR(\"a\")   \nWRITE(*,*) CHAR(97), ICHAR(\"a\")\n", "target": "print ord('a') \nprint chr(97)  \n"}
{"id": 38420, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38421, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Fibonacci\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            PrintNumberSequence(\"Fibonacci\", GetNnacciNumbers(2, 10));\n            PrintNumberSequence(\"Lucas\", GetLucasNumbers(10));\n            PrintNumberSequence(\"Tribonacci\", GetNnacciNumbers(3, 10));\n            PrintNumberSequence(\"Tetranacci\", GetNnacciNumbers(4, 10));\n            Console.ReadKey();\n        }\n\n        private static IList<ulong> GetLucasNumbers(int length)\n        {\n            IList<ulong> seedSequence = new List<ulong>() { 2, 1 };\n            return GetFibLikeSequence(seedSequence, length);\n        }\n\n        private static IList<ulong> GetNnacciNumbers(int seedLength, int length)\n        {\n            return GetFibLikeSequence(GetNacciSeed(seedLength), length);\n        }\n\n        private static IList<ulong> GetNacciSeed(int seedLength)\n        {\n            IList<ulong> seedSquence = new List<ulong>() { 1 };\n\n            for (uint i = 0; i < seedLength - 1; i++)\n            {\n                seedSquence.Add((ulong)Math.Pow(2, i));\n            }\n\n            return seedSquence;\n        }\n\n        private static IList<ulong> GetFibLikeSequence(IList<ulong> seedSequence, int length)\n        {\n            IList<ulong> sequence = new List<ulong>();\n\n            int count = seedSequence.Count();\n\n            if (length <= count)\n            {\n                sequence = seedSequence.Take((int)length).ToList();\n            }\n            else\n            {\n                sequence = seedSequence;\n\n                for (int i = count; i < length; i++)\n                {\n                    ulong num = 0;\n\n                    for (int j = 0; j < count; j++)\n                    {\n                        num += sequence[sequence.Count - 1 - j];\n                    }\n\n                    sequence.Add(num);\n                }\n            }\n\n            return sequence;\n        }\n\n        private static void PrintNumberSequence(string Title, IList<ulong> numbersequence)\n        {\n            StringBuilder output = new StringBuilder(Title).Append(\"   \");\n\n            foreach (long item in numbersequence)\n            {\n                output.AppendFormat(\"{0}, \", item);\n            }\n\n            Console.WriteLine(output.ToString());\n        }\n    }\n}\n"}
{"id": 38427, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38428, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": "class Fibonacci\n{\n  public static int[] lucas(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 2, 1 } : lucas(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int n, int numRequested)\n  {\n    if (n < 2)\n      throw new IllegalArgumentException(\"Fibonacci value must be at least 2\");\n    return fibonacci((n == 2) ? new int[] { 1, 1 } : fibonacci(n - 1, n), numRequested);\n  }\n  \n  public static int[] fibonacci(int[] startingValues, int numRequested)\n  {\n    int[] output = new int[numRequested];\n    int n = startingValues.length;\n    System.arraycopy(startingValues, 0, output, 0, n);\n    for (int i = n; i < numRequested; i++)\n      for (int j = 1; j <= n; j++)\n        output[i] += output[i - j];\n    return output;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"nacci(\" + n + \"):\");\n      for (int value : fibonacci(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n    for (int n = 2; n <= 10; n++)\n    {\n      System.out.print(\"lucas(\" + n + \"):\");\n      for (int value : lucas(n, 15))\n        System.out.print(\" \" + value);\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 38429, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38430, "name": "Fibonacci n-step number sequences", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  integer :: n, terms\n  integer, allocatable, dimension(:) :: sequence\n  integer :: i\n  character :: answer\n  write(6,'(a)',advance='no')'Enter the number of terms to sum: '\n  read(5,*) n\n  if ((n < 2) .or. (29 < n)) stop'Unreasonable\n  write(6,'(a)',advance='no')'Show the the first how many terms of the sequence?  '\n  read(5,*) terms\n  if (terms < 1) stop'Lazy programmer has not implemented backward sequences.'\n  n = min(n, terms)\n  allocate(sequence(1:terms))\n  sequence(1) = 1\n  do i = 0, n - 2\n     sequence(i+2) = 2**i\n  end do\n  write(6,*)'Accept this initial sequence (y/n)?'\n  write(6,*) sequence(:n)\n  read(5,*) answer\n  if (answer .eq. 'n') then\n     write(6,*) 'Fine.  Enter the initial terms.'\n     do i=1, n\n        write(6, '(i2,a2)', advance = 'no') i, ': '\n        read(5, *) sequence(i)\n     end do\n  end if\n  call nacci(n, sequence)\n  write(6,*) sequence(:terms)\n  deallocate(sequence)\n\ncontains\n\n    subroutine nacci(n, s)\n      \n      integer, intent(in) :: n\n      integer, intent(inout), dimension(:) :: s\n      integer :: i, terms\n      terms = size(s)\n\n \n  \n      i = n+1\n      if (n+1 .le. terms) s(i) = sum(s(i-n:i-1))\n      do i = n + 2, terms\n         s(i) = 2*s(i-1) - s(i-(n+1))\n      end do\n    end subroutine nacci\nend program f\n", "target": ">>> def fiblike(start):\n\taddnum = len(start)\n\tmemo = start[:]\n\tdef fibber(n):\n\t\ttry:\n\t\t\treturn memo[n]\n\t\texcept IndexError:\n\t\t\tans = sum(fibber(i) for i in range(n-addnum, n))\n\t\t\tmemo.append(ans)\n\t\t\treturn ans\n\treturn fibber\n\n>>> fibo = fiblike([1,1])\n>>> [fibo(i) for i in range(10)]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> lucas = fiblike([2,1])\n>>> [lucas(i) for i in range(10)]\n[2, 1, 3, 4, 7, 11, 18, 29, 47, 76]\n>>> for n, name in zip(range(2,11), 'fibo tribo tetra penta hexa hepta octo nona deca'.split()) :\n\tfibber = fiblike([1] + [2**i for i in range(n-1)])\n\tprint('n=%2i, %5snacci -> %s ...' % (n, name, ' '.join(str(fibber(i)) for i in range(15))))\n\n\t\nn= 2,  fibonacci -> 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...\nn= 3, tribonacci -> 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...\nn= 4, tetranacci -> 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...\nn= 5, pentanacci -> 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...\nn= 6,  hexanacci -> 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...\nn= 7, heptanacci -> 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ...\nn= 8,  octonacci -> 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ...\nn= 9,  nonanacci -> 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ...\nn=10,  decanacci -> 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ...\n>>>\n"}
{"id": 38796, "name": "Generic swap", "source": "Translate Fortran to C#: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "static void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n"}
{"id": 38799, "name": "Generic swap", "source": "Translate Fortran to Java: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "class Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n"}
{"id": 38800, "name": "Generic swap", "source": "Translate Fortran to Python: MODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   \n  WRITE(*,*) r1, r2   \n  WRITE(*,*) s1, s2   \nEND PROGRAM EXAMPLE\n", "target": "a, b = b, a\n"}
{"id": 39273, "name": "Modular arithmetic", "source": "Translate Fortran to C#: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39274, "name": "Modular arithmetic", "source": "Translate Fortran to C#: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "using System;\n\nnamespace ModularArithmetic {\n    interface IAddition<T> {\n        T Add(T rhs);\n    }\n    interface IMultiplication<T> {\n        T Multiply(T rhs);\n    }\n    interface IPower<T> {\n        T Power(int pow);\n    }\n    interface IOne<T> {\n        T One();\n    }\n\n    class ModInt : IAddition<ModInt>, IMultiplication<ModInt>, IPower<ModInt>, IOne<ModInt> {\n        private int modulo;\n\n        public ModInt(int value, int modulo) {\n            Value = value;\n            this.modulo = modulo;\n        }\n\n        public int Value { get; }\n\n        public ModInt One() {\n            return new ModInt(1, modulo);\n        }\n\n        public ModInt Add(ModInt rhs) {\n            return this + rhs;\n        }\n\n        public ModInt Multiply(ModInt rhs) {\n            return this * rhs;\n        }\n\n        public ModInt Power(int pow) {\n            return Pow(this, pow);\n        }\n\n        public override string ToString() {\n            return string.Format(\"ModInt({0}, {1})\", Value, modulo);\n        }\n\n        public static ModInt operator +(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value + rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt operator *(ModInt lhs, ModInt rhs) {\n            if (lhs.modulo != rhs.modulo) {\n                throw new ArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((lhs.Value * rhs.Value) % lhs.modulo, lhs.modulo);\n        }\n\n        public static ModInt Pow(ModInt self, int p) {\n            if (p < 0) {\n                throw new ArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            ModInt pwr = self.One();\n            while (pp-- > 0) {\n                pwr *= self;\n            }\n            return pwr;\n        }\n    }\n\n    class Program {\n        static T F<T>(T x) where T : IAddition<T>, IMultiplication<T>, IPower<T>, IOne<T> {\n            return x.Power(100).Add(x).Add(x.One());\n        }\n\n        static void Main(string[] args) {\n            ModInt x = new ModInt(10, 13);\n            ModInt y = F(x);\n            Console.WriteLine(\"x ^ 100 + x + 1 for x = {0} is {1}\", x, y);\n        }\n    }\n}\n"}
{"id": 39280, "name": "Modular arithmetic", "source": "Translate Fortran to Java: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39281, "name": "Modular arithmetic", "source": "Translate Fortran to Java: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "public class ModularArithmetic {\n    private interface Ring<T> {\n        Ring<T> plus(Ring<T> rhs);\n\n        Ring<T> times(Ring<T> rhs);\n\n        int value();\n\n        Ring<T> one();\n\n        default Ring<T> pow(int p) {\n            if (p < 0) {\n                throw new IllegalArgumentException(\"p must be zero or greater\");\n            }\n\n            int pp = p;\n            Ring<T> pwr = this.one();\n            while (pp-- > 0) {\n                pwr = pwr.times(this);\n            }\n            return pwr;\n        }\n    }\n\n    private static class ModInt implements Ring<ModInt> {\n        private int value;\n        private int modulo;\n\n        private ModInt(int value, int modulo) {\n            this.value = value;\n            this.modulo = modulo;\n        }\n\n        @Override\n        public Ring<ModInt> plus(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot add an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot add rings with different modulus\");\n            }\n            return new ModInt((value + rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public Ring<ModInt> times(Ring<ModInt> other) {\n            if (!(other instanceof ModInt)) {\n                throw new IllegalArgumentException(\"Cannot multiple an unknown ring.\");\n            }\n            ModInt rhs = (ModInt) other;\n            if (modulo != rhs.modulo) {\n                throw new IllegalArgumentException(\"Cannot multiply rings with different modulus\");\n            }\n            return new ModInt((value * rhs.value) % modulo, modulo);\n        }\n\n        @Override\n        public int value() {\n            return value;\n        }\n\n        @Override\n        public Ring<ModInt> one() {\n            return new ModInt(1, modulo);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"ModInt(%d, %d)\", value, modulo);\n        }\n    }\n\n    private static <T> Ring<T> f(Ring<T> x) {\n        return x.pow(100).plus(x).plus(x.one());\n    }\n\n    public static void main(String[] args) {\n        ModInt x = new ModInt(10, 13);\n        Ring<ModInt> y = f(x);\n        System.out.print(\"x ^ 100 + x + 1 for x = ModInt(10, 13) is \");\n        System.out.println(y);\n        System.out.flush();\n    }\n}\n"}
{"id": 39282, "name": "Modular arithmetic", "source": "Translate Fortran to Python: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39283, "name": "Modular arithmetic", "source": "Translate Fortran to Python: module modular_arithmetic\n  implicit none\n\n  type :: modular\n     integer :: val\n     integer :: modulus\n  end type modular\n\n  interface operator(+)\n     module procedure modular_modular_add\n     module procedure modular_integer_add\n  end interface operator(+)\n\n  interface operator(**)\n     module procedure modular_integer_pow\n  end interface operator(**)\n\ncontains\n\n  function modular_modular_add (a, b) result (c)\n    type(modular), intent(in) :: a\n    type(modular), intent(in) :: b\n    type(modular) :: c\n\n    if (a%modulus /= b%modulus) error stop\n    c%val = modulo (a%val + b%val, a%modulus)\n    c%modulus = a%modulus\n  end function modular_modular_add\n\n  function modular_integer_add (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    c%val = modulo (a%val + i, a%modulus)\n    c%modulus = a%modulus\n  end function modular_integer_add\n\n  function modular_integer_pow (a, i) result (c)\n    type(modular), intent(in) :: a\n    integer, intent(in) :: i\n    type(modular) :: c\n\n    \n    \n    \n    \n\n    integer :: modulus\n    integer :: base\n    integer :: exponent\n\n    modulus = a%modulus\n    exponent = i\n\n    if (modulus < 1) error stop\n    if (exponent < 0) error stop\n\n    c%modulus = modulus\n    if (modulus == 1) then\n       c%val = 0\n    else\n       c%val = 1\n       base = modulo (a%val, modulus)\n       do while (exponent > 0)\n          if (modulo (exponent, 2) /= 0) then\n             c%val = modulo (c%val * base, modulus)\n          end if\n          exponent = exponent / 2\n          base = modulo (base * base, modulus)\n       end do\n    end if\n  end function modular_integer_pow\n\nend module modular_arithmetic\n\n\n\n\n#define f(x) ((x)**100 + (x) + 1)\n\nprogram modular_arithmetic_task\n  use, intrinsic :: iso_fortran_env\n  use, non_intrinsic :: modular_arithmetic\n  implicit none\n\n  type(modular) :: x, y\n\n  x = modular(10, 13)\n  y = f(x)\n\n  write (*, '(\"    modulus 13:  \", I0)') y%val\n  write (*, '(\"floating point:  \", E55.50)') f(10.0_real64)\n\nend program modular_arithmetic_task\n", "target": "import operator\nimport functools\n\n@functools.total_ordering\nclass Mod:\n    __slots__ = ['val','mod']\n\n    def __init__(self, val, mod):\n        if not isinstance(val, int):\n            raise ValueError('Value must be integer')\n        if not isinstance(mod, int) or mod<=0:\n            raise ValueError('Modulo must be positive integer')\n        self.val = val % mod\n        self.mod = mod\n\n    def __repr__(self):\n        return 'Mod({}, {})'.format(self.val, self.mod)\n\n    def __int__(self):\n        return self.val\n\n    def __eq__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val==other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val == other\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Mod):\n            if self.mod == other.mod:\n                return self.val<other.val\n            else:\n                return NotImplemented\n        elif isinstance(other, int):\n            return self.val < other\n        else:\n            return NotImplemented\n\n    def _check_operand(self, other):\n        if not isinstance(other, (int, Mod)):\n            raise TypeError('Only integer and Mod operands are supported')\n        if isinstance(other, Mod) and self.mod != other.mod:\n            raise ValueError('Inconsistent modulus: {} vs. {}'.format(self.mod, other.mod))\n\n    def __pow__(self, other):\n        self._check_operand(other)\n        \n        return Mod(pow(self.val, int(other), self.mod), self.mod)\n\n    def __neg__(self):\n        return Mod(self.mod - self.val, self.mod)\n\n    def __pos__(self):\n        return self \n\n    def __abs__(self):\n        return self \n\n\n\ndef _make_op(opname):\n    op_fun = getattr(operator, opname)  \n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(self.val, int(other)) % self.mod, self.mod)\n    return op\n\ndef _make_reflected_op(opname):\n    op_fun = getattr(operator, opname)\n    def op(self, other):\n        self._check_operand(other)\n        return Mod(op_fun(int(other), self.val) % self.mod, self.mod)\n    return op\n\n\nfor opname, reflected_opname in [('__add__', '__radd__'), ('__sub__', '__rsub__'), ('__mul__', '__rmul__')]:\n    setattr(Mod, opname, _make_op(opname))\n    setattr(Mod, reflected_opname, _make_reflected_op(opname))\n\ndef f(x):\n    return x**100+x+1\n\nprint(f(Mod(10,13)))\n\n"}
{"id": 39534, "name": "String append", "source": "Translate Fortran to C#: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        string x = \"foo\";\n        x += \"bar\";\n        System.Console.WriteLine(x);\n    }\n}\n"}
{"id": 39537, "name": "String append", "source": "Translate Fortran to Java: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "String sa = \"Hello\";\nsa += \", World!\";\nSystem.out.println(sa);\n\nStringBuilder ba = new StringBuilder();\nba.append(\"Hello\");\nba.append(\", World!\");\nSystem.out.println(ba.toString());\n"}
{"id": 39538, "name": "String append", "source": "Translate Fortran to Python: program main\n\n character(len=:),allocatable :: str\n\n str = 'hello'\n str = str//' world'\n\n write(*,*) str\n\nend program main\n", "target": "\n\n\nstr = \"12345678\";\nstr += \"9!\";\nprint(str)\n"}
{"id": 39748, "name": "Count in octal", "source": "Translate Fortran to C#: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n"}
{"id": 39751, "name": "Count in octal", "source": "Translate Fortran to Java: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); \n        }\n    }\n}\n"}
{"id": 39752, "name": "Count in octal", "source": "Translate Fortran to Python: program Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n\n\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n", "target": "import sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n"}
{"id": 40013, "name": "Delete a file", "source": "Translate Fortran to C#:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "using System;\nusing System.IO;\n\nnamespace DeleteFile {\n  class Program {\n    static void Main() {\n      File.Delete(\"input.txt\");\n      Directory.Delete(\"docs\");\n      File.Delete(\"/input.txt\");\n      Directory.Delete(\"/docs\");\n    }\n  }\n}\n"}
{"id": 40016, "name": "Delete a file", "source": "Translate Fortran to Java:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "import java.io.File;\n\npublic class FileDeleteTest {\n    public static boolean deleteFile(String filename) {\n        boolean exists = new File(filename).delete();\n        return exists;\n    }\n    \n    public static void test(String type, String filename) {\n        System.out.println(\"The following \" + type + \" called \" + filename + \n            (deleteFile(filename) ? \" was deleted.\" : \" could not be deleted.\")\n        );\n    }\n\n    public static void main(String args[]) {\n        test(\"file\", \"input.txt\");\n        test(\"file\", File.seperator + \"input.txt\");\n        test(\"directory\", \"docs\");\n        test(\"directory\", File.seperator + \"docs\" + File.seperator);\n    }\n}\n"}
{"id": 40017, "name": "Delete a file", "source": "Translate Fortran to Python:  OPEN  (UNIT=5, FILE=\"input.txt\", STATUS=\"OLD\")   \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n OPEN  (UNIT=5, FILE=\"/input.txt\", STATUS=\"OLD\")  \n CLOSE (UNIT=5, STATUS=\"DELETE\")\n", "target": "import os\n\nos.remove(\"output.txt\")\nos.rmdir(\"docs\")\n\nos.remove(\"/output.txt\")\nos.rmdir(\"/docs\")\n"}
{"id": 40290, "name": "Sum of a series", "source": "Translate Fortran to C#: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        \n\n        List<double> myList = new List<double>();\n        for (double i = 1; i < 1001; i++)\n        {\n            myList.Add(i);\n        }\n        \n\n        var sum = myList.Sum(x => 1/(x*x));\n\n        Console.WriteLine(sum);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 40293, "name": "Sum of a series", "source": "Translate Fortran to Java: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "public class Sum{\n    public static double f(double x){\n       return 1/(x*x);\n    }\n \n    public static void main(String[] args){\n       double start = 1;\n       double end = 1000;\n       double sum = 0;\n \n       for(double x = start;x <= end;x++) sum += f(x);\n \n       System.out.println(\"Sum of f(x) from \" + start + \" to \" + end +\" is \" + sum);\n    }\n}\n"}
{"id": 40294, "name": "Sum of a series", "source": "Translate Fortran to Python: real, dimension(1000) :: a = (/ (1.0/(i*i), i=1, 1000) /)\nreal :: result\n\nresult = sum(a);\n", "target": "print ( sum(1.0 / (x * x) for x in range(1, 1001)) )\n"}
{"id": 40583, "name": "Sierpinski carpet", "source": "Translate Fortran to C#: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static List<string> NextCarpet(List<string> carpet)\n    {\n        return carpet.Select(x => x + x + x)\n                     .Concat(carpet.Select(x => x + x.Replace('#', ' ') + x))\n                     .Concat(carpet.Select(x => x + x + x)).ToList();\n    }\n\n    static List<string> SierpinskiCarpet(int n)\n    {\n        return Enumerable.Range(1, n).Aggregate(new List<string> { \"#\" }, (carpet, _) => NextCarpet(carpet));\n    }\n\n    static void Main(string[] args)\n    {\n        foreach (string s in SierpinskiCarpet(3))\n            Console.WriteLine(s);\n    }\n}\n"}
{"id": 40587, "name": "Sierpinski carpet", "source": "Translate Fortran to Java: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "public static boolean inCarpet(long x, long y) {\n    while (x!=0 && y!=0) {\n        if (x % 3 == 1 && y % 3 == 1)\n            return false;\n        x /= 3;\n        y /= 3;\n    }\n    return true;\n}\n \npublic static void carpet(final int n) {\n    final double power = Math.pow(3,n);\n    for(long i = 0; i < power; i++) {\n        for(long j = 0; j < power; j++) {\n            System.out.print(inCarpet(i, j) ? \"*\" : \" \");\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 40588, "name": "Sierpinski carpet", "source": "Translate Fortran to Python: program Sierpinski_carpet\n  implicit none\n  \n  call carpet(4)\n\ncontains\n\nfunction In_carpet(a, b)\n  logical :: in_carpet\n  integer, intent(in) :: a, b\n  integer :: x, y\n\n  x = a ; y = b\n  do \n    if(x == 0 .or. y == 0) then\n      In_carpet = .true.\n      return\n    else if(mod(x, 3) == 1 .and. mod(y, 3) == 1) then\n      In_carpet = .false.\n      return\n    end if\n    x = x / 3\n    y = y / 3\n  end do\nend function\n\nsubroutine Carpet(n)\n  integer, intent(in) :: n\n  integer :: i, j\n \n  do i = 0, 3**n - 1 \n    do j = 0, 3**n - 1\n      if(In_carpet(i, j)) then\n        write(*, \"(a)\", advance=\"no\") \"#\"\n      else\n        write(*, \"(a)\", advance=\"no\") \" \"\n      end if\n    end do\n    write(*,*)\n  end do\nend subroutine Carpet\nend program Sierpinski_carpet\n", "target": "def setup():\n    size(729, 729)\n    fill(0)\n    background(255)\n    noStroke()\n    rect(width / 3, height / 3, width / 3, width / 3)\n    rectangles(width / 3, height / 3, width / 3)\n\ndef rectangles(x, y, s):\n    if s < 1: return\n    xc, yc = x - s, y - s\n    for row in range(3):\n        for col in range(3):\n            if not (row == 1 and col == 1):\n                xx, yy = xc + row * s, yc + col * s\n                delta = s / 3\n                rect(xx + delta, yy + delta, delta, delta)\n                rectangles(xx + s / 3, yy + s / 3, s / 3)\n"}
{"id": 41192, "name": "Read a file line by line", "source": "Translate Fortran to C#:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "foreach (string readLine in File.ReadLines(\"FileName\"))\n  DoSomething(readLine);\n"}
{"id": 41195, "name": "Read a file line by line", "source": "Translate Fortran to Java:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\n\npublic class ReadFileByLines {\n    private static void processLine(int lineNo, String line) {\n        \n    }\n\n    public static void main(String[] args) {\n        for (String filename : args) {\n            BufferedReader br = null;\n            FileReader fr = null;\n            try {\n                fr = new FileReader(filename);\n                br = new BufferedReader(fr);\n                String line;\n                int lineNo = 0;\n                while ((line = br.readLine()) != null) {\n                    processLine(++lineNo, line);\n                }\n            }\n            catch (Exception x) {\n                x.printStackTrace();\n            }\n            finally {\n                if (fr != null) {\n                    try {br.close();} catch (Exception ignoreMe) {}\n                    try {fr.close();} catch (Exception ignoreMe) {}\n                }\n            }\n        }\n    }\n}\n"}
{"id": 41196, "name": "Read a file line by line", "source": "Translate Fortran to Python:       INTEGER ENUFF\t\t\n      PARAMETER (ENUFF = 2468)\t\n      CHARACTER*(ENUFF) ALINE\t\n      CHARACTER*66 FNAME\t\n      INTEGER LINPR,IN\t\t\n      INTEGER L,N\t\t\n      LOGICAL EXIST\t\t\n      LINPR = 6\t\t\t\n      IN = 10\t\t\t\n      FNAME = \"Read.for\"\t\n      INQUIRE (FILE = FNAME, EXIST = EXIST)\t\n      IF (.NOT.EXIST) THEN\t\t\n        WRITE (LINPR,1) FNAME\t\t\n    1   FORMAT (\"No sign of file \",A)\t\n        STOP \"No file, no go.\"\t\t\n      END IF\t\t\t\t\n      OPEN (IN,FILE = FNAME, STATUS = \"OLD\", ACTION = \"READ\")\t\n\n      N = 0\t\t\n   10 READ (IN,11,END = 20) L,ALINE(1:MIN(L,ENUFF))\t\n   11 FORMAT (Q,A)\t\t\n      N = N + 1\t\t\t\n      IF (L.GT.ENUFF) WRITE (LINPR,12) N,L,ENUFF\t\n   12 FORMAT (\"Record \",I0,\" has length \",I0,\": my limit is \",I0)\t\n      WRITE (LINPR,13) N,ALINE(1:MIN(L,ENUFF))\t\n   13 FORMAT (I9,\":\",A)\t\t\n      GO TO 10\t\t\t\n\n   20 CLOSE (IN)\t\n      END\t\n", "target": "for line in lines open('input.txt'):\n    print line\n"}
{"id": 41456, "name": "Write entire file", "source": "Translate Fortran to C#:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "System.IO.File.WriteAllText(\"filename.txt\", \"This file contains a string.\");\n"}
{"id": 41459, "name": "Write entire file", "source": "Translate Fortran to Java:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "import java.io.*;\n\npublic class Test {\n\n    public static void main(String[] args) throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(new FileWriter(\"test.txt\"))) {\n            bw.write(\"abc\");\n        }\n    }\n}\n"}
{"id": 41460, "name": "Write entire file", "source": "Translate Fortran to Python:       OPEN (F,FILE=\"SomeFileName.txt\",STATUS=\"REPLACE\")\n      WRITE (F,*) \"Whatever you like.\"\n      WRITE (F) BIGARRAY\n", "target": "with open(filename, 'w') as f:\n    f.write(data)\n"}
{"id": 41713, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to C#: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41714, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to C#: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "using System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n"}
{"id": 41719, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Java: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41720, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Java: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n"}
{"id": 41721, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Python: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 41722, "name": "4-rings or 4-squares puzzle", "source": "Translate Fortran to Python: WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n", "target": "import itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n"}
{"id": 42045, "name": "Mutual recursion", "source": "Translate Fortran to C#: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "namespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 42049, "name": "Mutual recursion", "source": "Translate Fortran to Java: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n"}
{"id": 42050, "name": "Mutual recursion", "source": "Translate Fortran to Python: module MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n", "target": "def F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n"}
{"id": 42980, "name": "Strip comments from a string", "source": "Translate Fortran to C#: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "using System.Text.RegularExpressions;\n\nstring RemoveComments(string str, string delimiter)\n        {\n            \n            \n            \n            return Regex.Replace(str, delimiter + \".+\", string.Empty).Trim();\n        }\n"}
{"id": 42983, "name": "Strip comments from a string", "source": "Translate Fortran to Java: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "import java.io.*;\n\npublic class StripLineComments{\n    public static void main( String[] args ){\n\tif( args.length < 1 ){\n\t    System.out.println(\"Usage: java StripLineComments StringToProcess\");\n\t}\n\telse{\n\t    String inputFile = args[0];\n\t    String input = \"\";\n\t    try{\n\t\tBufferedReader reader = new BufferedReader( new FileReader( inputFile ) );\n\t\tString line = \"\";\n\t\twhile((line = reader.readLine()) != null){\n\t\t    System.out.println( line.split(\"[#;]\")[0] );\n\t\t}\n\t    }\n\t    catch( Exception e ){\n\t\te.printStackTrace();\n\t    }\n\t}\n    }\n}\n"}
{"id": 42984, "name": "Strip comments from a string", "source": "Translate Fortran to Python: \n module string_routines\n\n implicit none\n private\n public :: strip_comments\n contains\n\n \n\t function strip_comments(str,c) result(str2)\n\t implicit none\n\t character(len=*),intent(in) :: str\n\t character(len=1),intent(in) :: c \n\t character(len=len(str)) :: str2\n\t \n\t integer :: i\n\t \n\t i = index(str,c)\n\t if (i>0) then\n\t\tstr2 = str(1:i-1)\n\t else\n\t\tstr2 = str\n\t end if\n\t \n\t end function strip_comments\n \n\n end module string_routines\n\n\n\n program main\n\n\n\n use string_routines, only: strip_comments\n implicit none\n \n write(*,*) strip_comments('apples, pears # and bananas', '#')\n write(*,*) strip_comments('apples, pears\u00a0; and bananas', ';')\n \n\n end program main\n\n", "target": "def remove_comments(line, sep):\n    for s in sep:\n        i = line.find(s)\n        if i >= 0:\n            line = line[:i]\n    return line.strip()\n\n\nprint remove_comments('apples\u00a0; pears \nprint remove_comments('apples\u00a0; pears \n"}
{"id": 43855, "name": "Determine if a string is numeric", "source": "Translate Fortran to C#: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "public static bool IsNumeric(string s)\n{\n    double Result;\n    return double.TryParse(s, out Result);  \n}        \n\nstring value = \"123\";\nif (IsNumeric(value)) \n{\n  \n}\n"}
{"id": 43858, "name": "Determine if a string is numeric", "source": "Translate Fortran to Java: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "public boolean isNumeric(String input) {\n  try {\n    Integer.parseInt(input);\n    return true;\n  }\n  catch (NumberFormatException e) {\n    \n    return false;\n  }\n}\n"}
{"id": 43859, "name": "Determine if a string is numeric", "source": "Translate Fortran to Python: FUNCTION is_numeric(string)\n  IMPLICIT NONE\n  CHARACTER(len=*), INTENT(IN) :: string\n  LOGICAL :: is_numeric\n  REAL :: x\n  INTEGER :: e\n  READ(string,*,IOSTAT=e) x\n  is_numeric = e == 0\nEND FUNCTION is_numeric\n", "target": "def is_numeric(s):\n    try:\n        float(s)\n        return True\n    except (ValueError, TypeError):\n        return False\n\nis_numeric('123.0')\n"}
{"id": 44128, "name": "One-dimensional cellular automata", "source": "Translate Fortran to C#: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\t\n\t\tconst int n_iter = 10;\n\t\tstatic int[] f = { 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0 };\n\t\t\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\tConsole.WriteLine(\"\");\t\t\t\n\t\t\t\n\t\t\tint[] g = new int[f.Length];\n\t\t\tfor( int n=n_iter; n!=0; n-- )\n\t\t\t{\n\t\t\t\tfor( int i=1; i<f.Length-1; i++ )\n\t\t\t\t{\n\t\t\t\t\tif ( (f[i-1] ^ f[i+1]) == 1 ) g[i] = f[i];\n\t\t\t\t\telse if ( f[i] == 0 && (f[i-1] & f[i+1]) == 1 ) g[i] = 1;\n\t\t\t\t\telse g[i] = 0;\n\t\t\t\t}\n\t\t\t\tg[0] = ( (f[0] & f[1]) == 1 ) ? 1 : 0;\n\t\t\t\tg[g.Length-1] = ( (f[f.Length-1] & f[f.Length-2]) == 1 ) ? 1 : 0;\n\t\t\t\t\n\t\t\t\tint[] tmp = f;\n\t\t\t\tf = g;\n\t\t\t\tg = tmp;\n\t\t\t\t\n\t\t\t\tfor( int i=0; i<f.Length; i++ )\n\t\t\t\t\tConsole.Write( f[i]==0 ? \"-\" : \"#\" );\n\t\t\t\tConsole.WriteLine(\"\");\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n"}
{"id": 44132, "name": "One-dimensional cellular automata", "source": "Translate Fortran to Java: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "public class Life{\n\tpublic static void main(String[] args) throws Exception{\n\t\tString start= \"_###_##_#_#_#_#__#__\";\n\t\tint numGens = 10;\n\t\tfor(int i= 0; i < numGens; i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \": \" + start);\n\t\t\tstart= life(start);\n\t\t}\n\t}\n\n\tpublic static String life(String lastGen){\n\t\tString newGen= \"\";\n\t\tfor(int i= 0; i < lastGen.length(); i++){\n\t\t\tint neighbors= 0;\n\t\t\tif (i == 0){\n\t\t\t\tneighbors= lastGen.charAt(1) == '#' ? 1 : 0;\n\t\t\t} else if (i == lastGen.length() - 1){\n\t\t\t\tneighbors= lastGen.charAt(i - 1) == '#' ? 1 : 0;\n\t\t\t} else{\n\t\t\t\tneighbors= getNeighbors(lastGen.substring(i - 1, i + 2));\n\t\t\t}\n\n\t\t\tif (neighbors == 0){\n\t\t\t\tnewGen+= \"_\";\n\t\t\t}\n\t\t\tif (neighbors == 1){\n\t\t\t\tnewGen+= lastGen.charAt(i);\n\t\t\t}\n\t\t\tif (neighbors == 2){\n\t\t\t\tnewGen+= lastGen.charAt(i) == '#' ? \"_\" : \"#\";\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String group){\n\t\tint ans= 0;\n\t\tif (group.charAt(0) == '#') ans++;\n\t\tif (group.charAt(2) == '#') ans++;\n\t\treturn ans;\n\t}\n}\n"}
{"id": 44133, "name": "One-dimensional cellular automata", "source": "Translate Fortran to Python: PROGRAM LIFE_1D\n   \n  IMPLICIT NONE\n\n  LOGICAL :: cells(20) = (/ .FALSE., .TRUE., .TRUE., .TRUE., .FALSE., .TRUE., .TRUE., .FALSE., .TRUE., .FALSE., &\n                            .TRUE., .FALSE., .TRUE., .FALSE., .TRUE., .FALSE., .FALSE., .TRUE., .FALSE., .FALSE. /)\n  INTEGER :: i\n  \n  DO i = 0, 9\n     WRITE(*, \"(A,I0,A)\", ADVANCE = \"NO\") \"Generation \", i, \": \"\n     CALL Drawgen(cells)\n     CALL Nextgen(cells)\n  END DO\n\nCONTAINS\n\n  SUBROUTINE Nextgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    LOGICAL :: left, centre, right\n    INTEGER :: i\n   \n    left = .FALSE.\n    DO i = 1, SIZE(cells)-1\n       centre = cells(i)\n       right = cells(i+1)\n       IF (left .AND. right) THEN\n          cells(i) = .NOT. cells(i)\n       ELSE IF (.NOT. left .AND. .NOT. right) THEN\n          cells(i) = .FALSE.\n       END IF\n       left = centre\n    END DO\n    cells(SIZE(cells)) = left .AND. right\n  END SUBROUTINE Nextgen\n\n  SUBROUTINE Drawgen(cells)\n    LOGICAL, INTENT (IN OUT) :: cells(:)\n    INTEGER :: i\n   \n    DO i = 1, SIZE(cells)\n       IF (cells(i)) THEN\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n       ELSE\n          WRITE(*, \"(A)\", ADVANCE = \"NO\") \"_\"\n       END IF\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Drawgen\n  \nEND PROGRAM LIFE_1D\n", "target": "import random\n\nprintdead, printlive = '_\nmaxgenerations = 10\ncellcount = 20\noffendvalue = '0'\n\nuniverse = ''.join(random.choice('01') for i in range(cellcount))\n\nneighbours2newstate = {\n '000': '0',\n '001': '0',\n '010': '0',\n '011': '1',\n '100': '0',\n '101': '1',\n '110': '1',\n '111': '0',\n }\n\nfor i in range(maxgenerations):\n    print \"Generation %3i:  %s\" % ( i,\n          universe.replace('0', printdead).replace('1', printlive) )\n    universe = offendvalue + universe + offendvalue\n    universe = ''.join(neighbours2newstate[universe[i:i+3]] for i in range(cellcount))\n"}
{"id": 44913, "name": "Zero to the zero power", "source": "Translate Fortran to C#: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 44914, "name": "Zero to the zero power", "source": "Translate Fortran to C#: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "using System;\n\nnamespace ZeroToTheZeroeth\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            double k = Math.Pow(0, 0);\n            Console.Write(\"0^0 is {0}\", k);           \n        }\n    }\n}\n"}
{"id": 44920, "name": "Zero to the zero power", "source": "Translate Fortran to Java: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 44921, "name": "Zero to the zero power", "source": "Translate Fortran to Java: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "System.out.println(Math.pow(0, 0));\n"}
{"id": 44922, "name": "Zero to the zero power", "source": "Translate Fortran to Python: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 44923, "name": "Zero to the zero power", "source": "Translate Fortran to Python: program zero\ndouble precision :: i, j\ndouble complex :: z1, z2\ni = 0.0D0\nj = 0.0D0\nz1 = (0.0D0,0.0D0)\nz2 = (0.0D0,0.0D0)\nwrite(*,*) 'When integers are used, we have 0^0 = ', 0**0\nwrite(*,*) 'When double precision numbers are used, we have 0.0^0.0 = ', i**j\nwrite(*,*) 'When complex numbers are used, we have (0.0+0.0i)^(0.0+0.0i) = ', z1**z2\nend program\n", "target": "from decimal import Decimal\nfrom fractions import Fraction\nfrom itertools import product\n\nzeroes = [0, 0.0, 0j, Decimal(0), Fraction(0, 1), -0.0, -0.0j, Decimal(-0.0)]\nfor i, j in product(zeroes, repeat=2):\n    try:\n        ans = i**j\n    except:\n        ans = '<Exception raised>'\n    print(f'{i!r:>15} ** {j!r:<15} = {ans!r}')\n"}
{"id": 45281, "name": "Runge-Kutta method", "source": "Translate Fortran to C#: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45282, "name": "Runge-Kutta method", "source": "Translate Fortran to C#: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "using System;\n\nnamespace RungeKutta\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \n            double t = 0.0;\n            double T = 10.0;\n            double dt = 0.1;\n\n            \n            int n = (int)(((T - t) / dt)) + 1;\n\n            \n            double[] y = new double[n];\n            double[] s = new double[n];\n\n            \n            double dy1;\n            double dy2;\n            double dy3;\n            double dy4;\n\n            \n            int i = 0;\n            s[i] = 0.0;\n            y[i] = 1.0;\n\n            Console.WriteLine(\" ===================================== \");\n            Console.WriteLine(\" Beging 4th Order Runge Kutta Method \");\n            Console.WriteLine(\" ===================================== \");\n\n            Console.WriteLine();\n            Console.WriteLine(\" Given the example Differential equation: \\n\");\n            Console.WriteLine(\"     y' = t*sqrt(y) \\n\");\n            Console.WriteLine(\" With the initial conditions: \\n\");\n            Console.WriteLine(\"     t0 = 0\" + \", y(0) = 1.0 \\n\");\n            Console.WriteLine(\" Whose exact solution is known to be: \\n\");\n            Console.WriteLine(\"     y(t) = 1/16*(t^2 + 4)^2 \\n\");\n            Console.WriteLine(\" Solve the given equations over the range t = 0...10 with a step value dt = 0.1 \\n\");\n            Console.WriteLine(\" Print the calculated values of y at whole numbered t's (0.0,1.0,...10.0) along with the error \\n\");\n            Console.WriteLine();\n\n            Console.WriteLine(\" y(t) \" +\"RK4\" + \" \".PadRight(18) + \"Absolute Error\");\n            Console.WriteLine(\" -------------------------------------------------\");\n            Console.WriteLine(\" y(0) \" + y[i] + \" \".PadRight(20) + (y[i] - solution(s[i])));\n\n            \n            while (i < y.Length - 1)\n            {\n\n                dy1 = dt * equation(s[i], y[i]);\n                dy2 = dt * equation(s[i] + dt / 2, y[i] + dy1 / 2);\n                dy3 = dt * equation(s[i] + dt / 2, y[i] + dy2 / 2);\n                dy4 = dt * equation(s[i] + dt, y[i] + dy3);\n\n                s[i + 1] = s[i] + dt;\n                y[i + 1] = y[i] + (dy1 + 2 * dy2 + 2 * dy3 + dy4) / 6;\n\n                double error = Math.Abs(y[i + 1] - solution(s[i + 1]));\n                double t_rounded = Math.Round(t + dt, 2);\n\n                if (t_rounded % 1 == 0)\n                {\n                    Console.WriteLine(\" y(\" + t_rounded + \")\" + \" \" + y[i + 1] + \" \".PadRight(5) + (error));\n                }\n\n                i++;\n                t += dt;\n\n            };\n\n            Console.ReadLine();\n        }\n\n        \n        public static double equation(double t, double y)\n        {\n            double y_prime;\n            return y_prime = t*Math.Sqrt(y);\n        }\n\n        \n        public static double solution(double t)\n        {\n            double actual;\n            actual = Math.Pow((Math.Pow(t, 2) + 4), 2)/16;\n            return actual;\n        }\n    }\n}\n"}
{"id": 45288, "name": "Runge-Kutta method", "source": "Translate Fortran to Java: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45289, "name": "Runge-Kutta method", "source": "Translate Fortran to Java: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "import static java.lang.Math.*;\nimport java.util.function.BiFunction;\n\npublic class RungeKutta {\n\n    static void runge(BiFunction<Double, Double, Double> yp_func, double[] t,\n            double[] y, double dt) {\n\n        for (int n = 0; n < t.length - 1; n++) {\n            double dy1 = dt * yp_func.apply(t[n], y[n]);\n            double dy2 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy1 / 2.0);\n            double dy3 = dt * yp_func.apply(t[n] + dt / 2.0, y[n] + dy2 / 2.0);\n            double dy4 = dt * yp_func.apply(t[n] + dt, y[n] + dy3);\n            t[n + 1] = t[n] + dt;\n            y[n + 1] = y[n] + (dy1 + 2.0 * (dy2 + dy3) + dy4) / 6.0;\n        }\n    }\n\n    static double calc_err(double t, double calc) {\n        double actual = pow(pow(t, 2.0) + 4.0, 2) / 16.0;\n        return abs(actual - calc);\n    }\n\n    public static void main(String[] args) {\n        double dt = 0.10;\n        double[] t_arr = new double[101];\n        double[] y_arr = new double[101];\n        y_arr[0] = 1.0;\n\n        runge((t, y) -> t * sqrt(y), t_arr, y_arr, dt);\n\n        for (int i = 0; i < t_arr.length; i++)\n            if (i % 10 == 0)\n                System.out.printf(\"y(%.1f) =\u00a0%.8f Error:\u00a0%.6f%n\",\n                        t_arr[i], y_arr[i],\n                        calc_err(t_arr[i], y_arr[i]));\n    }\n}\n"}
{"id": 45290, "name": "Runge-Kutta method", "source": "Translate Fortran to Python: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45291, "name": "Runge-Kutta method", "source": "Translate Fortran to Python: program rungekutta\n    implicit none\n    integer, parameter :: dp = kind(1d0)\n    real(dp) :: t, dt, tstart, tstop\n    real(dp) :: y, k1, k2, k3, k4\n    \n    tstart = 0.0d0\n    tstop = 10.0d0\n    dt = 0.1d0\n    y = 1.0d0\n    t = tstart\n    write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n        abs(y-(t**2+4)**2/16)\n    do while (t < tstop)\n        k1 = dt*f(t, y)\n        k2 = dt*f(t+dt/2, y+k1/2)\n        k3 = dt*f(t+dt/2, y+k2/2)\n        k4 = dt*f(t+dt, y+k3)\n        y = y+(k1+2*(k2+k3)+k4)/6\n        t = t+dt\n        if (abs(nint(t)-t) <= 1d-12) then\n            write (6, '(a,f4.1,a,f12.8,a,es13.6)') 'y(', t, ') = ', y, ' error = ', &\n                abs(y-(t**2+4)**2/16)\n        end if\n    end do\ncontains\n    function f(t,y)\n        real(dp), intent(in) :: t, y\n        real(dp) :: f\n\n        f = t*sqrt(y)\n    end function f\nend program rungekutta\n", "target": "from math import sqrt\n \ndef rk4(f, x0, y0, x1, n):\n    vx = [0] * (n + 1)\n    vy = [0] * (n + 1)\n    h = (x1 - x0) / float(n)\n    vx[0] = x = x0\n    vy[0] = y = y0\n    for i in range(1, n + 1):\n        k1 = h * f(x, y)\n        k2 = h * f(x + 0.5 * h, y + 0.5 * k1)\n        k3 = h * f(x + 0.5 * h, y + 0.5 * k2)\n        k4 = h * f(x + h, y + k3)\n        vx[i] = x = x0 + i * h\n        vy[i] = y = y + (k1 + k2 + k2 + k3 + k3 + k4) / 6\n    return vx, vy\n \ndef f(x, y):\n    return x * sqrt(y)\n \nvx, vy = rk4(f, 0, 1, 10, 100)\nfor x, y in list(zip(vx, vy))[::10]:\n    print(\"%4.1f %10.5f %+12.4e\" % (x, y, y - (4 + x * x)**2 / 16))\n\n 0.0    1.00000  +0.0000e+00\n 1.0    1.56250  -1.4572e-07\n 2.0    4.00000  -9.1948e-07\n 3.0   10.56250  -2.9096e-06\n 4.0   24.99999  -6.2349e-06\n 5.0   52.56249  -1.0820e-05\n 6.0   99.99998  -1.6595e-05\n 7.0  175.56248  -2.3518e-05\n 8.0  288.99997  -3.1565e-05\n 9.0  451.56246  -4.0723e-05\n10.0  675.99995  -5.0983e-05\n"}
{"id": 45622, "name": "Multiplication tables", "source": "Translate Fortran to C#: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": "using System;\n\nnamespace multtbl\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Write(\" X\".PadRight(4));\n            for (int i = 1; i <= 12; i++)\n                Console.Write(i.ToString(\"####\").PadLeft(4));\n\n            Console.WriteLine();\n            Console.Write(\" ___\");\n\n            for (int i = 1; i <= 12; i++)\n                Console.Write(\" ___\");\n\n            Console.WriteLine();\n            for (int row = 1; row <= 12; row++)\n            {\n                Console.Write(row.ToString(\"###\").PadLeft(3).PadRight(4));\n                for (int col = 1; col <= 12; col++)\n                {\n                    if (row <= col)\n                        Console.Write((row * col).ToString(\"###\").PadLeft(4));\n                    else\n                        Console.Write(\"\".PadLeft(4));\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine();\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 45625, "name": "Multiplication tables", "source": "Translate Fortran to Java: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": "public class MultiplicationTable {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 12; i++)\n            System.out.print(\"\\t\" + i);\n        \n        System.out.println();\n        for (int i = 0; i < 100; i++)\n            System.out.print(\"-\");\n        System.out.println();\n        for (int i = 1; i <= 12; i++) {\n            System.out.print(i + \"|\");\n            for(int j = 1; j <= 12; j++) {\n                System.out.print(\"\\t\");\n                if (j >= i)\n                    System.out.print(\"\\t\" + i * j);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 45626, "name": "Multiplication tables", "source": "Translate Fortran to Python: program multtable\nimplicit none\n\n  integer :: i, j, k\n\n    write(*, \"(a)\") \" x|   1   2   3   4   5   6   7   8   9  10  11  12\"\n    write(*, \"(a)\") \"--+------------------------------------------------\"\n    do i = 1, 12\n      write(*, \"(i2, a)\", advance=\"no\") i, \"|\"\n\tdo k = 2, i\n    \t  write(*, \"(a4)\", advance=\"no\") \"\"\n        end do\n    \tdo j = i, 12\n          write(*, \"(i4)\", advance=\"no\") i*j\n        end do\n        write(*, *)\n    end do\n\nend program multtable\n", "target": ">>> size = 12\n>>> width = len(str(size**2))\n>>> for row in range(-1,size+1):\n\tif row==0:\n\t\tprint(\"\u2500\"*width + \"\u253c\"+\"\u2500\"*((width+1)*size-1))\n\telse:\n\t\tprint(\"\".join(\"%*s%1s\" % ((width,) + ((\"x\",\"\u2502\")      if row==-1 and col==0\n\t\t\t\t\t              else (row,\"\u2502\") if row>0   and col==0\n\t\t\t\t\t              else (col,\"\")  if row==-1\n\t\t\t\t\t              else (\"\",\"\")   if row>col\n\t\t\t\t\t              else (row*col,\"\")))\n\t\t\t       for col in range(size+1)))\n\n\t\t\n  x\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  1\u2502  1   2   3   4   5   6   7   8   9  10  11  12 \n  2\u2502      4   6   8  10  12  14  16  18  20  22  24 \n  3\u2502          9  12  15  18  21  24  27  30  33  36 \n  4\u2502             16  20  24  28  32  36  40  44  48 \n  5\u2502                 25  30  35  40  45  50  55  60 \n  6\u2502                     36  42  48  54  60  66  72 \n  7\u2502                         49  56  63  70  77  84 \n  8\u2502                             64  72  80  88  96 \n  9\u2502                                 81  90  99 108 \n 10\u2502                                    100 110 120 \n 11\u2502                                        121 132 \n 12\u2502                                            144 \n>>>\n"}
{"id": 45914, "name": "Comma quibbling", "source": "Translate Fortran to C#:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 45915, "name": "Comma quibbling", "source": "Translate Fortran to C#:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "using System;\nusing System.Linq;\n\nnamespace CommaQuibbling\n{\n    internal static class Program\n    {\n        #region Static Members\n\tprivate static string Quibble(string[] input)\n\t{\n            return\n                String.Format(\"{{{0}}}\",\n                    String.Join(\"\",\n                        input.Reverse().Zip(\n                            new [] { \"\", \" and \" }.Concat(Enumerable.Repeat(\", \", int.MaxValue)),\n                            (x, y) => x + y).Reverse()));\n\t}\n\n\n        private static void Main()\n        {\n            Console.WriteLine( Quibble( new string[] {} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\"} ) );\n            Console.WriteLine( Quibble( new[] {\"ABC\", \"DEF\", \"G\", \"H\"} ) );\n\n            Console.WriteLine( \"< Press Any Key >\" );\n            Console.ReadKey();\n        }\n\n        #endregion\n    }\n}\n"}
{"id": 45920, "name": "Comma quibbling", "source": "Translate Fortran to Java:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 45921, "name": "Comma quibbling", "source": "Translate Fortran to Java:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "public class Quibbler {\n\n\tpublic static String quibble(String[] words) {\n\t\tString qText = \"{\";\n\t\tfor(int wIndex = 0; wIndex < words.length; wIndex++) {\n\t\t\tqText += words[wIndex] + (wIndex == words.length-1 ? \"\" : \n\t\t\t\t\t\t  wIndex == words.length-2 ? \" and \" :\n\t\t\t\t\t\t  \", \";\n\t\t}\n\t\tqText += \"}\";\n\t\treturn qText;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(quibble(new String[]{}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\"}));\n\t\tSystem.out.println(quibble(new String[]{\"ABC\", \"DEF\", \"G\", \"H\"}));\n\t}\n}\n"}
{"id": 45922, "name": "Comma quibbling", "source": "Translate Fortran to Python:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 45923, "name": "Comma quibbling", "source": "Translate Fortran to Python:       SUBROUTINE QUIBBLE(TEXT,OXFORDIAN)\t\n       CHARACTER*(*) TEXT\t\n       LOGICAL OXFORDIAN\t\n       INTEGER IST(6),LST(6)\t\n       INTEGER N,L,I\t\t\n       INTEGER L1,L2\t\t\n       INTEGER MSG\t\t\n       COMMON /IODEV/MSG\t\nChop the text into words.\n        N = 0\t\t\n        L = LEN(TEXT)\t\n        L2 = 0\t\t\n   10   L1 = L2\t\t\n   11   L1 = L1 + 1\t\t\n        IF (L1.GT.L) GO TO 20\t\t\n        IF (TEXT(L1:L1).LE.\" \") GO TO 11\t\n        L2 = L1\t\t\t\n   12   L2 = L2 + 1\t\t\n        IF (L2.GT.L) GO TO 13\t\n        IF (TEXT(L2:L2).GT.\" \") GO TO 12\t\n   13   N = N + 1\t\t\t\n        IST(N) = L1\t\t\n        LST(N) = L2 - 1\t\t\n        IF (L2.LT.L) GO TO 10\t\nComma time...\n   20   WRITE (MSG,21) \"{\"\t\n   21   FORMAT (A,$)\t\t\n        DO I = 1,N\t\t\n          IF (I.GT.1) THEN\t\t\n            IF (I.LT.N) THEN\t\t\t\n              WRITE (MSG,21) \", \"\t\t\t\n            ELSE IF (OXFORDIAN) THEN\t\t\n              WRITE (MSG,21) \", and \"\t\t\t\n            ELSE\t\t\t\t\n              WRITE (MSG,21) \" and \"\t\t\t\n            END IF\t\t\t\t\n          END IF\t\t\t\n          WRITE (MSG,21) TEXT(IST(I):LST(I))\t\n        END DO\t\t\t\n        WRITE (MSG,\"('}')\")\t\n      END\t\t\n\n      PROGRAM ENCOMMA\t\n      CHARACTER*(666) TEXT\t\n      INTEGER KBD,MSG,INF\t\n      COMMON /IODEV/MSG,KBD\t\n      KBD = 5\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,FILE=\"List.txt\",ACTION = \"READ\")\t\n\n   10 WRITE (MSG,11) \"To insert commas into lists...\"\t\n   11 FORMAT (A)\t\t\t\n   12 READ (INF,11,END = 20) TEXT\t\n      CALL QUIBBLE(TEXT,.FALSE.)\t\n      GO TO 12\t\t\t\t\n\n   20 REWIND (INF)\t\t\t\n      WRITE (MSG,11)\t\t\t\n      WRITE (MSG,11) \"Oxford style...\"\t\n   21 READ (INF,11,END = 30) TEXT\t\n      CALL QUIBBLE(TEXT,.TRUE.)\t\t\n      GO TO 21\t\t\t\t\n\nClosedown\n   30 END\t\n", "target": "fun quibble(s):\n    let result = s.join(' and ').replace(|| and ||, \", \", length(s) - 1)\n    return \"{ $result }\"\n\nlet s = [\n    []\n    [\"ABC\"]\n    [\"ABC\", \"DEF\"]\n    [\"ABC\", \"DEF\", \"G\", \"H\"]\n]\n\nfor i in s:\n    print(quibble i)\n"}
{"id": 46995, "name": "Ackermann function", "source": "Translate Fortran to C#: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "using System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n"}
{"id": 46998, "name": "Ackermann function", "source": "Translate Fortran to Java: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "import java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n"}
{"id": 46999, "name": "Ackermann function", "source": "Translate Fortran to Python: PROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n", "target": "from __future__ import print_function\n\ndef setup():\n    for m in range(4):\n        for n in range(7):\n            print(\"{} \".format(ackermann(m, n)), end = \"\")\n        print()\n    \n\ndef ackermann(m, n):\n    if m == 0:\n        return n + 1\n    elif m > 0 and n == 0:\n        return ackermann(m - 1, 1)\n    else:\n        return ackermann(m - 1, ackermann(m, n - 1))\n"}
{"id": 47275, "name": "Enumerations", "source": "Translate Fortran to C#: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": "enum fruits { apple, banana, cherry }\n\nenum fruits { apple = 0, banana = 1, cherry = 2 }\n\nenum fruits : int { apple = 0, banana = 1, cherry = 2 }\n\n[FlagsAttribute]\nenum Colors { Red = 1, Green = 2, Blue = 4, Yellow = 8 }\n"}
{"id": 47278, "name": "Enumerations", "source": "Translate Fortran to Java: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": "enum Fruits{\n   APPLE, BANANA, CHERRY\n}\n"}
{"id": 47279, "name": "Enumerations", "source": "Translate Fortran to Python: enum, bind(c)\n  enumerator :: one=1, two, three, four, five\n  enumerator :: six, seven, nine=9\nend enum\n", "target": ">>> from enum import Enum\n>>> Contact = Enum('Contact', 'FIRST_NAME, LAST_NAME, PHONE')\n>>> Contact.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact.FIRST_NAME: 1>), ('LAST_NAME', <Contact.LAST_NAME: 2>), ('PHONE', <Contact.PHONE: 3>)]))\n>>> \n>>> \n>>> class Contact2(Enum):\n\tFIRST_NAME = 1\n\tLAST_NAME = 2\n\tPHONE = 3\n\n\t\n>>> Contact2.__members__\nmappingproxy(OrderedDict([('FIRST_NAME', <Contact2.FIRST_NAME: 1>), ('LAST_NAME', <Contact2.LAST_NAME: 2>), ('PHONE', <Contact2.PHONE: 3>)]))\n>>>\n"}
{"id": 47873, "name": "Hello world_Text", "source": "Translate Fortran to C#: print *,\"Hello world\n", "target": "Using System;\nnamespace HelloWorld {\n  class Program\n  {\n    static void Main()\n    {\n      Console.Writeln(\"Hello World!\");\n    }\n  }\n}\n"}
{"id": 47875, "name": "Hello world_Text", "source": "Translate Fortran to Java: print *,\"Hello world\n", "target": "module HelloWorld\n    {\n    void run()\n        {\n        @Inject Console console;\n        console.print(\"Hello World!\");\n        }\n    }\n"}
{"id": 48340, "name": "Unbias a random generator", "source": "Translate Fortran to C#: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48341, "name": "Unbias a random generator", "source": "Translate Fortran to C#: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "using System;\n\nnamespace Unbias\n{\n    internal class Program\n    {\n        private static void Main(string[] args)\n        {\n            \n            for (int n = 3; n <= 6; n++)\n            {\n                int biasedZero = 0, biasedOne = 0, unbiasedZero = 0, unbiasedOne = 0;\n                for (int i = 0; i < 100000; i++)\n                {\n                    if (randN(n))\n                        biasedOne++;\n                    else\n                        biasedZero++;\n                    if (Unbiased(n))\n                        unbiasedOne++;\n                    else\n                        unbiasedZero++;\n                }\n\n                Console.WriteLine(\"(N = {0}):\".PadRight(17) + \"# of 0\\t# of 1\\t% of 0\\t% of 1\", n);\n                Console.WriteLine(\"Biased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  biasedZero, biasedOne,\n                                  biasedZero/1000, biasedOne/1000);\n                Console.WriteLine(\"Unbiased:\".PadRight(15) + \"{0}\\t{1}\\t{2}\\t{3}\",\n                                  unbiasedZero, unbiasedOne,\n                                  unbiasedZero/1000, unbiasedOne/1000);\n            }\n        }\n\n        private static bool Unbiased(int n)\n        {\n            bool flip1, flip2;\n\n            \n\n            do\n            {\n                flip1 = randN(n);\n                flip2 = randN(n);\n            } while (flip1 == flip2);\n\n            return flip1;\n        }\n\n        private static readonly Random random = new Random();\n\n        private static bool randN(int n)\n        {\n            \n            return random.Next(0, n) == 0;\n        }\n    }\n}\n"}
{"id": 48347, "name": "Unbias a random generator", "source": "Translate Fortran to Java: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48348, "name": "Unbias a random generator", "source": "Translate Fortran to Java: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "public class Bias {\n    public static boolean biased(int n) {\n        return Math.random() < 1.0 / n;\n    }\n\n    public static boolean unbiased(int n) {\n        boolean a, b;\n        do {\n            a = biased(n);\n            b = biased(n);\n        } while (a == b);\n        return a;\n    }\n\n    public static void main(String[] args) {\n        final int M = 50000;\n        for (int n = 3; n < 7; n++) {\n            int c1 = 0, c2 = 0;\n            for (int i = 0; i < M; i++) {\n                c1 += biased(n) ? 1 : 0;\n                c2 += unbiased(n) ? 1 : 0;\n            }\n            System.out.format(\"%d: %2.2f%%  %2.2f%%\\n\",\n                              n, 100.0*c1/M, 100.0*c2/M);\n        }\n    }\n}\n"}
{"id": 48349, "name": "Unbias a random generator", "source": "Translate Fortran to Python: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48350, "name": "Unbias a random generator", "source": "Translate Fortran to Python: program Bias_Unbias\n  implicit none\n\n  integer, parameter :: samples = 1000000\n  integer :: i, j\n  integer :: c1, c2, rand\n \n  do i = 3, 6\n    c1 = 0\n    c2 = 0\n    do j = 1, samples\n      rand = bias(i)\n      if (rand == 1) c1 = c1 + 1\n      rand = unbias(i)\n      if (rand == 1) c2 = c2 + 1\n    end do\n    write(*, \"(i2,a,f8.3,a,f8.3,a)\") i, \":\", real(c1) * 100.0 / real(samples), &\n                                     \"%\", real(c2) * 100.0 / real(samples), \"%\"\n  end do\n \ncontains\n\nfunction bias(n)\n  integer :: bias\n  integer, intent(in) :: n\n  real :: r\n\n  call random_number(r)\n  if (r > 1 / real(n)) then\n    bias = 0\n  else\n    bias = 1\n  end if\nend function\n\nfunction unbias(n)\n  integer :: unbias\n  integer, intent(in) :: n\n  integer :: a, b\n\n  do\n    a = bias(n)\n    b = bias(n)\n    if (a /= b) exit\n  end do\n  unbias = a     \nend function\n\nend program\n", "target": "from __future__ import print_function\nimport random\n\ndef randN(N):\n    \" 1,0 random generator factory with 1 appearing 1/N'th of the time\"\n    return lambda: random.randrange(N) == 0\n\ndef unbiased(biased):\n    'uses a biased() generator of 1 or 0, to create an unbiased one'\n    this, that = biased(), biased()\n    while this == that: \n        this, that = biased(), biased()\n    return this         \n\nif __name__ == '__main__':\n    from collections import namedtuple\n\n    Stats = namedtuple('Stats', 'count1 count0 percent')\n\n    for N in range(3, 7):\n        biased = randN(N)\n        v = [biased() for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"Biased(%i)  = %r\" % (N, Stats(v1, v0, 100. * v1/(v1 + v0))) )\n\n        v = [unbiased(biased) for x in range(1000000)]\n        v1, v0 = v.count(1), v.count(0)\n        print ( \"  Unbiased = %r\" % (Stats(v1, v0, 100. * v1/(v1 + v0)), ) )\n"}
{"id": 48842, "name": "Digital root", "source": "Translate Fortran to C#: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 48843, "name": "Digital root", "source": "Translate Fortran to C#: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static Tuple<int, int> DigitalRoot(long num)\n    {\n        int additivepersistence = 0;\n        while (num > 9)\n        {\n            num = num.ToString().ToCharArray().Sum(x => x - '0');\n            additivepersistence++;\n        }\n        return new Tuple<int, int>(additivepersistence, (int)num);\n    }\n    static void Main(string[] args)\n    {\n        foreach (long num in new long[] { 627615, 39390, 588225, 393900588225 })\n        {\n            var t = DigitalRoot(num);\n            Console.WriteLine(\"{0} has additive persistence {1} and digital root {2}\", num, t.Item1, t.Item2);\n        }\n    }\n}\n"}
{"id": 48849, "name": "Digital root", "source": "Translate Fortran to Java: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 48850, "name": "Digital root", "source": "Translate Fortran to Java: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "import java.math.BigInteger;\n\nclass DigitalRoot\n{\n  public static int[] calcDigitalRoot(String number, int base)\n  {\n    BigInteger bi = new BigInteger(number, base);\n    int additivePersistence = 0;\n    if (bi.signum() < 0)\n      bi = bi.negate();\n    BigInteger biBase = BigInteger.valueOf(base);\n    while (bi.compareTo(biBase) >= 0)\n    {\n      number = bi.toString(base);\n      bi = BigInteger.ZERO;\n      for (int i = 0; i < number.length(); i++)\n        bi = bi.add(new BigInteger(number.substring(i, i + 1), base));\n      additivePersistence++;\n    }\n    return new int[] { additivePersistence, bi.intValue() };\n  }\n\n  public static void main(String[] args)\n  {\n    for (String arg : args)\n    {\n      int[] results = calcDigitalRoot(arg, 10);\n      System.out.println(arg + \" has additive persistence \" + results[0] + \" and digital root of \" + results[1]);\n    }\n  }\n}\n"}
{"id": 48851, "name": "Digital root", "source": "Translate Fortran to Python: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 48852, "name": "Digital root", "source": "Translate Fortran to Python: program prec\nimplicit none\ninteger(kind=16) :: i\ni = 627615\ncall root_pers(i)\ni = 39390\ncall root_pers(i)\ni = 588225\ncall root_pers(i)\ni = 393900588225\ncall root_pers(i)\nend program\n\nsubroutine root_pers(i)\nimplicit none\ninteger(kind=16) :: N, s, a, i\nwrite(*,*) 'Number: ', i\nn = i\na = 0\ndo while(n.ge.10)\n  a = a + 1\n  s = 0\n  do while(n.gt.0)\n    s = s + n-int(real(n,kind=8)/10.0D0,kind=8) * 10_8\n    n = int(real(n,kind=16)/real(10,kind=8),kind=8)\n  end do\n  n = s\nend do\nwrite(*,*) 'digital root = ', s\nwrite(*,*) 'additive persistance = ', a\nend subroutine\n", "target": "def digital_root (n):\n    ap = 0\n    n = abs(int(n))\n    while n >= 10:\n        n = sum(int(digit) for digit in str(n))\n        ap += 1\n    return ap, n\n\nif __name__ == '__main__':\n    for n in [627615, 39390, 588225, 393900588225, 55]:\n        persistance, root = digital_root(n)\n        print(\"%12i has additive persistance %2i and digital root %i.\" \n              % (n, persistance, root))\n"}
{"id": 49286, "name": "Loops_Continue", "source": "Translate Fortran to C#: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        for (int i = 1; i <= 10; i++) {\n            Console.Write(i);\n\n            if (i % 5 == 0) {\n                Console.WriteLine();\n                continue;\n            }\n\n            Console.Write(\", \");\n        }\n    }\n}\n"}
{"id": 49289, "name": "Loops_Continue", "source": "Translate Fortran to Java: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "for(int i = 1;i <= 10; i++){\n   System.out.print(i);\n   if(i % 5 == 0){\n      System.out.println();\n      continue;\n   }\n   System.out.print(\", \");\n}\n"}
{"id": 49290, "name": "Loops_Continue", "source": "Translate Fortran to Python: do i = 1, 10\n   write(*, '(I0)', advance='no') i\n   if ( mod(i, 5) == 0 ) then\n      write(*,*)\n      cycle\n   end if\n   write(*, '(A)', advance='no') ', '\nend do\n", "target": "for i in range(1, 11):\n    if i % 5 == 0:\n        print(i)\n        continue\n    print(i, end=', ')\n"}
{"id": 49571, "name": "Filter", "source": "Translate Fortran to C#: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "ArrayList array = new ArrayList( new int[] { 1, 2, 3, 4, 5 } );\nArrayList evens = new ArrayList();\nforeach( int i in array )\n{\n        if( (i%2) == 0 )\n                evens.Add( i );\n}\nforeach( int i in evens )\n       System.Console.WriteLine( i.ToString() );\n"}
{"id": 49574, "name": "Filter", "source": "Translate Fortran to Java: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "int[] array = {1, 2, 3, 4, 5 };\nList<Integer> evensList = new ArrayList<Integer>();\nfor (int  i: array) {\n    if (i % 2 == 0) evensList.add(i);\n}\nint[] evens = evensList.toArray(new int[0]);\n"}
{"id": 49575, "name": "Filter", "source": "Translate Fortran to Python: module funcs\n  implicit none\ncontains\n  pure function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\nend module funcs\n", "target": "values = range(10)\nevens = [x for x in values if not x & 1]\nievens = (x for x in values if not x & 1) \n\nevens = filter(lambda x: not x & 1, values)\n"}
{"id": 49816, "name": "Ludic numbers", "source": "Translate Fortran to C#: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(\"First 25 ludic numbers:\");\n        Console.WriteLine(string.Join(\", \", LudicNumbers(150).Take(25)));\n        Console.WriteLine();\n        \n        Console.WriteLine($\"There are {LudicNumbers(1001).Count()} ludic numbers below 1000\");\n        Console.WriteLine();\n        \n        foreach (var ludic in LudicNumbers(22000).Skip(1999).Take(6)\n                .Select((n, i) => $\"#{i+2000} = {n}\")) {\n            Console.WriteLine(ludic);\n        }\n        Console.WriteLine();\n        \n        Console.WriteLine(\"Triplets below 250:\");\n        var queue = new Queue<int>(5);\n        foreach (int x in LudicNumbers(255)) {\n            if (queue.Count == 5) queue.Dequeue();\n            queue.Enqueue(x);\n            if (x - 6 < 250 && queue.Contains(x - 6) && queue.Contains(x - 4)) {\n                Console.WriteLine($\"{x-6}, {x-4}, {x}\");\n            }\n        }\n    }\n    \n    public static IEnumerable<int> LudicNumbers(int limit) {\n        yield return 1;\n        \n        \n        \n        Entry[] values = Enumerable.Range(0, limit + 1).Select(n => new Entry(n)).ToArray();\n        for (int i = 2; i < limit; i = values[i].Next) {\n            yield return values[i].N;\n            int start = i;\n            while (start < limit) {\n                Unlink(values, start);\n                for (int step = 0; step < i && start < limit; step++)\n                    start = values[start].Next;\n            }\n        }\n    }\n    \n    static void Unlink(Entry[] values, int index) {\n        values[values[index].Prev].Next = values[index].Next;\n        values[values[index].Next].Prev = values[index].Prev;\n    }\n    \n}\n\nstruct Entry\n{\n    public Entry(int n) : this() {\n        N = n;\n        Prev = n - 1;\n        Next = n + 1;\n    }\n    \n    public int N { get; }\n    public int Prev { get; set; }\n    public int Next { get; set; }\n}\n"}
{"id": 49819, "name": "Ludic numbers", "source": "Translate Fortran to Java: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Ludic{\n\tpublic static List<Integer> ludicUpTo(int n){\n\t\tList<Integer> ludics = new ArrayList<Integer>(n);\n\t\tfor(int i = 1; i <= n; i++){   \n\t\t\tludics.add(i);\n\t\t}\n\t\t\n\t\t\n\t\tfor(int cursor = 1; cursor < ludics.size(); cursor++){\n\t\t\tint thisLudic = ludics.get(cursor); \n\t\t\tint removeCursor = cursor + thisLudic; \n\t\t\twhile(removeCursor < ludics.size()){\n\t\t\t\tludics.remove(removeCursor);\t\t     \n\t\t\t\tremoveCursor = removeCursor + thisLudic - 1; \n\t\t\t\t\t\t\t\t\t     \n\t\t\t}\n\t\t}\n\t\treturn ludics;\n\t}\n\t\n\tpublic static List<List<Integer>> getTriplets(List<Integer> ludics){\n\t\tList<List<Integer>> triplets = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < ludics.size() - 2; i++){ \n\t\t\tint thisLudic = ludics.get(i);\n\t\t\tif(ludics.contains(thisLudic + 2) && ludics.contains(thisLudic + 6)){\n\t\t\t\tList<Integer> triplet = new ArrayList<Integer>(3);\n\t\t\t\ttriplet.add(thisLudic);\n\t\t\t\ttriplet.add(thisLudic + 2);\n\t\t\t\ttriplet.add(thisLudic + 6);\n\t\t\t\ttriplets.add(triplet);\n\t\t\t}\n\t\t}\n\t\treturn triplets;\n\t}\n\t\n\tpublic static void main(String[] srgs){\n\t\tSystem.out.println(\"First 25 Ludics: \" + ludicUpTo(110));\t\t\t\t\n\t\tSystem.out.println(\"Ludics up to 1000: \" + ludicUpTo(1000).size());\n\t\tSystem.out.println(\"2000th - 2005th Ludics: \" + ludicUpTo(22000).subList(1999, 2005));  \n\t\tSystem.out.println(\"Triplets up to 250: \" + getTriplets(ludicUpTo(250)));\n\t}\n}\n"}
{"id": 49820, "name": "Ludic numbers", "source": "Translate Fortran to Python: program ludic_numbers\n  implicit none\n  \n  integer, parameter :: nmax = 25000\n  logical :: ludic(nmax) = .true.\n  integer :: i, j, n\n\n  do i = 2, nmax / 2\n    if (ludic(i)) then\n      n = 0\n      do j = i+1, nmax\n        if(ludic(j)) n = n + 1\n        if(n == i) then\n          ludic(j) = .false.\n          n = 0\n        end if\n      end do\n    end if\n  end do\n\n  write(*, \"(a)\", advance = \"no\") \"First 25 Ludic numbers: \"\n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n      write(*, \"(i0, 1x)\", advance = \"no\") i\n      n = n + 1\n    end if\n    if(n == 25) exit\n  end do  \n   \n  write(*, \"(/, a)\", advance = \"no\") \"Ludic numbers below 1000: \"\n  write(*, \"(i0)\") count(ludic(:999))\n \n  write(*, \"(a)\", advance = \"no\") \"Ludic numbers 2000 to 2005: \" \n  n = 0\n  do i = 1, nmax\n    if(ludic(i)) then\n       n = n + 1\n       if(n >= 2000) then\n         write(*, \"(i0, 1x)\", advance = \"no\") i\n         if(n == 2005) exit\n       end if\n     end if\n  end do  \n\n  write(*, \"(/, a)\", advance = \"no\") \"Ludic Triplets below 250: \"\n  do i = 1, 243\n    if(ludic(i) .and. ludic(i+2) .and. ludic(i+6)) then\n       write(*, \"(a, 2(i0, 1x), i0, a, 1x)\", advance = \"no\") \"[\", i, i+2, i+6, \"]\"\n    end if  \n  end do\n\nend program\n", "target": "def ludic(nmax=100000):\n    yield 1\n    lst = list(range(2, nmax + 1))\n    while lst:\n        yield lst[0]\n        del lst[::lst[0]]\n\nludics = [l for l in ludic()]\n\nprint('First 25 ludic primes:')\nprint(ludics[:25])\nprint(\"\\nThere are %i ludic numbers <= 1000\"\n      % sum(1 for l in ludics if l <= 1000)) \nprint(\"\\n2000'th..2005'th ludic primes:\")\nprint(ludics[2000-1: 2005])\n\nn = 250\ntriplets = [(x, x+2, x+6)\n            for x in ludics\n            if x+6 < n and x+2 in ludics and x+6 in ludics]\nprint('\\nThere are %i triplets less than %i:\\n  %r'\n      % (len(triplets), n, triplets))\n"}
{"id": 50030, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to C#:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SieveOfEratosthenes\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int maxprime = int.Parse(args[0]);\n            var primelist = GetAllPrimesLessThan(maxprime);\n            foreach (int prime in primelist)\n            {\n                Console.WriteLine(prime);\n            }\n            Console.WriteLine(\"Count = \" + primelist.Count);\n            Console.ReadLine();\n        }\n\n        private static List<int> GetAllPrimesLessThan(int maxPrime)\n        {\n            var primes = new List<int>();\n            var maxSquareRoot = (int)Math.Sqrt(maxPrime);\n            var eliminated = new BitArray(maxPrime + 1);\n\n            for (int i = 2; i <= maxPrime; ++i)\n            {\n                if (!eliminated[i])\n                {\n                    primes.Add(i);\n                    if (i <= maxSquareRoot)\n                    {\n                        for (int j = i * i; j <= maxPrime; j += i)\n                        {\n                            eliminated[j] = true;\n                        }\n                    }\n                }\n            }\n            return primes;\n        }\n    }\n}\n"}
{"id": 50033, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to Java:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "import java.util.LinkedList;\n\npublic class Sieve{\n       public static LinkedList<Integer> sieve(int n){\n               if(n < 2) return new LinkedList<Integer>();\n               LinkedList<Integer> primes = new LinkedList<Integer>();\n               LinkedList<Integer> nums = new LinkedList<Integer>();\n\n               for(int i = 2;i <= n;i++){ \n                       nums.add(i);\n               }\n\n               while(nums.size() > 0){\n                       int nextPrime = nums.remove();\n                       for(int i = nextPrime * nextPrime;i <= n;i += nextPrime){\n                               nums.removeFirstOccurrence(i);\n                       }\n                       primes.add(nextPrime);\n               }\n               return primes;\n       }\n}\n"}
{"id": 50034, "name": "Sieve of Eratosthenes", "source": "Translate Fortran to Python:       PROGRAM MAIN\n      INTEGER LI\n      WRITE (6,100)\n      READ  (5,110) LI\n      call SOE(LI)\n 100  FORMAT( 'Limit:' )\n 110  FORMAT( I4 )\n      STOP\n      END\n      \nC --- SIEVE OF ERATOSTHENES ----------\n      SUBROUTINE SOE( LI )\n      INTEGER LI\n      LOGICAL A(LI)\n      INTEGER SL,P,I\n      \n      DO 10 I=1,LI\n         A(I) = .TRUE.\n 10   CONTINUE\n      \n      SL = INT(SQRT(REAL(LI)))\n      A(1) = .FALSE.\n      DO 30 P=2,SL\n         IF ( .NOT. A(P) ) GOTO 30\n         DO 20 I=P*P,LI,P\n            A(I)=.FALSE.\n 20      CONTINUE\n 30   CONTINUE\n\n      DO 40 I=2,LI\n         IF ( A(I) ) WRITE(6,100) I\n 40   CONTINUE\n\n 100  FORMAT(I3)\n      RETURN\n      END\n", "target": "from __future__ import print_function\n\ni = 2\n\ndef setup():\n    size(1000, 1000)\n    \n    global maxx, maxy, max_num, sieve\n    maxx = width\n    maxy = height\n    max_num = width * height\n    sieve = [False] * (max_num + 1)\n\n    sieve[1] = False\n    plot(0, False)\n    plot(1, False)\n    for i in range(2, max_num + 1):\n        sieve[i] = True\n        plot(i, True)\n\n\ndef draw():\n    global i\n    if not sieve[i]:\n        while (i * i < max_num and not sieve[i]):\n            i += 1\n\n    if sieve[i]:\n        print(\"{} \".format(i), end = '')\n        for j in range(i * i, max_num + 1, i):\n            if sieve[j]:\n                sieve[j] = False\n                plot(j, False)\n\n    if i * i < max_num:\n        i += 1\n    else:\n        noLoop()\n        println(\"finished\")\n\n\ndef plot(pos, active):\n    set(pos % maxx, pos / maxx, color(0) if active else color(255))\n"}
{"id": 50436, "name": "Sort disjoint sublist", "source": "Translate Fortran to C#: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n     \npublic class Test\n{\n    public static void Main()\n    {\n        var list = new List<int>{ 7, 6, 5, 4, 3, 2, 1, 0 };\n        list.SortSublist(6, 1, 7);\n        Console.WriteLine(string.Join(\", \", list));\n    }\n}\n     \npublic static class Extensions\n{\n    public static void SortSublist<T>(this List<T> list, params int[] indices)\n        where T : IComparable<T>\n    {\n        var sublist = indices.OrderBy(i => i)\n            .Zip(indices.Select(i => list[i]).OrderBy(v => v),\n                (Index, Value) => new { Index, Value });\n     \n        foreach (var entry in sublist) {\n            list[entry.Index] = entry.Value;\n        }\n    }\n     \n}\n"}
{"id": 50439, "name": "Sort disjoint sublist", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Disjoint {\n    public static <T extends Comparable<? super T>> void sortDisjoint(\n            List<T> array, int[] idxs) {\n        Arrays.sort(idxs);\n        List<T> disjoint = new ArrayList<T>();\n        for (int idx : idxs) {\n            disjoint.add(array.get(idx));\n        }\n        Collections.sort(disjoint);\n        int i = 0;\n        for (int idx : idxs) {\n            array.set(idx, disjoint.get(i++));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 5, 4, 3, 2, 1, 0);\n        int[] indices = {6, 1, 7};\n        System.out.println(list);\n        sortDisjoint(list, indices);\n        System.out.println(list);\n    }\n}\n"}
{"id": 50440, "name": "Sort disjoint sublist", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  integer :: array(8) = (/ 7, 6, 5, 4, 3, 2, 1, 0 /)\n  integer :: indices(3) = (/ 7, 2, 8 /)\n\n\n\n  call Isort(indices)\n\n\n\n\n  call Isort(array(indices))\n\n  write(*,*) array\n\ncontains\n\nsubroutine Isort(a)\n  integer, intent(in out) :: a(:)\n  integer :: temp\n  integer :: i, j\n   \n  do i = 2, size(a)\n     j = i - 1\n     temp = a(i)\n     do while (j>=1 .and. a(j)>temp)\n        a(j+1) = a(j)\n        j = j - 1\n     end do\n     a(j+1) = temp\n  end do\n  \nend subroutine Isort\nend program Example\n", "target": ">>> def sort_disjoint_sublist(data, indices):\n\tindices = sorted(indices)\n\tvalues  = sorted(data[i] for i in indices)\n\tfor index, value in zip(indices, values):\n\t\tdata[index] = value\n\n\t\t\n>>> d = [7, 6, 5, 4, 3, 2, 1, 0]\n>>> i = set([6, 1, 7])\n>>> sort_disjoint_sublist(d, i)\n>>> d\n[7, 0, 5, 4, 3, 2, 1, 6]\n>>> \n>>> def sort_disjoint_sublist(data, indices):\n\tfor index, value in zip(sorted(indices), sorted(data[i] for i in indices)): data[index] = value\n\n\t\n>>>\n"}
{"id": 50601, "name": "Kronecker product", "source": "Translate Fortran to C#:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class KroneckerProduct\n{\n    public static void Main() {\n        int[,] left = { {1, 2}, {3, 4} };\n        int[,] right = { {0, 5}, {6, 7} };\n        Print(Multiply(left, right));\n\n        left = new [,] { {0, 1, 0}, {1, 1, 1}, {0, 1, 0} };\n        right = new [,] { {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1} };\n        Print(Multiply(left, right));\n    }\n\n    static int[,] Multiply(int[,] left, int[,] right) {\n        (int lRows, int lColumns) = (left.GetLength(0), left.GetLength(1));\n        (int rRows, int rColumns) = (right.GetLength(0), right.GetLength(1));\n        int[,] result = new int[lRows * rRows, lColumns * rColumns];\n\n        foreach (var (r, c) in from r in Range(0, lRows) from c in Range(0, lColumns) select (r, c)) {\n            Copy(r * rRows, c * rColumns, left[r, c]);\n        }\n        return result;\n        \n        void Copy(int startRow, int startColumn, int multiplier) {\n            foreach (var (r, c) in from r in Range(0, rRows) from c in Range(0, rColumns) select (r, c)) {\n                result[startRow + r, startColumn + c] = right[r, c] * multiplier;\n            }\n        }\n    }\n\n    static void Print(int[,] matrix) {\n        (int rows, int columns) = (matrix.GetLength(0), matrix.GetLength(1));\n        int width = matrix.Cast<int>().Select(LengthOf).Max();\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"| \" + string.Join(\" \", Range(0, columns).Select(column => (matrix[row, column] + \"\").PadLeft(width, ' '))) + \" |\");\n        }\n        Console.WriteLine();\n    }\n\n    private static int LengthOf(int i) {\n        if (i < 0) return LengthOf(-i) + 1;\n        int length = 0;\n        while (i > 0) {\n            length++;\n            i /= 10;\n        }\n        return length;\n    }\n\n}\n"}
{"id": 50604, "name": "Kronecker product", "source": "Translate Fortran to Java:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "package kronecker;\n\n\npublic class Product {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void print_matrix(final int[][] m) {\n    \n    \n    \n    \n    final String[][] sts = new String[m.length][];\n    int max_length = 0;  \n    for (int im = 0; im < m.length; im++) {\n      sts[im] = new String[m[im].length];\n      for (int jm = 0; jm < m[im].length; jm++) {\n        final String st = String.valueOf(m[im][jm]);\n        if (st.length() > max_length) {\n          max_length = st.length();\n        }\n        sts[im][jm] = st;\n      }\n    }\n\n    \n    \n    \n    final String format = String.format(\"%%%ds\", max_length);\n    for (int im = 0; im < m.length; im++) {\n      System.out.print(\"|\");\n      \n      for (int jm = 0; jm < m[im].length - 1; jm++) {\n        System.out.format(format, m[im][jm]);\n        System.out.print(\" \");\n      }\n      System.out.format(format, m[im][m[im].length - 1]);\n      System.out.println(\"|\");\n    }\n  }\n\n  \n  private static void test(final int[][] a, final int[][] b) {\n    \n    System.out.println(\"Testing Kronecker product\");\n    System.out.println(\"Size of matrix a: \" + a.length + \" by \" + a[0].length);\n    System.out.println(\"Matrix a:\");\n    print_matrix(a);\n    System.out.println(\"Size of matrix b: \" + b.length + \" by \" + b[0].length);\n    System.out.println(\"Matrix b:\");\n    print_matrix(b);\n    System.out.println(\"Calculating matrix c as Kronecker product\");\n    final int[][] c = product(a, b);\n    System.out.println(\"Size of matrix c: \" + c.length + \" by \" + c[0].length);\n    System.out.println(\"Matrix c:\");\n    print_matrix(c);\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] a = new int[2][];  \n    a[0] = new int[]{1, 2};\n    a[1] = new int[]{3, 4};\n    final int[][] b = new int[2][];  \n    b[0] = new int[]{0, 5};\n    b[1] = new int[]{6, 7};\n    \n    test(a, b);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] a = new int[3][];  \n    a[0] = new int[]{0, 1, 0};\n    a[1] = new int[]{1, 1, 1};\n    a[2] = new int[]{0, 1, 0};\n    final int[][] b = new int[3][];  \n    b[0] = new int[]{1, 1, 1, 1};\n    b[1] = new int[]{1, 0, 0, 1};\n    b[2] = new int[]{1, 1, 1, 1};\n    \n    test(a, b);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n  }\n\n}\n"}
{"id": 50605, "name": "Kronecker product", "source": "Translate Fortran to Python:       MODULE ARRAYMUSH\t\n       CONTAINS\t\t\n        SUBROUTINE KPRODUCT(A,B,AB)\t\nConsiders the arrays to be addressed as A(row,column), despite any storage order arrangements.        .\nCreating array AB to fit here, adjusting the caller's array AB, may not work on some compilers.\n         INTEGER A(:,:),B(:,:)\t\t\n         INTEGER, ALLOCATABLE:: AB(:,:)\t\n         INTEGER R,RA,RB,C,CA,CB,I\t\n          RA = UBOUND(A,DIM = 1)\t\n          CA = UBOUND(A,DIM = 2)\t\n          RB = UBOUND(B,DIM = 1)\t\n          CB = UBOUND(B,DIM = 2)\t\n          WRITE (6,1) \"A\",RA,CA,\"B\",RB,CB,\"A.k.B\",RA*RB,CA*CB\t\n    1     FORMAT (3(A,\" is \",I0,\"x\",I0,1X))\t\n          IF (ALLOCATED(AB)) DEALLOCATE(AB)\t\n          ALLOCATE (AB(RA*RB,CA*CB))\t\t\n          R = 0\t\t\n          DO I = 1,RA\t\n            C = 0\t\t\n            DO J = 1,CA\t\t\n              AB(R + 1:R + RB,C + 1:C + CB) = A(I,J)*B\t\n              C = C + CB\t\t\n            END DO\t\t\n            R = R + RB\t\t\n          END DO\t\n        END SUBROUTINE KPRODUCT\t\n\n        SUBROUTINE SHOW(F,A)\t\n         INTEGER F\t\n         INTEGER A(:,:)\t\n         INTEGER R\t\n          DO R = 1,UBOUND(A,DIM = 1)\t\n            WRITE (F,1) A(R,:)\t\t\n    1       FORMAT (666I3)\t\t\n          END DO\t\t\t\n        END SUBROUTINE SHOW\t\n      END MODULE ARRAYMUSH\t\n\n      PROGRAM POKE\n      USE ARRAYMUSH\n      INTEGER A(2,2),B(2,2)\t\t\n      INTEGER, ALLOCATABLE:: AB(:,:)\t\n      INTEGER C(3,3),D(3,4)\t\t\n      DATA A/1,3, 2,4/,B/0,6, 5,7/\t\n      DATA C/0,1,0, 1,1,1, 0,1,0/\t\n      DATA D/1,1,1, 1,0,1, 1,0,1, 1,1,1/\n\n      WRITE (6,*) \"First test...\"\n      CALL KPRODUCT(A,B,AB)\n      CALL SHOW (6,AB)\n\n      WRITE (6,*)\n      WRITE (6,*) \"Second test...\"\n      CALL KPRODUCT(C,D,AB)\n      CALL SHOW (6,AB)\n\n      END\n", "target": "\n\n\na1 = [[1, 2], [3, 4]]\nb1 = [[0, 5], [6, 7]]\n\n\na2 = [[0, 1, 0], [1, 1, 1], [0, 1, 0]]\nb2 = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]]\n\ndef kronecker(matrix1, matrix2):\n    final_list = []\n    sub_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        counter = 0\n        check = 0\n        while check < count:\n            for num1 in elem1:\n                for num2 in matrix2[counter]:\n                    sub_list.append(num1 * num2)\n            counter += 1\n            final_list.append(sub_list)\n            sub_list = []\n            check +=1\n            \n    return final_list\n\n\nresult1 = kronecker(a1, b1)\nfor elem in result1:\n    print(elem)\n\nprint(\"\")\n\n\nresult2 = kronecker(a2, b2)\nfor elem in result2:\n    print(elem)\n"}
{"id": 50879, "name": "Split a character string based on change of character", "source": "Translate Fortran to C#:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 50880, "name": "Split a character string based on change of character", "source": "Translate Fortran to C#:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    string s = @\"gHHH5YY++\n    Console.WriteLine(s.RunLengthSplit().Delimit(\", \"));\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<string> RunLengthSplit(this string source) {\n        using (var enumerator = source.GetEnumerator()) {\n            if (!enumerator.MoveNext()) yield break;\n            char previous = enumerator.Current;\n            int count = 1;\n            while (enumerator.MoveNext()) {\n                if (previous == enumerator.Current) {\n                    count++;\n                } else {\n                    yield return new string(Enumerable.Repeat(previous, count).ToArray());\n                    previous = enumerator.Current;\n                    count = 1;\n                }\n            }\n            yield return new string(Enumerable.Repeat(previous, count).ToArray());\n        }\n    }\n\n    public static string Delimit<T>(this IEnumerable<T> source, string separator = \"\") => string.Join(separator ?? \"\", source);\n}\n"}
{"id": 50885, "name": "Split a character string based on change of character", "source": "Translate Fortran to Java:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 50886, "name": "Split a character string based on change of character", "source": "Translate Fortran to Java:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SplitStringByCharacterChange {\n    \n    public static void main(String... args){\n        for (String string : args){\n            \n            List<String> resultStrings = splitStringByCharacter(string);\n            String output = formatList(resultStrings);\n            System.out.println(output);\n        }\n    }\n    \n    \n    public static List<String> splitStringByCharacter(String string){\n        \n        List<String> resultStrings = new ArrayList<>();\n        StringBuilder currentString = new StringBuilder();\n        \n        for (int pointer = 0; pointer < string.length(); pointer++){\n            \n            currentString.append(string.charAt(pointer));\n            \n            if (pointer == string.length() - 1 \n                    || currentString.charAt(0) != string.charAt(pointer + 1)) {\n                resultStrings.add(currentString.toString());\n                currentString = new StringBuilder();\n            }\n        }\n        \n        return resultStrings;\n    }\n    \n    \n    public static String formatList(List<String> list){\n        \n        StringBuilder output = new StringBuilder();\n        \n        for (int pointer = 0; pointer < list.size(); pointer++){\n            output.append(list.get(pointer));\n            \n            if (pointer != list.size() - 1){\n                output.append(\", \");\n            }\n        }\n        \n        return output.toString();\n    }\n}\n"}
{"id": 50887, "name": "Split a character string based on change of character", "source": "Translate Fortran to Python:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 50888, "name": "Split a character string based on change of character", "source": "Translate Fortran to Python:       SUBROUTINE SPLATTER(TEXT)\t\nCan't display the inserted commas in a different colour so as not to look like any commas in TEXT.\n       CHARACTER*(*) TEXT\t\n       INTEGER L\t\n       CHARACTER*1 C\t\n        IF (LEN(TEXT).LE.0) RETURN\t\n        C = TEXT(1:1)\t\t\t\n        DO L = 1,LEN(TEXT)\t\n          IF (C.NE.TEXT(L:L)) THEN\t\n            C = TEXT(L:L)\t\t\t\n            WRITE (6,1) \", \"\t\t\t\n          END IF\t\t\t\n          WRITE (6,1) C\t\t\t\n    1     FORMAT (A,$)\t\t\t\n        END DO\t\t\t\n        WRITE (6,1)\t\n      END SUBROUTINE SPLATTER\t\n\n      PROGRAM POKE\n      CALL SPLATTER(\"gHHH5YY++///\\\")\t\n      END\n", "target": "from itertools import groupby\n\ndef splitter(text):\n    return ', '.join(''.join(group) for key, group in groupby(text))\n\nif __name__ == '__main__':\n    txt = 'gHHH5YY++///\\\\'      \n    print(f'Input: {txt}\\nSplit: {splitter(txt)}')\n"}
{"id": 51191, "name": "Truncatable primes", "source": "Translate Fortran to C#: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "using System;  \nusing System.Collections.Generic;\nclass truncatable_primes\n{\n    static void Main()\n    {\n        uint m = 1000000;\n        Console.Write(\"L \" + L(m) + \" R \" + R(m) + \"  \");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) { L(m); R(m); }\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint L(uint n)\n    {\n        n -= n & 1; n--;\n        for (uint d, d1 = 100; ; n -= 2)\n        {\n            while (n % 3 == 0 || n % 5 == 0 || n % 7 == 0) n -= 2;\n            if ((d = n % 10) == 3 || d == 7)\n            {\n                while (d1 < n && d < (d = n % d1) && isP(d)) d1 *= 10;\n                if (d1 > n && isP(n)) return n; d1 = 100;\n            }\n        }\n    }\n\n    static uint R(uint m)\n    {\n        var p = new List<uint>() { 2, 3, 5, 7 }; uint n = 20, np;\n        for (int i = 1; i < p.Count; n = 10 * p[i++])\n        {\n            if ((np = n + 1) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 3) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 7) >= m) break; if (isP(np)) p.Add(np);\n            if ((np = n + 9) >= m) break; if (isP(np)) p.Add(np);\n        }\n        return p[p.Count - 1];\n    }\n\n    static bool isP(uint n)\n    {\n        if (n < 7) return n == 2 || n == 3 || n == 5;\n        if ((n & 1) == 0 || n % 3 == 0 || n % 5 == 0) return false;\n        for (uint r = (uint)Math.Sqrt(n), d = 7; d <= r; d += 30)\n            if (n % (d + 00) == 0 || n % (d + 04) == 0 ||\n                n % (d + 06) == 0 || n % (d + 10) == 0 ||\n                n % (d + 12) == 0 || n % (d + 16) == 0 ||\n                n % (d + 22) == 0 || n % (d + 24) == 0) return false;\n        return true;\n    }\n}\n"}
{"id": 51195, "name": "Truncatable primes", "source": "Translate Fortran to Java: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "import java.util.BitSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args){\n\n\t\tfinal int MAX = 1000000;\n\n\t\t\n\t\tBitSet primeList = new BitSet(MAX>>1); \n\t\tprimeList.set(0,primeList.size(),true); \n\n\t\tint sqroot = (int) Math.sqrt(MAX); \n\t\tprimeList.clear(0); \n\t\tfor(int num = 3; num <= sqroot; num+=2) \n\t\t{ \n\t\t\tif( primeList.get(num >> 1) ) \n\t\t\t{ \n\t\t\t\tint inc = num << 1;\n\t\t\t\tfor(int factor = num * num; factor < MAX; factor += inc) \n\t\t\t\t{ \n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tprimeList.clear(factor >> 1); \n\t\t\t\t\t\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\t\n\n\t\t\n\t\tint rightTrunc = -1, leftTrunc = -1;\n\t\tfor(int prime = (MAX - 1) | 1; prime >= 3; prime -= 2)\n\t\t{\n\t\t\tif(primeList.get(prime>>1))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(rightTrunc == -1)\n\t\t\t\t{\n\t\t\t\t\tint right = prime;\n\t\t\t\t\twhile(right > 0 && right % 2 != 0 && primeList.get(right >> 1)) right /= 10;\n\t\t\t\t\tif(right == 0) rightTrunc = prime;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(leftTrunc == -1 )\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tString left = Integer.toString(prime);\n\t\t\t\t\tif(!left.contains(\"0\"))\n\t\t\t\t\t{\n\t\t\t\t\t\twhile( left.length() > 0 ){\n\t\t\t\t\t\t\tint iLeft = Integer.parseInt(left);\n\t\t\t\t\t\t\tif(!primeList.get( iLeft >> 1)) break;\n\t\t\t\t\t\t\tleft = left.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left.length() == 0) leftTrunc = prime;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftTrunc != -1 && rightTrunc != -1) \n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Left  Truncatable\u00a0: \" + leftTrunc);\n\t\tSystem.out.println(\"Right Truncatable\u00a0: \" + rightTrunc);\n\t}\n}\n"}
{"id": 51196, "name": "Truncatable primes", "source": "Translate Fortran to Python: module primes_mod\n  implicit none\n  \n  logical, allocatable :: primes(:)\n  \ncontains\n\nsubroutine Genprimes(parr)\n  logical, intent(in out) :: parr(:)\n  integer :: i\n\n  parr = .true.\n  parr (1) = .false.\n  parr (4 : size(parr) : 2) = .false.\n  do i = 3, int (sqrt (real (size(parr)))), 2\n    if (parr(i)) parr(i * i : size(parr) : i) = .false.\n  end do\n\nend subroutine\n\nfunction is_rtp(candidate)\n  logical :: is_rtp\n  integer, intent(in) :: candidate\n  integer :: n\n\n  is_rtp = .true.\n  n = candidate / 10\n  do while(n > 0)\n    if(.not. primes(n)) then\n      is_rtp = .false.\n      return\n    end if\n    n = n / 10\n  end do\n  \nend function\n\nfunction is_ltp(candidate)\n  logical :: is_ltp\n  integer, intent(in) :: candidate\n  integer :: i, n\n  character(10) :: nstr\n\n  write(nstr, \"(i10)\") candidate\n  is_ltp = .true.\n  do i = len_trim(nstr)-1, 1, -1\n    n = mod(candidate, 10**i)\n    if(.not. primes(n)) then\n      is_ltp = .false.\n      return\n    end if\n  end do\nend function\n\nend module primes_mod\n\nprogram Truncatable_Primes\n  use primes_mod\n  implicit none\n  \n  integer, parameter :: limit = 999999\n  integer :: i\n  character(10) :: nstr\n \n\n  allocate(primes(limit))\n  call Genprimes(primes)\n   \n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_ltp(i)) then\n      write(*, \"(a, i0)\") \"Largest left truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\n\n\n  do i = limit, 1, -1\n    write(nstr, \"(i10)\") i\n    if(index(trim(nstr), \"0\") /= 0) cycle      \n    if(is_rtp(i)) then\n      write(*, \"(a, i0)\") \"Largest right truncatable prime below 1000000 is \", i\n      exit\n    end if\n  end do\nend program\n", "target": "maxprime = 1000000\n\ndef primes(n):\n    multiples = set()\n    prime = []\n    for i in range(2, n+1):\n        if i not in multiples:\n            prime.append(i)\n            multiples.update(set(range(i*i, n+1, i)))\n    return prime\n\ndef truncatableprime(n):\n    'Return a longest left and right truncatable primes below n'\n    primelist = [str(x) for x in primes(n)[::-1]]\n    primeset = set(primelist)\n    for n in primelist:\n        \n        alltruncs = set(n[i:] for i in range(len(n)))\n        if alltruncs.issubset(primeset):\n            truncateleft = int(n)\n            break\n    for n in primelist:\n        \n        alltruncs = set([n[:i+1] for i in range(len(n))])\n        if alltruncs.issubset(primeset):\n            truncateright = int(n)\n            break\n    return truncateleft, truncateright\n\nprint(truncatableprime(maxprime))\n"}
{"id": 51541, "name": "Nested function", "source": "Translate Fortran to C#:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51542, "name": "Nested function", "source": "Translate Fortran to C#:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "string MakeList(string separator)\n{\n    int counter = 1;\n\n    Func<string, string> makeItem = item => counter++ + separator + item + \"\\n\";\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\");\n}\n\nConsole.WriteLine(MakeList(\". \"));\n"}
{"id": 51548, "name": "Nested function", "source": "Translate Fortran to Java:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51549, "name": "Nested function", "source": "Translate Fortran to Java:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "module NestedFunction\n    {\n    static String makeList(String separator)\n        {\n        Int counter = 1;\n\n        function String(String) makeItem = item -> $\"{counter++}{separator}{item}\\n\";\n\n        return makeItem(\"first\")\n             + makeItem(\"second\")\n             + makeItem(\"third\");\n        }\n\n    void run()\n        {\n        @Inject Console console;\n        console.print(makeList(\". \"));\n        }\n    }\n"}
{"id": 51550, "name": "Nested function", "source": "Translate Fortran to Python:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51551, "name": "Nested function", "source": "Translate Fortran to Python:       FUNCTION F(X)\n       REAL X\n       DIST(U,V,W) = X*SQRT(U**2 + V**2 + W**2)    \n        T = EXP(X)\n        F = T + DIST(T,SIN(X),ATAN(X) + 7)         \n      END\n", "target": "def makeList(separator):\n    counter = 1\n\n    def makeItem(item):\n        nonlocal counter\n        result = str(counter) + separator + item + \"\\n\"\n        counter += 1\n        return result\n\n    return makeItem(\"first\") + makeItem(\"second\") + makeItem(\"third\")\n\nprint(makeList(\". \"))\n"}
{"id": 51887, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to C#:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "namespace RosettaCode {\n  using System;\n\n  public class MergeSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    public const Int32 MERGES_DEFAULT = 6;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    protected UInt32[] Positions { get; set; }\n\n    private Int32 merges;\n    public Int32 Merges {\n      get { return merges; }\n      set {\n        \n        if (value > 1)\n          merges = value;\n        else\n          throw new ArgumentOutOfRangeException($\"value = {value} must be greater than one\", nameof(Merges));\n\n        if (Positions == null || Positions.Length != merges)\n          Positions = new UInt32[merges];\n      }\n    }\n    #endregion\n\n    #region Constructors\n    public MergeSort(UInt32 insertionLimit, Int32 merges) {\n      InsertionLimit = insertionLimit;\n      Merges = merges;\n    }\n\n    public MergeSort()\n      : this(INSERTION_LIMIT_DEFAULT, MERGES_DEFAULT) {\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      \n      var entries2 = new T[entries.Length];\n      Sort(entries, entries2, 0, entries.Length - 1);\n    }\n\n    \n    public void Sort(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      if (length < 2) return;      \n      if (length < Merges || length < InsertionLimit) {\n        InsertionSort<T>.Sort(entries1, first, last);\n        return;\n      }\n\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size) {\n        var right = left + Math.Min(remaining, size) - 1;\n        Sort(entries1, entries2, left, right);\n      }\n\n      Merge(entries1, entries2, first, last);\n      Array.Copy(entries2, first, entries1, first, length);\n    }\n    #endregion\n\n    #region Merge Methods\n    public void Merge(T[] entries1, T[] entries2, Int32 first, Int32 last) {\n      Array.Clear(Positions, 0, Merges);\n      \n      for (var index = first; index <= last; index++)\n        entries2[index] = remove(entries1, first, last);\n    }\n\n    private T remove(T[] entries, Int32 first, Int32 last) {\n      T entry = default;\n      Int32? found = default;\n      var length = last + 1 - first;\n\n      var index = 0;\n      var left = first;\n      var size = ceiling(length, Merges);\n      for (var remaining = length; remaining > 0; remaining -= size, left += size, index++) {\n        var position = Positions[index];\n        if (position < Math.Min(remaining, size)) {\n          var next = entries[left + position];\n          if (!found.HasValue || entry.CompareTo(next) > 0) {\n            found = index;\n            entry = next;\n          }\n        }\n      }\n\n      \n      Positions[found.Value]++;\n      return entry;\n    }\n    #endregion\n\n    #region Math Methods\n    private static Int32 ceiling(Int32 numerator, Int32 denominator) {\n      return (numerator + denominator - 1) / denominator;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 51890, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to Java:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Merge{\n    public static <E extends Comparable<? super E>> List<E> mergeSort(List<E> m){\n        if(m.size() <= 1) return m;\n\n        int middle = m.size() / 2;\n        List<E> left = m.subList(0, middle);\n        List<E> right = m.subList(middle, m.size());\n\n        right = mergeSort(right);\n        left = mergeSort(left);\n        List<E> result = merge(left, right);\n\n        return result;\n    }\n\n    public static <E extends Comparable<? super E>> List<E> merge(List<E> left, List<E> right){\n        List<E> result = new ArrayList<E>();\n        Iterator<E> it1 = left.iterator();\n        Iterator<E> it2 = right.iterator();\n\n\tE x = it1.next();\n\tE y = it2.next();\n        while (true){\n            \n            if(x.compareTo(y) <= 0){\n\t\tresult.add(x);\n\t\tif(it1.hasNext()){\n\t\t    x = it1.next();\n\t\t}else{\n\t\t    result.add(y);\n\t\t    while(it2.hasNext()){\n\t\t\tresult.add(it2.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }else{\n\t\tresult.add(y);\n\t\tif(it2.hasNext()){\n\t\t    y = it2.next();\n\t\t}else{\n\t\t    result.add(x);\n\t\t    while (it1.hasNext()){\n\t\t\tresult.add(it1.next());\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n        }\n        return result;\n    }\n}\n"}
{"id": 51891, "name": "Sorting algorithms_Merge sort", "source": "Translate Fortran to Python:       program TestMergeSort\n        implicit none\n        integer, parameter :: N = 8\n        integer :: A(N) = (/ 1, 5, 2, 7, 3, 9, 4, 6 /)\n        integer :: work((size(A) + 1) / 2)\n        write(*,'(A,/,10I3)')'Unsorted array\u00a0:',A\n        call MergeSort(A, work)\n        write(*,'(A,/,10I3)')'Sorted array\u00a0:',A\n      contains\n\n      subroutine merge(A, B, C)\n        implicit none\n\n        integer, target, intent(in) :: A(:), B(:)\n        integer, target, intent(inout) :: C(:)\n        integer :: i, j, k\n\n        if (size(A) + size(B) > size(C)) stop(1)\n\n        i = 1; j = 1\n        do k = 1, size(C)\n          if (i <= size(A) .and. j <= size(B)) then\n            if (A(i) <= B(j)) then\n              C(k) = A(i)\n              i = i + 1\n            else\n              C(k) = B(j)\n              j = j + 1\n            end if\n          else if (i <= size(A)) then\n            C(k) = A(i)\n            i = i + 1\n          else if (j <= size(B)) then\n            C(k) = B(j)\n            j = j + 1\n          end if\n        end do\n      end subroutine merge\n\n      subroutine swap(x, y)\n        implicit none\n        integer, intent(inout) :: x, y\n        integer :: tmp\n        tmp = x; x = y; y = tmp\n      end subroutine\n\n      recursive subroutine MergeSort(A, work)\n        implicit none\n        integer, intent(inout) :: A(:)\n        integer, intent(inout) :: work(:)\n        integer :: half\n        half = (size(A) + 1) / 2\n        if (size(A) < 2) then\n          continue\n        else if (size(A) == 2) then\n          if (A(1) > A(2)) then\n            call swap(A(1), A(2))\n          end if\n        else\n          call MergeSort(A( : half), work)\n          call MergeSort(A(half + 1 :), work)\n          if (A(half) > A(half + 1)) then\n            work(1 : half) = A(1 : half)\n            call merge(work(1 : half), A(half + 1:), A)\n          endif\n        end if\n      end subroutine MergeSort\n      end program TestMergeSort\n", "target": "fun mergesort(m):\n    if m.lenght <= 1: return m\n    let middle = floor m.lenght / 2\n    let left = merge(m[:middle])\n    let right = merge(m[middle-1:]);\n\nfun merge(left, right):\n    let result = []\n    while not (left.isempty or right.isempty):\n        if left[1] <= right[1]:\n            result.push! left.shift!()\n        else:\n            result.push! right.shift!()\n    result.push! left.push! right\n\nlet arr = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\nprint mergesort arr\n"}
{"id": 52921, "name": "Ascending primes", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 52922, "name": "Ascending primes", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace ascendingprimes\n{\n    class Program\n    {\n        static bool isPrime(uint n)\n        {\n            if (n == 2)\n                return true;\n            if (n == 1 || n % 2 = 0)\n                return false;\n            uint root = (uint)Math.Sqrt(n);\n            for (uint k = 3; k <= root; k += 2)\n                if (n % k == 0)\n                    return false;\n            return true;\n        }\n        static void Main(string[] args)\n        {\n            var queue = new Queue<uint>();\n            var primes = new List<uint>();\n\n            for (uint k = 1; k <= 9; k++)\n                queue.Enqueue(k);\n            while(queue.Count > 0)\n            {\n                uint n = queue.Dequeue();\n                if (isPrime(n))\n                    primes.Add(n);\n                for (uint k = n % 10 + 1; k <= 9; k++)\n                    queue.Enqueue(n * 10 + k);\n            }\n\n            foreach (uint p in primes)\n            {\n                Console.Write(p);\n                Console.Write(\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 52929, "name": "Ascending primes", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 52930, "name": "Ascending primes", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "\n\npackage example.rossetacode.ascendingprimes;\n\nimport java.util.Arrays;\n\npublic class Program implements Runnable {\n\n    public static void main(String[] args) {\n        long t1 = System.nanoTime();\n        new Program().run();\n        long t2 = System.nanoTime();\n        System.out.println(\n                \"total time consumed = \" + (t2 - t1) * 1E-6 + \" milliseconds\");\n    }\n\n    public void run() {\n\n        final int MAX_SIZE = 1000;\n        final int[] queue = new int[MAX_SIZE];\n        int begin = 0;\n        int end = 0;\n\n        for (int k = 1; k <= 9; k++) {\n            queue[end++] = k;\n        }\n\n        while (begin < end) {\n            int n = queue[begin++];\n            for (int k = n % 10 + 1; k <= 9; k++) {\n                queue[end++] = n * 10 + k;\n            }\n        }\n\n        \n        \n        \n        System.out.println(Arrays.stream(queue).filter(this::isPrime).boxed().toList());\n    }\n\n    private boolean isPrime(int n) {\n        if (n == 2) {\n            return true;\n        }\n        if (n == 1 || n % 2 == 0) {\n            return false;\n        }\n        int root = (int) Math.sqrt(n);\n        for (int k = 3; k <= root; k += 2) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 52931, "name": "Ascending primes", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 52932, "name": "Ascending primes", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    \nprogram prog\n\n    parameter (MAXSIZE = 1000)\n    \n    logical isprime\n    dimension iqueue(MAXSIZE)\n    dimension iprimes(MAXSIZE)\n    \n    ibegin = 1\n    iend = 1\n    n = 0\n\n    do k = 1, 9\n        iqueue(iend) = k\n        iend = iend + 1\n    end do\n    \n    do while (ibegin .lt. iend)\n        iv = iqueue(ibegin)\n        ibegin = ibegin + 1\n        if (isprime(iv)) then\n            n = n + 1\n            iprimes(n) = iv\n        end if\n        lsd1 = mod(iv, 10) + 1\n        if (lsd1 .le. 9) then\n            do k = lsd1, 9\n                iqueue(iend) = iv * 10 + k\n                iend = iend + 1\n            end do\n        end if\n    end do\n\n    print *, (iprimes(i), i = 1, n)\n\nend program\n\n\nlogical function isprime(n)\n    \n\n\n\n\n\n\n\n\n\n    isprime = .FALSE.\n    if (n .eq. 0 .or. n .eq. 1) then\n        return\n    end if\n    if (n .ne. 2) then\n        if (mod(n, 2) .eq. 0) then\n            return\n        end if\n        m = n**0.5\n        do k = 3, m, 2\n            if (mod(n, k) .eq. 0) then\n                return\n            end if\n        end do\n    end if\n    isprime = .TRUE.\nend function\n", "target": "from sympy import isprime\n\ndef ascending(x=0):\n    for y in range(x*10 + (x%10) + 1, x*10 + 10):\n        yield from ascending(y)\n        yield(y)\n\nprint(sorted(x for x in ascending() if isprime(x)))\n"}
{"id": 53148, "name": "Tic-tac-toe", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\nmodule tic\n   implicit none\n   integer :: b(9)\ncontains\n   logical function iswin(p)\n      integer,intent(in) :: p\n      iswin = &\n         all(b([1,2,3])==p).or.all(b([4,5,6])==p).or.all(b([7,8,9])==p).or.&\n         all(b([1,4,7])==p).or.all(b([2,5,8])==p).or.all(b([3,6,9])==p).or.&\n         all(b([1,5,9])==p).or.all(b([3,5,7])==p)\n   end function iswin\n   subroutine printb(mes)\n      character(len=*) :: mes\n      integer          :: i,j\n      character        :: s(0:2) = ['.','X','O']\n      print \"(3a3,'   ',3i3)\",(s(b(3*i+1:3*i+3)),(j,j=3*i+1,3*i+3),i=0,2)\n      if(mes /= ' ') print \"(/,a)\",mes\n   end subroutine printb\n   integer recursive function minmax(player,bestm) result(bestv)\n      integer :: player,bestm,move,v,bm,win=1000,inf=100000\n      real    :: x\n      if (all(b .ne. 0)) then\n         bestv = 0\n      else\n         bestv = -inf\n         do move=1,9\n            if (b(move) == 0) then\n               b(move) = player\n               if (iswin(player)) then\n                  v = win\n               else\n                  call random_number(x)\n                  v = -minmax(3-player,bm) - int(10*x)\n               endif\n               if (v > bestv) then\n                  bestv = v\n                  bestm = move\n               endif\n               b(move) = 0\n               if (v == win) exit\n            endif\n         enddo\n      endif\n   end function minmax\nend module tic\nprogram tictactoe\n   \n   use tic\n   implicit none \n   integer :: move,ios,v,bestmove,ply,player=2,k,values(8)\n   integer,allocatable :: seed(:)\n   call date_and_time(values=values)\n   call random_seed(size=k)\n   allocate(seed(k))\n   seed = values(8)+1000*values(7)+60*1000*values(6)+60*60*1000*values(5)\n   call random_seed(put=seed)\n   mainloop: do\n      b = 0\n      call printb('You have O, I have X. You enter 0: game ends.')\n      plyloop: do ply=0,4\n         if (player == 2 .or. ply >0 ) then  \n            write(*,\"(/,a)\",advance='no'),'Your move? (0..9) '\n            getloop: do\n               readloop: do\n                  read (*,*,iostat=ios),move\n                  if (ios == 0 .and. move  >= 0 .and. move <= 9) exit readloop\n                  write(*,\"(a)\",advance='no'),'huh? Try again (0..9): '\n               enddo readloop\n               if (  move  == 0) exit mainloop\n               if (b(move) == 0) exit getloop\n               write(*,\"(a)\",advance='no'),'Already occupied, again (0..9): '\n            enddo getloop\n            b(move) = 2\n            if(iswin(2)) then   \n               call printb('***** You win *****')\n               exit plyloop\n            endif\n         endif\n         v = minmax(1,bestmove)   \n         b(bestmove) = 1\n         if(iswin(1)) then\n            call printb('***** I win *****')\n            exit plyloop\n         endif\n         write(*,\"(/,a,i3)\"), 'My move: ',bestmove\n         call printb(' ')\n      enddo plyloop\n      if(ply == 5) write(*,\"('***** Draw *****',/)\")\n      player = 3-player\n   enddo mainloop\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaTicTacToe\n{\n  class Program\n  {\n\n    \n    static string[][] Players = new string[][] { \n      new string[] { \"COMPUTER\", \"X\" }, \n      new string[] { \"HUMAN\", \"O\" }     \n    };\n\n    const int Unplayed = -1;\n    const int Computer = 0;\n    const int Human = 1;\n\n    \n    static int[] GameBoard = new int[9];\n\n    static int[] corners = new int[] { 0, 2, 6, 8 };\n\n    static int[][] wins = new int[][] { \n      new int[] { 0, 1, 2 }, new int[] { 3, 4, 5 }, new int[] { 6, 7, 8 }, \n      new int[] { 0, 3, 6 }, new int[] { 1, 4, 7 }, new int[] { 2, 5, 8 }, \n      new int[] { 0, 4, 8 }, new int[] { 2, 4, 6 } };\n\n\n    \n    static void Main(string[] args)\n    {\n      while (true)\n      {\n        Console.Clear();\n        Console.WriteLine(\"Welcome to Rosetta Code Tic-Tac-Toe for C#.\");\n        initializeGameBoard();\n        displayGameBoard();\n        int currentPlayer = rnd.Next(0, 2);  \n        Console.WriteLine(\"The first move goes to {0} who is playing {1}s.\\n\", playerName(currentPlayer), playerToken(currentPlayer));\n        while (true)\n        {\n          int thisMove = getMoveFor(currentPlayer);\n          if (thisMove == Unplayed)\n          {\n            Console.WriteLine(\"{0}, you've quit the game ... am I that good?\", playerName(currentPlayer));\n            break;\n          }\n          playMove(thisMove, currentPlayer);\n          displayGameBoard();\n          if (isGameWon())\n          {\n            Console.WriteLine(\"{0} has won the game!\", playerName(currentPlayer));\n            break;\n          }\n          else if (isGameTied())\n          {\n            Console.WriteLine(\"Cat game ... we have a tie.\");\n            break;\n          }\n          currentPlayer = getNextPlayer(currentPlayer);\n        }\n        if (!playAgain())\n          return;\n      }\n    }\n\n    \n    static int getMoveFor(int player)\n    {\n      if (player == Human)\n        return getManualMove(player);\n      else\n      {\n        \n        \n        int selectedMove = getSemiRandomMove(player);\n        \n        Console.WriteLine(\"{0} selects position {1}.\", playerName(player), selectedMove + 1);\n        return selectedMove;\n      }\n    }\n\n    static int getManualMove(int player)\n    {\n      while (true)\n      {\n        Console.Write(\"{0}, enter you move (number): \", playerName(player));\n        ConsoleKeyInfo keyInfo = Console.ReadKey();\n        Console.WriteLine();  \n        if (keyInfo.Key == ConsoleKey.Escape)\n          return Unplayed;\n        if (keyInfo.Key >= ConsoleKey.D1 && keyInfo.Key <= ConsoleKey.D9)\n        {\n          int move = keyInfo.KeyChar - '1';  \n          if (GameBoard[move] == Unplayed)\n            return move;\n          else\n            Console.WriteLine(\"Spot {0} is already taken, please select again.\", move + 1);\n        }\n        else\n          Console.WriteLine(\"Illegal move, please select again.\\n\");\n      }\n    }\n\n    static int getRandomMove(int player)\n    {\n      int movesLeft = GameBoard.Count(position => position == Unplayed);\n      int x = rnd.Next(0, movesLeft);\n      for (int i = 0; i < GameBoard.Length; i++)  \n      {\n        if (GameBoard[i] == Unplayed && x < 0)    \n          return i;\n        x--;\n      }\n      return Unplayed;\n    }\n\n    \n    static int getSemiRandomMove(int player)\n    {\n      int posToPlay;\n      if (checkForWinningMove(player, out posToPlay))\n        return posToPlay;\n      if (checkForBlockingMove(player, out posToPlay))\n        return posToPlay;\n      return getRandomMove(player);\n    }\n\n    \n    static int getBestMove(int player)\n    {\n      return -1;\n    }\n\n    static bool checkForWinningMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(player, line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool checkForBlockingMove(int player, out int posToPlay)\n    {\n      posToPlay = Unplayed;\n      foreach (var line in wins)\n        if (twoOfThreeMatchPlayer(getNextPlayer(player), line, out posToPlay))\n          return true;\n      return false;\n    }\n\n    static bool twoOfThreeMatchPlayer(int player, int[] line, out int posToPlay)\n    {\n      int cnt = 0;\n      posToPlay = int.MinValue;\n      foreach (int pos in line)\n      {\n        if (GameBoard[pos] == player)\n          cnt++;\n        else if (GameBoard[pos] == Unplayed)\n          posToPlay = pos;\n      }\n      return cnt == 2 && posToPlay >= 0;\n    }\n\n    static void playMove(int boardPosition, int player)\n    {\n      GameBoard[boardPosition] = player;\n    }\n\n    static bool isGameWon()\n    {\n      return wins.Any(line => takenBySamePlayer(line[0], line[1], line[2]));\n    }\n\n    static bool takenBySamePlayer(int a, int b, int c)\n    {\n      return GameBoard[a] != Unplayed && GameBoard[a] == GameBoard[b] && GameBoard[a] == GameBoard[c];\n    }\n\n    static bool isGameTied()\n    {\n      return !GameBoard.Any(spot => spot == Unplayed);\n    }\n\n    \n    static Random rnd = new Random();\n\n    static void initializeGameBoard()\n    {\n      for (int i = 0; i < GameBoard.Length; i++)\n        GameBoard[i] = Unplayed;\n    }\n\n    static string playerName(int player)\n    {\n      return Players[player][0];\n    }\n\n    static string playerToken(int player)\n    {\n      return Players[player][1];\n    }\n\n    static int getNextPlayer(int player)\n    {\n      return (player + 1) % 2;\n    }\n\n    static void displayGameBoard()\n    {\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(0), pieceAt(1), pieceAt(2));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(3), pieceAt(4), pieceAt(5));\n      Console.WriteLine(\"---|---|---\");\n      Console.WriteLine(\" {0} | {1} | {2}\", pieceAt(6), pieceAt(7), pieceAt(8));\n      Console.WriteLine();\n    }\n\n    static string pieceAt(int boardPosition)\n    {\n      if (GameBoard[boardPosition] == Unplayed)\n        return (boardPosition + 1).ToString();  \n      return playerToken(GameBoard[boardPosition]);\n    }\n\n    private static bool playAgain()\n    {\n      Console.WriteLine(\"\\nDo you want to play again?\");\n      return Console.ReadKey(false).Key == ConsoleKey.Y;\n    }\n  }\n\n}\n"}
{"id": 53152, "name": "Tic-tac-toe", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\nmodule tic\n   implicit none\n   integer :: b(9)\ncontains\n   logical function iswin(p)\n      integer,intent(in) :: p\n      iswin = &\n         all(b([1,2,3])==p).or.all(b([4,5,6])==p).or.all(b([7,8,9])==p).or.&\n         all(b([1,4,7])==p).or.all(b([2,5,8])==p).or.all(b([3,6,9])==p).or.&\n         all(b([1,5,9])==p).or.all(b([3,5,7])==p)\n   end function iswin\n   subroutine printb(mes)\n      character(len=*) :: mes\n      integer          :: i,j\n      character        :: s(0:2) = ['.','X','O']\n      print \"(3a3,'   ',3i3)\",(s(b(3*i+1:3*i+3)),(j,j=3*i+1,3*i+3),i=0,2)\n      if(mes /= ' ') print \"(/,a)\",mes\n   end subroutine printb\n   integer recursive function minmax(player,bestm) result(bestv)\n      integer :: player,bestm,move,v,bm,win=1000,inf=100000\n      real    :: x\n      if (all(b .ne. 0)) then\n         bestv = 0\n      else\n         bestv = -inf\n         do move=1,9\n            if (b(move) == 0) then\n               b(move) = player\n               if (iswin(player)) then\n                  v = win\n               else\n                  call random_number(x)\n                  v = -minmax(3-player,bm) - int(10*x)\n               endif\n               if (v > bestv) then\n                  bestv = v\n                  bestm = move\n               endif\n               b(move) = 0\n               if (v == win) exit\n            endif\n         enddo\n      endif\n   end function minmax\nend module tic\nprogram tictactoe\n   \n   use tic\n   implicit none \n   integer :: move,ios,v,bestmove,ply,player=2,k,values(8)\n   integer,allocatable :: seed(:)\n   call date_and_time(values=values)\n   call random_seed(size=k)\n   allocate(seed(k))\n   seed = values(8)+1000*values(7)+60*1000*values(6)+60*60*1000*values(5)\n   call random_seed(put=seed)\n   mainloop: do\n      b = 0\n      call printb('You have O, I have X. You enter 0: game ends.')\n      plyloop: do ply=0,4\n         if (player == 2 .or. ply >0 ) then  \n            write(*,\"(/,a)\",advance='no'),'Your move? (0..9) '\n            getloop: do\n               readloop: do\n                  read (*,*,iostat=ios),move\n                  if (ios == 0 .and. move  >= 0 .and. move <= 9) exit readloop\n                  write(*,\"(a)\",advance='no'),'huh? Try again (0..9): '\n               enddo readloop\n               if (  move  == 0) exit mainloop\n               if (b(move) == 0) exit getloop\n               write(*,\"(a)\",advance='no'),'Already occupied, again (0..9): '\n            enddo getloop\n            b(move) = 2\n            if(iswin(2)) then   \n               call printb('***** You win *****')\n               exit plyloop\n            endif\n         endif\n         v = minmax(1,bestmove)   \n         b(bestmove) = 1\n         if(iswin(1)) then\n            call printb('***** I win *****')\n            exit plyloop\n         endif\n         write(*,\"(/,a,i3)\"), 'My move: ',bestmove\n         call printb(' ')\n      enddo plyloop\n      if(ply == 5) write(*,\"('***** Draw *****',/)\")\n      player = 3-player\n   enddo mainloop\nend program\n", "target": "\n\nimport random\n\nboard = list('123456789')\nwins = ((0,1,2), (3,4,5), (6,7,8),\n        (0,3,6), (1,4,7), (2,5,8),\n        (0,4,8), (2,4,6))\n\ndef printboard():\n    print('\\n'.join(' '.join(board[x:x+3]) for x in(0,3,6)))\n\ndef score():\n    for w in wins:\n        b = board[w[0]]\n        if b in 'XO' and all (board[i] == b for i in w):\n            return b, [i+1 for i in w]\n    return None, None\n\ndef finished():\n    return all (b in 'XO' for b in board)\n\ndef space():\n    return [ b for b in board if b not in 'XO']\n\ndef my_turn(xo):\n    options = space()\n    choice = random.choice(options)\n    board[int(choice)-1] = xo\n    return choice\n\ndef your_turn(xo):\n    options = space()\n    while True:\n        choice = input(\" Put your %s in any of these positions: %s \"\n                       % (xo, ''.join(options))).strip()\n        if choice in options:\n            break\n        print( \"Whoops I don't understand the input\" )\n    board[int(choice)-1] = xo\n    return choice\n\ndef me(xo='X'):\n    printboard()\n    print('I go at', my_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\ndef you(xo='O'):\n    printboard()\n    \n    print('You went at', your_turn(xo))\n    return score()\n    assert not s[0], \"\\n%s wins across %s\" % s\n\n\nprint(__doc__)\nwhile not finished():\n    s = me('X')\n    if s[0]:\n        printboard()\n        print(\"\\n%s wins across %s\" % s)\n        break\n    if not finished():\n        s = you('O')\n        if s[0]:\n            printboard()\n            print(\"\\n%s wins across %s\" % s)\n            break\nelse:\n    print('\\nA draw')\n"}
{"id": 53368, "name": "Pick random element", "source": "Translate Fortran to C#: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass RandomElementPicker {\n  static void Main() {\n    var list = new List<int>(new[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n    var rng = new Random();\n    var randomElement = list[rng.Next(list.Count)];\n    Console.WriteLine(\"I picked element {0}\", randomElement);\n  }\n}\n"}
{"id": 53372, "name": "Pick random element", "source": "Translate Fortran to Java: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": "import java.util.Random;\n...\nint[] array = {1,2,3};\nreturn array[new Random().nextInt(array.length)]; \n"}
{"id": 53373, "name": "Pick random element", "source": "Translate Fortran to Python: program pick_random\n  implicit none\n\n  integer :: i\n  integer :: a(10) = (/ (i, i = 1, 10) /)\n  real :: r\n\n  call random_seed\n  call random_number(r)\n  write(*,*) a(int(r*size(a)) + 1)\nend program\n", "target": ">>> import random\n>>> random.choice(['foo', 'bar', 'baz'])\n'baz'\n"}
{"id": 53637, "name": "Jensen's Device", "source": "Translate Fortran to C#:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "using System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n"}
{"id": 53640, "name": "Jensen's Device", "source": "Translate Fortran to Java:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "import java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n"}
{"id": 53641, "name": "Jensen's Device", "source": "Translate Fortran to Python:       FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n", "target": "class Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    \n    temp = 0\n    i.value = lo\n    while i.value <= hi:  \n        temp += term() \n        i.value += 1   \n    return temp\n\ni = Ref()\n\n\n\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n"}
{"id": 53901, "name": "Greatest element of a list", "source": "Translate Fortran to C#: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "int[] values = new int[] {1,2,3,4,5,6,7,8,9,10};\n\nint max = values.Max();\n"}
{"id": 53905, "name": "Greatest element of a list", "source": "Translate Fortran to Java: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "public static float max(float[] values) throws NoSuchElementException {\n    if (values.length == 0)\n        throw new NoSuchElementException();\n    float themax = values[0];\n    for (int idx = 1; idx < values.length; ++idx) {\n        if (values[idx] > themax)\n            themax = values[idx];\n    }\n    return themax;\n}\n"}
{"id": 53906, "name": "Greatest element of a list", "source": "Translate Fortran to Python: program test_maxval\n \ninteger,dimension(5),parameter :: x = [10,100,7,1,2]\nreal,dimension(5),parameter :: y = [5.0,60.0,1.0,678.0,0.0]\n \nwrite(*,'(I5)') maxval(x)\nwrite(*,'(F5.1)') maxval(y)\n\nend program test_maxval\n", "target": "max(values)\n"}
{"id": 54190, "name": "Discordian date", "source": "Translate Fortran to C#: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "using System;\n\npublic static class DiscordianDate\n{\n    static readonly string[] seasons = { \"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\" };\n    static readonly string[] weekdays = { \"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\" };\n    static readonly string[] apostles = { \"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\" };\n    static readonly string[] holidays = { \"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\" };\n    \n    public static string Discordian(this DateTime date) {\n        string yold = $\" in the YOLD {date.Year + 1166}.\";\n        int dayOfYear = date.DayOfYear;\n\n        if (DateTime.IsLeapYear(date.Year)) {\n            if (dayOfYear == 60) return \"St. Tib's day\" + yold;\n            else if (dayOfYear > 60) dayOfYear--;\n        }\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        int seasonNr = dayOfYear / 73;\n        int weekdayNr = dayOfYear % 5;\n        string holyday = \"\";\n\n        if (seasonDay == 5)       holyday = $\" Celebrate {apostles[seasonNr]}!\";\n        else if (seasonDay == 50) holyday = $\" Celebrate {holidays[seasonNr]}!\";\n        return $\"{weekdays[weekdayNr]}, day {seasonDay} of {seasons[seasonNr]}{yold}{holyday}\";\n    }\n\n    public static void Main() {\n        foreach (var (day, month, year) in new [] {\n            (1, 1, 2010),\n            (5, 1, 2010),\n            (19, 2, 2011),\n            (28, 2, 2012),\n            (29, 2, 2012),\n            (1, 3, 2012),\n            (19, 3, 2013),\n            (3, 5, 2014),\n            (31, 5, 2015),\n            (22, 6, 2016),\n            (15, 7, 2016),\n            (12, 8, 2017),\n            (19, 9, 2018),\n            (26, 9, 2018),\n            (24, 10, 2019),\n            (8, 12, 2020),\n            (31, 12, 2020)\n        })\n        {\n            Console.WriteLine($\"{day:00}-{month:00}-{year:00} = {new DateTime(year, month, day).Discordian()}\");\n        }\n    }\n\n}\n"}
{"id": 54193, "name": "Discordian date", "source": "Translate Fortran to Java: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class DiscordianDate {\n    final static String[] seasons = {\"Chaos\", \"Discord\", \"Confusion\",\n        \"Bureaucracy\", \"The Aftermath\"};\n\n    final static String[] weekday = {\"Sweetmorn\", \"Boomtime\", \"Pungenday\",\n        \"Prickle-Prickle\", \"Setting Orange\"};\n\n    final static String[] apostle = {\"Mungday\", \"Mojoday\", \"Syaday\",\n        \"Zaraday\", \"Maladay\"};\n\n    final static String[] holiday = {\"Chaoflux\", \"Discoflux\", \"Confuflux\",\n        \"Bureflux\", \"Afflux\"};\n\n    public static String discordianDate(final GregorianCalendar date) {\n        int y = date.get(Calendar.YEAR);\n        int yold = y + 1166;\n        int dayOfYear = date.get(Calendar.DAY_OF_YEAR);\n\n        if (date.isLeapYear(y)) {\n            if (dayOfYear == 60)\n                return \"St. Tib's Day, in the YOLD \" + yold;\n            else if (dayOfYear > 60)\n                dayOfYear--;\n        }\n\n        dayOfYear--;\n\n        int seasonDay = dayOfYear % 73 + 1;\n        if (seasonDay == 5)\n            return apostle[dayOfYear / 73] + \", in the YOLD \" + yold;\n        if (seasonDay == 50)\n            return holiday[dayOfYear / 73] + \", in the YOLD \" + yold;\n\n        String season = seasons[dayOfYear / 73];\n        String dayOfWeek = weekday[dayOfYear % 5];\n\n        return String.format(\"%s, day %s of %s in the YOLD %s\",\n                dayOfWeek, seasonDay, season, yold);\n    }\n\n    public static void main(String[] args) {\n\n        System.out.println(discordianDate(new GregorianCalendar()));\n\n        test(2010, 6, 22, \"Pungenday, day 57 of Confusion in the YOLD 3176\");\n        test(2012, 1, 28, \"Prickle-Prickle, day 59 of Chaos in the YOLD 3178\");\n        test(2012, 1, 29, \"St. Tib's Day, in the YOLD 3178\");\n        test(2012, 2, 1, \"Setting Orange, day 60 of Chaos in the YOLD 3178\");\n        test(2010, 0, 5, \"Mungday, in the YOLD 3176\");\n        test(2011, 4, 3, \"Discoflux, in the YOLD 3177\");\n        test(2015, 9, 19, \"Boomtime, day 73 of Bureaucracy in the YOLD 3181\");\n    }\n\n    private static void test(int y, int m, int d, final String result) {\n        assert (discordianDate(new GregorianCalendar(y, m, d)).equals(result));\n    }\n}\n"}
{"id": 54194, "name": "Discordian date", "source": "Translate Fortran to Python: program discordianDate\n    implicit none\n    \n    character(32) :: arg\n    character(15) :: season,day,holyday\n    character(80) :: Output,fmt1,fmt2,fmt3\n    character(2) :: dayfix,f1,f2,f3,f4\n    integer :: i,j,k,daysofyear,dayofweek,seasonnum,yold,dayofseason,t1,t2,t3\n    integer,dimension(8) :: values\n    integer, dimension(12) :: daysinmonth\n    logical  :: isleapyear, isholyday, Pleapyear\n     \n    \n    call date_and_time(VALUES=values)\n    \n    daysinmonth = (/ 31,28,31,30,31,30,31,31,30,31,30,31 /)\n    isleapyear = .false.\n    isholyday = .false.\n    \n    \n    j = iargc()\n    do i = 1, iargc()\n      call getarg(i, arg)  \n      if (j==3) then\n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n        if (i==3) then\n          read(arg,'(i4)') values(1)  \n \n        endif\n      endif\n      if (j==2) then  \n        if (i==1) then\n          read(arg,'(i2)') values(3)  \n        endif\n        if (i==2) then\n          read(arg,'(i2)') values(2)  \n        endif\n      endif\n      if (j==1) then \n        read(arg,'(i2)') values(3)  \n      endif\n    end do\n \n    \n\n    yold = values(1) + 1166\n    daysofyear = 0\n    if (values(2)>1) then \n    do i=1 , values(2)-1 , 1\n        daysofyear = daysofyear + daysinmonth(i)\n     end do\n   end if\n    daysofyear = daysofyear + values(3)\n    isholyday = .false.\n    isleapyear = Pleapyear(yold)\n    dayofweek = mod (daysofyear, 5)\n    seasonnum = ((daysofyear - 1) / 73) + 1 \n    dayofseason = daysofyear - ((seasonnum - 1)  * 73)\n    k = mod(dayofseason,10)  \n    select case (k)\n      case (1)\n         dayfix='st'\n      case (2)\n         dayfix='nd'\n      case (3)\n         dayfix='rd'\n      case default\n         dayfix='th'\n    end select\n    \n    if (((dayofseason > 10) .and. (dayofseason < 20)) .eqv. .true.) then\n      dayfix = 'th'\n    end if\n    select case (Seasonnum)\n      case (1) \n        season ='Choas'\n        f4 = '5'\n      case (2) \n        season ='Discord'\n        f4 = '7'\n      case (3) \n        season ='Confusion'\n        f4 = '9'\n      case (4) \n        season ='Bureaucracy'\n        f4 = '10'\n      case (5) \n        season ='The Aftermath'\n        f4 = '13'\n    end select\n    select case (dayofweek)\n       case (0) \n         day='Setting Orange'\n         f2 = '14'\n       case (1) \n         day ='Sweetmorn'\n         f2 = '9'\n       case (2) \n         day = 'Boomtime'\n         f2 = '8'\n       case (3) \n         day = 'Pungenday'\n         f2 = '9'\n       case (4) \n         day = 'Prickle-Prickle'\n         f2 = '15'\n    end select\n    \n    select case (dayofseason)\n      case (5)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n             holyday ='Mungday'\n             f1 = '7'\n          case (2)\n             holyday = 'Mojoday'\n             f1 = '7'\n          case (3)\n            holyday = 'Syaday'\n            f1 = '6'\n          case (4)\n             holyday = 'Zaraday'\n             f1 = '7'\n          case (5)\n            holyday = 'Maladay'\n            f1 = '7'\n         end select\n      Case (50)\n        isholyday = .true.\n        select case (seasonnum)\n          case (1)\n            holyday = 'Chaoflux'\n            f1 = '8'\n          case (2)\n            holyday = 'Discoflux'\n            f1 = '9'\n          case (3)\n            holyday = 'Confuflux'\n            f1 = '9'\n          case (4)\n            holyday = 'Bureflux'\n            f1 = '8'\n          case (5)\n            holyday = 'Afflux'\n            f1 = '6'\n         end select\n    end select\n    \n\n    \n    if (isleapyear .eqv. .true.) then \n      if ((values(2) == 2) .and. (values(3) == 29)) then\n         isholyday = .true.\n      end if\n    end if\n    \n    f3 = \"2\"\n    if (dayofseason < 10) then\n      f3 = \"1\"\n    end if\n    fmt1 = \"(a,i4)\"\n    fmt2 = \"(A,a\" // f1 // \",A,A\" // f2 // \",A,I\" // f3 // \",A2,A,A\" // f4 // \",A,I4)\"\n    fmt3 = \"(A,A\" // f2 // \",A,I\" // f3 //\",A2,A,A\" // f4 // \",A,I4)\"\n    \n    if (isholyday .eqv. .true.) then\n      if (values(3) == 29) then\n         print fmt1,'Celebrate for today is St. Tibbs Day in the YOLD ',yold\n       else\n         print fmt2, 'Today is ',holyday, ' on ',day,' the ',dayofseason,dayfix,' day of ',season,' in the YOLD ',yold \n       end if\n     else   \n         print fmt3, 'Today is ',day,' the ',dayofseason,dayfix, ' day of ',season,' in the YOLD ',yold\n     end if\n    end program discordianDate\n\n    \n\n    function Pleapyear(dloy) result(leaper)\n    implicit none\n    integer, intent(in) :: dloy\n    logical :: leaper\n    leaper = .false.\n    if (mod((dloy-1166),4) == 0)  then\n      leaper = .true.\n    end if\n    if (mod((dloy-1166),100) == 0) then\n        leaper = .false.\n        if (mod((dloy-1166),400)==0) then\n           leaper = .true.\n        end if\n    end if \n    end function Pleapyear\n", "target": "import datetime, calendar\n\nDISCORDIAN_SEASONS = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"]\n\ndef ddate(year, month, day):\n    today = datetime.date(year, month, day)\n    is_leap_year = calendar.isleap(year)\n    if is_leap_year and month == 2 and day == 29:\n        return \"St. Tib's Day, YOLD \" + (year + 1166)\n    \n    day_of_year = today.timetuple().tm_yday - 1\n    \n    if is_leap_year and day_of_year >= 60:\n        day_of_year -= 1 \n    \n    season, dday = divmod(day_of_year, 73)\n    return \"%s %d, YOLD %d\" % (DISCORDIAN_SEASONS[season], dday + 1, year + 1166)\n"}
{"id": 54566, "name": "Binary digits", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n"}
{"id": 54569, "name": "Binary digits", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": "module BinaryDigits\n    {\n    @Inject Console console;\n    void run()\n        {\n        Int[] tests = [0, 1, 5, 50, 9000];\n\n        Int longestInt = tests.map(n -> n.estimateStringLength()).reduce(0, (max, len) -> max.maxOf(len));\n        Int longestBin = tests.map(n -> (64-n.leadingZeroCount).maxOf(1)).reduce(0, (max, len) -> max.maxOf(len));\n\n        function String(Int) num = n ->\n            {\n            Int indent = longestInt - n.estimateStringLength();\n            return $\"{' ' * indent}{n}\";\n            };\n\n        function String(Int) bin = n ->\n            {\n            Int index  = n.leadingZeroCount.minOf(63);\n            Int indent = index - (64 - longestBin);\n            val bits   = n.toBitArray()[index ..< 64];\n            return $\"{' ' * indent}{bits.toString().substring(2)}\";\n            };\n\n        for (Int test : tests)\n            {\n            console.print($\"The decimal value {num(test)} should produce an output of {bin(test)}\");\n            }\n        }\n    }\n"}
{"id": 54570, "name": "Binary digits", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n", "target": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n"}
{"id": 55564, "name": "Find the intersection of two lines", "source": "Translate Fortran to C#: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55565, "name": "Find the intersection of two lines", "source": "Translate Fortran to C#: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "using System;\nusing System.Drawing;\npublic class Program\n{\n    static PointF FindIntersection(PointF s1, PointF e1, PointF s2, PointF e2) {\n        float a1 = e1.Y - s1.Y;\n        float b1 = s1.X - e1.X;\n        float c1 = a1 * s1.X + b1 * s1.Y;\n\n        float a2 = e2.Y - s2.Y;\n        float b2 = s2.X - e2.X;\n        float c2 = a2 * s2.X + b2 * s2.Y;\n\n        float delta = a1 * b2 - a2 * b1;\n        \n        return delta == 0 ? new PointF(float.NaN, float.NaN)\n            : new PointF((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    static void Main() {\n        Func<float, float, PointF> p = (x, y) => new PointF(x, y);\n        Console.WriteLine(FindIntersection(p(4f, 0f), p(6f, 10f), p(0f, 3f), p(10f, 7f)));\n        Console.WriteLine(FindIntersection(p(0f, 0f), p(1f, 1f), p(1f, 2f), p(4f, 5f)));\n    }\n}\n"}
{"id": 55571, "name": "Find the intersection of two lines", "source": "Translate Fortran to Java: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55572, "name": "Find the intersection of two lines", "source": "Translate Fortran to Java: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "public class Intersection {\n    private static class Point {\n        double x, y;\n\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{%f, %f}\", x, y);\n        }\n    }\n\n    private static class Line {\n        Point s, e;\n\n        Line(Point s, Point e) {\n            this.s = s;\n            this.e = e;\n        }\n    }\n\n    private static Point findIntersection(Line l1, Line l2) {\n        double a1 = l1.e.y - l1.s.y;\n        double b1 = l1.s.x - l1.e.x;\n        double c1 = a1 * l1.s.x + b1 * l1.s.y;\n\n        double a2 = l2.e.y - l2.s.y;\n        double b2 = l2.s.x - l2.e.x;\n        double c2 = a2 * l2.s.x + b2 * l2.s.y;\n\n        double delta = a1 * b2 - a2 * b1;\n        return new Point((b2 * c1 - b1 * c2) / delta, (a1 * c2 - a2 * c1) / delta);\n    }\n\n    public static void main(String[] args) {\n        Line l1 = new Line(new Point(4, 0), new Point(6, 10));\n        Line l2 = new Line(new Point(0, 3), new Point(10, 7));\n        System.out.println(findIntersection(l1, l2));\n\n        l1 = new Line(new Point(0, 0), new Point(1, 1));\n        l2 = new Line(new Point(1, 2), new Point(4, 5));\n        System.out.println(findIntersection(l1, l2));\n    }\n}\n"}
{"id": 55573, "name": "Find the intersection of two lines", "source": "Translate Fortran to Python: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55574, "name": "Find the intersection of two lines", "source": "Translate Fortran to Python: program intersect_two_lines\n  implicit none\n  \n  type point\n    real::x,y\n  end type point\n  \n  integer, parameter :: n = 4\n  type(point)        :: p(n)\n  \n  p(1)%x = 4; p(1)%y = 0; p(2)%x = 6;  p(2)%y = 10 \n  p(3)%x = 0; p(3)%y = 3; p(4)%x = 10; p(4)%y = 7  \n  \n  call intersect(p, n)\n  \n  contains\n  \n  subroutine intersect(p,m)\n  integer, intent(in)       :: m\n  type(point), intent(in)   :: p(m)\n  integer   :: i\n  real      :: a(2), b(2) \n  real      :: x, y       \n  real      :: dx,dy      \n  \n  do i = 1, 2\n    dx = p(2*i-1)%x - p(2*i)%x\n    dy = p(2*i-1)%y - p(2*i)%y\n    if( dx == 0.) then    \n        a(i) = 0.\n        b(i) = p(2*i-1)%y\n    else\n        a(i)= dy / dx\n        b(i) = p(2*i-1)%y - a(i)*p(2*i-1)%x\n    endif\n  enddo\n  \n  if( a(1) - a(2) == 0. ) then\n    write(*,*)\"lines are not intersecting\"\n    return\n  endif\n  \n  x = ( b(2) - b(1) ) / ( a(1) - a(2) )\n  y = a(1) * x + b(1)\n  write(*,*)x,y\n  end subroutine intersect\nend program intersect_two_lines\n", "target": "from __future__ import division\n\ndef setup():\n    \n    (a, b), (c, d) = (4, 0), (6, 10)  \n    (e, f), (g, h) = (0, 3), (10, 7)  \n    pt = line_instersect(a, b, c, d, e, f, g, h)\n    scale(9)\n    line(a, b, c, d)\n    line(e, f, g, h)\n    if pt:\n        x, y = pt\n        stroke(255)\n        point(x, y)\n    println(pt)  \n\ndef line_instersect(Ax1, Ay1, Ax2, Ay2, Bx1, By1, Bx2, By2):\n    \n    d = (By2 - By1) * (Ax2 - Ax1) - (Bx2 - Bx1) * (Ay2 - Ay1)\n    if d:\n        uA = ((Bx2 - Bx1) * (Ay1 - By1) - (By2 - By1) * (Ax1 - Bx1)) / d\n        uB = ((Ax2 - Ax1) * (Ay1 - By1) - (Ay2 - Ay1) * (Ax1 - Bx1)) / d\n    else:\n        return\n    if not(0 <= uA <= 1 and 0 <= uB <= 1):\n        return\n    x = Ax1 + uA * (Ax2 - Ax1)\n    y = Ay1 + uA * (Ay2 - Ay1)\n    return x, y\n"}
{"id": 55865, "name": "Conditional structures", "source": "Translate Fortran to C#: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if (condition)\n{\n   \n}\n\nif (condition)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}\n"}
{"id": 55869, "name": "Conditional structures", "source": "Translate Fortran to Java: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if (s == 'Hello World') {\n    foo();\n} else if (s == 'Bye World') {\n    bar();\n} else {\n    deusEx();\n}\n"}
{"id": 55870, "name": "Conditional structures", "source": "Translate Fortran to Python: if ( a .gt. 20.0 ) then\n   q = q + a**2\nelse if ( a .ge. 0.0 ) then\n   q = q + 2*a**3\nelse\n   q = q - a\nend if\n", "target": "if x == 0:\n    foo()\nelif x == 1:\n    bar()\nelif x == 2:\n    baz()\nelse:\n    qux()\n\nmatch x:\n    0 => foo()\n    1 => bar()\n    2 => baz()\n    _ => qux()\n\n(a) ? b : c\n"}
{"id": 56076, "name": "Align columns", "source": "Translate Fortran to C#:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "using System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        \n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        \n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            \n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            \n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        \n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n"}
{"id": 56078, "name": "Align columns", "source": "Translate Fortran to Java:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    \n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    \n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    \n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    \n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n"}
{"id": 56079, "name": "Align columns", "source": "Translate Fortran to Python:       SUBROUTINE RAKE(IN,M,X,WAY)\t\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t\n       INTEGER M\t\t\n       CHARACTER*1 X\t\t\n       INTEGER WAY\t\t\n       INTEGER W(M + 1)\t\t\n       INTEGER C(0:M + 1)\t\n       CHARACTER*(M) ACARD\t\n       CHARACTER*(28 + 4*M) FORMAT\t\n       INTEGER I\t\t\n       INTEGER L,LF\t\t\n       INTEGER NF,MF\t\t\n       CHARACTER*6 WAYNESS(-1:+1)\t\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t\n       INTEGER LINPR\t\n       COMMON LINPR\t\n        W = 0\t\t\n        MF = 0\t\t\n        C(0) = 0\t\n        WRITE (LINPR,*)\t\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t\n   11   FORMAT (Q,A)\t\t\t\t\n        CALL LIZZIEBORDEN\t\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t\n        MF = MAX(MF,NF)\t\t\n        GO TO 10\t\t\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t\n        WRITE (FORMAT,21) W(1:MF) + 1\t\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t\n        LF = INDEX(FORMAT,\", \")\t\t\n        IF (LF.LE.0) STOP \"Format trouble\n        FORMAT(LF:LF) = \")\"\t\t\t\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t\n        CALL LIZZIEBORDEN\t\t\n        SELECT CASE(WAY)\t\n         CASE(-1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t\n         CASE( 0)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t\n         CASE(+1)\t\t\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t\n         CASE DEFAULT\t\t\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t\n         STOP \"Unanticipated value for WAY\n        END SELECT\t\t\n        GO TO 30\t\t\nClosedown\n   40   REWIND(IN)\t\t\n       CONTAINS\t\n        SUBROUTINE LIZZIEBORDEN\t\n          NF = 0\t\t\n          DO I = 1,L\t\t\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t\n              NF = NF + 1\t\t\n              C(NF) = I\t\t\n            END IF\t\t\n          END DO\t\t\n          NF = NF + 1\t\t\n          C(NF) = L + 1\t\t\n        END SUBROUTINE LIZZIEBORDEN\t\n      END SUBROUTINE RAKE\t\n\n      INTEGER L,M,N\t\n      INTEGER LINPR,IN\t\n      COMMON LINPR\t\n      LINPR = 6\t\t\n      IN = 10\t\t\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n      N = 0\t\t\n      M = 0\t\t\n\n    1 READ (IN,2,END = 10) L\t\n    2 FORMAT (Q)\t\n      N = N + 1\t\t\n      M = MAX(M,L)\t\n      GO TO 1\t\t\n\n   10 REWIND (IN)\t\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t\n      CALL RAKE(IN,M,\"$\", 0)\t\n      CALL RAKE(IN,M,\"$\",+1)\t\n      END\t\n", "target": "from itertools import zip_longest\n\ntxt = \n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n"}
{"id": 56655, "name": "String matching", "source": "Translate Fortran to C#:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "class Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); \n\t\tvalue = \"abab\".Contains(\"bb\"); \n\t\tvalue = \"abab\".Contains(\"ab\"); \n\t\tint loc = \"abab\".IndexOf(\"bb\"); \n\t\tloc = \"abab\".IndexOf(\"ab\"); \n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); \n\t}\n}\n"}
{"id": 56658, "name": "String matching", "source": "Translate Fortran to Java:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "\"abcd\".startsWith(\"ab\") \n\"abcd\".endsWith(\"zn\") \n\"abab\".contains(\"bb\") \n\"abab\".contains(\"ab\") \nint loc = \"abab\".indexOf(\"bb\") \nloc = \"abab\".indexOf(\"ab\") \nloc = \"abab\".indexOf(\"ab\",loc+1) \n"}
{"id": 56659, "name": "String matching", "source": "Translate Fortran to Python:       SUBROUTINE STARTS(A,B)\t\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t\n        IF (L.LT.0) THEN\t\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n", "target": "\"abcd\".startswith(\"ab\") \n\"abcd\".endswith(\"zn\") \n\"bb\" in \"abab\" \n\"ab\" in \"abab\" \nloc = \"abab\".find(\"bb\") \nloc = \"abab\".find(\"ab\") \nloc = \"abab\".find(\"ab\",loc+1) \n"}
{"id": 56917, "name": "Real constants and functions", "source": "Translate Fortran to C#:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {        \n        Console.WriteLine(Math.E); \n        Console.WriteLine(Math.PI); \n        Console.WriteLine(Math.Sqrt(10)); \n        Console.WriteLine(Math.Log(10)); \n        Console.WriteLine(Math.Log10(10)); \n        Console.WriteLine(Math.Exp(10)); \n        Console.WriteLine(Math.Abs(10)); \n        Console.WriteLine(Math.Floor(10.0)); \n        Console.WriteLine(Math.Ceiling(10.0)); \n        Console.WriteLine(Math.Pow(2, 5)); \n    }\n}\n"}
{"id": 56921, "name": "Real constants and functions", "source": "Translate Fortran to Java:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "Math.E; \nMath.PI; \nMath.sqrt(x); \nMath.log(x); \nMath.exp(x); \nMath.abs(x); \nMath.floor(x); \nMath.ceil(x); \nMath.pow(x,y); \n"}
{"id": 56922, "name": "Real constants and functions", "source": "Translate Fortran to Python:  e          \n pi         \n SQRT(x)    \n LOG(x)     \n LOG10(x)   \n EXP(x)     \n ABS(x)     \n FLOOR(x)   \n CEILING(x) \n x**y       \n", "target": "import math\n\nmath.e          \nmath.pi         \nmath.sqrt(x)    \nmath.log(x)     \nmath.log10(x)   \nmath.exp(x)     \nabs(x)          \nmath.floor(x)   \nmath.ceil(x)    \nx ** y          \npow(x, y[, n])  \n\n\n\n"}
{"id": 57159, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to C#: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    \n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n"}
{"id": 57163, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to Java: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class Link\n{\n    Link next;\n    int data;\n}\n"}
{"id": 57164, "name": "Singly-linked list_Element definition", "source": "Translate Fortran to Python: type node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n\n\n\ntype( node ) :: head\n", "target": "class LinkedList(object):\n     \n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n"}
{"id": 57434, "name": "System time", "source": "Translate Fortran to C#: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "Console.WriteLine(DateTime.Now);\n"}
{"id": 57437, "name": "System time", "source": "Translate Fortran to Java: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "public class SystemTime{\n    public static void main(String[] args){\n        System.out.format(\"%tc%n\", System.currentTimeMillis());\n    }\n}\n"}
{"id": 57438, "name": "System time", "source": "Translate Fortran to Python: integer :: start, stop, rate\nreal :: result\n      \n\n\n\ncall system_clock( start, rate )\n      \nresult = do_timed_work()\n      \ncall system_clock( stop )\n      \nprint *, \"elapsed time: \", real(stop - start) / real(rate)\n", "target": "import time\nprint time.ctime()\n"}
{"id": 57615, "name": "Roots of a quadratic function", "source": "Translate Fortran to C#: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "using System;\nusing System.Numerics;\n\nclass QuadraticRoots\n{\n    static Tuple<Complex, Complex> Solve(double a, double b, double c)\n    {\n        var q = -(b + Math.Sign(b) * Complex.Sqrt(b * b - 4 * a * c)) / 2;\n        return Tuple.Create(q / a, c / q);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Solve(1, -1E20, 1));\n    }\n}\n"}
{"id": 57618, "name": "Roots of a quadratic function", "source": "Translate Fortran to Java: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "public class QuadraticRoots {\n    private static class Complex {\n        double re, im;\n\n        public Complex(double re, double im) {\n            this.re = re;\n            this.im = im;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {return true;}\n            if (!(obj instanceof Complex)) {return false;}\n            Complex other = (Complex) obj;\n            return (re == other.re) && (im == other.im);\n        }\n\n        @Override\n        public String toString() {\n            if (im == 0.0) {return String.format(\"%g\", re);}\n            if (re == 0.0) {return String.format(\"%gi\", im);}\n            return String.format(\"%g %c %gi\", re,\n                (im < 0.0 ? '-' : '+'), Math.abs(im));\n        }\n    }\n\n    private static Complex[] quadraticRoots(double a, double b, double c) {\n        Complex[] roots = new Complex[2];\n        double d = b * b - 4.0 * a * c;  \n        double aa = a + a;\n\n        if (d < 0.0) {\n            double re = -b / aa;\n            double im = Math.sqrt(-d) / aa;\n            roots[0] = new Complex(re, im);\n            roots[1] = new Complex(re, -im);\n        } else if (b < 0.0) {\n            \n            \n            double re = (-b + Math.sqrt(d)) / aa;\n            roots[0] = new Complex(re, 0.0);\n            roots[1] = new Complex(c / (a * re), 0.0);\n        } else {\n            \n            double re = (-b - Math.sqrt(d)) / aa;\n            roots[1] = new Complex(re, 0.0);\n            roots[0] = new Complex(c / (a * re), 0.0);\n        }\n        return roots;\n    }\n\n    public static void main(String[] args) {\n        double[][] equations = {\n            {1.0, 22.0, -1323.0},   \n            {6.0, -23.0, 20.0},     \n            {1.0, -1.0e9, 1.0},     \n            {1.0, 2.0, 1.0},        \n            {1.0, 0.0, 1.0},        \n            {1.0, 1.0, 1.0}         \n        };\n        for (int i = 0; i < equations.length; i++) {\n            Complex[] roots = quadraticRoots(\n                equations[i][0], equations[i][1], equations[i][2]);\n            System.out.format(\"%na = %g   b = %g   c = %g%n\",\n                equations[i][0], equations[i][1], equations[i][2]);\n            if (roots[0].equals(roots[1])) {\n                System.out.format(\"X1,2 = %s%n\", roots[0]);\n            } else {\n                System.out.format(\"X1 = %s%n\", roots[0]);\n                System.out.format(\"X2 = %s%n\", roots[1]);\n            }\n        }\n    }\n}\n"}
{"id": 57619, "name": "Roots of a quadratic function", "source": "Translate Fortran to Python: PROGRAM QUADRATIC\n\n IMPLICIT NONE\n INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15)\n REAL(dp) :: a, b, c, e, discriminant, rroot1, rroot2\n COMPLEX(dp) :: croot1, croot2\n\n WRITE(*,*) \"Enter the coefficients of the equation ax^2 + bx + c\"\n WRITE(*, \"(A)\", ADVANCE=\"NO\") \"a = \"\n READ *, a\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"b = \"\n READ *, b\n WRITE(*,\"(A)\", ADVANCE=\"NO\") \"c = \"\n READ *, c\n \n WRITE(*,\"(3(A,E23.15))\") \"Coefficients are: a = \", a, \"   b = \", b, \"   c = \", c\n e = 1.0e-9_dp\n discriminant = b*b - 4.0_dp*a*c\n \n IF (ABS(discriminant) < e) THEN\n    rroot1 = -b / (2.0_dp * a)\n    WRITE(*,*) \"The roots are real and equal:\"\n    WRITE(*,\"(A,E23.15)\") \"Root = \", rroot1\n ELSE IF (discriminant > 0) THEN\n    rroot1 = -(b + SIGN(SQRT(discriminant), b)) / (2.0_dp * a)\n    rroot2 = c / (a * rroot1)\n    WRITE(*,*) \"The roots are real:\"\n    WRITE(*,\"(2(A,E23.15))\") \"Root1 = \", rroot1, \"  Root2 = \", rroot2\n ELSE\n    croot1 = (-b + SQRT(CMPLX(discriminant))) / (2.0_dp*a) \n    croot2 = CONJG(croot1)\n    WRITE(*,*) \"The roots are complex:\" \n    WRITE(*,\"(2(A,2E23.15,A))\") \"Root1 = \", croot1, \"j \", \"  Root2 = \", croot2, \"j\"\n END IF\n", "target": "\n\nimport math\nimport cmath\nimport numpy\n\ndef quad_discriminating_roots(a,b,c, entier = 1e-5):\n    \n    discriminant = b*b - 4*a*c\n    a,b,c,d =complex(a), complex(b), complex(c), complex(discriminant)\n    root1 = (-b + cmath.sqrt(d))/2./a\n    root2 = (-b - cmath.sqrt(d))/2./a\n    if abs(discriminant) < entier:\n        return \"real and equal\", abs(root1), abs(root1)\n    if discriminant > 0:\n        return \"real\", root1.real, root2.real\n    return \"complex\", root1, root2\n\ndef middlebrook(a, b, c):\n    try:\n        q = math.sqrt(a*c)/b\n        f = .5+ math.sqrt(1-4*q*q)/2\n    except ValueError:\n        q = cmath.sqrt(a*c)/b\n        f = .5+ cmath.sqrt(1-4*q*q)/2\n    return (-b/a)*f, -c/(b*f)\n\ndef whatevery(a, b, c):\n    try:\n        d = math.sqrt(b*b-4*a*c)\n    except ValueError:\n        d = cmath.sqrt(b*b-4*a*c)\n    if b > 0:\n        return div(2*c, (-b-d)), div((-b-d), 2*a)\n    else:\n        return div((-b+d), 2*a), div(2*c, (-b+d))\n\ndef div(n, d):\n    \n    try:\n        return n/d\n    except ZeroDivisionError:\n        if n:\n            return n*float('inf')\n        return float('nan')\n\ntestcases = [\n    (3, 4, 4/3),    \n    (3, 2, -1),     \n    (3, 2, 1),      \n    (1, -1e9, 1),   \n    (1, -1e100, 1),\n    (1, -1e200, 1),\n    (1, -1e300, 1),\n]\n\nprint('Naive:')\nfor c in testcases:\n    print(\"{} {:.5} {:.5}\".format(*quad_discriminating_roots(*c)))\n\nprint('\\nMiddlebrook:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*middlebrook(*c)))\n\nprint('\\nWhat Every...')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*whatevery(*c)))\n\nprint('\\nNumpy:')\nfor c in testcases:\n    print((\"{:.5} \"*2).format(*numpy.roots(c)))\n"}
{"id": 57972, "name": "Secure temporary file", "source": "Translate Fortran to Java:         OPEN (F,STATUS = 'SCRATCH')   \n", "target": "import java.io.File;\nimport java.io.IOException;\n\npublic class CreateTempFile {\n    public static void main(String[] args)  {\n        try {\n            \n            File temp = File.createTempFile(\"temp-file-name\", \".tmp\");\n            System.out.println(\"Temp file\u00a0: \" + temp.getAbsolutePath());\n        }\n        catch(IOException e) {\n            e.printStackTrace();\n    \t}\n    }\n}\n"}
{"id": 57973, "name": "Secure temporary file", "source": "Translate Fortran to Python:         OPEN (F,STATUS = 'SCRATCH')   \n", "target": ">>> import tempfile\n>>> invisible = tempfile.TemporaryFile()\n>>> invisible.name\n'<fdopen>'\n>>> visible = tempfile.NamedTemporaryFile()\n>>> visible.name\n'/tmp/tmpZNfc_s'\n>>> visible.close()\n>>> invisible.close()\n"}
{"id": 58638, "name": "Box the compass", "source": "Translate Fortran to C#: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58639, "name": "Box the compass", "source": "Translate Fortran to C#: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace BoxTheCompass\n{\n    class Compass\n    {\n        string[] cp = new string[] {\"North\", \"North by east\", \"North-northeast\", \"Northeast by north\", \"Northeast\",\"Northeast by east\", \n\t    \"East-northeast\", \"East by north\", \"East\", \"East by south\", \"East-southeast\", \"Southeast by east\", \"Southeast\", \n            \"Southeast by south\", \"South-southeast\", \"South by east\", \"South\", \"South by west\", \"South-southwest\", \"Southwest by south\", \n            \"Southwest\", \"Southwest by west\", \"West-southwest\", \"West by south\", \"West\", \"West by north\", \"West-northwest\", \n            \"Northwest by west\", \"Northwest\", \"Northwest by north\", \"North-northwest\", \"North by west\", \"North\"};\n\n        public void compassHeading(float a)\n        {\n            int h = Convert.ToInt32(Math.Floor(a / 11.25f + .5f)) % 32;\n            Console.WriteLine( \"{0,2}: {1,-22}\u00a0: {2,6:N}\",h + 1, cp[h], a );\n        }\n    };\n    class Program\n    {\n        static void Main(string[] args)\n       {\n            Compass c = new Compass();\n            float[] degs = new float[] {0.0f, 16.87f, 16.88f, 33.75f, 50.62f, 50.63f, 67.5f, 84.37f, 84.38f, 101.25f, \n                118.12f, 118.13f, 135.0f, 151.87f, 151.88f, 168.75f, 185.62f, 185.63f, 202.5f, 219.37f, 219.38f, 236.25f, \n                253.12f, 253.13f, 270.0f, 286.87f, 286.88f, 303.75f, 320.62f, 320.63f, 337.5f, 354.37f, 354.38f};\n\n            foreach (float d in degs)\n                c.compassHeading(d);\n\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 58645, "name": "Box the compass", "source": "Translate Fortran to Java: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58646, "name": "Box the compass", "source": "Translate Fortran to Java: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "public class BoxingTheCompass{\n    private static String[] points = new String[32];\n \n    public static void main(String[] args){\n        buildPoints();\n \n        double heading = 0;\n \n        for(int i = 0; i<= 32;i++){\n            heading = i * 11.25;\n            switch(i % 3){\n                case 1:\n                    heading += 5.62;\n                    break;\n                case 2:\n                    heading -= 5.62;\n                    break;\n                default:\n            }\n \n            System.out.printf(\"%s\\t%18s\\t%s\u00b0\\n\",(i % 32) + 1, initialUpper(getPoint(heading)), heading);\n        }\n    }\n \n    private static void buildPoints(){\n        String[] cardinal = {\"north\", \"east\", \"south\", \"west\"};\n        String[] pointDesc = {\"1\", \"1 by 2\", \"1-C\", \"C by 1\", \"C\", \"C by 2\", \"2-C\", \"2 by 1\"};\n \n        String str1, str2, strC;\n \n        for(int i = 0;i <= 3;i++){\n            str1 = cardinal[i];\n            str2 = cardinal[(i + 1) % 4];\n            strC = (str1.equals(\"north\") || str1.equals(\"south\")) ? (str1 + str2): (str2 + str1);\n            for(int j = 0;j <= 7;j++){\n                points[i * 8 + j] = pointDesc[j].replace(\"1\", str1).replace(\"2\", str2).replace(\"C\", strC);\n            }\n        }\n    }\n \n    private static String initialUpper(String s){\n        return s.substring(0, 1).toUpperCase() + s.substring(1);\n    }\n \n    private static String getPoint(double degrees){\n        double testD = (degrees / 11.25) + 0.5;\n        return points[(int)Math.floor(testD % 32)];\n    }\n}\n"}
{"id": 58647, "name": "Box the compass", "source": "Translate Fortran to Python: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 58648, "name": "Box the compass", "source": "Translate Fortran to Python: Program Compass\n  implicit none\n\n  integer :: i, ind\n  real :: heading\n\n  do i = 0, 32\n    heading = i * 11.25\n    if (mod(i, 3) == 1) then\n      heading = heading + 5.62\n    else if (mod(i, 3) == 2) then\n            heading = heading - 5.62\n    end if\n    ind = mod(i, 32) + 1\n    write(*, \"(i2, a20, f8.2)\") ind, compasspoint(heading), heading\n  end do\n\ncontains\n\nfunction compasspoint(h)\n  character(18) :: compasspoint\n  character(18) :: points(32) = (/ \"North             \", \"North by east     \", \"North-northeast   \", & \n             \"Northeast by north\", \"Northeast         \", \"Northeast by east \", \"East-northeast    \", &\n             \"East by north     \", \"East              \", \"East by south     \", \"East-southeast    \", &\n             \"Southeast by east \", \"Southeast         \", \"Southeast by south\", \"South-southeast   \", &\n             \"South by east     \", \"South             \", \"South by west     \", \"South-southwest   \", &\n             \"Southwest by south\", \"Southwest         \", \"Southwest by west \", \"West-southwest    \", &\n             \"West by south     \", \"West              \", \"West by north     \", \"West-northwest    \", &\n             \"Northwest by west \", \"Northwest         \", \"Northwest by north\", \"North-northwest   \", &\n             \"North by west     \"  /)  \n  real, intent(in) :: h\n  real :: x\n\n  x = h / 11.25 + 1.5\n  if (x >= 33.0) x = x - 32.0\n  compasspoint = points(int(x))\nend function compasspoint\nend program Compass\n", "target": "majors   = 'north east south west'.split()\nmajors   *= 2 \nquarter1 = 'N,N by E,N-NE,NE by N,NE,NE by E,E-NE,E by N'.split(',')\nquarter2 = [p.replace('NE','EN') for p in quarter1]\n\ndef degrees2compasspoint(d):\n    d = (d % 360) + 360/64\n    majorindex, minor = divmod(d, 90.)\n    majorindex = int(majorindex)\n    minorindex  = int( (minor*4) // 45 )\n    p1, p2 = majors[majorindex: majorindex+2]\n    if p1 in {'north', 'south'}:\n        q = quarter1\n    else:\n        q = quarter2\n    return q[minorindex].replace('N', p1).replace('E', p2).capitalize()\n\nif __name__ == '__main__':\n    for i in range(33):\n        d = i * 11.25\n        m = i % 3\n        if   m == 1: d += 5.62\n        elif m == 2: d -= 5.62\n        n = i % 32 + 1\n        print( '%2i %-18s %7.2f\u00b0' % (n, degrees2compasspoint(d), d) )\n"}
{"id": 59719, "name": "99 bottles of beer", "source": "Translate Fortran to C#: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59720, "name": "99 bottles of beer", "source": "Translate Fortran to C#: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 99; i > -1; i--)\n        {\n            if (i == 0)\n            {\n                Console.WriteLine(\"No more bottles of beer on the wall, no more bottles of beer.\");\n                Console.WriteLine(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n                break;\n            }\n            if (i == 1)\n            {\n                Console.WriteLine(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n                Console.WriteLine(\"Take one down and pass it around, no more bottles of beer on the wall.\");\n                Console.WriteLine();\n            }\n            else\n            {\n                Console.WriteLine(\"{0} bottles of beer on the wall, {0} bottles of beer.\", i);\n                Console.WriteLine(\"Take one down and pass it around, {0} bottles of beer on the wall.\", i - 1);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 59726, "name": "99 bottles of beer", "source": "Translate Fortran to Java: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59727, "name": "99 bottles of beer", "source": "Translate Fortran to Java: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "module Bottles\n    {\n    @Inject Console console;\n    void run()\n        {\n        function String(Int) num     = i -> i==0 ? \"No\" : i.toString();\n        function String(Int) bottles = i -> i==1 ? \"bottle\" : \"bottles\";\n\n        for (Int remain : 99..1)\n            {\n            console.print($|{num(remain)} {bottles(remain)} of beer on the wall\n                           |{num(remain)} {bottles(remain)} of beer\n                           |Take one down, pass it around\n                           |{num(remain-1)} {bottles(remain-1)} of beer on the wall\n                           |\n                         );\n            }\n        }\n    }\n"}
{"id": 59728, "name": "99 bottles of beer", "source": "Translate Fortran to Python: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 59729, "name": "99 bottles of beer", "source": "Translate Fortran to Python: program bottlestest\n\n  implicit none\n\n  integer :: i\n  \n  character(len=*), parameter   :: bwall = \" on the wall\", &\n                                   bottles = \"bottles of beer\", &\n                                   bottle  = \"bottle of beer\", &\n                                   take = \"Take one down, pass it around\", &\n                                   form = \"(I0, ' ', A)\"\n\n  do i = 99,0,-1\n     if ( i /= 1 ) then\n        write (*,form)  i, bottles // bwall\n        if ( i > 0 ) write (*,form)  i, bottles\n     else\n        write (*,form)  i, bottle // bwall\n        write (*,form)  i, bottle\n     end if\n     if ( i > 0 ) write (*,*) take\n  end do\n\nend program bottlestest\n", "target": "fun bottles(n): match __args__:\n    (0) => \"No more bottles\"\n    (1) => \"1 bottle\"\n    (_) => \"$n bottles\"\n\nfor n in 99..-1..1:\n    print @format\n"}
{"id": 60139, "name": "Concurrent computing", "source": "Translate Fortran to C#: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "static Random tRand = new Random();\n\nstatic void Main(string[] args)\n{\n\tThread t = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Enjoy\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Rosetta\");\n\n\tt = new Thread(new ParameterizedThreadStart(WriteText));\n\tt.Start(\"Code\");\n\n\tConsole.ReadLine();\n}\n\nprivate static void WriteText(object p)\n{\n\tThread.Sleep(tRand.Next(1000, 4000));\n\tConsole.WriteLine(p);\n}\n"}
{"id": 60142, "name": "Concurrent computing", "source": "Translate Fortran to Java: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "import java.util.concurrent.CyclicBarrier;\n\npublic class Threads\n{\n  public static class DelayedMessagePrinter implements Runnable\n  {\n    private CyclicBarrier barrier;\n    private String msg;\n    \n    public DelayedMessagePrinter(CyclicBarrier barrier, String msg)\n    {\n      this.barrier = barrier;\n      this.msg = msg;\n    }\n    \n    public void run()\n    {\n      try\n      {  barrier.await();  }\n      catch (Exception e)\n      {  }\n      System.out.println(msg);\n    }\n  }\n  \n  public static void main(String[] args)\n  {\n    CyclicBarrier barrier = new CyclicBarrier(3);\n    new Thread(new DelayedMessagePrinter(barrier, \"Enjoy\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Rosetta\")).start();\n    new Thread(new DelayedMessagePrinter(barrier, \"Code\")).start();\n  }\n}\n"}
{"id": 60143, "name": "Concurrent computing", "source": "Translate Fortran to Python: program concurrency\n  implicit none\n  character(len=*), parameter :: str1 = 'Enjoy'\n  character(len=*), parameter :: str2 = 'Rosetta'\n  character(len=*), parameter :: str3 = 'Code'\n  integer                     :: i\n  real                        :: h\n  real, parameter             :: one_third = 1.0e0/3\n  real, parameter             :: two_thirds = 2.0e0/3\n\n  interface\n     integer function omp_get_thread_num\n     end function omp_get_thread_num\n  end interface\n  interface\n     integer function omp_get_num_threads\n     end function omp_get_num_threads\n  end interface\n\n  \n  \n  do i=1,20\n     \n     \n     if (omp_get_thread_num() == 0 .and. i == 1) then\n        write(*,'(a,i0,a)') 'Using ',omp_get_num_threads(),' threads'\n     end if\n\n     \n     call random_number(h)\n\n     \n     if (h < one_third) then\n        write(*,'(a)') str1\n     else if (h < two_thirds) then\n        write(*,'(a)') str2\n     else\n        write(*,'(a)') str3\n     end if\n     \n  end do\n  \n\nend program concurrency\n", "target": "let words = [\"Enjoy\", \"Rosetta\", \"Code\"]\n\nfor word in words:\n    (word) |> async (w) =>\n        sleep(random())\n        print(w)\n"}
{"id": 60360, "name": "Strip a set of characters from a string", "source": "Translate Fortran to C#: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": "using System;\n\npublic static string RemoveCharactersFromString(string testString, string removeChars)\n{\n    char[] charAry = removeChars.ToCharArray();\n    string returnString = testString;\n    foreach (char c in charAry)\n    {\n        while (returnString.IndexOf(c) > -1)\n        {\n            returnString = returnString.Remove(returnString.IndexOf(c), 1);\n        }\n    }\n    return returnString;\n}\n"}
{"id": 60363, "name": "Strip a set of characters from a string", "source": "Translate Fortran to Java: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": "class StripChars {\n    public static String stripChars(String inString, String toStrip) {\n        return inString.replaceAll(\"[\" + toStrip + \"]\", \"\");\n    }\n\n    public static void main(String[] args) {\n        String sentence = \"She was a soul stripper. She took my heart!\";\n        String chars = \"aei\";\n        System.out.println(\"sentence: \" + sentence);\n        System.out.println(\"to strip: \" + chars);\n        System.out.println(\"stripped: \" + stripChars(sentence, chars));\n    }\n}\n"}
{"id": 60364, "name": "Strip a set of characters from a string", "source": "Translate Fortran to Python: elemental subroutine strip(string,set)\n  character(len=*), intent(inout) :: string\n  character(len=*), intent(in)    :: set\n  integer                         :: old, new, stride\n  old = 1; new = 1\n  do\n    stride = scan( string( old : ), set )\n    if ( stride > 0 ) then\n      string( new : new+stride-2 ) = string( old : old+stride-2 )\n      old = old+stride\n      new = new+stride-1\n    else\n      string( new : ) = string( old : )\n      return\n    end if\n  end do\nend subroutine strip\n", "target": ">>> def stripchars(s, chars):\n...     return s.translate(None, chars)\n... \n>>> stripchars(\"She was a soul stripper. She took my heart!\", \"aei\")\n'Sh ws  soul strppr. Sh took my hrt!'\n"}
{"id": 60631, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to C#: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60632, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to C#: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "using System;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\u00a0\nclass Program {\n\u00a0\n    static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n        q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\u00a0\n    static void Main() { const int max = 73, smax = 65;\n        int power_width = ((BI.Pow(7, max).ToString().Length / 3) << 2) + 3,\n            isqrt_width = (power_width + 1) >> 1;\n        WriteLine(\"Integer square root for numbers 0 to {0}:\", smax);\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", \n            (n / 10).ToString().Replace(\"0\", \" \")); WriteLine();\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", n % 10); WriteLine();\n        WriteLine(new String('-', (smax << 1) + 1));\n        for (int n = 0; n <= smax; ++n) Write(\"{0} \", isqrt(n));\n        WriteLine(\"\\n\\nInteger square roots of odd powers of 7 from 1 to {0}:\", max);\n        string s = string.Format(\"[0,2] |[1,{0}:n0] |[2,{1}:n0]\",\n            power_width, isqrt_width).Replace(\"[\", \"{\").Replace(\"]\", \"}\");\n        WriteLine(s, \"n\", \"7 ^ n\", \"isqrt(7 ^ n)\");\n        WriteLine(new String('-', power_width + isqrt_width + 6));\n        BI p = 7; for (int n = 1; n <= max; n += 2, p *= 49)\n            WriteLine (s, n, p, isqrt(p)); }\n}\n"}
{"id": 60637, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Java: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60638, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Java: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "import java.math.BigInteger;\n\npublic class Isqrt {\n    private static BigInteger isqrt(BigInteger x) {\n        if (x.compareTo(BigInteger.ZERO) < 0) {\n            throw new IllegalArgumentException(\"Argument cannot be negative\");\n        }\n        var q = BigInteger.ONE;\n        while (q.compareTo(x) <= 0) {\n            q = q.shiftLeft(2);\n        }\n        var z = x;\n        var r = BigInteger.ZERO;\n        while (q.compareTo(BigInteger.ONE) > 0) {\n            q = q.shiftRight(2);\n            var t = z;\n            t = t.subtract(r);\n            t = t.subtract(q);\n            r = r.shiftRight(1);\n            if (t.compareTo(BigInteger.ZERO) >= 0) {\n                z = t;\n                r = r.add(q);\n            }\n        }\n        return r;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The integer square root of integers from 0 to 65 are:\");\n        for (int i = 0; i <= 65; i++) {\n            System.out.printf(\"%s \", isqrt(BigInteger.valueOf(i)));\n        }\n        System.out.println();\n\n        System.out.println(\"The integer square roots of powers of 7 from 7^1 up to 7^73 are:\");\n        System.out.println(\"power                                    7 ^ power                                                 integer square root\");\n        System.out.println(\"----- --------------------------------------------------------------------------------- -----------------------------------------\");\n        var pow7 = BigInteger.valueOf(7);\n        var bi49 = BigInteger.valueOf(49);\n        for (int i = 1; i < 74; i += 2) {\n            System.out.printf(\"%2d\u00a0%,84d\u00a0%,41d\\n\", i, pow7, isqrt(pow7));\n            pow7 = pow7.multiply(bi49);\n        }\n    }\n}\n"}
{"id": 60639, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Python: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 60640, "name": "Isqrt (integer square root) of X", "source": "Translate Fortran to Python: MODULE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n    CONTAINS\n        \n    \n    FUNCTION COMMATIZE(NUM) RESULT(OUT_STR)\n         INTEGER(16), INTENT(IN) :: NUM\n         INTEGER(16) I \n         CHARACTER(83) :: TEMP, OUT_STR\n         \n         WRITE(TEMP, '(I0)') NUM\n\n         OUT_STR = \"\"\n\n         DO I=0, LEN_TRIM(TEMP)-1\n             IF (MOD(I, 3) .EQ. 0 .AND. I .GT. 0 .AND. I .LT. LEN_TRIM(TEMP)) THEN\n                  OUT_STR = \",\" // TRIM(OUT_STR)\n             END IF\n             OUT_STR = TEMP(LEN_TRIM(TEMP)-I:LEN_TRIM(TEMP)-I) // TRIM(OUT_STR)\n         END DO\n    END FUNCTION COMMATIZE\n\n\n    \n    FUNCTION ISQRT(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: ISQRT\n        INTEGER(16) :: Q, Z, R, T\n    \n        Q = 1\n        Z = NUM\n        R = 0\n        T = 0\n    \n        DO WHILE (Q .LT. NUM)\n            Q = Q * 4\n        END DO\n    \n        DO WHILE (Q .GT. 1)\n            Q = Q / 4\n            T = Z - R - Q\n            R = R / 2\n            \n            IF (T .GE. 0) THEN\n                Z = T\n                R = R + Q\n            END IF\n        END DO\n    \n        ISQRT = R\n    END FUNCTION ISQRT\n\nEND MODULE INTEGER_SQUARE_ROOT\n\n\n\n\nPROGRAM ISQRT_DEMO\n    USE INTEGER_SQUARE_ROOT\n    IMPLICIT NONE\n\n\n    INTEGER(16), PARAMETER :: MIN_NUM_HZ = 0\n    INTEGER(16), PARAMETER :: MAX_NUM_HZ = 65\n    INTEGER(16), PARAMETER :: POWER_BASE = 7\n    INTEGER(16), PARAMETER :: POWER_MIN = 1\n    INTEGER(16), PARAMETER :: POWER_MAX = 73\n    INTEGER(16), DIMENSION(MAX_NUM_HZ-MIN_NUM_HZ+1) :: VALUES\n    CHARACTER(2) :: HEADER_1\n    CHARACTER(83) :: HEADER_2\n    CHARACTER(83) :: HEADER_3\n\n    INTEGER(16) :: I\n\n    HEADER_1 = \" n\"\n    HEADER_2 = \"7^n\"\n    HEADER_3 = \"isqrt(7^n)\"\n\n    WRITE(*,'(A, I0, A, I0)') \"Integer square root for numbers \", MIN_NUM_HZ, \" to \", MAX_NUM_HZ\n\n    DO I=1, SIZE(VALUES)\n        VALUES(I) = ISQRT(MIN_NUM_HZ+I)\n    END DO\n\n    WRITE(*,'(100I2)') VALUES\n    WRITE(*,*) NEW_LINE('A')\n    \n    WRITE(*,'(A,A,A,A,A)') HEADER_1, \" | \", HEADER_2, \" | \", HEADER_3\n    WRITE(*,*) REPEAT(\"-\", 8+83*2)\n\n    DO I=POWER_MIN,POWER_MAX, 2\n        WRITE(*,'(I2, A, A, A, A)') I, \" | \" // COMMATIZE(7**I), \" | \", COMMATIZE(ISQRT(7**I))\n    END DO\n        \n\n END PROGRAM ISQRT_DEMO\n", "target": "def isqrt ( x ):\n    q = 1\n    while q <= x : \n        q *= 4\n    z,r = x,0\n    while q > 1 :\n        q  /= 4\n        t,r = z-r-q,r/2\n        if t >= 0 :\n            z,r = t,r+q\n    return r \n\nprint ' '.join( '%d'%isqrt( n ) for n in xrange( 66 ))\nprint '\\n'.join( '{0:114,} = isqrt( 7^{1:3} )'.format( isqrt( 7**n ),n ) for n in range( 1,204,2 ))\n"}
{"id": 61310, "name": "Factorial", "source": "Translate Fortran to C#: nfactorial = PRODUCT((/(i, i=1,n)/))\n", "target": "using System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n"}
{"id": 61313, "name": "Factorial", "source": "Translate Fortran to Java: nfactorial = PRODUCT((/(i, i=1,n)/))\n", "target": "module ShowFactorials\n    {\n    static <Value extends IntNumber> Value factorial(Value n)\n        {\n        assert:arg n >= Value.zero();\n        return n <= Value.one() ? n : n * factorial(n-Value.one());\n        }\n\n    @Inject Console console;\n    void run()\n        {\n        \n        UInt128 bigNum = 34;\n        console.print($\"factorial({bigNum})={factorial(bigNum)}\");\n\n        \n        for (Int i : 10..-1)\n            {\n            console.print($\"factorial({i})={factorial(i)}\");\n            }\n        }\n    }\n"}
{"id": 61539, "name": "Polynomial regression", "source": "Translate Fortran to C#: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": "        public static double[] Polyfit(double[] x, double[] y, int degree)\n        {\n            \n            var v = new DenseMatrix(x.Length, degree + 1);\n            for (int i = 0; i < v.RowCount; i++)\n                for (int j = 0; j <= degree; j++) v[i, j] = Math.Pow(x[i], j);\n            var yv = new DenseVector(y).ToColumnMatrix();\n            QR<double> qr = v.QR();\n            \n            \n            var r = qr.R.SubMatrix(0, degree + 1, 0, degree + 1);\n            var q = v.Multiply(r.Inverse());\n            var p = r.Inverse().Multiply(q.TransposeThisAndMultiply(yv));\n            return p.Column(0).ToArray();\n        }\n"}
{"id": 61542, "name": "Polynomial regression", "source": "Translate Fortran to Java: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": "import java.util.Arrays;\nimport java.util.function.IntToDoubleFunction;\nimport java.util.stream.IntStream;\n\npublic class PolynomialRegression {\n    private static void polyRegression(int[] x, int[] y) {\n        int n = x.length;\n        double xm = Arrays.stream(x).average().orElse(Double.NaN);\n        double ym = Arrays.stream(y).average().orElse(Double.NaN);\n        double x2m = Arrays.stream(x).map(a -> a * a).average().orElse(Double.NaN);\n        double x3m = Arrays.stream(x).map(a -> a * a * a).average().orElse(Double.NaN);\n        double x4m = Arrays.stream(x).map(a -> a * a * a * a).average().orElse(Double.NaN);\n        double xym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            xym += x[i] * y[i];\n        }\n        xym /= Math.min(x.length, y.length);\n        double x2ym = 0.0;\n        for (int i = 0; i < x.length && i < y.length; ++i) {\n            x2ym += x[i] * x[i] * y[i];\n        }\n        x2ym /= Math.min(x.length, y.length);\n\n        double sxx = x2m - xm * xm;\n        double sxy = xym - xm * ym;\n        double sxx2 = x3m - xm * x2m;\n        double sx2x2 = x4m - x2m * x2m;\n        double sx2y = x2ym - x2m * ym;\n\n        double b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2);\n        double a = ym - b * xm - c * x2m;\n\n        IntToDoubleFunction abc = (int xx) -> a + b * xx + c * xx * xx;\n\n        System.out.println(\"y = \" + a + \" + \" + b + \"x + \" + c + \"x^2\");\n        System.out.println(\" Input  Approximation\");\n        System.out.println(\" x   y     y1\");\n        for (int i = 0; i < n; ++i) {\n            System.out.printf(\"%2d %3d  %5.1f\\n\", x[i], y[i], abc.applyAsDouble(x[i]));\n        }\n    }\n\n    public static void main(String[] args) {\n        int[] x = IntStream.range(0, 11).toArray();\n        int[] y = new int[]{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321};\n        polyRegression(x, y);\n    }\n}\n"}
{"id": 61543, "name": "Polynomial regression", "source": "Translate Fortran to Python: module fitting\ncontains\n\n  function polyfit(vx, vy, d)\n    implicit none\n    integer, intent(in)                   :: d\n    integer, parameter                    :: dp = selected_real_kind(15, 307)\n    real(dp), dimension(d+1)              :: polyfit\n    real(dp), dimension(:), intent(in)    :: vx, vy\n   \n    real(dp), dimension(:,:), allocatable :: X\n    real(dp), dimension(:,:), allocatable :: XT\n    real(dp), dimension(:,:), allocatable :: XTX\n   \n    integer :: i, j\n   \n    integer     :: n, lda, lwork\n    integer :: info\n    integer, dimension(:), allocatable :: ipiv\n    real(dp), dimension(:), allocatable :: work\n   \n    n = d+1\n    lda = n\n    lwork = n\n   \n    allocate(ipiv(n))\n    allocate(work(lwork))\n    allocate(XT(n, size(vx)))\n    allocate(X(size(vx), n))\n    allocate(XTX(n, n))\n   \n    \n    do i = 0, d\n       do j = 1, size(vx)\n          X(j, i+1) = vx(j)**i\n       end do\n    end do\n   \n    XT  = transpose(X)\n    XTX = matmul(XT, X)\n   \n    \n    call DGETRF(n, n, XTX, lda, ipiv, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    call DGETRI(n, XTX, lda, ipiv, work, lwork, info)\n    if ( info /= 0 ) then\n       print *, \"problem\"\n       return\n    end if\n    \n    polyfit = matmul( matmul(XTX, XT), vy)\n    \n    deallocate(ipiv)\n    deallocate(work)\n    deallocate(X)\n    deallocate(XT)\n    deallocate(XTX)\n  \n  end function\n \nend module\n", "target": ">>> x = [0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10]\n>>> y = [1,   6,  17,  34,  57,  86, 121, 162, 209, 262, 321]\n>>> coeffs = numpy.polyfit(x,y,deg=2)\n>>> coeffs\narray([ 3.,  2.,  1.])\n"}
{"id": 61750, "name": "Menu", "source": "Translate Fortran to C#: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Menu\n{\n        static void Main(string[] args)\n        {\n            List<string> menu_items = new List<string>() { \"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\" };\n            \n            Console.WriteLine(PrintMenu(menu_items));\n            Console.ReadLine();\n        }\n        private static string PrintMenu(List<string> items)\n        {\n            if (items.Count == 0)\n                return \"\";\n\n            string input = \"\";\n            int i = -1;\n            do\n            {\n                for (int j = 0; j < items.Count; j++)\n                    Console.WriteLine(\"{0}) {1}\", j, items[j]);\n\n                Console.WriteLine(\"What number?\");\n                input = Console.ReadLine();\n\n            } while (!int.TryParse(input, out i) || i >= items.Count || i < 0);\n            return items[i];\n        }\n}\n"}
{"id": 61753, "name": "Menu", "source": "Translate Fortran to Java: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "public static String select(List<String> list, String prompt){\n    if(list.size() == 0) return \"\";\n    Scanner sc = new Scanner(System.in);\n    String ret = null;\n    do{\n        for(int i=0;i<list.size();i++){\n            System.out.println(i + \": \"+list.get(i));\n        }\n        System.out.print(prompt);\n        int index = sc.nextInt();\n        if(index >= 0 && index < list.size()){\n            ret = list.get(index);\n        }\n    }while(ret == null);\n    return ret;\n}\n"}
{"id": 61754, "name": "Menu", "source": "Translate Fortran to Python: \n\n\n      module menu\n      public :: selector\n      contains\n\n      function selector(title,options) result(choice)\n      character(len=*),intent(in) :: title\n      character(len=*),dimension(:),intent(in) :: options\n      character(len=len(options)) :: choice\n      integer :: i,ichoose,ios,n\n\n      choice = \"\"\n\n      n = size(options)\n      if (n > 0) then\n        do\n          print \"(a)\",title\n          print \"(i8,\"\", \"\",a)\",(i,options(i),i=1,n)\n          read (*,fmt=\"(i8)\",iostat=ios) ichoose\n\n          if (ios == -1) exit \n          if (ios /= 0) cycle \n          if (ichoose < 1) cycle\n          if (ichoose > n) cycle \n\n          choice = options(ichoose)\n          exit\n        end do\n      end if\n      end function selector\n      end module menu\n\n      program menu_demo\n      use menu\n      character(len=14),dimension(:),allocatable :: zero_items,fairytale\n      character(len=len(zero_items)) :: s\n\n      \n      allocate(zero_items(0))\n      print \"(a)\",\"input items:\",zero_items\n      s = selector('Choose from the empty list',zero_items)\n      print \"(a)\",\"returned:\",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      \n      allocate(fairytale(4))\n      fairytale = (/'fee fie       ','huff and puff ', &\n        'mirror mirror ','tick tock     '/)\n      print \"(a)\",\"input items:\",fairytale\n      s = selector('Choose a fairy tale',fairytale)\n      print \"(a)\",\"returned: \",s\n      if (s == \"\") print \"(a)\",\"(an empty string)\"\n\n      end program menu_demo\n", "target": "def _menu(items):\n    for indexitem in enumerate(items):\n        print (\"  %2i) %s\" % indexitem)\n\ndef _ok(reply, itemcount):\n    try:\n        n = int(reply)\n        return 0 <= n < itemcount\n    except:\n        return False\n    \ndef selector(items, prompt):\n    'Prompt to select an item from the items'\n    if not items: return ''\n    reply = -1\n    itemcount = len(items)\n    while not _ok(reply, itemcount):\n        _menu(items)\n        \n        reply = raw_input(prompt).strip()\n    return items[int(reply)]\n\nif __name__ == '__main__':\n    items = ['fee fie', 'huff and puff', 'mirror mirror', 'tick tock']\n    item = selector(items, 'Which is from the three pigs: ')\n    print (\"You chose: \" + item)\n"}
{"id": 62082, "name": "Greatest subsequential sum", "source": "Translate Fortran to C#: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62083, "name": "Greatest subsequential sum", "source": "Translate Fortran to C#: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "using System;\n\nnamespace Tests_With_Framework_4\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] integers = { -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 }; int length = integers.Length;\n            int maxsum, beginmax, endmax, sum; maxsum = beginmax = sum = 0; endmax = -1;\n\n            for (int i = 0; i < length; i++)\n            {\n                sum = 0;\n                for (int k = i; k < length; k++)\n                {\n                    sum += integers[k];\n                    if (sum > maxsum)\n                    {\n                        maxsum = sum;\n                        beginmax = i;\n                        endmax = k;\n                    }\n                }\n            }\n\n            for (int i = beginmax; i <= endmax; i++)\n                Console.WriteLine(integers[i]);\n\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 62088, "name": "Greatest subsequential sum", "source": "Translate Fortran to Java: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62089, "name": "Greatest subsequential sum", "source": "Translate Fortran to Java: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Sub{\n    private static int[] indices;\n\n    public static void main(String[] args){\n        ArrayList<Long> array= new ArrayList<Long>(); \n        Scanner in = new Scanner(System.in);\n        while(in.hasNextLong()) array.add(in.nextLong());\n        long highSum= Long.MIN_VALUE;\n        ArrayList<Long> highSet= new ArrayList<Long>();\n        \n        for(int subSize= 0;subSize<= array.size();subSize++){\n            indices= new int[subSize];\n            for(int i= 0;i< subSize;i++) indices[i]= i;\n            do{\n                long sum= 0;\n                ArrayList<Long> temp= new ArrayList<Long>();\n                \n                for(long index:indices) {sum+= array.get(index); temp.add(array.get(index));}\n                if(sum > highSum){\n                    highSet= temp;    \n                    highSum= sum;\n                }\n            }while(nextIndices(array));\n        }\n        System.out.println(\"Sum: \" + highSum + \"\\nSet: \" + \n        \t\thighSet);\n    }\n    \n\n    private static boolean nextIndices(ArrayList<Long> a) {\n        for(int i= indices.length-1;i >= 0;--i){\n            indices[i]++;\n            for(int j=i+1;j < indices.length;++j){\n                indices[j]= indices[j - 1] + 1;\n            }\n            if(indices[indices.length - 1] < a.size()){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"}
{"id": 62090, "name": "Greatest subsequential sum", "source": "Translate Fortran to Python: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62091, "name": "Greatest subsequential sum", "source": "Translate Fortran to Python: program MaxSubSeq\n  implicit none\n\n  integer, parameter :: an = 11\n  integer, dimension(an) :: a = (/ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 /)\n\n  integer, dimension(an,an) :: mix\n  integer :: i, j\n  integer, dimension(2) :: m\n\n  forall(i=1:an,j=1:an) mix(i,j) = sum(a(i:j))\n  m = maxloc(mix)\n  \n  print *, a(m(1):m(2))\n\nend program MaxSubSeq\n", "target": "def maxsubseq(seq):\n  return max((seq[begin:end] for begin in xrange(len(seq)+1)\n                             for end in xrange(begin, len(seq)+1)),\n             key=sum)\n"}
{"id": 62566, "name": "Integer sequence", "source": "Translate Fortran to C#: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62567, "name": "Integer sequence", "source": "Translate Fortran to C#: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "using System;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main()\n    {\n        BigInteger i = 1;\n        while (true)\n        {\n            Console.WriteLine(i++);\n        }\n    }\n}\n"}
{"id": 62572, "name": "Integer sequence", "source": "Translate Fortran to Java: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62573, "name": "Integer sequence", "source": "Translate Fortran to Java: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "public class Count{\n    public static void main(String[] args){\n        for(long i = 1; ;i++) System.out.println(i);\n    }\n}\n"}
{"id": 62574, "name": "Integer sequence", "source": "Translate Fortran to Python: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62575, "name": "Integer sequence", "source": "Translate Fortran to Python: program Intseq\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 1\n  \n\n\n  do\n    print*, n\n    n = n + 1\n  end do\nend program\n", "target": "i=1\nwhile i:\n    print(i)\n    i += 1\n"}
{"id": 62951, "name": "Fibonacci sequence", "source": "Translate Fortran to C#: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "public static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n"}
{"id": 62954, "name": "Fibonacci sequence", "source": "Translate Fortran to Java: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "public static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n"}
{"id": 62955, "name": "Fibonacci sequence", "source": "Translate Fortran to Python: C     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n", "target": "from math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n"}
{"id": 63235, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to C#: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(new[] { 1, 2, 3 }.Average());\n    }\n}\n"}
{"id": 63239, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to Java: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "public static double avg(double... arr) {\n    double sum = 0.0;\n    for (double x : arr) {\n        sum += x;\n    }\n    return sum / arr.length;\n}\n"}
{"id": 63240, "name": "Averages_Arithmetic mean", "source": "Translate Fortran to Python: real, target, dimension(100) :: a = (/ (i, i=1, 100) /)\nreal, dimension(5,20) :: b = reshape( a, (/ 5,20 /) )\nreal, pointer, dimension(:) :: p => a(2:1)       \nreal :: mean, zmean, bmean\nreal, dimension(20) :: colmeans\nreal, dimension(5) :: rowmeans\n\nmean = sum(a)/size(a)                \nmean = sum(a)/max(size(a),1)         \n                                     \n\nzmean = sum(p)/max(size(p),1)        \n                                     \n\nbmean = sum(b)/max(size(b),1)        \n\nrowmeans = sum(b,1)/max(size(b,2),1) \n                                     \ncolmeans = sum(b,2)/max(size(b,1),1) \n                                     \n", "target": "from math import fsum\ndef average(x):\n    return fsum(x)/float(len(x)) if x else 0\nprint (average([0,0,3,1,4,1,5,9,0,0]))\nprint (average([1e20,-1e-20,3,1,4,1,5,9,-1e20,1e-20]))\n"}
{"id": 63500, "name": "Spiral matrix", "source": "Translate Fortran to C#: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "public int[,] Spiral(int n) {\n    int[,] result = new int[n, n];\n\n    int pos = 0;\n    int count = n;\n    int value = -n;\n    int sum = -1;\n\n    do {\n        value = -1 * value / n;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n        value *= n;\n        count--;\n        for (int i = 0; i < count; i++) {\n            sum += value;\n            result[sum / n, sum % n] = pos++;\n        }\n    } while (count > 0);\n\n    return result;\n}\n\n\n\npublic void PrintArray(int[,] array) {\n    int n = (array.GetLength(0) * array.GetLength(1) - 1).ToString().Length + 1;\n\n    for (int i = 0; i < array.GetLength(0); i++) {\n        for (int j = 0; j < array.GetLength(1); j++) {\n            Console.Write(array[i, j].ToString().PadLeft(n, ' '));\n        }\n        Console.WriteLine();\n    }\n}\n"}
{"id": 63503, "name": "Spiral matrix", "source": "Translate Fortran to Java: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "public class Blah {\n\n  public static void main(String[] args) {\n    print2dArray(getSpiralArray(5));\n  }\n\n  public static int[][] getSpiralArray(int dimension) {\n    int[][] spiralArray = new int[dimension][dimension];\n\n    int numConcentricSquares = (int) Math.ceil((dimension) / 2.0);\n\n    int j;\n    int sideLen = dimension;\n    int currNum = 0;\n\n    for (int i = 0; i < numConcentricSquares; i++) {\n      \n      for (j = 0; j < sideLen; j++) {\n        spiralArray[i][i + j] = currNum++;\n      }\n\n      \n      for (j = 1; j < sideLen; j++) {\n        spiralArray[i + j][dimension - 1 - i] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > -1; j--) {\n        spiralArray[dimension - 1 - i][i + j] = currNum++;\n      }\n\n      \n      for (j = sideLen - 2; j > 0; j--) {\n        spiralArray[i + j][i] = currNum++;\n      }\n\n      sideLen -= 2;\n    }\n\n    return spiralArray;\n  }\n\n  public static void print2dArray(int[][] array) {\n    for (int[] row : array) {\n      for (int elem : row) {\n        System.out.printf(\"%3d\", elem);\n      }\n      System.out.println();\n    }\n  }\n}\n"}
{"id": 63504, "name": "Spiral matrix", "source": "Translate Fortran to Python: PROGRAM SPIRAL\n\n  IMPLICIT NONE\n \n  INTEGER, PARAMETER :: size = 5\n  INTEGER :: i, x = 0, y = 1, count = size, n = 0\n  INTEGER :: array(size,size)\n\n  DO i = 1, count\n    x = x + 1 \n      array(x,y) = n\n    n = n + 1\n  END DO\n\n  DO\n    count = count  - 1\n      DO i = 1, count\n        y = y + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      IF (n > size*size-1) EXIT\n      count = count - 1\n      DO i = 1, count\n        y = y - 1\n        array(x,y) = n\n        n = n + 1\n      END DO\n      DO i = 1, count\n        x = x + 1\n        array(x,y) = n\n        n = n + 1\n      END DO\t\n      IF (n > size*size-1) EXIT\n  END DO\n   \n  DO y = 1, size\n    DO x = 1, size\n      WRITE (*, \"(I4)\", ADVANCE=\"NO\") array (x, y)\n    END DO\n    WRITE (*,*)\n  END DO\n\nEND PROGRAM SPIRAL\n", "target": "def spiral(n):\n    dx,dy = 1,0            \n    x,y = 0,0              \n    myarray = [[None]* n for j in range(n)]\n    for i in xrange(n**2):\n        myarray[x][y] = i\n        nx,ny = x+dx, y+dy\n        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:\n            x,y = nx,ny\n        else:\n            dx,dy = -dy,dx\n            x,y = x+dx, y+dy\n    return myarray\n\ndef printspiral(myarray):\n    n = range(len(myarray))\n    for y in n:\n        for x in n:\n            print \"%2i\" % myarray[x][y],\n        print\n\nprintspiral(spiral(5))\n"}
{"id": 63709, "name": "Sort an array of composite structures", "source": "Translate Fortran to C#: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n"}
{"id": 63712, "name": "Sort an array of composite structures", "source": "Translate Fortran to Java: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n"}
{"id": 63713, "name": "Sort an array of composite structures", "source": "Translate Fortran to Python: PROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n", "target": "people = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n"}
{"id": 64026, "name": "Julia set", "source": "Translate Fortran to C#: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64027, "name": "Julia set", "source": "Translate Fortran to C#: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n"}
{"id": 64033, "name": "Julia set", "source": "Translate Fortran to Java: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64034, "name": "Julia set", "source": "Translate Fortran to Java: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "import javax.swing.*;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\n\npublic class JuliaSet extends JPanel {\n    private static final int MAX_ITERATIONS = 300;\n    private static final double ZOOM = 1;\n    private static final double CX = -0.7;\n    private static final double CY = 0.27015;\n    private static final double MOVE_X = 0;\n    private static final double MOVE_Y = 0;\n\n    public JuliaSet() {\n        setPreferredSize(new Dimension(800, 600));\n        setBackground(Color.white);\n    }\n\n    void drawJuliaSet(Graphics2D g) {\n        int w = getWidth();\n        int h = getHeight();\n        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);\n\n        for (int x = 0; x < w; x++) {\n            for (int y = 0; y < h; y++) {\n                double zx = 1.5 * (x - w / 2) / (0.5 * ZOOM * w) + MOVE_X;\n                double zy = (y - h / 2) / (0.5 * ZOOM * h) + MOVE_Y;\n                float i = MAX_ITERATIONS;\n                while (zx * zx + zy * zy < 4 && i > 0) {\n                    double tmp = zx * zx - zy * zy + CX;\n                    zy = 2.0 * zx * zy + CY;\n                    zx = tmp;\n                    i--;\n                }\n                int c = Color.HSBtoRGB((MAX_ITERATIONS / i) % 1, 1, i > 0 ? 1 : 0);\n                image.setRGB(x, y, c);\n            }\n        }\n        g.drawImage(image, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawJuliaSet(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Julia Set\");\n            f.setResizable(false);\n            f.add(new JuliaSet(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 64035, "name": "Julia set", "source": "Translate Fortran to Python: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64036, "name": "Julia set", "source": "Translate Fortran to Python: C     ==================================================================\n      PROGRAM JULIA\nC     ------------------------------------------------------------------\n      INTEGER    NMAP,NROW,NCOL\n      COMPLEX*16 C\n      PARAMETER(NMAP=11,NROW=40,NCOL=100,C=(-0.798D0,0.1618D0))\n      CHARACTER*1 MAP(NMAP)\n      DATA MAP /' ','.',':','-','=','+','*','#','%','$','@'/\n      REAL*8      X(NCOL), Y(NROW)\n      INTEGER     IR, IC, I, J, MX\n      CHARACTER*1 CLR, LINE(NCOL)\n      COMPLEX*16  Z\n\n      MX = (NMAP-1)*5\n      CALL LINSPACE( NCOL, X, -1.5D0,  1.5D0 )\n      CALL LINSPACE( NROW, Y,  1.0D0, -1.0D0 )\n\n      WRITE (*,*) C\n\n      DO 110 IR=1,NROW\n         DO 100 IC=1,NCOL\n            Z = DCMPLX( X(IC), Y(IR) )\n            I  = 1\n            CLR = ' '\n 10         CONTINUE\n            Z = Z*Z + C\n            IF ( 2.0D0 .LT. CDABS(Z) ) THEN\n               CLR = MAP(MOD(I,NMAP-1)+1)\n               GOTO 20\n            END IF\n            I = I + 1\n            IF ( MX .GT. I ) GOTO 10\n 20         CONTINUE\n            LINE(IC) = CLR\n 100     CONTINUE\n         WRITE(*,*) (LINE(J),J=1,NCOL)\n 110  CONTINUE\n      \n      STOP\n      END\n\nC     ==================================================================\n      SUBROUTINE LINSPACE( N, A, S, F )\nC     ------------------------------------------------------------------\n      INTEGER N\n      REAL*8  N A(N), S, F\n      INTEGER I\n      REAL*8  D\n      D = (F-S)/DBLE(N-1)\n      A(1) = S\n      DO 10 I=2,N\n         A(I) = A(I-1) + D\n 10   CONTINUE\n      RETURN\n      END\n", "target": "from __future__ import division\n\ncX = -0.7\ncY = 0.27015\nmaxIter = 300\n\ndef setup():\n    size(640, 480)\n\ndef draw():\n    for x in range(width):\n        for y in range(height):\n            zx = 1.5 * (x - width / 2) / (0.5 * width)\n            zy = (y - height / 2) / (0.5 * height)\n            i = maxIter\n            while zx * zx + zy * zy < 4 and i > 0:\n                tmp = zx * zx - zy * zy + cX\n                zy = 2.0 * zx * zy + cY\n                zx = tmp\n                i -= 1\n            colorMode(HSB)\n            c = color(i / maxIter * 255, 255, 255 if i > 1 else 0)\n            set(x, y, c)\n"}
{"id": 64402, "name": "Calculating the value of e", "source": "Translate Fortran to C#: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64403, "name": "Calculating the value of e", "source": "Translate Fortran to C#: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "using System;\n\nnamespace CalculateE {\n    class Program {\n        public const double EPSILON = 1.0e-15;\n\n        static void Main(string[] args) {\n            ulong fact = 1;\n            double e = 2.0;\n            double e0;\n            uint n = 2;\n            do {\n                e0 = e;\n                fact *= n++;\n                e += 1.0 / fact;\n            } while (Math.Abs(e - e0) >= EPSILON);\n            Console.WriteLine(\"e = {0:F15}\", e);\n        }\n    }\n}\n"}
{"id": 64408, "name": "Calculating the value of e", "source": "Translate Fortran to Java: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64409, "name": "Calculating the value of e", "source": "Translate Fortran to Java: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "public class CalculateE {\n    public static final double EPSILON = 1.0e-15;\n\n    public static void main(String[] args) {\n        long fact = 1;\n        double e = 2.0;\n        int n = 2;\n        double e0;\n        do {\n            e0 = e;\n            fact *= n++;\n            e += 1.0 / fact;\n        } while (Math.abs(e - e0) >= EPSILON);\n        System.out.printf(\"e =\u00a0%.15f\\n\", e);\n    }\n}\n"}
{"id": 64410, "name": "Calculating the value of e", "source": "Translate Fortran to Python: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64411, "name": "Calculating the value of e", "source": "Translate Fortran to Python: Program eee\nimplicit none\ninteger, parameter  :: QP = selected_real_kind(16)\nreal(QP), parameter :: one = 1.0\nreal(QP)            :: ee\n\nwrite(*,*) '    exp(1.) ', exp(1._QP)\n\nee = 1. +(one +(one +(one +(one +(one+ (one +(one +(one +(one +(one +(one & \n        +(one +(one +(one +(one +(one +(one +(one +(one +(one +(one)      & \n        /21.)/20.)/19.)/18.)/17.)/16.)/15.)/14.)/13.)/12.)/11.)/10.)/9.)  &\n        /8.)/7.)/6.)/5.)/4.)/3.)/2.)\n\nwrite(*,*) ' polynomial ', ee\n\t\t\t   \nend Program eee\n", "target": "import math\n\ne0 = 0\ne = 2\nn = 0\nfact = 1\nwhile(e-e0 > 1e-15):\n\te0 = e\n\tn += 1\n\tfact *= 2*n*(2*n+1)\n\te += (2.*n+2)/fact\n\nprint \"Computed e = \"+str(e)\nprint \"Real e = \"+str(math.e)\nprint \"Error = \"+str(math.e-e)\nprint \"Number of iterations = \"+str(n)\n"}
{"id": 64962, "name": "Symmetric difference", "source": "Translate Fortran to C#: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaCode.SymmetricDifference\n{\n    public static class IEnumerableExtension\n    {\n        public static IEnumerable<T> SymmetricDifference<T>(this IEnumerable<T> @this, IEnumerable<T> that)\n        {\n            return @this.Except(that).Concat(that.Except(@this));\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            var a = new[] { \"John\", \"Bob\", \"Mary\", \"Serena\" };\n            var b = new[] { \"Jim\", \"Mary\", \"John\", \"Bob\" };\n\n            foreach (var element in a.SymmetricDifference(b))\n            {\n                Console.WriteLine(element);\n            }\n        }\n    }\n}\n"}
{"id": 64965, "name": "Symmetric difference", "source": "Translate Fortran to Java: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": "Set<String> setA = new Set<String>{'John', 'Bob', 'Mary', 'Serena'};\nSet<String> setB = new Set<String>{'Jim', 'Mary', 'John', 'Bob'};\n\n\nSet<String> notInSetA = setB.clone();\nnotInSetA.removeAll(setA);\n\nSet<String> notInSetB = setA.clone();\nnotInSetB.removeAll(setB);\n\nSet<String> symmetricDifference = new Set<String>();\nsymmetricDifference.addAll(notInSetA);\nsymmetricDifference.addAll(notInSetB);\n\n\nSet<String> union = setA.clone();\nunion.addAll(setB);\n\nSet<String> intersection = setA.clone();\nintersection.retainAll(setB);\n\nSet<String> symmetricDifference2 = union.clone();\nsymmetricDifference2.removeAll(intersection);\n\nSystem.debug('Not in set A: ' + notInSetA);\nSystem.debug('Not in set B: ' + notInSetB);\nSystem.debug('Symmetric Difference: ' + symmetricDifference);\nSystem.debug('Symmetric Difference 2: ' + symmetricDifference2);\n"}
{"id": 64966, "name": "Symmetric difference", "source": "Translate Fortran to Python: program Symmetric_difference\nimplicit none\n\n  character(6) :: a(4) = (/ \"John  \", \"Bob   \", \"Mary  \", \"Serena\" /)\n  character(6) :: b(4) = (/ \"Jim   \", \"Mary  \", \"John  \", \"Bob   \" /)\n  integer :: i, j\n\nouter1: do i = 1, size(a)\n          do j = 1, i-1\n            if(a(i) == a(j)) cycle outer1   \n          end do\n          if(.not. any(b == a(i))) write(*,*) a(i)\n        end do outer1\n  \nouter2: do i = 1, size(b)\n          do j = 1, i-1\n            if(b(i) == b(j)) cycle outer2   \n          end do\n          if(.not. any(a == b(i))) write(*,*) b(i)\n        end do outer2\n      \nend program\n", "target": ">>> setA = {\"John\", \"Bob\", \"Mary\", \"Serena\"}\n>>> setB = {\"Jim\", \"Mary\", \"John\", \"Bob\"}\n>>> setA ^ setB \n{'Jim', 'Serena'}\n>>> setA - setB \n{'Serena'}\n>>> setB - setA \n{'Jim'}\n>>> setA | setB \n{'John', 'Bob', 'Jim', 'Serena', 'Mary'}\n>>> setA & setB \n{'Bob', 'John', 'Mary'}\n"}
{"id": 65195, "name": "Inheritance_Single", "source": "Translate Fortran to C#: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "class Animal\n{ \n   \n  \n}\n\nclass Dog : Animal\n{ \n   \n  \n}\n\nclass Lab : Dog\n{ \n   \n  \n}\n\nclass Collie : Dog\n{ \n  \n  \n}\n\nclass Cat : Animal\n{ \n  \n  \n}\n"}
{"id": 65197, "name": "Inheritance_Single", "source": "Translate Fortran to Java: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "public class Animal{\n   \n}\n"}
{"id": 65198, "name": "Inheritance_Single", "source": "Translate Fortran to Python: module anim\n\n  type animal\n  end type animal\n\n  type, extends(animal) :: dog\n  end type dog\n\n  type, extends(animal) :: cat\n  end type cat\n\n  type, extends(dog) :: lab\n  end type lab\n\n  type, extends(dog) :: collie\n  end type collie\n\nend module anim\n", "target": "class Animal:\n  pass \n\nclass Dog(Animal):\n  pass \n\nclass Cat(Animal):\n  pass \n\nclass Lab(Dog):\n  pass \n\nclass Collie(Dog):\n  pass \n"}
{"id": 65426, "name": "Averages_Mode", "source": "Translate Fortran to C#: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n     \n        static void Main(string[] args)\n        {\n            \n            List<int> myList = new List<int>() { 1, 1, 2, 4, 4 }; \n\n            var query =     from numbers in myList \n                            group numbers by numbers \n                            into groupedNumbers\n                            select new { Number = groupedNumbers.Key, Count = groupedNumbers.Count() }; \n            \n            int max = query.Max(g => g.Count);\n            IEnumerable<int> modes = query.Where(x => x.Count == max).Select(x => x.Number);\n            foreach (var item in modes)\n            {\n                Console.WriteLine(item);\n            }\n            \n            Console.ReadLine();\n        }\n\n             \n       \n    }\n     \n    \n}\n"}
{"id": 65429, "name": "Averages_Mode", "source": "Translate Fortran to Java: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": "import java.util.*;\n\npublic class Mode {\n    public static <T> List<T> mode(List<? extends T> coll) {\n        Map<T, Integer> seen = new HashMap<T, Integer>();\n        int max = 0;\n        List<T> maxElems = new ArrayList<T>();\n        for (T value : coll) {\n            if (seen.containsKey(value))\n                seen.put(value, seen.get(value) + 1);\n            else\n                seen.put(value, 1);\n            if (seen.get(value) > max) {\n                max = seen.get(value);\n                maxElems.clear();\n                maxElems.add(value);\n            } else if (seen.get(value) == max) {\n                maxElems.add(value);\n            }\n        }\n        return maxElems;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(mode(Arrays.asList(1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17))); \n        System.out.println(mode(Arrays.asList(1, 1, 2, 4, 4))); \n    }\n}\n"}
{"id": 65430, "name": "Averages_Mode", "source": "Translate Fortran to Python: program mode_test\n  use Qsort_Module only Qsort => sort\n  implicit none\n\n  integer, parameter    :: S = 10\n  integer, dimension(S) :: a1 = (/ -1, 7, 7, 2, 2, 2, -1, 7, -3, -3 /)\n  integer, dimension(S) :: a2 = (/  1, 1, 1, 1, 1, 0, 2, 2, 2, 2 /)\n  integer, dimension(S) :: a3 = (/  0, 0, -1, -1, 9, 9, 3, 3, 7, 7 /)\n\n  integer, dimension(S) :: o\n  integer               :: l, trash\n\n  print *, stat_mode(a1)\n\n  trash = stat_mode(a1, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a2, o, l)\n  print *, o(1:l)\n  trash = stat_mode(a3, o, l)\n  print *, o(1:l)\n\ncontains\n\n  \n  \n  \n  \n  \n  \n  integer function stat_mode(a, others, otherslen, ok)\n    integer, dimension(:), intent(in) :: a\n    logical, optional, intent(out)    :: ok\n    integer, dimension(size(a,1)), optional, intent(out) :: others\n    integer, optional, intent(out)    :: otherslen\n\n    \n    \n    \n    integer, dimension(size(a, 1)) :: ta, freq, idx\n    integer                        :: rs, i, tm, ml, tf\n\n    if ( present(ok) ) ok = .false.\n\n    select case ( size(a, 1) )\n    case (0)  \n       return\n    case (1)\n       if ( present(ok) ) ok = .true.\n       stat_mode = a(1)\n       return\n    case default\n       if ( present(ok) ) ok = .true.\n       ta = a         \n       call sort(ta)  \n       freq = 1\n       idx = 0\n       rs = 1         \n       \n       do i = 2, size(ta, 1)\n          if ( ta(i-1) == ta(i) ) then\n             freq(rs) = freq(rs) + 1\n          else\n             idx(rs) = i-1\n             rs = rs + 1\n          end if\n       end do\n       idx(rs) = i-1\n         \n       ml = maxloc(freq(1:rs), 1)  \n       tf = freq(ml)               \n       tm = ta(idx(ml))            \n\n       \n       if ( present(others) ) then\n          i = 1\n          others(1) = tm\n          do\n             freq(ml) = 0\n             ml = maxloc(freq(1:rs), 1)\n             if ( tf == freq(ml) ) then \n                i = i + 1               \n                others(i) = ta(idx(ml))\n             else\n                exit\n             end if\n          end do\n                \n          if ( present(otherslen) ) then\n             otherslen = i\n          end if\n\n       end if\n       stat_mode = tm\n    end select\n\n  end function stat_mode\n\nend program mode_test\n", "target": ">>> from collections import defaultdict\n>>> def modes(values):\n\tcount = defaultdict(int)\n\tfor v in values:\n\t\tcount[v] +=1\n\tbest = max(count.values())\n\treturn [k for k,v in count.items() if v == best]\n\n>>> modes([1,3,6,6,6,6,7,7,12,12,17])\n[6]\n>>> modes((1,1,2,4,4))\n[1, 4]\n"}
{"id": 65671, "name": "Monte Carlo methods", "source": "Translate Fortran to C#: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": "using System;\n\nclass Program {\n    static double MonteCarloPi(int n) {\n        int inside = 0;\n        Random r = new Random();\n\n        for (int i = 0; i < n; i++) {\n            if (Math.Pow(r.NextDouble(), 2)+ Math.Pow(r.NextDouble(), 2) <= 1) {\n                inside++;\n            }\n        }\n\n        return 4.0 * inside / n;\n    }\n\n    static void Main(string[] args) {\n        int value = 1000;\n        for (int n = 0; n < 5; n++) {\n            value *= 10;\n            Console.WriteLine(\"{0}:{1}\", value.ToString(\"#,###\").PadLeft(11, ' '), MonteCarloPi(value));\n        }\n    }\n}\n"}
{"id": 65674, "name": "Monte Carlo methods", "source": "Translate Fortran to Java: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": "public class MC {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getPi(10000));\n\t\tSystem.out.println(getPi(100000));\n\t\tSystem.out.println(getPi(1000000));\n\t\tSystem.out.println(getPi(10000000));\n\t\tSystem.out.println(getPi(100000000));\n\t\t\n\t}\n\tpublic static double getPi(int numThrows){\n\t\tint inCircle= 0;\n\t\tfor(int i= 0;i < numThrows;i++){\n\t\t\t\n\t\t\t\n\t\t\tdouble randX= (Math.random() * 2) - 1;\n\t\t\tdouble randY= (Math.random() * 2) - 1;\n\t\t\t\n\t\t\tdouble dist= Math.sqrt(randX * randX + randY * randY);\n\t\t\t\n\t\t\tif(dist < 1){\n\t\t\t\tinCircle++;\n\t\t\t}\n\t\t}\n\t\treturn 4.0 * inCircle / numThrows;\n\t}\n}\n"}
{"id": 65675, "name": "Monte Carlo methods", "source": "Translate Fortran to Python: MODULE Simulation\n \n   IMPLICIT NONE\n \n   CONTAINS\n \n   FUNCTION Pi(samples)\n     REAL :: Pi\n     REAL :: coords(2), length\n     INTEGER :: i, in_circle, samples\n  \n     in_circle = 0\n     DO i=1, samples\n       CALL RANDOM_NUMBER(coords)\n       coords = coords * 2 - 1\n       length = SQRT(coords(1)*coords(1) + coords(2)*coords(2))\n       IF (length <= 1) in_circle = in_circle + 1\n     END DO\n     Pi = 4.0 * REAL(in_circle) / REAL(samples)\n   END FUNCTION Pi\n \n END MODULE Simulation\n  \n PROGRAM MONTE_CARLO\n \n   USE Simulation \n   \n   INTEGER :: n = 10000\n \n   DO WHILE (n <= 100000000)\n     WRITE (*,*) n, Pi(n)\n     n = n * 10\n   END DO\n     \n END PROGRAM MONTE_CARLO\n", "target": ">>> import random, math\n>>> throws = 1000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1520000000000001\n>>> throws = 1000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1396359999999999\n>>> throws = 100000000\n>>> 4.0 * sum(math.hypot(*[random.random()*2-1\n\t                 for q in [0,1]]) < 1\n              for p in xrange(throws)) / float(throws)\n3.1415666400000002\n"}
{"id": 66019, "name": "N'th", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "using System;\nusing System.Linq;\n\nclass Program\n{\n    private static string Ordinalize(int i)\n    {\n        i = Math.Abs(i);\n\n        if (new[] {11, 12, 13}.Contains(i%100))\n            return i + \"th\";\n\n        switch (i%10)\n        {\n            case 1:\n                return i + \"st\";\n            case 2:\n                return i + \"nd\";\n            case 3:\n                return i + \"rd\";\n            default:\n                return i + \"th\";\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(0, 26).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(250, 16).Select(Ordinalize)));\n        Console.WriteLine(string.Join(\" \", Enumerable.Range(1000, 26).Select(Ordinalize)));\n    }\n}\n"}
{"id": 66022, "name": "N'th", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "public class Nth {\n\tpublic static String ordinalAbbrev(int n){\n\t\tString ans = \"th\"; \n\t\tif(n % 100 / 10 == 1) return ans; \n\t\tswitch(n % 10){\n\t\t\tcase 1: ans = \"st\"; break;\n\t\t\tcase 2: ans = \"nd\"; break;\n\t\t\tcase 3: ans = \"rd\"; break;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 25;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 250; i <= 265;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 1000; i <= 1025;i++){\n\t\t\tSystem.out.print(i + ordinalAbbrev(i) + \" \");\n\t\t}\n\t}\n}\n"}
{"id": 66023, "name": "N'th", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram nth\n  implicit none\n  logical :: need\n  integer :: here, there, n, i, iostat\n  read(5,*,iostat=iostat) here, there\n  if (iostat .ne. 0) then\n     write(6,*)'such bad input never before seen.'\n     write(6,*)'I AYE EYE QUIT\n     call exit(1)\n  end if\n  need = .false.\n  n = abs(there - here) + 1\n  i = 0\n  do while (0 /= mod(3+mod(here-i, 3), 3))\n     write(6,'(a22)',advance='no') ''\n     i = i+1\n  end do\n  do i = here, there, sign(1, there-here)\n     write(6,'(a22)',advance='no') ordinate(i)\n     if (2 /= mod(i,3)) then\n        need = .true.\n     else\n        write(6,'(a)')''\n        need = .false.\n     end if\n  end do\n  if (need) write(6,'(a)')''\n\ncontains\n\n  character(len=22) function ordinate(n)\n    character(len=19) :: a\n    character(len=20), parameter :: &\n         &a09 =   \"thstndrdthththththth\",&\n         &ateen = \"thththththththththth\"\n    integer :: ones, tens, ones_index\n    integer, intent(in) :: n\n    write(a,'(i19)') n\n    ones = mod(n,10)\n    tens = mod(n,100)\n    ones_index = ones*2+1\n    if (n < 1000) then\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // \"'\" // ateen(ones_index:ones_index+1)\n          \n       else\n          ordinate = a // \"'\" // a09(ones_index:ones_index+1)\n          \n       end if\n    else\n       if ((10 .le. tens) .and. (tens .lt. 20)) then\n          ordinate = a // ateen(ones_index:ones_index+1)\n       else\n          ordinate = a // a09(ones_index:ones_index+1)\n       end if\n    end if\n  end function ordinate\n\nend program nth\n", "target": "_suffix = ['th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th']\n\ndef nth(n):\n    return \"%i'%s\" % (n, _suffix[n%10] if n % 100 <= 10 or n % 100 > 20 else 'th')\n\nif __name__ == '__main__':\n    for j in range(0,1001, 250):\n        print(' '.join(nth(i) for i in list(range(j, j+25))))\n"}
{"id": 66371, "name": "Levenshtein distance", "source": "Translate Fortran to C#: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66372, "name": "Levenshtein distance", "source": "Translate Fortran to C#: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "using System;\n\nnamespace LevenshteinDistance\n{\n    class Program\n    {\n        static int LevenshteinDistance(string s, string t)\n        {\n            int n = s.Length;\n            int m = t.Length;\n            int[,] d = new int[n + 1, m + 1];\n\t\t\n\t    if (n == 0)\n\t    {\n\t\treturn m;\n\t    }\n\t\n\t    if (m == 0)\n\t    {\n\t\treturn n;\n\t    }\n\n            for (int i = 0; i <= n; i++)\n                d[i, 0] = i;\n            for (int j = 0; j <= m; j++)\n                d[0, j] = j;\n\t\t\t\n            for (int j = 1; j <= m; j++)\n                for (int i = 1; i <= n; i++)\n                    if (s[i - 1] == t[j - 1])\n                        d[i, j] = d[i - 1, j - 1];  \n                    else\n                        d[i, j] = Math.Min(Math.Min(\n                            d[i - 1, j] + 1,    \n                            d[i, j - 1] + 1),   \n                            d[i - 1, j - 1] + 1 \n                            );\n            return d[n, m];\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 2)\n                Console.WriteLine(\"{0} -> {1} = {2}\",\n                    args[0], args[1], LevenshteinDistance(args[0], args[1]));\n            else\n                Console.WriteLine(\"Usage:-\\n\\nLevenshteinDistance <string1> <string2>\");\n        }\n    }\n}\n"}
{"id": 66378, "name": "Levenshtein distance", "source": "Translate Fortran to Java: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66379, "name": "Levenshtein distance", "source": "Translate Fortran to Java: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "public class Levenshtein {\n\n    public static int distance(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int [] costs = new int [b.length() + 1];\n        for (int j = 0; j < costs.length; j++)\n            costs[j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            \n            costs[0] = i;\n            int nw = i - 1;\n            for (int j = 1; j <= b.length(); j++) {\n                int cj = Math.min(1 + Math.min(costs[j], costs[j - 1]), a.charAt(i - 1) == b.charAt(j - 1) ? nw : nw + 1);\n                nw = costs[j];\n                costs[j] = cj;\n            }\n        }\n        return costs[b.length()];\n    }\n\n    public static void main(String [] args) {\n        String [] data = { \"kitten\", \"sitting\", \"saturday\", \"sunday\", \"rosettacode\", \"raisethysword\" };\n        for (int i = 0; i < data.length; i += 2)\n            System.out.println(\"distance(\" + data[i] + \", \" + data[i+1] + \") = \" + distance(data[i], data[i+1]));\n    }\n}\n"}
{"id": 66380, "name": "Levenshtein distance", "source": "Translate Fortran to Python: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66381, "name": "Levenshtein distance", "source": "Translate Fortran to Python: program demo_edit_distance\ncharacter(len=:),allocatable :: sources(:),targets(:)\ninteger,allocatable          :: answers(:),expected(:)\n\nsources=[character(len=20)   :: \"kitten\",  \"rosettacode\",   \"Saturday\", \"sleep\",    \"qwerty\", \"Fortran\" ]\ntargets=[character(len=20)   :: \"sitting\", \"raisethysword\", \"Sunday\",   \"fleeting\", \"qweryt\", \"Fortran\" ]\nexpected=[                       3,         8,               3,          5,          2,        0        ]\n\nanswers=edit_distance(sources,targets)\n\ndo i=1, size(sources)\n   write(*,'(*(g0,1x))') sources(i), targets(i), answers(i), answers(i) == expected(i)\nenddo\n\nwrite(*,*)edit_distance(\"here's a bunch of words\", \"to wring out this code\")==18\n\ncontains\n\npure elemental integer function edit_distance (source,target)\n\n\ncharacter(len=*), intent(in) :: source, target\ninteger                      :: len_source, len_target, i, j, cost\ninteger                      :: matrix(0:len_trim(source), 0:len_trim(target))\n   len_source = len_trim(source)\n   len_target = len_trim(target)\n   matrix(:,0) = [(i,i=0,len_source)]\n   matrix(0,:) = [(j,j=0,len_target)]\n   do i = 1, len_source\n      do j = 1, len_target\n         cost=merge(0,1,source(i:i)==target(j:j))\n         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)\n      enddo\n   enddo\n   edit_distance = matrix(len_source,len_target)\nend function edit_distance\n\nend program demo_edit_distance\n", "target": "def setup():\n    println(distance(\"kitten\", \"sitting\"))\n\ndef distance(a, b):\n    costs = []\n    for j in range(len(b) + 1):\n        costs.append(j)\n    for i in range(1, len(a) + 1):\n        costs[0] = i\n        nw = i - 1\n        for j in range(1, len(b) + 1):\n            cj = min(1 + min(costs[j], costs[j - 1]),\n                     nw if a[i - 1] == b[j - 1] else nw + 1)\n            nw = costs[j]\n            costs[j] = cj\n\n    return costs[len(b)]\n"}
{"id": 66857, "name": "15 puzzle game", "source": "Translate Fortran to C#: LOCZ = MINLOC(BOARD)\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 66858, "name": "15 puzzle game", "source": "Translate Fortran to C#: LOCZ = MINLOC(BOARD)\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Windows.Forms;\n\npublic class FifteenPuzzle\n{\n    const int GridSize = 4; \n    const int BlockCount = 16;\n\n    static readonly Random R = new Random();\n\n    private List<Button> Puzzles = new List<Button>();\n    private int Moves = 0;\n    private DateTime Start;\n\n    public class Puzzle\n    {\n        private int mOrderedNumer;\n\n        public int CurrentNumber;\n\n        public int X;\n        public int Y;\n\n        public int InvX\n        {\n            get { return (GridSize - 1) - X; }\n        }\n        public int InvY\n        {\n            get { return (GridSize - 1) - Y; }\n        }\n\n        public Puzzle(int OrderedNumer)\n        {\n            mOrderedNumer = OrderedNumer;\n\n            CurrentNumber = OrderedNumer;\n\n            X = OrderedNumer % GridSize;\n            Y = OrderedNumer / GridSize;\n        }\n        public Puzzle(int OrderedNumer, int CurrentNumber)\n            : this(OrderedNumer)\n        {\n            this.CurrentNumber = CurrentNumber;\n        }\n\n        public bool IsEmptyPuzzle\n        {\n            get { return CurrentNumber >= (BlockCount - 1); }\n        }\n        public bool IsTruePlace\n        {\n            get { return (CurrentNumber == mOrderedNumer); }\n        }\n        public bool NearestWith(Puzzle OtherPz)\n        {\n            int dx = (X - OtherPz.X);\n            int dy = (Y - OtherPz.Y);\n\n            if ((dx == 0) && (dy <= 1) && (dy >= -1)) return true;\n            if ((dy == 0) && (dx <= 1) && (dx >= -1)) return true;\n\n            return false;\n        }\n\n        public override string ToString()\n        {\n            return (CurrentNumber + 1).ToString();\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        FifteenPuzzle Game = new FifteenPuzzle();\n        Application.Run(Game.CreateForm());\n    }\n\n    private Form CreateForm()\n    {\n        int ButtonSize = 50;\n        int ButtonMargin = 3;\n        int FormEdge = 9;\n\n        Font ButtonFont = new Font(\"Arial\", 15.75F, FontStyle.Regular);\n\n        Button StartButton = new Button();\n        StartButton.Location = new Point(FormEdge, (GridSize * (ButtonMargin + ButtonSize)) + FormEdge);\n        StartButton.Size = new Size(86, 23);\n        StartButton.Font = new Font(\"Arial\", 9.75F, FontStyle.Regular);\n        StartButton.Text = \"New Game\";\n        StartButton.UseVisualStyleBackColor = true;\n        StartButton.TabStop = false;\n\n        StartButton.Click += new EventHandler(NewGame);\n\n        int FormWidth = (GridSize * ButtonSize) + ((GridSize - 1) * ButtonMargin) + (FormEdge * 2);\n        int FormHeigth = FormWidth + StartButton.Height;\n\n        Form Form = new Form();\n        Form.Text = \"Fifteen\";\n        Form.ClientSize = new Size(FormWidth, FormHeigth);\n        Form.FormBorderStyle = FormBorderStyle.FixedSingle;\n        Form.MaximizeBox = false;\n        Form.SuspendLayout();\n\n        for (int i = 0; i < BlockCount; i++)\n        {\n            Button Bt = new Button();\n            Puzzle Pz = new Puzzle(i);\n\n            int PosX = FormEdge + (Pz.X) * (ButtonSize + ButtonMargin);\n            int PosY = FormEdge + (Pz.Y) * (ButtonSize + ButtonMargin);\n            Bt.Location = new Point(PosX, PosY);\n\n            Bt.Size = new Size(ButtonSize, ButtonSize);\n            Bt.Font = ButtonFont;\n\n            Bt.Text = Pz.ToString();\n            Bt.Tag = Pz;\n            Bt.UseVisualStyleBackColor = true;\n            Bt.TabStop = false;\n\n            Bt.Enabled = false;\n            if (Pz.IsEmptyPuzzle) Bt.Visible = false;\n\n            Bt.Click += new EventHandler(MovePuzzle);\n\n            Puzzles.Add(Bt);\n            Form.Controls.Add(Bt);\n        }\n\n        Form.Controls.Add(StartButton);\n        Form.ResumeLayout();\n\n        return Form;\n    }\n\n    private void NewGame(object Sender, EventArgs E)\n    {\n        do\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Button Bt1 = Puzzles[R.Next(i, Puzzles.Count)];\n                Button Bt2 = Puzzles[i];\n                Swap(Bt1, Bt2);\n            }\n        }\n        while (!IsSolvable());\n\n        for (int i = 0; i < Puzzles.Count; i++)\n        {\n            Puzzles[i].Enabled = true;\n        }\n\n        Moves = 0;\n        Start = DateTime.Now;\n    }\n\n    private void MovePuzzle(object Sender, EventArgs E)\n    {\n        Button Bt1 = (Button)Sender;\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n\n        Button Bt2 = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        if (Pz1.NearestWith(Pz2))\n        {\n            Swap(Bt1, Bt2);\n            Moves++;\n        }\n\n        CheckWin();\n    }\n\n    private void CheckWin()\n    {\n        Button WrongPuzzle = Puzzles.Find(Bt => !((Puzzle)Bt.Tag).IsTruePlace);\n        bool UWin = (WrongPuzzle == null);\n\n        if (UWin)\n        {\n            for (int i = 0; i < Puzzles.Count; i++)\n            {\n                Puzzles[i].Enabled = false;\n            }\n\n            TimeSpan Elapsed = DateTime.Now - Start;\n            Elapsed = TimeSpan.FromSeconds(Math.Round(Elapsed.TotalSeconds, 0));\n            MessageBox.Show(String.Format(\"Solved in {0} moves. Time: {1}\", Moves, Elapsed));\n        }\n    }\n\n    private void Swap(Button Bt1, Button Bt2)\n    {\n        if (Bt1 == Bt2) return;\n\n        Puzzle Pz1 = (Puzzle)Bt1.Tag;\n        Puzzle Pz2 = (Puzzle)Bt2.Tag;\n\n        int g = Pz1.CurrentNumber;\n        Pz1.CurrentNumber = Pz2.CurrentNumber;\n        Pz2.CurrentNumber = g;\n\n        Bt1.Visible = true;\n        Bt1.Text = Pz1.ToString();\n        if (Pz1.IsEmptyPuzzle) Bt1.Visible = false;\n\n        Bt2.Visible = true;\n        Bt2.Text = Pz2.ToString();\n        if (Pz2.IsEmptyPuzzle) Bt2.Visible = false;\n    }\n\n    private bool IsSolvable()\n    {\n        \n        \n\n        int InvCount = 0;\n        for (int i = 0; i < Puzzles.Count - 1; i++)\n        {\n            for (int j = i + 1; j < Puzzles.Count; j++)\n            {\n                Puzzle Pz1 = (Puzzle)Puzzles[i].Tag;\n                if (Pz1.IsEmptyPuzzle) continue;\n\n                Puzzle Pz2 = (Puzzle)Puzzles[j].Tag;\n                if (Pz2.IsEmptyPuzzle) continue;\n\n                if (Pz1.CurrentNumber > Pz2.CurrentNumber) InvCount++;\n            }\n        }\n\n        Button EmptyBt = Puzzles.Find(Bt => ((Puzzle)Bt.Tag).IsEmptyPuzzle);\n        Puzzle EmptyPz = (Puzzle)EmptyBt.Tag;\n\n        bool Result = false;\n        if ((EmptyPz.InvY + 1) % 2 == 0) \n        {\n            \n            if (InvCount % 2 != 0) Result = true;\n        }\n        else \n        {\n            \n            if (InvCount % 2 == 0) Result = true;\n        }\n        return Result;\n    }\n}\n"}
{"id": 66864, "name": "15 puzzle game", "source": "Translate Fortran to Java: LOCZ = MINLOC(BOARD)\t\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 66865, "name": "15 puzzle game", "source": "Translate Fortran to Java: LOCZ = MINLOC(BOARD)\t\n", "target": "package fifteenpuzzle;\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\nclass FifteenPuzzle extends JPanel {\n\n    private final int side = 4;\n    private final int numTiles = side * side - 1;\n\n    private final Random rand = new Random();\n    private final int[] tiles = new int[numTiles + 1];\n    private final int tileSize;\n    private int blankPos;\n    private final int margin;\n    private final int gridSize;\n    private boolean gameOver;\n\n    private FifteenPuzzle() {\n        final int dim = 640;\n\n        margin = 80;\n        tileSize = (dim - 2 * margin) / side;\n        gridSize = tileSize * side;\n\n        setPreferredSize(new Dimension(dim, dim + margin));\n        setBackground(Color.WHITE);\n        setForeground(new Color(0x6495ED)); \n        setFont(new Font(\"SansSerif\", Font.BOLD, 60));\n\n        gameOver = true;\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (gameOver) {\n                    newGame();\n\n                } else {\n\n                    int ex = e.getX() - margin;\n                    int ey = e.getY() - margin;\n\n                    if (ex < 0 || ex > gridSize || ey < 0 || ey > gridSize) {\n                        return;\n                    }\n\n                    int c1 = ex / tileSize;\n                    int r1 = ey / tileSize;\n                    int c2 = blankPos % side;\n                    int r2 = blankPos / side;\n\n                    int clickPos = r1 * side + c1;\n\n                    int dir = 0;\n                    if (c1 == c2 && Math.abs(r1 - r2) > 0) {\n                        dir = (r1 - r2) > 0 ? 4 : -4;\n                        \n                    } else if (r1 == r2 && Math.abs(c1 - c2) > 0) {\n                        dir = (c1 - c2) > 0 ? 1 : -1;\n                    }\n\n                    if (dir != 0) {\n                        do {\n                            int newBlankPos = blankPos + dir;\n                            tiles[blankPos] = tiles[newBlankPos];\n                            blankPos = newBlankPos;\n                        } while (blankPos != clickPos);\n                        tiles[blankPos] = 0;\n                    }\n                    \n                    gameOver = isSolved();\n                }\n                repaint();\n            }\n        });\n\n        newGame();\n    }\n\n    private void newGame() {\n        do {\n            reset();\n            shuffle();\n        } while (!isSolvable());\n        gameOver = false;\n    }\n\n    private void reset() {\n        for (int i = 0; i < tiles.length; i++) {\n            tiles[i] = (i + 1) % tiles.length;\n        }\n        blankPos = tiles.length - 1;\n    }\n\n    private void shuffle() {\n        \n        \n        int n = numTiles;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n            int tmp = tiles[r];\n            tiles[r] = tiles[n];\n            tiles[n] = tmp;\n        }\n    }\n\n    \n    private boolean isSolvable() {\n        int countInversions = 0;\n        for (int i = 0; i < numTiles; i++) {\n            for (int j = 0; j < i; j++) {\n                if (tiles[j] > tiles[i]) {\n                    countInversions++;\n                }\n            }\n        }\n        return countInversions % 2 == 0;\n    }\n\n    private boolean isSolved() {\n        if (tiles[tiles.length - 1] != 0) {\n            return false;\n        }\n        for (int i = numTiles - 1; i >= 0; i--) {\n            if (tiles[i] != i + 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void drawGrid(Graphics2D g) {\n        for (int i = 0; i < tiles.length; i++) {\n            int r = i / side;\n            int c = i % side;\n            int x = margin + c * tileSize;\n            int y = margin + r * tileSize;\n\n            if (tiles[i] == 0) {\n                if (gameOver) {\n                    g.setColor(Color.GREEN);\n                    drawCenteredString(g, \"\\u2713\", x, y);\n                }\n                continue;\n            }\n\n            g.setColor(getForeground());\n            g.fillRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.blue.darker());\n            g.drawRoundRect(x, y, tileSize, tileSize, 25, 25);\n            g.setColor(Color.WHITE);\n\n            drawCenteredString(g, String.valueOf(tiles[i]), x, y);\n        }\n    }\n\n    private void drawStartMessage(Graphics2D g) {\n        if (gameOver) {\n            g.setFont(getFont().deriveFont(Font.BOLD, 18));\n            g.setColor(getForeground());\n            String s = \"click to start a new game\";\n            int x = (getWidth() - g.getFontMetrics().stringWidth(s)) / 2;\n            int y = getHeight() - margin;\n            g.drawString(s, x, y);\n        }\n    }\n\n    private void drawCenteredString(Graphics2D g, String s, int x, int y) {\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int des = fm.getDescent();\n\n        x = x + (tileSize - fm.stringWidth(s)) / 2;\n        y = y + (asc + (tileSize - (asc + des)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawStartMessage(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fifteen Puzzle\");\n            f.setResizable(false);\n            f.add(new FifteenPuzzle(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 66866, "name": "15 puzzle game", "source": "Translate Fortran to Python: LOCZ = MINLOC(BOARD)\t\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 66867, "name": "15 puzzle game", "source": "Translate Fortran to Python: LOCZ = MINLOC(BOARD)\t\n", "target": "type Puzzle(var items: {}, var position: -1)\n\nfun mainframe(puz):\n    let d = puz.items\n    print('+-----+-----+-----+-----+')\n    print(d[1], d[2], d[3], d[4], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[5], d[6], d[7], d[8], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[9], d[10], d[11], d[12], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n    print(d[13], d[14], d[15], d[16], first: '|', sep: '|', last: '|')\n    print('+-----+-----+-----+-----+')\n\nfun format(puz, ch):\n    match ch.trim().length:\n        1 => '  $ch  '\n        2 => '  $ch '\n        0 => '     '\n\nfun change(puz, to):\n    let fro = puz.position\n    for a, b in puz.items where b == puz.format(str i):\n        to = a\n        break\n\n    swap(puz.items[fro], :[to])\n    puz.position = to;\n\nfun buildboard(puz, difficulty):\n    for i in 1..16:\n        puz.items[i] = puz.format(str i)\n\n    var tmp = a\n    for a, b in puz.items where b == '  16 ':\n        puz.items[a] = '     '\n            tmp = a\n            break\n\n    puz.position = tmp\n    let diff = match difficulty:\n        0 => 10\n        1 => 50\n        _ => 100\n\n    for i in 1..diff:\n        let lst = puz.validmoves()\n        let lst1 = []\n        for j in lst:\n            lst1.push! j.trim().int()\n        puz.change(lst1[random(1, lst1.length - 1)])\n\nfun validmoves(puz):\n    match puz.position:\n        6 | 7 | 10 | 11 =>\n            puz.items[pos - 4], :[pos - 1], :[pos + 1], :[pos + 4]\n        5 | 9 =>\n            puz.items[pos - 4], :[pos + 4], :[pos + 1]\n        8 | 12 =>\n            puz.items[pos - 4], :[pos + 4], :[pos - 1]\n        2 | 3 =>\n            puz.items[pos - 1], :[pos + 1], :[pos + 4]\n        14 | 15 =>\n            puz.items[pos - 1], :[pos + 1], :[pos - 4]\n        1 =>\n            puz.items[pos + 1], :[pos + 4]\n        4 =>\n            puz.items[pos - 1], :[pos + 4]\n        13 =>\n            puz.items[pos + 1], :[pos - 4]\n        16 =>\n            puz.items[pos - 1], :[pos - 4]\n\nfun mainframe(puz):\n    var flag = false\n    for a, b in puz.items:\n        if b == '     ':\n            pass\n        else:\n            flag = (a == b.trim().int())\n    ..\n    return flag\n\nlet game = Puzzle()\ngame.buildboard(\n    int(input('Enter the difficulty\u00a0: 0 1 2\\n2 => highest 0=> lowest\\n'))\n)\ngame.mainframe()\n\nprint 'Enter 0 to exit'\n\nloop:\n    print 'Hello user:\\nTo change the position just enter the no. near it'\n\n    var lst = game.validmoves()\n    var lst1 = []\n    for i in lst:\n        lst1.push! i.trim().int()\n        print(i.strip(), '\\t', last: '')\n\n    print()\n\n    let value = int(input())\n    if value == 0:\n        break\n    elif x not in lst1:\n        print('Wrong move')\n    else:\n        game.change(x)\n\n    game.mainframe()\n    if g.gameover():\n        print 'You WON'\n        break\n"}
{"id": 67202, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to C#: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": "using System;\nusing System.Linq;\n\nnamespace CountingSort\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Random rand = new Random();                                   \n            int[] arr = new int[100];                                     \n            for (int i = 0; i < 100; i++) { arr[i] = rand.Next(0, 100); } \n\n            int[] newarr = countingSort(arr, arr.Min(), arr.Max());\n        }\n\n        private static int[] countingSort(int[] arr, int min, int max)\n        {\n            int[] count = new int[max - min + 1];\n            int z = 0;\n\n            for (int i = 0; i < count.Length; i++) { count[i] = 0; }\n            for (int i = 0; i < arr.Length; i++) { count[arr[i] - min]++; }           \n\n            for (int i = min; i <= max; i++)\n            {\n                while (count[i - min]-- > 0)\n                {\n                    arr[z] = i;\n                    z++;                    \n                }\n            }\n            return arr;\n        }\n    }\n}\n"}
{"id": 67206, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to Java: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": "public static void countingSort(int[] array, int min, int max){\n\tint[] count= new int[max - min + 1];\n\tfor(int number : array){\n\t\tcount[number - min]++;\n\t}\n\tint z= 0;\n\tfor(int i= min;i <= max;i++){\n\t\twhile(count[i - min] > 0){\n\t\t\tarray[z]= i;\n\t\t\tz++;\n\t\t\tcount[i - min]--;\n\t\t}\n\t}\n}\n"}
{"id": 67207, "name": "Sorting algorithms_Counting sort", "source": "Translate Fortran to Python: module CountingSort\n  implicit none\n\n  interface counting_sort\n     module procedure counting_sort_mm, counting_sort_a\n  end interface\n\ncontains\n\n  subroutine counting_sort_a(array)\n    integer, dimension(:), intent(inout) :: array\n\n    call counting_sort_mm(array, minval(array), maxval(array))\n\n  end subroutine counting_sort_a\n\n  subroutine counting_sort_mm(array, tmin, tmax)\n    integer, dimension(:), intent(inout) :: array\n    integer, intent(in) :: tmin, tmax\n\n    integer, dimension(tmin:tmax) :: cnt\n    integer :: i, z\n\n    cnt = 0                   \n    FORALL (I=1:size(array))  \n        cnt(array(i)) = cnt(array(i))+1\n    END FORALL\n\n\n\n\n    z = 1\n    do i = tmin, tmax\n       do while ( cnt(i) > 0 )\n          array(z) = i\n          z = z + 1\n          cnt(i) = cnt(i) - 1\n       end do\n    end do\n\n  end subroutine counting_sort_mm\n\nend module CountingSort\n", "target": ">>> from collections import defaultdict\n>>> def countingSort(array, mn, mx):\n\tcount = defaultdict(int)\n\tfor i in array:\n\t\tcount[i] += 1\n\tresult = []\n\tfor j in range(mn,mx+1):\n\t\tresult += [j]* count[j]\n\treturn result\n\n>>> data = [9, 7, 10, 2, 9, 7, 4, 3, 10, 2, 7, 10, 2, 1, 3, 8, 7, 3, 9, 5, 8, 5, 1, 6, 3, 7, 5, 4, 6, 9, 9, 6, 6, 10, 2, 4, 5, 2, 8, 2, 2, 5, 2, 9, 3, 3, 5, 7, 8, 4]\n>>> mini,maxi = 1,10\n>>> countingSort(data, mini, maxi) == sorted(data)\nTrue\n"}
{"id": 67562, "name": "Array length", "source": "Translate Fortran to C#:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67563, "name": "Array length", "source": "Translate Fortran to C#:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "using System;\n\nnamespace ArrayLength\n{\n  class Program\n  {\n    public static void Main()\n    {\n      var array = new String[](\"apple\", \"orange\");\n      Console.WriteLine(array.Count);\n      delete(array);\n    }\n  }\n}\n"}
{"id": 67569, "name": "Array length", "source": "Translate Fortran to Java:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67570, "name": "Array length", "source": "Translate Fortran to Java:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "String[] array  = [\"apple\", \"orange\"];\nInt      length = array.size;\n"}
{"id": 67571, "name": "Array length", "source": "Translate Fortran to Python:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67572, "name": "Array length", "source": "Translate Fortran to Python:       MODULE EXAMPLE\n       CONTAINS\n        SUBROUTINE ABOUND(A)\n         CHARACTER*(*) A(:)\t\n          WRITE (6,*) \"Lower bound\",LBOUND(A),\", Upper bound\",UBOUND(A)\n          WRITE (6,*) \"Element size\",LEN(A(LBOUND(A)))\n          WRITE (6,*) A\n        END SUBROUTINE ABOUND\n      END MODULE EXAMPLE\n\n      PROGRAM SHOWBOUNDS\n       USE EXAMPLE\n       CHARACTER*6 ARRAY(-1:1)\n        ARRAY(-1) = \"Apple\"\n        ARRAY(0) = \"Orange\"\n        ARRAY(1) = \"\"\n        CALL ABOUND(ARRAY)\n        WRITE (6,*) \"But, when it is at home...\"\n        WRITE (6,*) \"L. bound\",LBOUND(ARRAY),\", U. bound\",UBOUND(ARRAY)\n      END\n", "target": "arr = ['apple', 'orange']  \n\ndef setup():\n    println(len(arr))\n"}
{"id": 67981, "name": "Bulls and cows", "source": "Translate Fortran to C#: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "using System;\n\nnamespace BullsnCows\n{\n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            int[] nums = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n            KnuthShuffle<int>(ref nums);\n            int[] chosenNum = new int[4];\n            Array.Copy(nums, chosenNum, 4);\n\n            Console.WriteLine(\"Your Guess\u00a0?\");\n            while (!game(Console.ReadLine(), chosenNum))\n            {\n                Console.WriteLine(\"Your next Guess\u00a0?\");\n            }\n            \n            Console.ReadKey();\n        }\n\n        public static void KnuthShuffle<T>(ref T[] array)\n        {\n            System.Random random = new System.Random();\n            for (int i = 0; i < array.Length; i++)\n            {\n                int j = random.Next(array.Length);\n                T temp = array[i]; array[i] = array[j]; array[j] = temp;\n            }\n        }\n\n        public static bool game(string guess, int[] num)\n        {\n            char[] guessed = guess.ToCharArray();\n            int bullsCount = 0, cowsCount = 0;\n\n            if (guessed.Length != 4)\n            {\n                Console.WriteLine(\"Not a valid guess.\");\n                return false;\n            }\n\n            for (int i = 0; i < 4; i++)\n            {\n                int curguess = (int) char.GetNumericValue(guessed[i]);\n                if (curguess < 1 || curguess > 9)\n                {\n                    Console.WriteLine(\"Digit must be ge greater 0 and lower 10.\");\n                    return false;\n                }\n                if (curguess == num[i])\n                {\n                    bullsCount++;\n                }\n                else\n                {\n                    for (int j = 0; j < 4; j++)\n                    {\n                        if (curguess == num[j])\n                            cowsCount++;\n                    }\n                }\n            }\n\n            if (bullsCount == 4)\n            {\n                Console.WriteLine(\"Congratulations! You have won!\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(\"Your Score is {0} bulls and {1} cows\", bullsCount, cowsCount);\n                return false;\n            }\n        }\n    }\n}\n"}
{"id": 67985, "name": "Bulls and cows", "source": "Translate Fortran to Java: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "import java.util.InputMismatchException;\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class BullsAndCows{\n\tpublic static void main(String[] args){\n\t\tRandom gen= new Random();\n\t\tint target;\n\t\twhile(hasDupes(target= (gen.nextInt(9000) + 1000)));\n\t\tString targetStr = target +\"\";\n\t\tboolean guessed = false;\n\t\tScanner input = new Scanner(System.in);\n\t\tint guesses = 0;\n\t\tdo{\n\t\t\tint bulls = 0;\n\t\t\tint cows = 0;\n\t\t\tSystem.out.print(\"Guess a 4-digit number with no duplicate digits: \");\n\t\t\tint guess;\n\t\t\ttry{\n\t\t\t\tguess = input.nextInt();\n\t\t\t\tif(hasDupes(guess) || guess < 1000) continue;\n\t\t\t}catch(InputMismatchException e){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tguesses++;\n\t\t\tString guessStr = guess + \"\";\n\t\t\tfor(int i= 0;i < 4;i++){\n\t\t\t\tif(guessStr.charAt(i) == targetStr.charAt(i)){\n\t\t\t\t\tbulls++;\n\t\t\t\t}else if(targetStr.contains(guessStr.charAt(i)+\"\")){\n\t\t\t\t\tcows++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bulls == 4){\n\t\t\t\tguessed = true;\n\t\t\t}else{\n\t\t\t\tSystem.out.println(cows+\" Cows and \"+bulls+\" Bulls.\");\n\t\t\t}\n\t\t}while(!guessed);\n\t\tSystem.out.println(\"You won after \"+guesses+\" guesses!\");\n\t}\n\n\tpublic static boolean hasDupes(int num){\n\t\tboolean[] digs = new boolean[10];\n\t\twhile(num > 0){\n\t\t\tif(digs[num%10]) return true;\n\t\t\tdigs[num%10] = true;\n\t\t\tnum/= 10;\n\t\t}\n\t\treturn false;\n\t}\n}\n"}
{"id": 67986, "name": "Bulls and cows", "source": "Translate Fortran to Python: module bac\n  implicit none\n\ncontains\n\n  subroutine Gennum(n)\n    integer, intent(out) :: n(4)\n    integer :: i, j\n    real :: r\n      \n    call random_number(r)\n    n(1) = int(r * 9.0) + 1\n    i = 2\n    \nouter: do while (i <= 4)\n         call random_number(r)\n         n(i) = int(r * 9.0) + 1\ninner:   do j = i-1 , 1, -1\n           if (n(j) == n(i)) cycle outer\n         end do inner\n         i = i + 1\n       end do outer\n \n  end subroutine Gennum\n\n  subroutine Score(n, guess, b, c) \n    character(*), intent(in) :: guess\n    integer, intent(in) :: n(0:3)\n    integer, intent(out) :: b, c\n    integer :: digit, i, j, ind\n   \n    b = 0; c = 0\n    do i = 1, 4\n      read(guess(i:i), \"(i1)\") digit\n      if (digit == n(i-1)) then\n        b = b + 1\n      else\n        do j = i, i+2\n          ind = mod(j, 4)\n          if (digit == n(ind)) then\n            c = c + 1\n            exit\n          end if\n        end do    \n      end if\n    end do  \n\n end subroutine Score  \n\nend module bac\n\nprogram Bulls_and_Cows\n   use bac\n   implicit none\n   \n   integer :: n(4)\n   integer :: bulls=0, cows=0, tries=0\n   character(4) :: guess\n\n   call random_seed\n   call Gennum(n)\n   \n   write(*,*) \"I have selected a number made up of 4 digits (1-9) without repetitions.\"\n   write(*,*) \"You attempt to guess this number.\"\n   write(*,*) \"Every digit in your guess that is in the correct position scores 1 Bull\"\n   write(*,*) \"Every digit in your guess that is in an incorrect position scores 1 Cow\"\n   write(*,*)\n\n   do while (bulls /= 4)\n     write(*,*) \"Enter a 4 digit number\"\n     read*, guess\n     if (verify(guess, \"123456789\") /= 0) then\n       write(*,*) \"That is an invalid entry. Please try again.\"\n       cycle\n     end if\n     tries = tries + 1\n     call Score (n, guess, bulls, cows)\n     write(*, \"(a, i1, a, i1, a)\") \"You scored \", bulls, \" bulls and \", cows, \" cows\"\n     write(*,*)\n   end do\n\n   write(*,\"(a,i0,a)\") \"Congratulations\n\nend program Bulls_and_Cows\n", "target": "\n\nimport random\n\ndigits = '123456789'\nsize = 4\nchosen = ''.join(random.sample(digits,size))\n\nprint  % (size, size)\nguesses = 0\nwhile True:\n    guesses += 1\n    while True:\n        \n        guess = raw_input('\\nNext guess [%i]: ' % guesses).strip()\n        if len(guess) == size and \\\n           all(char in digits for char in guess) \\\n           and len(set(guess)) == size:\n            break\n        print \"Problem, try again. You need to enter %i unique digits from 1 to 9\" % size\n    if guess == chosen:\n        print '\\nCongratulations you guessed correctly in',guesses,'attempts'\n        break\n    bulls = cows = 0\n    for i in range(size):\n        if guess[i] == chosen[i]:\n            bulls += 1\n        elif guess[i] in chosen:\n            cows += 1\n    print '  %i Bulls\\n  %i Cows' % (bulls, cows)\n"}
{"id": 68460, "name": "Accumulator factory", "source": "Translate Fortran to C#: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68461, "name": "Accumulator factory", "source": "Translate Fortran to C#: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "using System;\n\nclass Program\n{\n    static Func<dynamic, dynamic> Foo(dynamic n)\n    {\n        return i => n += i;\n    }\n\n    static void Main(string[] args)\n    {\n        var x = Foo(1);\n        x(5);\n        Foo(3);\n        Console.WriteLine(x(2.3));\n    }\n}\n"}
{"id": 68466, "name": "Accumulator factory", "source": "Translate Fortran to Java: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68467, "name": "Accumulator factory", "source": "Translate Fortran to Java: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "public class Accumulator\n    \n{\n    private Number sum;\n\n    public Accumulator(Number sum0) {\n\tsum = sum0;\n    }\n\n    public Number apply(Number n) {\n\t\n\t\n\treturn (longable(sum) && longable(n)) ?\n\t    (sum = sum.longValue() + n.longValue()) :\n\t    (sum = sum.doubleValue() + n.doubleValue());\n    }\n\n    private static boolean longable(Number n) {\n\treturn n instanceof Byte || n instanceof Short ||\n\t    n instanceof Integer || n instanceof Long;\n    }\n\n    public static void main(String[] args) {\n\tAccumulator x = new Accumulator(1);\n\tx.apply(5);\n\tnew Accumulator(3);\n\tSystem.out.println(x.apply(2.3));\n    }\n}\n"}
{"id": 68468, "name": "Accumulator factory", "source": "Translate Fortran to Python: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 68469, "name": "Accumulator factory", "source": "Translate Fortran to Python: #define foo(type,g,nn) \\\ntypex function g(i);\\\ntypex i,s,n;\\\ndata s,n/0,nn/;\\\ns=s+i;\\\ng=s+n;\\\nend\n\n      foo(real,x,1)\n      foo(integer,y,3)\n\n      program acc\n      real x, temp\n      integer y, itemp\n      temp = x(5.0)\n      print *, x(2.3)\n      itemp = y(5)\n      print *, y(2)\n      stop\n      end\n", "target": "fun accumulator(var sum): :: Real -> _\n    n => sum += n\n\nlet f = accumulator!(5)\nprint f(5)   \nprint f(10)  \nprint f(2.4) \n"}
{"id": 69142, "name": "Averages_Root mean square", "source": "Translate Fortran to C#: print *,sqrt( sum(x**2)/size(x) )\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69143, "name": "Averages_Root mean square", "source": "Translate Fortran to C#: print *,sqrt( sum(x**2)/size(x) )\n", "target": "using System;\n\nnamespace rms\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] x = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n            Console.WriteLine(rootMeanSquare(x));\n        }\n\n        private static double rootMeanSquare(int[] x)\n        {            \n            double sum = 0;\n            for (int i = 0; i < x.Length; i++)\n            {\n                sum += (x[i]*x[i]);\n            }\n            return Math.Sqrt(sum / x.Length);\n        }\n    }\n}\n"}
{"id": 69149, "name": "Averages_Root mean square", "source": "Translate Fortran to Java: print *,sqrt( sum(x**2)/size(x) )\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69150, "name": "Averages_Root mean square", "source": "Translate Fortran to Java: print *,sqrt( sum(x**2)/size(x) )\n", "target": "public class RootMeanSquare {\n\n    public static double rootMeanSquare(double... nums) {\n        double sum = 0.0;\n        for (double num : nums)\n            sum += num * num;\n        return Math.sqrt(sum / nums.length);\n    }\n\n    public static void main(String[] args) {\n        double[] nums = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        System.out.println(\"The RMS of the numbers from 1 to 10 is \" + rootMeanSquare(nums));\n    }\n}\n"}
{"id": 69649, "name": "Pi", "source": "Translate Fortran to C#: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "using System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n"}
{"id": 69652, "name": "Pi", "source": "Translate Fortran to Java: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "import java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n"}
{"id": 69653, "name": "Pi", "source": "Translate Fortran to Python: program pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n", "target": "def calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\n"}
{"id": 69980, "name": "Terminal control_Coloured text", "source": "Translate Fortran to C#: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 69981, "name": "Terminal control_Coloured text", "source": "Translate Fortran to C#: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "static void Main(string[] args)\n{\n    Console.ForegroundColor = ConsoleColor.Red;\n    Console.BackgroundColor = ConsoleColor.Yellow;\n    Console.WriteLine(\"Red on Yellow\");\n    Console.ForegroundColor = ConsoleColor.White;\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.WriteLine(\"White on black\");\n    Console.ResetColor();\n    Console.WriteLine(\"Back to normal\");\n    Console.ReadKey();\n}\n"}
{"id": 69984, "name": "Terminal control_Coloured text", "source": "Translate Fortran to Python: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 69985, "name": "Terminal control_Coloured text", "source": "Translate Fortran to Python: \n\nprogram coloured_terminal_text\n  use, intrinsic :: iso_fortran_env, only: ERROR_UNIT\n  implicit none\n\n  \n  character(*), parameter :: esc = achar(27) \n  character(*), parameter :: reset = esc // '[0m' \n  \n  character(*), parameter :: red     = esc // '[31m'\n  character(*), parameter :: green   = esc // '[32m'\n  character(*), parameter :: yellow  = esc // '[33m'\n  character(*), parameter :: blue    = esc // '[34m'\n  character(*), parameter :: magenta = esc // '[35m'\n  character(*), parameter :: cyan    = esc // '[36m'\n  character(*), parameter :: grey    = esc // '[90m' \n  \n  character(*), parameter :: background_green = esc // '[42m'\n  \n  character(*), parameter :: bold = esc // '[1m'\n  character(*), parameter :: bold_blink = esc // '[1;5m'\n\n  \n  write(ERROR_UNIT, '(a)') bold // 'Coloured words:' // reset\n  write(ERROR_UNIT, '(4x, a)')       & \n      red     // 'Red'     // reset, &\n      green   // 'Green'   // reset, &\n      yellow  // 'Yellow'  // reset, &\n      blue    // 'Blue'    // reset, &\n      magenta // 'Magenta' // reset, &\n      cyan    // 'Cyan'    // reset, &\n      grey    // 'Grey'    // reset\n  write(ERROR_UNIT, '(a)') bold_blink // 'THE END\u00a0;-)' // reset\n\n  write(ERROR_UNIT, '(a)') background_green // 'Bonus Round' // reset\nend program coloured_terminal_text\n", "target": "from colorama import init, Fore, Back, Style\ninit(autoreset=True)\n\nprint Fore.RED + \"FATAL ERROR! Cannot write to /boot/vmlinuz-3.2.0-33-generic\"\nprint Back.BLUE + Fore.YELLOW + \"What a cute console!\"\nprint \"This is an %simportant%s word\" % (Style.BRIGHT, Style.NORMAL)\nprint Fore.YELLOW  + \"Rosetta Code!\"\nprint Fore.CYAN    + \"Rosetta Code!\"\nprint Fore.GREEN   + \"Rosetta Code!\"\nprint Fore.MAGENTA + \"Rosetta Code!\"\nprint Back.YELLOW + Fore.BLUE + Style.BRIGHT + \" \" * 40 + \" == Good Bye!\"\n"}
{"id": 70214, "name": "Loops_Foreach", "source": "Translate Fortran to C#: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "string[] things = {\"Apple\", \"Banana\", \"Coconut\"};\n\nforeach (string thing in things)\n{\n    Console.WriteLine(thing);\n}\n"}
{"id": 70217, "name": "Loops_Foreach", "source": "Translate Fortran to Java: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "module LoopForEach\n    {\n    @Inject Console console;\n    void run()\n        {\n        val vals = [10, 20, 30, 40];\n        console.print(\"Array of values:\");\n        Loop: for (val val : vals)\n            {\n            console.print($\"  value #{Loop.count + 1}: {val}\");\n            }\n\n        Map<String, Int> pairs = [\"x\"=42, \"y\"=69];\n        console.print(\"\\nKeys and values:\");\n        for ((String key, Int val) : pairs)\n            {\n            console.print($\"  {key}={val}\");\n            }\n        console.print(\"\\nJust the keys:\");\n        Loop: for (String key : pairs)\n            {\n            console.print($\"  key #{Loop.count + 1}: {key}\");\n            }\n\n        console.print(\"\\nValues from a range:\");\n        for (Int n : 1..5)\n            {\n            console.print($\"  {n}\");\n            }\n        }\n    }\n"}
{"id": 70218, "name": "Loops_Foreach", "source": "Translate Fortran to Python: program main\n\n implicit none\n\n integer :: i\n character(len=5),dimension(5),parameter :: colors = ['Red  ','Green','Blue ','Black','White']\n\n \n do i=1,size(colors)\n   write(*,'(A)') colors(i) \n end do\n\n \n write(*,'(A)') colors\n\nend program main\n", "target": "for i in collection:\n   print i\n"}
{"id": 70435, "name": "Brownian tree", "source": "Translate Fortran to C#: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BrownianTree\n{\n    class Program\n    {\n        static Bitmap BrownianTree(int size, int numparticles)\n        {\n            Bitmap bmp = new Bitmap(size, size);\n            Rectangle bounds = new Rectangle { X = 0, Y = 0, Size = bmp.Size };\n            using (Graphics g = Graphics.FromImage(bmp))\n            {\n                g.Clear(Color.Black);\n            }\n            Random rnd = new Random();\n            bmp.SetPixel(rnd.Next(size), rnd.Next(size), Color.White);\n            Point pt = new Point(), newpt = new Point();\n            for (int i = 0; i < numparticles; i++)\n            {\n                pt.X = rnd.Next(size);\n                pt.Y = rnd.Next(size);\n                do\n                {\n                    newpt.X = pt.X + rnd.Next(-1, 2);\n                    newpt.Y = pt.Y + rnd.Next(-1, 2);\n                    if (!bounds.Contains(newpt))\n                    {\n                        pt.X = rnd.Next(size);\n                        pt.Y = rnd.Next(size);\n                    }\n                    else if (bmp.GetPixel(newpt.X, newpt.Y).R > 0)\n                    {\n                        bmp.SetPixel(pt.X, pt.Y, Color.White);\n                        break;\n                    }\n                    else\n                    {\n                        pt = newpt;\n                    }\n                } while (true);\n            }\n            return bmp;\n        }\n\n        static void Main(string[] args)\n        {\n            BrownianTree(300, 3000).Save(\"browniantree.png\");\n        }\n    }\n}\n"}
{"id": 70438, "name": "Brownian tree", "source": "Translate Fortran to Java: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "import java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class BrownianTree extends JFrame implements Runnable {\n\n    BufferedImage I;\n    private List<Particle> particles;\n    static Random rand = new Random();\n\n    public BrownianTree() {\n        super(\"Brownian Tree\");\n        setBounds(100, 100, 400, 300);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        I.setRGB(I.getWidth() / 2, I.getHeight() / 2, 0xff00);\n        particles = new LinkedList<Particle>();\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public void run() {\n        for (int i = 0; i < 20000; i++) {\n            particles.add(new Particle());\n        }\n        while (!particles.isEmpty()) {\n            for (Iterator<Particle> it = particles.iterator(); it.hasNext();) {\n                if (it.next().move()) {\n                    it.remove();\n                }\n            }\n            repaint();\n        }\n    }\n\n    public static void main(String[] args) {\n        BrownianTree b = new BrownianTree();\n        b.setVisible(true);\n        new Thread(b).start();\n    }\n\n    private class Particle {\n\n        private int x, y;\n\n        private Particle() {\n            x = rand.nextInt(I.getWidth());\n            y = rand.nextInt(I.getHeight());\n        }\n\n        \n        private boolean move() {\n            int dx = rand.nextInt(3) - 1;\n            int dy = rand.nextInt(3) - 1;\n            if ((x + dx < 0) || (y + dy < 0)\n                    || (y + dy >= I.getHeight()) || (x + dx >= I.getWidth())) {\n                return true;\n            }\n            x += dx;\n            y += dy;\n            if ((I.getRGB(x, y) & 0xff00) == 0xff00) {\n                I.setRGB(x - dx, y - dy, 0xff00);\n                return true;\n            }\n            return false;\n        }\n    }\n}\n"}
{"id": 70439, "name": "Brownian tree", "source": "Translate Fortran to Python: program BrownianTree\n  use RCImageBasic\n  use RCImageIO\n\n  implicit none\n\n  integer, parameter :: num_particles = 1000\n  integer, parameter :: wsize         = 800\n\n  integer, dimension(wsize, wsize) :: world\n  type(rgbimage) :: gworld\n  integer :: x, y\n\n  \n  call init_random_seed\n  \n  world = 0\n  call draw_brownian_tree(world)\n\n  call alloc_img(gworld, wsize, wsize)\n  call fill_img(gworld, rgb(0,0,0))\n  \n  do y = 1, wsize\n     do x = 1, wsize\n        if ( world(x, y) /= 0 ) then\n           call put_pixel(gworld, x, y, rgb(255, 255, 255))\n        end if\n     end do\n  end do\n\n  open(unit=10, file='browniantree.ppm', action='write')\n  call output_ppm(10, gworld)\n  close(10)\n\n  call free_img(gworld)\n\ncontains\n\n  \n  subroutine init_random_seed\n    integer :: i, n, clock\n    integer, dimension(:), allocatable :: seed\n\n    call random_seed(size = n)\n    allocate(seed(n))\n    call system_clock(count = clock)\n    seed = clock + 37 * (/ ( i - 1, i = 1, n) /)\n    call random_seed(put = seed)\n    deallocate(seed)\n  end subroutine init_random_seed\n\n\n  function randbetween(a, b) result(res) \n    integer, intent(in) :: a, b\n    integer :: res\n\n    real :: r\n\n    call random_number(r)\n\n    res = a + int((b-a)*r + 0.5)\n\n  end function randbetween\n\n  function bounded(v, ll, ul) result(res)\n    integer, intent(in) :: v, ll, ul\n    logical res\n\n    res = ( v >= ll ) .and. ( v <= ul )\n  end function bounded\n\n\n  subroutine draw_brownian_tree(w)\n    integer, dimension(:,:), intent(inout) :: w\n\n    integer :: px, py, dx, dy, i\n    integer :: xsize, ysize\n\n    xsize = size(w, 1)\n    ysize = size(w, 2)\n\n    w(randbetween(1, xsize), randbetween(1, ysize)) = 1\n    \n    do i = 1, num_particles\n       px = randbetween(1, xsize)\n       py = randbetween(1, ysize)\n       \n       do\n          dx = randbetween(-1, 1)\n          dy = randbetween(-1, 1)\n          if ( .not. bounded(dx+px, 1, xsize) .or. .not. bounded(dy+py, 1, ysize) ) then\n             px = randbetween(1, xsize)\n             py = randbetween(1, ysize)\n          else if ( w(px+dx, py+dy) /= 0 ) then\n             w(px, py) = 1\n             exit\n          else\n             py = py + dy\n             px = px + dx\n          end if\n       end do\n    end do\n    \n  end subroutine draw_brownian_tree\n\nend program\n", "target": "SIDESTICK = False\n\ndef setup() :\n    global is_taken\n    size(512, 512)\n    background(0)\n    is_taken = [[False] * height for _ in range(width)]\n    is_taken[width/2][height/2] = True\n\n\ndef draw() :\n    x = floor(random(width))\n    y = floor(random(height))\n    if is_taken[x][y]: \n        return\n    while True:\n        xp = x + floor(random(-1, 2))\n        yp = y + floor(random(-1, 2))\n        is_contained = 0 <= xp < width and 0 <= yp < height\n        if is_contained and not is_taken[xp][yp]:\n            x = xp\n            y = yp\n            continue\n        else:\n            if SIDESTICK or (is_contained and is_taken[xp][yp]):\n                is_taken[x][y] = True\n                set(x, y, color(255))            \n            break\n        \n    if frameCount > width * height:\n        noLoop()\n"}
{"id": 70618, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to C#: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading; \n\nnamespace ConsoleApplication1\n{\n    class RealisticGuess \n    {\n        private int max;\n        private int min;\n        private int guess;\n\n        public void Start()\n        {\n            Console.Clear();\n            string input;\n\n            try\n            {\n                Console.WriteLine(\"Please enter the lower boundary\");\n                input = Console.ReadLine();\n                min = Convert.ToInt32(input);\n                Console.WriteLine(\"Please enter the upper boundary\");\n                input = Console.ReadLine();\n                max = Convert.ToInt32(input);\n            }\n            catch (FormatException)\n            {\n                Console.WriteLine(\"The entry you have made is invalid. Please make sure your entry is an integer and try again.\");\n                Console.ReadKey(true);\n                Start();\n            }\n            Console.WriteLine(\"Think of a number between {0} and {1}.\", min, max);\n            Thread.Sleep(2500);\n            Console.WriteLine(\"Ready?\");\n            Console.WriteLine(\"Press any key to begin.\");\n            Console.ReadKey(true);\n            Guess(min, max);\n        }\n        public void Guess(int min, int max)\n        {\n            int counter = 1;\n            string userAnswer;\n            bool correct = false;\n            Random rand = new Random();\n\n            while (correct == false)\n            {\n                guess = rand.Next(min, max);\n                Console.Clear();\n                Console.WriteLine(\"{0}\", guess);\n                Console.WriteLine(\"Is this number correct? {Y/N}\");\n                userAnswer = Console.ReadLine();\n                if (userAnswer != \"y\" && userAnswer != \"Y\" && userAnswer != \"n\" && userAnswer != \"N\")\n                {\n                    Console.WriteLine(\"Your entry is invalid. Please enter either 'Y' or 'N'\");\n                    Console.WriteLine(\"Is the number correct? {Y/N}\");\n                    userAnswer = Console.ReadLine();\n                }\n                if (userAnswer == \"y\" || userAnswer == \"Y\")\n                {\n                    correct = true;\n                }\n                if (userAnswer == \"n\" || userAnswer == \"N\")\n                {\n                    counter++;\n                    if (max == min)\n                    {\n                        Console.WriteLine(\"Error: Range Intersect. Press enter to restart the game.\");  \n                        Console.ReadKey(true);                                                          \n                        Guess(1, 101);                                                                  \n                    }\n                    Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                    userAnswer = Console.ReadLine();\n                    if (userAnswer != \"l\" && userAnswer != \"L\" && userAnswer != \"h\" && userAnswer != \"H\")\n                    {\n                        Console.WriteLine(\"Your entry is invalid. Please enter either 'L' or 'H'\");\n                        Console.WriteLine(\"Is the number you're thinking of lower or higher? {L/H}\");\n                        userAnswer = Console.ReadLine();\n                    }\n                    if (userAnswer == \"l\" || userAnswer == \"L\")\n                    {\n                        max = guess;\n                    }\n                    if (userAnswer == \"h\" || userAnswer == \"H\")\n                    {\n                        min = guess;\n                    }\n                }\n            }\n            if (correct == true)\n            {\n                EndAndLoop(counter);\n            }\n        }\n\n        public void EndAndLoop(int iterations)\n        {\n            string userChoice;\n            bool loop = false;\n            Console.WriteLine(\"Game over. It took {0} guesses to find the number.\", iterations);\n            while (loop == false)\n            {\n                Console.WriteLine(\"Would you like to play again? {Y/N}\");\n                userChoice = Console.ReadLine();\n                if (userChoice != \"Y\" && userChoice != \"y\" && userChoice != \"N\" && userChoice != \"n\")\n                {\n                    Console.WriteLine(\"Sorry, your input is invalid. Please answer 'Y' to play again, or 'N' to quit.\");\n                }\n                if (userChoice == \"Y\" || userChoice == \"y\")\n                {\n                    Start();\n                }\n                if (userChoice == \"N\" || userChoice == \"n\")\n                {\n                    Environment.Exit(1);\n                }\n            }\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.Title = \"Random Number\";\n            RealisticGuess game = new RealisticGuess();\n            game.Start();\n        }\n    }\n}\n"}
{"id": 70621, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to Java: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "import java.util.AbstractList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class GuessNumber {\n    public static final int LOWER = 0, UPPER = 100;\n    public static void main(String[] args) {\n\tSystem.out.printf(\"Instructions:\\n\" +\n\t\t\t  \"Think of integer number from %d (inclusive) to %d (exclusive) and\\n\" +\n\t\t\t  \"I will guess it. After each guess, you respond with L, H, or C depending\\n\" +\n\t\t\t  \"on if my guess was too low, too high, or correct.\\n\",\n\t\t\t  LOWER, UPPER);\n\tint result = Collections.binarySearch(new AbstractList<Integer>() {\n\t\tprivate final Scanner in = new Scanner(System.in);\n\t\tpublic int size() { return UPPER - LOWER; }\n\t\tpublic Integer get(int i) {\n\t\t    System.out.printf(\"My guess is: %d. Is it too high, too low, or correct? (H/L/C) \", LOWER+i);\n\t\t    String s = in.nextLine();\n\t\t    assert s.length() > 0;\n\t\t    switch (Character.toLowerCase(s.charAt(0))) {\n\t\t    case 'l':\n\t\t\treturn -1;\n\t\t    case 'h':\n\t\t\treturn 1;\n\t\t    case 'c':\n\t\t\treturn 0;\n\t\t    }\n\t\t    return -1;\n\t\t}\n\t    }, 0);\n\tif (result < 0)\n\t    System.out.println(\"That is impossible.\");\n\telse\n\t    System.out.printf(\"Your number is %d.\\n\", result);\n    }\n}\n"}
{"id": 70622, "name": "Guess the number_With feedback (player)", "source": "Translate Fortran to Python: program Guess_a_number_Player\n  implicit none\n  \n  integer, parameter :: limit = 100\n  integer :: guess, mx = limit, mn = 1\n  real :: rnum\n  character(1) :: score\n  \n  write(*, \"(a, i0, a)\") \"Think of a number between 1 and \", limit, &\n                         \" and I will try to guess it.\" \n  write(*, \"(a)\")  \"You score my guess by entering: h if my guess is higher than that number\"\n  write(*, \"(a)\")  \"                                l if my guess is lower than that number\"\n  write(*, \"(a/)\") \"                                c if my guess is the same as that number\"\n\n  call random_seed\n  call random_number(rnum)\n  guess = rnum * limit + 1\n  do\n    write(*, \"(a, i0, a,)\", advance='no') \"My quess is: \", guess, \"   Score(h, l or c)?: \"\n    read*, score\n    select case(score)\n      case(\"l\", \"L\")\n        mn = guess\n        guess = (mx-guess+1) / 2 + mn \n        \n      case(\"h\", \"H\")\n        mx = guess\n        guess = mx - (guess-mn+1) / 2 \n\n      case(\"c\", \"C\")\n        write(*, \"(a)\") \"I solved it\n        exit\n\n      case default\n        write(*, \"(a)\") \"I did not understand that\"\n    end select\n  end do\nend program\n", "target": "inclusive_range = mn, mx = (1, 10)\n\nprint( % inclusive_range)\n\ni = 0\nwhile True:\n    i += 1\n    guess = (mn+mx)//2\n    txt = input(\"Guess %2i is: %2i. The score for which is (h,l,=): \"\n                % (i, guess)).strip().lower()[0]\n    if txt not in 'hl=':\n        print(\"  I don't understand your input of '%s'\u00a0?\" % txt)\n        continue\n    if txt == 'h':\n        mx = guess-1\n    if txt == 'l':\n        mn = guess+1\n    if txt == '=':\n        print(\"  Ye-Haw!!\")\n        break\n    if (mn > mx) or (mn < inclusive_range[0]) or (mx > inclusive_range[1]):\n        print(\"Please check your scoring as I cannot find the value\")\n        break\n        \nprint(\"\\nThanks for keeping score.\")\n"}
{"id": 71556, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71557, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to C#: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    static void Main\n    {\n        string[] input = {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"};\n        foreach (string s in input) {\n            Console.WriteLine($\"\\\"{s}\\\" (Length {s.Length}) \" +\n                string.Join(\", \",\n                    s.Select((c, i) => (c, i))\n                    .GroupBy(t => t.c).Where(g => g.Count() > 1)\n                    .Select(g => $\"'{g.Key}' (0X{(int)g.Key:X})[{string.Join(\", \", g.Select(t => t.i))}]\")\n                    .DefaultIfEmpty(\"All characters are unique.\")\n                )\n            );\n        }\n    }\n}\n"}
{"id": 71562, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71563, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Java: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class StringUniqueCharacters {\n\n    public static void main(String[] args) {\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"String\", \"Length\", \"All Unique\", \"1st Diff\", \"Hex\", \"Positions\");\n        System.out.printf(\"%-40s  %2s  %10s  %8s  %s  %s%n\", \"------------------------\", \"------\", \"----------\", \"--------\", \"---\", \"---------\");\n        for ( String s : new String[] {\"\", \".\", \"abcABC\", \"XYZ ZYX\", \"1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ\"} ) {\n            processString(s);\n        }\n    }\n    \n    \n    \n    private static void processString(String input) {\n        Map<Character,Integer> charMap = new HashMap<>(); \n        char dup = 0;\n        int index = 0;\n        int pos1 = -1;\n        int pos2 = -1;\n        for ( char key : input.toCharArray() ) {\n            index++;\n            if ( charMap.containsKey(key) ) {\n                dup = key;\n                pos1 = charMap.get(key);\n                pos2 = index;\n                break;\n            }\n            charMap.put(key, index);\n        }\n        String unique = dup == 0 ? \"yes\" : \"no\";\n        String diff = dup == 0 ? \"\" : \"'\" + dup + \"'\";\n        String hex = dup == 0 ? \"\" : Integer.toHexString(dup).toUpperCase();\n        String position = dup == 0 ? \"\" : pos1 + \" \" + pos2;\n        System.out.printf(\"%-40s \u00a0%-6d \u00a0%-10s \u00a0%-8s \u00a0%-3s \u00a0%-5s%n\", input, input.length(), unique, diff, hex, position);\n    }\n\n}\n"}
{"id": 71564, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71565, "name": "Determine if a string has all unique characters", "source": "Translate Fortran to Python: program demo_verify\nimplicit none\n    call nodup('')\n    call nodup('.')\n    call nodup('abcABC')\n    call nodup('XYZ ZYX')\n    call nodup('1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ')\ncontains\n\nsubroutine nodup(str)\ncharacter(len=*),intent(in)  :: str\ncharacter(len=*),parameter   :: g='(*(g0))'\ncharacter(len=:),allocatable :: ch\ninteger                      :: where\ninteger                      :: i\n   where=0\n   ch=''\n\n   do i=1,len(str)-1\n      ch=str(i:i)\n      where=index(str(i+1:),ch)\n      if(where.ne.0)then\n         where=where+i\n         exit\n      endif\n   enddo\n\n   if(where.eq.0)then\n     write(*,g)'STR: \"',str,'\"',new_line('a'),'LEN: ',len(str),'. No duplicate characters found'\n   else\n     write(*,g)'STR: \"',str,'\"'\n     write(*,'(a,a,t1,a,a)')repeat(' ',where+5),'^',repeat(' ',i+5),'^'\n     write(*,g)'LEN: ',len(str), &\n     & '. Duplicate chars. First duplicate at positions ',i,' and ',where, &\n     & ' where a ','\"'//str(where:where)//'\"(hex:',hex(str(where:where)),') was found.'\n   endif\n   write(*,*)\n\nend subroutine nodup\n\nfunction hex(ch) result(hexstr)\ncharacter(len=1),intent(in) :: ch\ncharacter(len=:),allocatable :: hexstr\n   hexstr=repeat(' ',100)\n   write(hexstr,'(Z0)')ch\n   hexstr=trim(hexstr)\nend function hex\n\nend program demo_verify\n", "target": "\n\nfrom itertools import groupby\n\n\n\ndef duplicatedCharIndices(s):\n    \n    def go(xs):\n        if 1 < len(xs):\n            duplicates = list(filter(lambda kv: 1 < len(kv[1]), [\n                (k, list(v)) for k, v in groupby(\n                    sorted(xs, key=swap),\n                    key=snd\n                )\n            ]))\n            return Just(second(fmap(fst))(\n                sorted(\n                    duplicates,\n                    key=lambda kv: kv[1][0]\n                )[0]\n            )) if duplicates else Nothing()\n        else:\n            return Nothing()\n    return go(list(enumerate(s)))\n\n\n\n\ndef main():\n    \n\n    def showSample(s):\n        return repr(s) + ' (' + str(len(s)) + ')'\n\n    def showDuplicate(cix):\n        c, ix = cix\n        return repr(c) + (\n            ' (' + hex(ord(c)) + ') at ' + repr(ix)\n        )\n\n    print(\n        fTable('First duplicated character, if any:')(\n            showSample\n        )(maybe('None')(showDuplicate))(duplicatedCharIndices)([\n            '', '.', 'abcABC', 'XYZ ZYX',\n            '1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ'\n        ])\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef fmap(f):\n    \n    return lambda xs: [f(x) for x in xs]\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef head(xs):\n    \n    return xs[0] if isinstance(xs, list) else next(xs)\n\n\n\ndef maybe(v):\n    \n    return lambda f: lambda m: v if (\n        None is m or m.get('Nothing')\n    ) else f(m.get('Just'))\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef swap(tpl):\n    \n    return (tpl[1], tpl[0])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 71845, "name": "Combinations with repetitions", "source": "Translate Fortran to C#: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MultiCombinations\n{\n    private static void Main()\n    {\n        var set = new List<string> { \"iced\", \"jam\", \"plain\" };\n        var combinations = GenerateCombinations(set, 2);\n\n        foreach (var combination in combinations)\n        {\n            string combinationStr = string.Join(\" \", combination);\n            Console.WriteLine(combinationStr);\n        }\n\n        var donuts = Enumerable.Range(1, 10).ToList();\n\n        int donutsCombinationsNumber = GenerateCombinations(donuts, 3).Count;\n\n        Console.WriteLine(\"{0} ways to order 3 donuts given 10 types\", donutsCombinationsNumber);\n    }\n    \n    private static List<List<T>> GenerateCombinations<T>(List<T> combinationList, int k)\n    {\n        var combinations = new List<List<T>>();\n\n        if (k == 0)\n        {\n            var emptyCombination = new List<T>();\n            combinations.Add(emptyCombination);\n\n            return combinations;\n        }\n\n        if (combinationList.Count == 0)\n        {\n            return combinations;\n        }\n\n        T head = combinationList[0];\n        var copiedCombinationList = new List<T>(combinationList);\n        \n        List<List<T>> subcombinations = GenerateCombinations(copiedCombinationList, k - 1);\n\n        foreach (var subcombination in subcombinations)\n        {\n            subcombination.Insert(0, head);\n            combinations.Add(subcombination);\n        }\n\n        combinationList.RemoveAt(0);\n        combinations.AddRange(GenerateCombinations(combinationList, k));\n\n        return combinations;\n    }\n}\n"}
{"id": 71848, "name": "Combinations with repetitions", "source": "Translate Fortran to Java: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": "import com.objectwave.utility.*;\n\npublic class MultiCombinationsTester {\n\n    public MultiCombinationsTester() throws CombinatoricException {\n        Object[] objects = {\"iced\", \"jam\", \"plain\"};\n        \n        \n        \n        MultiCombinations mc = new MultiCombinations(objects, 2);\n        while (mc.hasMoreElements()) {\n            for (int i = 0; i < mc.nextElement().length; i++) {\n                System.out.print(mc.nextElement()[i].toString() + \" \");\n            }\n            System.out.println();\n        }\n\n        \n        System.out.println(\"----------\");\n        System.out.println(\"The ways to choose 3 items from 10 with replacement = \" + MultiCombinations.c(10, 3));\n    } \n\n    public static void main(String[] args) throws CombinatoricException {\n        new MultiCombinationsTester();\n    }\n} \n"}
{"id": 71849, "name": "Combinations with repetitions", "source": "Translate Fortran to Python: program main\n\tinteger :: chosen(4)\n\tinteger :: ssize\n\t\n\tcharacter(len=50) :: donuts(4) = [ \"iced\", \"jam\", \"plain\", \"something completely different\" ]\n\t\n\tssize = choose( chosen, 2, 3 )\n\twrite(*,*) \"Total = \", ssize\n\t\n\tcontains\n\t\n\trecursive function choose( got, len, maxTypes, nChosen, at ) result ( output )\n\t\tinteger :: got(:)\n\t\tinteger :: len\n\t\tinteger :: maxTypes\n\t\tinteger :: output\n\t\tinteger, optional :: nChosen\n\t\tinteger, optional :: at\n\t\t\n\t\tinteger :: effNChosen\n\t\tinteger :: effAt\n\t\t\n\t\tinteger :: i\n\t\tinteger :: counter\n\t\t\n\t\teffNChosen = 1\n\t\tif( present(nChosen) ) effNChosen = nChosen\n\t\t\n\t\teffAt = 1\n\t\tif( present(at) ) effAt = at\n\t\t\n\t\tif ( effNChosen == len+1 ) then\n\t\t\tdo i=1,len\n\t\t\t\twrite(*,\"(A10,5X)\", advance='no') donuts( got(i)+1 )\n\t\t\tend do\n\t\t\t\n\t\t\twrite(*,*) \"\"\n\t\t\t\n\t\t\toutput = 1\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcounter = 0\n\t\tdo i=effAt,maxTypes\n\t\t\tgot(effNChosen) = i-1\n\t\t\tcounter = counter + choose( got, len, maxTypes, effNChosen + 1, i )\n\t\tend do\n\t\t\n\t\toutput = counter\n\t\treturn\n\tend function choose\n\nend program main\n", "target": ">>> from itertools import combinations_with_replacement\n>>> n, k = 'iced jam plain'.split(), 2\n>>> list(combinations_with_replacement(n,k))\n[('iced', 'iced'), ('iced', 'jam'), ('iced', 'plain'), ('jam', 'jam'), ('jam', 'plain'), ('plain', 'plain')]\n>>> \n>>> len(list(combinations_with_replacement(range(10), 3)))\n220\n>>>\n"}
{"id": 72120, "name": "Multiple distinct objects", "source": "Translate Fortran to C#: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72121, "name": "Multiple distinct objects", "source": "Translate Fortran to C#: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nList<Foo> foos = Enumerable.Range(1, n).Select(x => new Foo()).ToList();\n"}
{"id": 72127, "name": "Multiple distinct objects", "source": "Translate Fortran to Java: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72128, "name": "Multiple distinct objects", "source": "Translate Fortran to Java: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "Foo[] foos = new Foo[n]; \nfor (int i = 0; i < foos.length; i++)\n    foos[i] = new Foo();\n\n\nFoo[] foos_WRONG = new Foo[n];\nArrays.fill(foos, new Foo());  \n"}
{"id": 72129, "name": "Multiple distinct objects", "source": "Translate Fortran to Python: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "[Foo()] * n \n"}
{"id": 72130, "name": "Multiple distinct objects", "source": "Translate Fortran to Python: program multiple\n  \n  type T\n     integer :: a = 3\n  end type T\n\n  \n  type S\n     integer, pointer :: a\n  end type S\n\n  type(T), allocatable :: T_array(:)\n  type(S), allocatable :: S_same(:)\n  integer              :: i\n  integer, target      :: v\n  integer, parameter   :: N = 10\n\n  \n  allocate(T_array(N))\n\n  \n  T_array(5)%a = 1\n\n  \n  write(*,'(10i2)') (T_array(i),i=1,N)\n\n  \n  allocate(S_same(N))\n  v = 5\n  do i=1, N\n     allocate(S_same(i)%a)\n     S_same(i)%a => v\n  end do\n\n  \n  write(*,'(10i2)') (S_same(i)%a,i=1,N)\n\n  \n  v = 3\n  write(*,'(10i2)') (S_same(i)%a,i=1,N)  \n\nend program multiple\n", "target": "[Foo()] * n \n"}
{"id": 72424, "name": "Five weekends", "source": "Translate Fortran to C#: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "using System;\n\nnamespace _5_Weekends\n{\n    class Program\n    {\n        const int FIRST_YEAR = 1900;\n        const int LAST_YEAR = 2100;\n        static int[] _31_MONTHS = { 1, 3, 5, 7, 8, 10, 12 }; \n\n        static void Main(string[] args)\n        {\n            int totalNum = 0;\n            int totalNo5Weekends = 0;\n\n            for (int year = FIRST_YEAR; year <= LAST_YEAR; year++)\n            {\n                bool has5Weekends = false;\n\n                foreach (int month in _31_MONTHS)\n                {\n                    DateTime firstDay = new DateTime(year, month, 1);\n                    if (firstDay.DayOfWeek == DayOfWeek.Friday)\n                    {\n                        totalNum++;\n                        has5Weekends = true;\n                        Console.WriteLine(firstDay.ToString(\"yyyy - MMMM\"));\n                    }\n                }\n\n                if (!has5Weekends) totalNo5Weekends++;\n            }\n            Console.WriteLine(\"Total 5-weekend months between {0} and {1}: {2}\", FIRST_YEAR, LAST_YEAR, totalNum);\n            Console.WriteLine(\"Total number of years with no 5-weekend months {0}\", totalNo5Weekends);\n        }\n    }\n}\n"}
{"id": 72427, "name": "Five weekends", "source": "Translate Fortran to Java: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "import java.util.Calendar;\nimport java.util.GregorianCalendar;\n\npublic class FiveFSS {\n    private static boolean[] years = new boolean[201];\n    private static int[] month31 = {Calendar.JANUARY, Calendar.MARCH, Calendar.MAY,\n        Calendar.JULY, Calendar.AUGUST, Calendar.OCTOBER, Calendar.DECEMBER};\n\n    public static void main(String[] args) {\n        StringBuilder months = new StringBuilder();\n        int numMonths = 0;\n        for (int year = 1900; year <= 2100; year++) {\n            for (int month : month31) {\n                Calendar date = new GregorianCalendar(year, month, 1);\n                if (date.get(Calendar.DAY_OF_WEEK) == Calendar.FRIDAY) {\n                    years[year - 1900] = true;\n                    numMonths++;\n                    \n                    months.append((date.get(Calendar.MONTH) + 1) + \"-\" + year +\"\\n\");\n                }\n            }\n        }\n        System.out.println(\"There are \"+numMonths+\" months with five weekends from 1900 through 2100:\");\n        System.out.println(months);\n        System.out.println(\"Years with no five-weekend months:\");\n        for (int year = 1900; year <= 2100; year++) {\n            if(!years[year - 1900]){\n                System.out.println(year);\n            }\n        }\n    }\n}\n"}
{"id": 72428, "name": "Five weekends", "source": "Translate Fortran to Python: program Five_weekends\n  implicit none\n\n  integer :: m, year, nfives = 0, not5 = 0\n  logical :: no5weekend\n\n  type month\n    integer :: n\n    character(3) :: name\n  end type month\n\n  type(month) :: month31(7)\n  \n  month31(1) = month(13, \"Jan\")\n  month31(2) = month(3,  \"Mar\")\n  month31(3) = month(5,  \"May\")\n  month31(4) = month(7,  \"Jul\")\n  month31(5) = month(8,  \"Aug\")\n  month31(6) = month(10, \"Oct\")\n  month31(7) = month(12, \"Dec\")\n\n  do year = 1900, 2100\n    no5weekend = .true.\n    do m = 1, size(month31)\n      if(month31(m)%n == 13) then\n        if(Day_of_week(1, month31(m)%n, year-1) == 6) then\n          write(*, \"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      else \n        if(Day_of_week(1, month31(m)%n, year) == 6) then\n          write(*,\"(a3, i5)\") month31(m)%name, year\n          nfives = nfives + 1\n          no5weekend = .false.\n        end if\n      end if\n    end do\n    if(no5weekend) not5 = not5 + 1\n  end do\n  \n  write(*, \"(a, i0)\") \"Number of months with five weekends between 1900 and 2100 = \", nfives\n  write(*, \"(a, i0)\") \"Number of years between 1900 and 2100 with no five weekend months = \", not5\n  \ncontains\n \nfunction Day_of_week(d, m, y)\n  integer :: Day_of_week\n  integer, intent(in) :: d, m, y\n  integer :: j, k\n    \n  j = y / 100\n  k = mod(y, 100)\n  Day_of_week = mod(d + (m+1)*26/10 + k + k/4 + j/4 + 5*j, 7)\n  \nend function Day_of_week\nend program Five_weekends\n", "target": "from datetime import (date,\n                      timedelta)\n\nDAY = timedelta(days=1)\nSTART, STOP = date(1900, 1, 1), date(2101, 1, 1)\nWEEKEND = {6, 5, 4}  \nFMT = '%Y %m(%B)'\n\n\ndef five_weekends_per_month(start: date = START,\n                            stop: date = STOP) -> list[date]:\n    \n    current_date = start\n    last_month = weekend_days = 0\n    five_weekends = []\n    while current_date < stop:\n        if current_date.month != last_month:\n            if weekend_days >= 15:\n                five_weekends.append(current_date - DAY)\n            weekend_days = 0\n            last_month = current_date.month\n        if current_date.weekday() in WEEKEND:\n            weekend_days += 1\n        current_date += DAY\n    return five_weekends\n\n\ndates = five_weekends_per_month()\nindent = '  '\nprint(f\"There are {len(dates)} months of which the first and last five are:\")\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[:5]))\nprint(indent + '...')\nprint(indent + ('\\n' + indent).join(d.strftime(FMT) for d in dates[-5:]))\n\nyears_without_five_weekends_months = (STOP.year - START.year\n                                      - len({d.year for d in dates}))\nprint(f\"\\nThere are {years_without_five_weekends_months} years in the \"\n      f\"range that do not have months with five weekends\")\n"}
{"id": 73425, "name": "Josephus problem", "source": "Translate Fortran to C#: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": "namespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n"}
{"id": 73428, "name": "Josephus problem", "source": "Translate Fortran to Java: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": "import java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n"}
{"id": 73429, "name": "Josephus problem", "source": "Translate Fortran to Python: program josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n", "target": ">>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n"}
{"id": 73640, "name": "Pathological floating point problems", "source": "Translate Fortran to C#:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73641, "name": "Pathological floating point problems", "source": "Translate Fortran to C#:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "#define USE_BIGRATIONAL\n#define BANDED_ROWS\n#define INCREASED_LIMITS\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Numerics;\nusing Numerics;\n\nusing static Common;\nusing static Task1;\nusing static Task2;\nusing static Task3;\n\n#if !USE_BIGRATIONAL\n\nstruct BigRational\n{\n    public override string ToString() => \"NOT USING BIGRATIONAL\";\n    public static explicit operator decimal(BigRational value) => -1;\n}\n#endif\n\nstatic class Common\n{\n    public const string FMT_STR = \"{0,4}   {1,-15:G9}   {2,-24:G17}   {3,-32}   {4,-32}\";\n    public static string Headings { get; } =\n        string.Format(\n            CultureInfo.InvariantCulture,\n            FMT_STR,\n            new[] { \"N\", \"Single\", \"Double\", \"Decimal\", \"BigRational (rounded as Decimal)\" });\n\n    [Conditional(\"BANDED_ROWS\")]\n    static void SetConsoleFormat(int n)\n    {\n        if (n % 2 == 0)\n        {\n            Console.BackgroundColor = ConsoleColor.Black;\n            Console.ForegroundColor = ConsoleColor.White;\n        }\n        else\n        {\n            Console.BackgroundColor = ConsoleColor.White;\n            Console.ForegroundColor = ConsoleColor.Black;\n        }\n    }\n\n    public static string FormatOutput(int n, (float sn, double db, decimal dm, BigRational br) x)\n    {\n        SetConsoleFormat(n);\n        return string.Format(CultureInfo.CurrentCulture, FMT_STR, n, x.sn, x.db, x.dm, (decimal)x.br);\n    }\n\n    static void Main()\n    {\n        WrongConvergence();\n\n        Console.WriteLine();\n        ChaoticBankSociety();\n\n        Console.WriteLine();\n        SiegfriedRump();\n\n        SetConsoleFormat(0);\n    }\n}\n"}
{"id": 73644, "name": "Pathological floating point problems", "source": "Translate Fortran to Java:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73645, "name": "Pathological floating point problems", "source": "Translate Fortran to Java:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "import java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class FPProblems {\n    public static void wrongConvergence() {\n        int[] INDEXES = new int[] { 3, 4, 5, 6, 7, 8, 20, 30, 50, 100 };\n        \n        \n        double[] fpValues = new double[100];\n        fpValues[0] = 2.0;\n        fpValues[1] = -4.0;\n        for (int i = 2; i < fpValues.length; i++) {\n            fpValues[i] = 111.0 - 1130.0 / fpValues[i - 1] + 3000.0 / (fpValues[i - 1] * fpValues[i - 2]);\n        }\n        \n        \n        BigRational[] brValues = new BigRational[100];\n        brValues[0] = BigRational.valueOf(2);\n        brValues[1] = BigRational.valueOf(-4);\n        for (int i = 2; i < brValues.length; i++) {\n            \n            BigRational clause2 = BigRational.valueOf(1130).divide(brValues[i - 1]);\n            BigRational clause3 = BigRational.valueOf(3000).divide(brValues[i - 1].multiply(brValues[i - 2]));\n            brValues[i] = BigRational.valueOf(111).subtract(clause2).add(clause3);\n        }\n        \n        System.out.println(\"Wrong Convergence Sequence\");\n        for (int n : INDEXES) {\n            BigDecimal value = brValues[n - 1].toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  For index \" + n + \", FP value is \" + fpValues[n - 1] + \", and rounded BigRational value is \" + value.toPlainString());\n        }\n        \n        return;\n    }\n    \n    public static void chaoticBankSociety() {\n        System.out.println(\"Chaotic Bank Society\");\n        double balance = Math.E - 1.0;\n        \n        \n        BigRational e = BigRational.ONE;\n        BigRational d = BigRational.ONE;\n        for (int i = 1; i < 1000; i++) {\n            d = d.multiply(BigRational.valueOf(i));\n            e = e.add(d.reciprocal());\n        }\n        System.out.println(\"DEBUG: e=\" + e.toBigDecimal(100, RoundingMode.HALF_UP).toPlainString());\n        \n        \n        \n        \n        BigRational brBalance = e.subtract(BigRational.ONE);\n        for (int year = 1; year <= 25; year++) {\n            balance = (balance * year) - 1.0;\n            brBalance = brBalance.multiply(BigRational.valueOf(year)).subtract(BigRational.ONE);\n            BigDecimal bdValue = brBalance.toBigDecimal(16, RoundingMode.HALF_UP);\n            System.out.println(\"  Year=\" + year + \", FP balance=\" + balance + \", BigRational balance=\" + bdValue.toPlainString());\n        }\n    }\n    \n    public static void siegfriedRump() {\n        System.out.println(\"Siegfried Rump formula\");\n        double fpValue;\n        {\n            double a = 77617.0;\n            double b = 33096.0;\n            fpValue = 333.75 * Math.pow(b, 6) + a * a * (11.0 * a * a * b * b - Math.pow(b, 6) - 121.0 * Math.pow(b, 4) - 2.0) + 5.5 * Math.pow(b, 8) + a / (2.0 * b);\n        }\n        \n        BigRational brValue;\n        {\n            BigRational a = BigRational.valueOf(77617);\n            BigRational b = BigRational.valueOf(33096);\n            BigRational clause1 = BigRational.valueOf(333.75).multiply(b.pow(6));\n            BigRational clause2a = BigRational.valueOf(11).multiply(a).multiply(a).multiply(b).multiply(b);\n            BigRational clause2b = b.pow(6).add(BigRational.valueOf(121).multiply(b.pow(4))).add(BigRational.valueOf(2));\n            BigRational clause2 = a.multiply(a).multiply(clause2a.subtract(clause2b));\n            BigRational clause3 = BigRational.valueOf(5.5).multiply(b.pow(8));\n            BigRational clause4 = a.divide(b.multiply(BigRational.valueOf(2)));\n            brValue = clause1.add(clause2).add(clause3).add(clause4);\n        }\n        \n        System.out.println(\"  FP value is \" + fpValue);\n        System.out.println(\"  BigRational rounded value is \" + brValue.toBigDecimal(64, RoundingMode.HALF_UP).toPlainString());\n        System.out.println(\"  BigRational full value is \" + brValue.toString());\n    }\n    \n    public static void main(String... args) {\n        wrongConvergence();\n        \n        System.out.println();\n        chaoticBankSociety();\n\n        System.out.println();\n        siegfriedRump();\n    }\n}\n"}
{"id": 73646, "name": "Pathological floating point problems", "source": "Translate Fortran to Python:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 73647, "name": "Pathological floating point problems", "source": "Translate Fortran to Python:       SUBROUTINE MULLER\n       REAL*4 VN,VNL1,VNL2\t\n       REAL*8 WN,WNL1,WNL2\t\n       INTEGER I\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (\"Muller's sequence should converge to six...\",/\n     1   \"  N     Single      Double\")\n        VNL1 = 2; VN = -4\t\n        WNL1 = 2; WN = -4\t\n        DO I = 3,36\t\t\t\n          VNL2 = VNL1; VNL1 = VN\t\t\n          WNL2 = WNL1; WNL1 = WN\t\t\n          VN = 111 - 1130/VNL1 + 3000/(VNL1*VNL2)\t\n          WN = 111 - 1130/WNL1 + 3000/(WNL1*WNL2)\t\n          WRITE (6,2) I,VN,WN\t\t\t\n    2     FORMAT (I3,F12.7,F21.16)\t\t\n        END DO\t\t\t\t\n      END SUBROUTINE MULLER\t\n\n      SUBROUTINE CBS\t\t\n       INTEGER YEAR\t\n       REAL*4 V\t\t\n       REAL*8 W\t\t\n        V = 1; W = 1\t\t\n        V = EXP(V) - 1\t\t\n        W = EXP(W) - 1\t\t\n        WRITE (6,1)\t\t\n    1   FORMAT (///\"The Chaotic Bank Society in action...\"/\"Year\")\n        WRITE (6,2) 0,V,W\t\n    2   FORMAT (I3,F16.7,F28.16)\n        DO YEAR = 1,25\t\t\n          V = V*YEAR - 1\t\n          W = W*YEAR - 1\t\n          WRITE (6,2) YEAR,V,W\t\n        END DO\t\t\t\n      END SUBROUTINE CBS\t\n\n      REAL*4 FUNCTION SR4(A,B)\t\n       REAL*4 A,B\n        SR4 = 333.75*B**6\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR4\n      REAL*8 FUNCTION SR8(A,B)\t\n       REAL*8 A,B\n        SR8 = 333.75*B**6\t\n     1      + A**2*(11*A**2*B**2 - B**6 - 121*B**4 - 2)\n     2      + 5.5*B**8 + A/(2*B)\n      END FUNCTION SR8\n\n      PROGRAM POKE\n      REAL*4 V\t\n      REAL*8 W\t\n      WRITE (6,1) RADIX(V),DIGITS(V),\"single\",DIGITS(W),\"double\"\n    1   FORMAT (\"Floating-point arithmetic is conducted in base \",I0,/\n     1   2(I3,\" digits for \",A,\" precision\",/))\n      WRITE (6,*) \"Single precision limit\",HUGE(V)\n      WRITE (6,*) \"Double precision limit\",HUGE(W)\n      WRITE (6,*)\n\n      CALL MULLER\n\n      CALL CBS\n\n      WRITE (6,10)\n   10 FORMAT (///\"Evaluation of Siegfried Rump's function of 1988\",\n     1 \" where F(77617,33096) = -0.827396059946821\")\n      WRITE (6,*) \"Single precision:\",SR4(77617.0,33096.0)\n      WRITE (6,*) \"Double precision:\",SR8(77617.0D0,33096.0D0)\t\n      END\n", "target": "from fractions import Fraction\n\ndef muller_seq(n:int) -> float:\n    seq = [Fraction(0), Fraction(2), Fraction(-4)]\n    for i in range(3, n+1):\n        next_value = (111 - 1130/seq[i-1]\n            + 3000/(seq[i-1]*seq[i-2]))\n        seq.append(next_value)\n    return float(seq[n])\n\nfor n in [3, 4, 5, 6, 7, 8, 20, 30, 50, 100]:\n    print(\"{:4d} -> {}\".format(n, muller_seq(n)))\n"}
{"id": 74034, "name": "Sum to 100", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74035, "name": "Sum to 100", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        \n        var expressionsPlus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, 1));\n        \n        var expressionsMinus = Enumerable.Range(0, (int)Math.Pow(3, 8)).AsParallel().Select(i => new Expression(i, -1));\n        var expressions = expressionsPlus.Concat(expressionsMinus);\n        var results = new Dictionary<int, List<Expression>>();\n        foreach (var e in expressions)\n        {\n            if (results.Keys.Contains(e.Value))\n                results[e.Value].Add(e);\n            else\n                results[e.Value] = new List<Expression>() { e };\n        }\n        Console.WriteLine(\"Show all solutions that sum to 100\");\n        foreach (Expression e in results[100])\n            Console.WriteLine(\"  \" + e);\n        Console.WriteLine(\"Show the sum that has the maximum number of solutions (from zero to infinity)\");\n        var summary = results.Keys.Select(k => new Tuple<int, int>(k, results[k].Count));\n        var maxSols = summary.Aggregate((a, b) => a.Item2 > b.Item2 ? a : b);\n        Console.WriteLine(\"  The sum \" + maxSols.Item1 + \" has \" + maxSols.Item2 + \" solutions.\");\n        Console.WriteLine(\"Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task\");\n        var lowestPositive = Enumerable.Range(1, int.MaxValue).First(x => !results.Keys.Contains(x));\n        Console.WriteLine(\"  \" + lowestPositive);\n        Console.WriteLine(\"Show the ten highest numbers that can be expressed using the rules for this task (extra credit)\");\n        var highest = from k in results.Keys\n                      orderby k descending\n                      select k;\n        foreach (var x in highest.Take(10))\n            Console.WriteLine(\"  \" + x);\n    }\n}\npublic enum Operations { Plus, Minus, Join };\npublic class Expression\n{\n    protected Operations[] Gaps;\n    \n    \n    public int Value; \n    protected int _one;\n    \n    public Expression(int serial, int one)\n    {\n        _one = one;\n        Gaps = new Operations[8];\n        \n        int divisor = 2187; \n        int times;\n        for (int i = 0; i < 8; i++)\n        {\n            times = Math.DivRem(serial, divisor, out serial);\n            divisor /= 3;\n            if (times == 0)\n                Gaps[i] = Operations.Join;\n            else if (times == 1)\n                Gaps[i] = Operations.Minus;\n            else\n                Gaps[i] = Operations.Plus;\n        }\n        \n        \n        Value = Evaluate();\n    }\n    public override string ToString()\n    {\n        string ret = _one.ToString();\n        for (int i = 0; i < 8; i++)\n        {\n            switch (Gaps[i])\n            {\n                case Operations.Plus:\n                    ret += \"+\";\n                    break;\n                case Operations.Minus:\n                    ret += \"-\";\n                    break;\n            }\n            ret += (i + 2);\n        }\n        return ret;\n    }\n    private int Evaluate()\n        \n    {\n        var numbers = new int[9];\n        int nc = 0;\n        var operations = new List<Operations>();\n        int a = 1;\n        for (int i = 0; i < 8; i++)\n        {\n            if (Gaps[i] == Operations.Join)\n                a = a * 10 + (i + 2);\n            else\n            {\n                if (a > 0)\n                {\n                    if (nc == 0)\n                        a *= _one;\n                    numbers[nc++] = a;\n                    a = i + 2;\n                }\n                operations.Add(Gaps[i]);\n            }\n        }\n        if (nc == 0)\n            a *= _one;\n        numbers[nc++] = a;\n        int ni = 0;\n        int left = numbers[ni++];\n        foreach (var operation in operations)\n        {\n            int right = numbers[ni++];\n            if (operation == Operations.Plus)\n                left = left + right;\n            else\n                left = left - right;\n        }\n        return left;\n    }\n}\n"}
{"id": 74041, "name": "Sum to 100", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "\npackage rosettacode;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SumTo100 implements Runnable {\n\n    public static void main(String[] args) {\n        new SumTo100().run();\n    }\n\n    void print(int givenSum) {\n        Expression expression = new Expression();\n        for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n            if (expression.toInt() == givenSum) {\n                expression.print();\n            }\n        }\n    }\n\n    void comment(String commentString) {\n        System.out.println();\n        System.out.println(commentString);\n        System.out.println();\n    }\n\n    @Override\n    public void run() {\n        final Stat stat = new Stat();\n\n        comment(\"Show all solutions that sum to 100\");\n        final int givenSum = 100;\n        print(givenSum);\n\n        comment(\"Show the sum that has the maximum number of solutions\");\n        final int maxCount = Collections.max(stat.sumCount.keySet());\n        int maxSum;\n        Iterator<Integer> it = stat.sumCount.get(maxCount).iterator();\n        do {\n            maxSum = it.next();\n        } while (maxSum < 0);\n        System.out.println(maxSum + \" has \" + maxCount + \" solutions\");\n\n        comment(\"Show the lowest positive number that can't be expressed\");\n        int value = 0;\n        while (stat.countSum.containsKey(value)) {\n            value++;\n        }\n        System.out.println(value);\n\n        comment(\"Show the ten highest numbers that can be expressed\");\n        final int n = stat.countSum.keySet().size();\n        final Integer[] sums = stat.countSum.keySet().toArray(new Integer[n]);\n        Arrays.sort(sums);\n        for (int i = n - 1; i >= n - 10; i--) {\n            print(sums[i]);\n        }\n    }\n\n    private static class Expression {\n\n        private final static int NUMBER_OF_DIGITS = 9;\n        private final static byte ADD = 0;\n        private final static byte SUB = 1;\n        private final static byte JOIN = 2;\n\n        final byte[] code = new byte[NUMBER_OF_DIGITS];\n        final static int NUMBER_OF_EXPRESSIONS = 2 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3;\n\n        Expression next() {\n            for (int i = 0; i < NUMBER_OF_DIGITS; i++) {\n                if (++code[i] > JOIN) {\n                    code[i] = ADD;\n                } else {\n                    break;\n                }\n            }\n            return this;\n        }\n\n        int toInt() {\n            int value = 0;\n            int number = 0;\n            int sign = (+1);\n            for (int digit = 1; digit <= 9; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        value += sign * number;\n                        number = digit;\n                        sign = (+1);\n                        break;\n                    case SUB:\n                        value += sign * number;\n                        number = digit;\n                        sign = (-1);\n                        break;\n                    case JOIN:\n                        number = 10 * number + digit;\n                        break;\n                }\n            }\n            return value + sign * number;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder s = new StringBuilder(2 * NUMBER_OF_DIGITS + 1);\n            for (int digit = 1; digit <= NUMBER_OF_DIGITS; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        if (digit > 1) {\n                            s.append('+');\n                        }\n                        break;\n                    case SUB:\n                        s.append('-');\n                        break;\n                }\n                s.append(digit);\n            }\n            return s.toString();\n        }\n\n        void print() {\n            print(System.out);\n        }\n\n        void print(PrintStream printStream) {\n            printStream.format(\"%9d\", this.toInt());\n            printStream.println(\" = \" + this);\n        }\n    }\n\n    private static class Stat {\n\n        final Map<Integer, Integer> countSum = new HashMap<>();\n        final Map<Integer, Set<Integer>> sumCount = new HashMap<>();\n\n        Stat() {\n            Expression expression = new Expression();\n            for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n                int sum = expression.toInt();\n                countSum.put(sum, countSum.getOrDefault(sum, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : countSum.entrySet()) {\n                Set<Integer> set;\n                if (sumCount.containsKey(entry.getValue())) {\n                    set = sumCount.get(entry.getValue());\n                } else {\n                    set = new HashSet<>();\n                }\n                set.add(entry.getKey());\n                sumCount.put(entry.getValue(), set);\n            }\n        }\n    }\n}\n"}
{"id": 74042, "name": "Sum to 100", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "\npackage rosettacode;\n\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SumTo100 implements Runnable {\n\n    public static void main(String[] args) {\n        new SumTo100().run();\n    }\n\n    void print(int givenSum) {\n        Expression expression = new Expression();\n        for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n            if (expression.toInt() == givenSum) {\n                expression.print();\n            }\n        }\n    }\n\n    void comment(String commentString) {\n        System.out.println();\n        System.out.println(commentString);\n        System.out.println();\n    }\n\n    @Override\n    public void run() {\n        final Stat stat = new Stat();\n\n        comment(\"Show all solutions that sum to 100\");\n        final int givenSum = 100;\n        print(givenSum);\n\n        comment(\"Show the sum that has the maximum number of solutions\");\n        final int maxCount = Collections.max(stat.sumCount.keySet());\n        int maxSum;\n        Iterator<Integer> it = stat.sumCount.get(maxCount).iterator();\n        do {\n            maxSum = it.next();\n        } while (maxSum < 0);\n        System.out.println(maxSum + \" has \" + maxCount + \" solutions\");\n\n        comment(\"Show the lowest positive number that can't be expressed\");\n        int value = 0;\n        while (stat.countSum.containsKey(value)) {\n            value++;\n        }\n        System.out.println(value);\n\n        comment(\"Show the ten highest numbers that can be expressed\");\n        final int n = stat.countSum.keySet().size();\n        final Integer[] sums = stat.countSum.keySet().toArray(new Integer[n]);\n        Arrays.sort(sums);\n        for (int i = n - 1; i >= n - 10; i--) {\n            print(sums[i]);\n        }\n    }\n\n    private static class Expression {\n\n        private final static int NUMBER_OF_DIGITS = 9;\n        private final static byte ADD = 0;\n        private final static byte SUB = 1;\n        private final static byte JOIN = 2;\n\n        final byte[] code = new byte[NUMBER_OF_DIGITS];\n        final static int NUMBER_OF_EXPRESSIONS = 2 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3;\n\n        Expression next() {\n            for (int i = 0; i < NUMBER_OF_DIGITS; i++) {\n                if (++code[i] > JOIN) {\n                    code[i] = ADD;\n                } else {\n                    break;\n                }\n            }\n            return this;\n        }\n\n        int toInt() {\n            int value = 0;\n            int number = 0;\n            int sign = (+1);\n            for (int digit = 1; digit <= 9; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        value += sign * number;\n                        number = digit;\n                        sign = (+1);\n                        break;\n                    case SUB:\n                        value += sign * number;\n                        number = digit;\n                        sign = (-1);\n                        break;\n                    case JOIN:\n                        number = 10 * number + digit;\n                        break;\n                }\n            }\n            return value + sign * number;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder s = new StringBuilder(2 * NUMBER_OF_DIGITS + 1);\n            for (int digit = 1; digit <= NUMBER_OF_DIGITS; digit++) {\n                switch (code[NUMBER_OF_DIGITS - digit]) {\n                    case ADD:\n                        if (digit > 1) {\n                            s.append('+');\n                        }\n                        break;\n                    case SUB:\n                        s.append('-');\n                        break;\n                }\n                s.append(digit);\n            }\n            return s.toString();\n        }\n\n        void print() {\n            print(System.out);\n        }\n\n        void print(PrintStream printStream) {\n            printStream.format(\"%9d\", this.toInt());\n            printStream.println(\" = \" + this);\n        }\n    }\n\n    private static class Stat {\n\n        final Map<Integer, Integer> countSum = new HashMap<>();\n        final Map<Integer, Set<Integer>> sumCount = new HashMap<>();\n\n        Stat() {\n            Expression expression = new Expression();\n            for (int i = 0; i < Expression.NUMBER_OF_EXPRESSIONS; i++, expression.next()) {\n                int sum = expression.toInt();\n                countSum.put(sum, countSum.getOrDefault(sum, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : countSum.entrySet()) {\n                Set<Integer> set;\n                if (sumCount.containsKey(entry.getValue())) {\n                    set = sumCount.get(entry.getValue());\n                } else {\n                    set = new HashSet<>();\n                }\n                set.add(entry.getKey());\n                sumCount.put(entry.getValue(), set);\n            }\n        }\n    }\n}\n"}
{"id": 74043, "name": "Sum to 100", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74044, "name": "Sum to 100", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\nprogram sumto100\n    \n    parameter (nexpr = 13122)\n\n    print *\n    print *, 'Show all solutions that sum to 100'\n    print *\n    do i = 0, nexpr-1\n        if ( ievaluate(i) .eq. 100 ) then\n            call printexpr(i)\n        endif    \n    enddo\n    \n    print *\n    print *, 'Show the sum that has the maximum number of solutions'\n    print *    \n    ibest = -1\n    nbest = -1\n    do i = 0, nexpr-1\n        itest = ievaluate(i)\n        if ( itest .ge. 0 ) then\n            ntest = 0\n            do j = 0, nexpr-1\n                if ( ievaluate(j) .eq. itest ) then\n                    ntest = ntest + 1\n                endif\n            enddo\n            if ( (ntest .gt. nbest) ) then\n                ibest = itest\n                nbest = ntest\n            endif\n        endif\n    enddo\n    print *, ibest, ' has ', nbest, ' solutions'\n    print *\n\n\n\n\n\n\n    print *\n    print *, 'Show the lowest positive number that can''t be expressed'\n    print *\n    loop: do i = 0,123456789\n        do j = 0,nexpr-1\n            if ( i .eq. ievaluate(j) ) then\n                cycle loop\n            endif\n        enddo\n        exit\n    enddo loop\n    print *, i\n \n    print *\n    print *, 'Show the ten highest numbers that can be expressed'\n    print *\n    ilimit = 123456789\n    do i = 1,10\n        ibest = 0\n        do j = 0, nexpr-1\n            itest = ievaluate(j)\n            if ( (itest .le. ilimit) .and. (itest .gt. ibest ) ) then\n                ibest = itest\n            endif\n        enddo\n        do j = 0, nexpr-1    \n            if ( ievaluate(j) .eq. ibest ) then\n                call printexpr(j)\n            endif    \n        enddo\n        ilimit = ibest - 1;\n    enddo\n       \nend \n\nfunction ievaluate(icode)\n    ic = icode\n    ievaluate = 0\n    n = 0\n    ip = 1\n    do k = 9,1,-1\n        n = ip*k + n\n        select case(mod(ic,3))\n            case ( 0 )\n                ievaluate = ievaluate + n\n                n = 0\n                ip = 1\n            case ( 1 )\n                ievaluate = ievaluate - n\n                n = 0\n                ip = 1\n            case ( 2 )\n                ip = ip * 10\n        end select\n        ic = ic / 3                \n    enddo\nend \n\nsubroutine printexpr(icode)\n    character(len=32) s\n    ia = 19683\n    ib =  6561\n    s = \"\"\n    do k = 1,9\n        ic = mod(icode,ia) / ib\n        ia = ib\n        ib = ib / 3\n        select case(mod(ic,3))\n            case ( 0 )\n                if ( k .gt. 1 ) then\n                    s = trim(s) // '+'\n                endif\n            case ( 1 )\n                s = trim(s) // '-'\n        end select\n        s = trim(s) // char(ichar('0')+k)\n    end do\n    ivalue = ievaluate(icode)\n    print *, ivalue, ' = ', s\nend\n", "target": "from itertools import product, islice\n\n\ndef expr(p):\n    return \"{}1{}2{}3{}4{}5{}6{}7{}8{}9\".format(*p)\n\n\ndef gen_expr():\n    op = ['+', '-', '']\n    return [expr(p) for p in product(op, repeat=9) if p[0] != '+']\n\n\ndef all_exprs():\n    values = {}\n    for expr in gen_expr():\n        val = eval(expr)\n        if val not in values:\n            values[val] = 1\n        else:\n            values[val] += 1\n    return values\n\n\ndef sum_to(val):\n    for s in filter(lambda x: x[0] == val, map(lambda x: (eval(x), x), gen_expr())):\n        print(s)\n\n\ndef max_solve():\n    print(\"Sum {} has the maximum number of solutions: {}\".\n          format(*max(all_exprs().items(), key=lambda x: x[1])))\n\n\ndef min_solve():\n    values = all_exprs()\n    for i in range(123456789):\n        if i not in values:\n            print(\"Lowest positive sum that can't be expressed: {}\".format(i))\n            return\n\n\ndef highest_sums(n=10):\n    sums = map(lambda x: x[0],\n               islice(sorted(all_exprs().items(), key=lambda x: x[0], reverse=True), n))\n    print(\"Highest Sums: {}\".format(list(sums)))\n\n\nsum_to(100)\nmax_solve()\nmin_solve()\nhighest_sums()\n"}
{"id": 74323, "name": "Array concatenation", "source": "Translate Fortran to C#: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "using System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n"}
{"id": 74327, "name": "Array concatenation", "source": "Translate Fortran to Java: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "String[] fruits = [\"apples\", \"oranges\"];\nString[] grains = [\"wheat\", \"corn\"];\nString[] all    = fruits + grains;\n"}
{"id": 74328, "name": "Array concatenation", "source": "Translate Fortran to Python: program Concat_Arrays\n  implicit none\n\n  \n  integer, dimension(3) :: a = [1, 2, 3] \n  integer, dimension(3) :: b = [4, 5, 6] \n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  \n  d = [a, b] \n  print*, d\nend program Concat_Arrays\n", "target": "arr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n"}
{"id": 74606, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to C#:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        int abundant, deficient, perfect;\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        ClassifyNumbers.UsingSieve(20000, out abundant, out deficient, out perfect); sw.Stop();\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingOptiDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n        sw.Restart();\n        ClassifyNumbers.UsingDivision(20000, out abundant, out deficient, out perfect);\n        Console.WriteLine($\"Abundant: {abundant}, Deficient: {deficient}, Perfect: {perfect}  {sw.Elapsed.TotalMilliseconds} ms\");\n    }\n}\n\npublic static class ClassifyNumbers\n{\n    \n    public static void UsingSieve(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        \n        int[] sum = new int[bound + 1];\n        for (int divisor = 1; divisor <= bound >> 1; divisor++)\n            for (int i = divisor << 1; i <= bound; i += divisor)\n                sum[i] += divisor;\n        for (int i = 1; i <= bound; i++) {\n            if (sum[i] > i) abundant++;\n            else if (sum[i] == i) perfect++;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingOptiDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0; int sum = 0;\n        for (int i = 2, d, r = 1; i <= bound; i++) {\n            if ((d = r * r - i) < 0) r++;\n            for (int x = 2; x < r; x++) if (i % x == 0) sum += x + i / x;\n            if (d == 0) sum += r;\n            switch (sum.CompareTo(i)) { case 0: perfect++; break; case 1: abundant++; break; }\n            sum = 1;\n        }\n        deficient = bound - abundant - perfect;\n    }\n\n    \n    public static void UsingDivision(int bound, out int abundant, out int deficient, out int perfect) {\n        abundant = perfect = 0;\n        for (int i = 2; i <= bound; i++) {\n            int sum = Enumerable.Range(1, (i + 1) / 2)\n                .Where(div => i % div == 0).Sum();\n            switch (sum.CompareTo(i)) {\n                case 0: perfect++; break;\n                case 1: abundant++; break;\n            }\n        }\n        deficient = bound - abundant - perfect;\n    }\n}\n"}
{"id": 74609, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to Java:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": "import java.util.stream.LongStream;\n\npublic class NumberClassifications {\n \n    public static void main(String[] args) {\n        int deficient = 0;\n        int perfect = 0;\n        int abundant = 0;\n \n        for (long i = 1; i <= 20_000; i++) {\n            long sum = properDivsSum(i);\n            if (sum < i)\n                deficient++;\n            else if (sum == i)\n                perfect++;\n            else\n                abundant++;\n        }\n        System.out.println(\"Deficient: \" + deficient);\n        System.out.println(\"Perfect: \" + perfect);\n        System.out.println(\"Abundant: \" + abundant);\n    }\n \n    public static long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n != i && n % i == 0).sum();\n    }\n}\n"}
{"id": 74610, "name": "Abundant, deficient and perfect number classifications", "source": "Translate Fortran to Python:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\n       INTEGER LOTS\t\t\n       PARAMETER (LOTS = 20000)\n       INTEGER KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\n        SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         PURE INTEGER FUNCTION SIGN3(N)\t\nConfounded by the intrinsic function SIGN distinguishing only two states: < 0 from >= 0. NOT three-way.\n         INTEGER, INTENT(IN):: N\t\n          IF (N) 1,2,3\t\n    1     SIGN3 = -1\t\n          RETURN\n    2     SIGN3 = 0\t\n          RETURN\n    3     SIGN3 = +1\t\n        END FUNCTION SIGN3\t\n      END MODULE FACTORSTUFF\t\n       PROGRAM THREEWAYS\t\n       USE FACTORSTUFF\t\t\n       INTEGER I\t\t\n       INTEGER TEST(LOTS)\t\n        WRITE (6,*) \"Inspecting sums of proper divisors for 1 to\",LOTS\n        CALL PREPARESUMF\t\t\n        FORALL(I = 1:LOTS) TEST(I) = SIGN3(KNOWNSUM(I) - I)\t\n        WRITE (6,*) \"Deficient\",COUNT(TEST .LT. 0)\t\n        WRITE (6,*) \"Perfect\n        WRITE (6,*) \"Abundant \",COUNT(TEST .GT. 0)\t\n      END\t\t\t\n", "target": ">>> from proper_divisors import proper_divs\n>>> from collections import Counter\n>>> \n>>> rangemax = 20000\n>>> \n>>> def pdsum(n):\n...     return sum(proper_divs(n))\n... \n>>> def classify(n, p):\n...     return 'perfect' if n == p else 'abundant' if p > n else 'deficient'\n... \n>>> classes = Counter(classify(n, pdsum(n)) for n in range(1, 1 + rangemax))\n>>> classes.most_common()\n[('deficient', 15043), ('abundant', 4953), ('perfect', 4)]\n>>>\n"}
{"id": 74806, "name": "Leonardo numbers", "source": "Translate Fortran to C#:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "using System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n"}
{"id": 74809, "name": "Leonardo numbers", "source": "Translate Fortran to Java:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n"}
{"id": 74810, "name": "Leonardo numbers", "source": "Translate Fortran to Python:       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t\n       INTEGER LAST\t\n       INTEGER L0,L1\t\n       INTEGER AF\t\n       OPTIONAL AF\t\n       INTEGER EMBOLISM\t\n       INTEGER N,LN,LNL1,LNL2\t\n        IF (PRESENT(AF)) THEN\t\n          EMBOLISM = AF\t\t\t\n         ELSE\t\t\t\n          EMBOLISM = 1\t\t\t\n        END IF\t\t\t\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t\n    1   FORMAT (\"The first \",I0,\t\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t\n        IF (LAST .GE. 2) WRITE (6,2) L1\t\n    2   FORMAT (I0,\", \",$)\t\n        LNL1 = L0\t\n        LN = L1\t\t\n        DO N = 3,LAST\t\n          LNL2 = LNL1\t\t\n          LNL1 = LN\t\t\n          LN = LNL1 + LNL2 + EMBOLISM\t\n          WRITE (6,2) LN\t\n        END DO\t\t\n        WRITE (6,*)\t\n      END SUBROUTINE LEONARDO\t\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t\n      CALL LEONARDO(25,0,1,0)\t\n      END\n", "target": "def Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n"}
{"id": 74979, "name": "Variadic function", "source": "Translate Fortran to C#: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "using System;\n\nclass Program {\n    static void Main(string[] args) {\n        PrintAll(\"test\", \"rosetta code\", 123, 5.6);\n    }\n\n    static void PrintAll(params object[] varargs) {\n        foreach (var i in varargs) {\n            Console.WriteLine(i);\n        }\n    }\n}\n"}
{"id": 74982, "name": "Variadic function", "source": "Translate Fortran to Java: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "module VariadicFunction\n    {\n    void show(String[] strings)\n        {\n        @Inject Console console;\n        strings.forEach(s -> console.print(s));\n        }\n\n    void run()\n        {\n        show([\"hello\", \"world\"]);\n\n        String s1 = \"not\";\n        String s2 = \"a\";\n        String s3 = \"constant\";\n        String s4 = \"literal\";\n        show([s1, s2, s3, s4]);\n        }\n    }\n"}
{"id": 74983, "name": "Variadic function", "source": "Translate Fortran to Python: program varargs\n\n  integer, dimension(:), allocatable :: va\n  integer :: i\n\n  \n  call v_func()\n  call v_func( (/ 100 /) )\n  call v_func( (/ 90, 20, 30 /) )\n\n  \n  allocate(va(5))\n  va = (/ (i,i=1,5) /)\n  call v_func(va)\n  deallocate(va)\n\ncontains\n\n  subroutine v_func(arglist)\n    integer, dimension(:), intent(in), optional :: arglist\n\n    integer :: i\n\n    if ( present(arglist) ) then\n       do i = lbound(arglist, 1), ubound(arglist, 1)\n          print *, arglist(i)\n       end do\n    else\n       print *, \"no argument at all\"\n    end if\n  end subroutine v_func\n\nend program varargs\n", "target": "def print_all(*things):\n    for x in things:\n        print x\n"}
{"id": 75662, "name": "Exponentiation operator", "source": "Translate Fortran to C#: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "static void Main(string[] args)\n{\n\tConsole.WriteLine(\"5^5 = \" + Expon(5, 5));\n\tConsole.WriteLine(\"5.5^5 = \" + Expon(5.5, 5));\n\tConsole.ReadLine();\n}\n\nstatic double Expon(int Val, int Pow) \n{\n\treturn Math.Pow(Val, Pow);\n}\nstatic double Expon(double Val, int Pow)\n{\n\treturn Math.Pow(Val, Pow);\n}\n"}
{"id": 75665, "name": "Exponentiation operator", "source": "Translate Fortran to Java: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "public class Exp{\n   public static void main(String[] args){\n      System.out.println(pow(2,30));\n      System.out.println(pow(2.0,30)); \n      System.out.println(pow(2.0,-2));\n   }\n\n   public static double pow(double base, int exp){\n      if(exp < 0) return 1 / pow(base, -exp);\n      double ans = 1.0;\n      for(;exp > 0;--exp) ans *= base;\n      return ans;\n   }\n}\n"}
{"id": 75666, "name": "Exponentiation operator", "source": "Translate Fortran to Python: MODULE Exp_Mod\nIMPLICIT NONE\n\nINTERFACE OPERATOR (.pow.)    \n  MODULE PROCEDURE Intexp, Realexp\nEND INTERFACE\n\nCONTAINS\n\n  FUNCTION Intexp (base, exponent)\n    INTEGER :: Intexp\n    INTEGER, INTENT(IN) :: base, exponent\n    INTEGER :: i\n\n    IF (exponent < 0) THEN\n       IF (base == 1) THEN\n          Intexp = 1\n       ELSE\n          Intexp = 0\n       END IF\n       RETURN\n    END IF\n    Intexp = 1\n    DO i = 1, exponent\n      Intexp = Intexp * base\n    END DO\n  END FUNCTION IntExp\n\n  FUNCTION Realexp (base, exponent)\n    REAL :: Realexp\n    REAL, INTENT(IN) :: base\n    INTEGER, INTENT(IN) :: exponent\n    INTEGER :: i\n  \n    Realexp = 1.0\n    IF (exponent < 0) THEN\n       DO i = exponent, -1\n          Realexp = Realexp / base\n       END DO\n    ELSE  \n       DO i = 1, exponent\n          Realexp = Realexp * base\n       END DO\n    END IF\n  END FUNCTION RealExp\nEND MODULE Exp_Mod\n\nPROGRAM EXAMPLE\nUSE Exp_Mod\n  WRITE(*,*) 2.pow.30, 2.0.pow.30\nEND PROGRAM EXAMPLE\n", "target": "MULTIPLY = lambda x, y: x*y\n\nclass num(float):\n    \n    \n    def __pow__(self, b):\n        return reduce(MULTIPLY, [self]*b, 1)\n\n\nprint num(2).__pow__(3)\nprint num(2) ** 3\n\n\nprint num(2.3).__pow__(8)\nprint num(2.3) ** 8\n"}
{"id": 75899, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to C#: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RosettaCode.BubbleSort\n{\n    public static class BubbleSortMethods\n    {\n        \n        \n        \n        public static void BubbleSort<T>(this List<T> list) where T : IComparable\n        {\n            bool madeChanges;\n            int itemCount = list.Count;\n            do\n            {\n                madeChanges = false;\n                itemCount--;\n                for (int i = 0; i < itemCount; i++)\n                {\n                    if (list[i].CompareTo(list[i + 1]) > 0)\n                    {\n                        T temp = list[i + 1];\n                        list[i + 1] = list[i];\n                        list[i] = temp;\n                        madeChanges = true;\n                    }\n                }\n            } while (madeChanges);\n        }\n    }\n\n    \n    \n    class Program\n    {\n        static void Main()\n        {\n            List<int> testList = new List<int> { 3, 7, 3, 2, 1, -4, 10, 12, 4 };\n            testList.BubbleSort();\n            foreach (var t in testList) Console.Write(t + \" \");\n        }\n    }\n}\n"}
{"id": 75902, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to Java: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "public static <E extends Comparable<? super E>> void bubbleSort(E[] comparable) {\n    boolean changed = false;\n    do {\n        changed = false;\n        for (int a = 0; a < comparable.length - 1; a++) {\n            if (comparable[a].compareTo(comparable[a + 1]) > 0) {\n                E tmp = comparable[a];\n                comparable[a] = comparable[a + 1];\n                comparable[a + 1] = tmp;\n                changed = true;\n            }\n        }\n    } while (changed);\n}\n"}
{"id": 75903, "name": "Sorting algorithms_Bubble sort", "source": "Translate Fortran to Python: SUBROUTINE Bubble_Sort(a)\n  REAL, INTENT(in out), DIMENSION(:) :: a\n  REAL :: temp\n  INTEGER :: i, j\n  LOGICAL :: swapped\n \n  DO j = SIZE(a)-1, 1, -1\n    swapped = .FALSE.\n    DO i = 1, j\n      IF (a(i) > a(i+1)) THEN\n        temp = a(i)\n        a(i) = a(i+1)\n        a(i+1) = temp\n        swapped = .TRUE.\n      END IF\n    END DO\n    IF (.NOT. swapped) EXIT\n  END DO\nEND SUBROUTINE Bubble_Sort\n", "target": "def bubble_sort(seq):\n    \n    changed = True\n    while changed:\n        changed = False\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i+1]:\n                seq[i], seq[i+1] = seq[i+1], seq[i]\n                changed = True\n    return seq\n\nif __name__ == \"__main__\":\n   \n\n   from random import shuffle\n\n   testset = [_ for _ in range(100)]\n   testcase = testset.copy() \n   shuffle(testcase)\n   assert testcase != testset  \n   bubble_sort(testcase)\n   assert testcase == testset  \n"}
{"id": 76254, "name": "Find the missing permutation", "source": "Translate Fortran to C#: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76255, "name": "Find the missing permutation", "source": "Translate Fortran to C#: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace MissingPermutation\n{\n    class Program\n    {\n        static void Main()\n        {\n            string[] given = new string[] { \"ABCD\", \"CABD\", \"ACDB\", \"DACB\", \n                                            \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \n                                            \"DABC\", \"BCAD\", \"CADB\", \"CDBA\", \n                                            \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \n                                            \"DCBA\", \"BACD\", \"BADC\", \"BDAC\", \n                                            \"CBDA\", \"DBCA\", \"DCAB\" };\n            \n            List<string> result = new List<string>();\n            permuteString(ref result, \"\", \"ABCD\");\n            \n            foreach (string a in result)            \n                if (Array.IndexOf(given, a) == -1)\n                    Console.WriteLine(a + \" is a missing Permutation\");\n        }\n\n        public static void permuteString(ref List<string> result, string beginningString, string endingString)\n        {\n            if (endingString.Length <= 1)\n            {                 \n                result.Add(beginningString + endingString);\n            }\n            else\n            {\n                for (int i = 0; i < endingString.Length; i++)\n                {                     \n                    string newString = endingString.Substring(0, i) + endingString.Substring(i + 1);\n                    permuteString(ref result, beginningString + (endingString.ToCharArray())[i], newString);                    \n                }\n            }\n        }\n    }\n}\n"}
{"id": 76260, "name": "Find the missing permutation", "source": "Translate Fortran to Java: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76261, "name": "Find the missing permutation", "source": "Translate Fortran to Java: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "import java.util.ArrayList;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\n\npublic class FindMissingPermutation {\n\tpublic static void main(String[] args) {\n\t\tJoiner joiner = Joiner.on(\"\").skipNulls();\n\t\tImmutableSet<String> s = ImmutableSet.of(\"ABCD\", \"CABD\", \"ACDB\",\n\t\t\t\t\"DACB\", \"BCDA\", \"ACBD\", \"ADCB\", \"CDAB\", \"DABC\", \"BCAD\", \"CADB\",\n\t\t\t\t\"CDBA\", \"CBAD\", \"ABDC\", \"ADBC\", \"BDCA\", \"DCBA\", \"BACD\", \"BADC\",\n\t\t\t\t\"BDAC\", \"CBDA\", \"DBCA\", \"DCAB\");\n\n\t\tfor (ArrayList<Character> cs : Utils.Permutations(Lists.newArrayList(\n\t\t\t\t'A', 'B', 'C', 'D')))\n\t\t\tif (!s.contains(joiner.join(cs)))\n\t\t\t\tSystem.out.println(joiner.join(cs));\n\t}\n}\n"}
{"id": 76262, "name": "Find the missing permutation", "source": "Translate Fortran to Python: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76263, "name": "Find the missing permutation", "source": "Translate Fortran to Python: program missing_permutation\n\n  implicit none\n  character (4), dimension (23), parameter :: list =                    &\n    & (/'ABCD', 'CABD', 'ACDB', 'DACB', 'BCDA', 'ACBD', 'ADCB', 'CDAB', &\n    &   'DABC', 'BCAD', 'CADB', 'CDBA', 'CBAD', 'ABDC', 'ADBC', 'BDCA', &\n    &   'DCBA', 'BACD', 'BADC', 'BDAC', 'CBDA', 'DBCA', 'DCAB'/)\n  integer :: i, j, k\n\n  do i = 1, 4\n    j = minloc ((/(count (list (:) (i : i) == list (1) (k : k)), k = 1, 4)/), 1)\n    write (*, '(a)', advance = 'no') list (1) (j : j)\n  end do\n  write (*, *)\n\nend program missing_permutation\n", "target": "from itertools import permutations\n\ngiven = .split()\n\nallPerms = [''.join(x) for x in permutations(given[0])]\n\nmissing = list(set(allPerms) - set(given)) \n"}
{"id": 76696, "name": "Approximate equality", "source": "Translate Fortran to C#: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76697, "name": "Approximate equality", "source": "Translate Fortran to C#: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "using System;\n\npublic static class Program\n{\n    public static void Main() {\n        Test(100000000000000.01, 100000000000000.011);\n        Test(100.01, 100.011);\n        Test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        Test(0.001, 0.0010000001);\n        Test(0.000000000000000000000101, 0.0);\n        Test(Math.Sqrt(2) * Math.Sqrt(2), 2.0);\n        Test(-Math.Sqrt(2) * Math.Sqrt(2), -2.0);\n        Test(3.14159265358979323846, 3.14159265358979324);\n\n        void Test(double a, double b) {\n            const double epsilon = 1e-18;\n            WriteLine($\"{a}, {b} => {a.ApproxEquals(b, epsilon)}\");\n        }\n    }\n\n    public static bool ApproxEquals(this double value, double other, double epsilon) => Math.Abs(value - other) < epsilon;\n}\n"}
{"id": 76702, "name": "Approximate equality", "source": "Translate Fortran to Java: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76703, "name": "Approximate equality", "source": "Translate Fortran to Java: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "public class Approximate {\n    private static boolean approxEquals(double value, double other, double epsilon) {\n        return Math.abs(value - other) < epsilon;\n    }\n\n    private static void test(double a, double b) {\n        double epsilon = 1e-18;\n        System.out.printf(\"%f, %f => %s\\n\", a, b, approxEquals(a, b, epsilon));\n    }\n\n    public static void main(String[] args) {\n        test(100000000000000.01, 100000000000000.011);\n        test(100.01, 100.011);\n        test(10000000000000.001 / 10000.0, 1000000000.0000001000);\n        test(0.001, 0.0010000001);\n        test(0.000000000000000000000101, 0.0);\n        test(Math.sqrt(2.0) * Math.sqrt(2.0), 2.0);\n        test(-Math.sqrt(2.0) * Math.sqrt(2.0), -2.0);\n        test(3.14159265358979323846, 3.14159265358979324);\n    }\n}\n"}
{"id": 76704, "name": "Approximate equality", "source": "Translate Fortran to Python: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 76705, "name": "Approximate equality", "source": "Translate Fortran to Python: program main\n  implicit none\n\n  integer                       :: i\n  double precision, allocatable :: vals(:)\n\n  vals = [ 100000000000000.01d0,          100000000000000.011d0,   &\n    &      100.01d0,                      100.011d0,               &\n    &      10000000000000.001d0/10000d0,  1000000000.0000001000d0, &\n    &      0.001d0,                       0.0010000001d0,          &\n    &      0.000000000000000000000101d0,  0d0,                     &\n    &      sqrt(2d0)*sqrt(2d0),           2d0,                     &\n    &     -sqrt(2d0)*sqrt(2d0),          -2d0,                     &\n    &      3.14159265358979323846d0,      3.14159265358979324d0    ]\n\n  do i = 1, size(vals)/2\n    print '(ES30.18, A, ES30.18, A, L)', vals(2*i-1), ' == ', vals(2*i), '\u00a0? ', eq_approx(vals(2*i-1), vals(2*i))\n  end do\n\ncontains\n\n  logical function eq_approx(a, b, reltol, abstol)\n    \n\n    double precision, intent(in)           :: a, b\n      \n    double precision, intent(in), optional :: reltol, abstol\n      \n      \n\n    double precision :: rt, at\n\n    rt = epsilon(1d0)\n    at = tiny(1d0)\n    if (present(reltol)) rt = reltol\n    if (present(abstol)) at = abstol\n\n    eq_approx = abs(a - b) .le. max(rt * max(abs(a), abs(b)), at)\n    return\n  end function\n\nend program\n", "target": "from numpy import sqrt\nfrom math import isclose\n\ntestvalues = [[100000000000000.01,           100000000000000.011],\n              [100.01,                       100.011],\n              [10000000000000.001 / 10000.0, 1000000000.0000001000],\n              [0.001,                        0.0010000001],\n              [0.000000000000000000000101,   0.0],\n              [sqrt(2) * sqrt(2),            2.0],\n              [-sqrt(2) * sqrt(2),          -2.0],\n              [3.14159265358979323846,       3.14159265358979324]]\n\nfor (x, y) in testvalues:\n    maybenot = \"is\" if isclose(x, y) else \"is NOT\"\n    print(x, maybenot, \"approximately equal to \", y)\n"}
{"id": 77017, "name": "Greatest common divisor", "source": "Translate Fortran to C#: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "static void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n\n\n\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n"}
{"id": 77020, "name": "Greatest common divisor", "source": "Translate Fortran to Java: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "public static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n"}
{"id": 77021, "name": "Greatest common divisor", "source": "Translate Fortran to Python: recursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n", "target": "from fractions import gcd\n"}
{"id": 77297, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to C#: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": "    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n"}
{"id": 77300, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to Java: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": "public class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){\n                s1 += digit;\n            }else{\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 77301, "name": "Luhn test of credit card numbers", "source": "Translate Fortran to Python: program luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  \n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  \n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n\n\n\n\n\n", "target": ">>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2])) % 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n"}
{"id": 77578, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to C#: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "\n\n\n\n\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        \n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        \n        \n        \n        \n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    \n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    \n    \n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      \n      for (var sample = 0; sample < samples; sample++) {\n        \n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        \n        \n        \n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        \n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        \n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      \n      swapIn(entries, first, last);\n\n      \n      \n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      \n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    \n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    \n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    \n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n"}
{"id": 77581, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to Java: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "public static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        \n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        \n        less = quickSort(less);\n        more = quickSort(more);\n\n        \n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n"}
{"id": 77582, "name": "Sorting algorithms_Quicksort", "source": "Translate Fortran to Python: MODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    \n     REAL    :: VALUE    \n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    \n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    \n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   \n       left = 1\n       right = nA\n       \n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  \n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  \n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n", "target": "def quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n"}
{"id": 78074, "name": "Rot-13", "source": "Translate Fortran to C#: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static char Rot13(char c)\n    {\n        if ('a' <= c && c <= 'm' || 'A' <= c && c <= 'M')\n        {\n            return (char)(c + 13);\n        }\n        if ('n' <= c && c <= 'z' || 'N' <= c && c <= 'Z')\n        {\n            return (char)(c - 13);\n        }\n        return c;\n    }\n\n    static string Rot13(string s)\n    {\n        return new string(s.Select(Rot13).ToArray());\n    }\n\n\n    static void Main(string[] args)\n    {\n        foreach (var file in args.Where(file => File.Exists(file)))\n        {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any())\n        {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n"}
{"id": 78078, "name": "Rot-13", "source": "Translate Fortran to Java: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": "import java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n"}
{"id": 78079, "name": "Rot-13", "source": "Translate Fortran to Python: program test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n", "target": ">>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n"}
{"id": 78296, "name": "Parametric polymorphism", "source": "Translate Fortran to C#:       MODULE SORTSEARCH\t\t\n\n       INTERFACE FIND\t\t\t\n        MODULE PROCEDURE\n     1   FINDI4,\t\t\t\t\n     2   FINDF4,FINDF8,\t\t\t\t\n     3          FINDTTI2,FINDTTI4\t\t\n       END INTERFACE FIND\n\n      CONTAINS\n      INTEGER FUNCTION FINDI4(THIS,NUMB,N)\t\n       USE ASSISTANCE\t\t\n       INTENT(IN) THIS,NUMB,N\t\n       INTEGER*4 THIS,NUMB(1:*)\t\n       INTEGER N\t\t\n       INTEGER L,R,P\t\t\nChop away.\n        L = 0\t\t\t\n        R = N + 1\t\t\n    1   P = (R - L)/2\t\t\n        IF (P.LE.0) THEN\t\n          FINDI4 = -L\t\t\n          RETURN\t\t\n        END IF\t\t\t\n        P = P + L\t\t\n        IF (THIS - NUMB(P)) 3,4,2\t\n    2   L = P\t\t\t\n        GO TO 1\t\t\t\n    3   R = P\t\t\t\n        GO TO 1\t\t\t\nCaught it\n    4   FINDI4 = P\t\t\n      END FUNCTION FINDI4\t\n\n      END MODULE SORTSEARCH\n", "target": "using System;\n\nclass BinaryTree<T>\n{\n    public T value;\n    public BinaryTree<T> left;\n    public BinaryTree<T> right;\n\n    public BinaryTree(T value)\n    {\n        this.value = value;\n    }\n\n    public BinaryTree<U> Map<U>(Func<T, U> f)\n    {\n        BinaryTree<U> tree = new BinaryTree<U>(f(this.value));\n        if (this.left != null)\n        {\n            tree.left = this.left.Map(f);\n        }\n        if (this.right != null)\n        {\n            tree.right = this.right.Map(f);\n        }\n        return tree;\n    }\n}\n"}
{"id": 78299, "name": "Parametric polymorphism", "source": "Translate Fortran to Java:       MODULE SORTSEARCH\t\t\n\n       INTERFACE FIND\t\t\t\n        MODULE PROCEDURE\n     1   FINDI4,\t\t\t\t\n     2   FINDF4,FINDF8,\t\t\t\t\n     3          FINDTTI2,FINDTTI4\t\t\n       END INTERFACE FIND\n\n      CONTAINS\n      INTEGER FUNCTION FINDI4(THIS,NUMB,N)\t\n       USE ASSISTANCE\t\t\n       INTENT(IN) THIS,NUMB,N\t\n       INTEGER*4 THIS,NUMB(1:*)\t\n       INTEGER N\t\t\n       INTEGER L,R,P\t\t\nChop away.\n        L = 0\t\t\t\n        R = N + 1\t\t\n    1   P = (R - L)/2\t\t\n        IF (P.LE.0) THEN\t\n          FINDI4 = -L\t\t\n          RETURN\t\t\n        END IF\t\t\t\n        P = P + L\t\t\n        IF (THIS - NUMB(P)) 3,4,2\t\n    2   L = P\t\t\t\n        GO TO 1\t\t\t\n    3   R = P\t\t\t\n        GO TO 1\t\t\t\nCaught it\n    4   FINDI4 = P\t\t\n      END FUNCTION FINDI4\t\n\n      END MODULE SORTSEARCH\n", "target": "public class Tree<T>{\n\tprivate T value;\n\tprivate Tree<T> left;\n\tprivate Tree<T> right;\n\n\tpublic void replaceAll(T value){\n\t\tthis.value = value;\n\t\tif (left != null)\n\t\t\tleft.replaceAll(value);\n\t\tif (right != null)\n\t\t\tright.replaceAll(value);\n\t}\n}\n"}
{"id": 78505, "name": "Write float arrays to a text file", "source": "Translate Fortran to C#: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78506, "name": "Write float arrays to a text file", "source": "Translate Fortran to C#: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "using System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var x = new double[] { 1, 2, 3, 1e11 };\n        var y = new double[] { 1, 1.4142135623730951, 1.7320508075688772, 316227.76601683791 };\n\n        int xprecision = 3;\n        int yprecision = 5;\n\n        string formatString = \"{0:G\" + xprecision + \"}\\t{1:G\" + yprecision + \"}\";\n\n        using (var outf = new StreamWriter(\"FloatArrayColumns.txt\"))\n            for (int i = 0; i < x.Length; i++)\n                outf.WriteLine(formatString, x[i], y[i]);\n    }\n}\n"}
{"id": 78511, "name": "Write float arrays to a text file", "source": "Translate Fortran to Java: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78512, "name": "Write float arrays to a text file", "source": "Translate Fortran to Java: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import java.io.*;\n\npublic class FloatArray {\n    public static void writeDat(String filename, double[] x, double[] y,\n                                int xprecision, int yprecision)\n        throws IOException {\n        assert x.length == y.length;\n        PrintWriter out = new PrintWriter(filename);\n        for (int i = 0; i < x.length; i++)\n            out.printf(\"%.\"+xprecision+\"g\\t%.\"+yprecision+\"g\\n\", x[i], y[i]);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        double[] x = {1, 2, 3, 1e11};\n        double[] y = new double[x.length];\n        for (int i = 0; i < x.length; i++)\n            y[i] = Math.sqrt(x[i]);\n        \n        try {\n            writeDat(\"sqrt.dat\", x, y, 3, 5);\n        } catch (IOException e) {\n            System.err.println(\"writeDat: exception: \"+e);\n        }\n\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(\"sqrt.dat\"));\n            String line;\n            while ((line = br.readLine()) != null)\n                System.out.println(line);\n        } catch (IOException e) { }\n    }\n}\n"}
{"id": 78513, "name": "Write float arrays to a text file", "source": "Translate Fortran to Python: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78514, "name": "Write float arrays to a text file", "source": "Translate Fortran to Python: program writefloats\n  implicit none\n\n  real, dimension(10) :: a, sqrta\n  integer :: i\n  integer, parameter :: unit = 40 \n\n  a = (/ (i, i=1,10) /)\n  sqrta = sqrt(a)\n\n  open(unit, file=\"xydata.txt\", status=\"new\", action=\"write\")\n  call writexy(unit, a, sqrta)\n  close(unit)\n\ncontains\n\n  subroutine writexy(u, x, y)\n    real, dimension(:), intent(in) :: x, y\n    integer, intent(in) :: u\n\n    integer :: i\n\n    write(u, \"(2F10.4)\") (x(i), y(i), i=lbound(x,1), ubound(x,1))\n  end subroutine writexy\n\nend program writefloats\n", "target": "import itertools\ndef writedat(filename, x, y, xprecision=3, yprecision=5):\n    with open(filename,'w') as f:\n        for a, b in itertools.izip(x, y):\n            print >> f, \"%.*g\\t%.*g\" % (xprecision, a, yprecision, b)\n"}
{"id": 78849, "name": "21 game", "source": "Translate Fortran to C#: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 78850, "name": "21 game", "source": "Translate Fortran to C#: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "\n\nusing System;\n\nnamespace _21Game\n{\n    public class Program\n    {\n        private const string computerPlayer = \"Computer\";\n        private const string humanPlayer = \"Player 1\";\n\n        public static string SwapPlayer(string currentPlayer)\n        {\n            if (currentPlayer == computerPlayer)\n            {\n                currentPlayer = humanPlayer;\n            }\n            else\n            {\n                currentPlayer = computerPlayer;\n            }\n\n            return currentPlayer;\n        }\n\n        public static void PlayGame()\n        {\n            bool playAnother = true;\n            int total = 0;\n            int final = 21;\n            int roundChoice = 0;\n            string currentPlayer = RandomPLayerSelect();\n            int compWins = 0;\n            int humanWins = 0;\n\n            while (playAnother)\n            {\n                Console.WriteLine($\"Now playing: {currentPlayer}\");\n                try\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                       roundChoice =  CompMove(total);\n                    }\n                    else\n                    {\n                        roundChoice = int.Parse(Console.ReadLine());\n                    }\n                    \n\n                    if (roundChoice != 1 && roundChoice != 2 && roundChoice != 3)\n                    {\n                        throw new Exception();\n                    }\n\n                    total += roundChoice;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Invalid choice! Choose from numbers: 1, 2, 3.\");\n                    continue;\n                }\n\n                Console.WriteLine(total);\n\n                if (total == final)\n                {\n                    if (currentPlayer == computerPlayer)\n                    {\n                        compWins++;\n                    }\n                    if (currentPlayer == humanPlayer)\n                    {\n                        humanWins++;\n                    }\n                    Console.WriteLine($\"Winner: {currentPlayer}\");\n                    Console.WriteLine($\"Comp wins: {compWins}. Human wins: {humanWins}\");\n                    Console.WriteLine($\"do you wan to play another round? y/n\");\n                    var choice = Console.ReadLine();\n                    if (choice == \"y\")\n                    {\n                        total = 0;\n                    }\n                    else if (choice == \"n\")\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Invalid choice! Choose from y or n\");\n                        continue;\n                    }\n                }\n\n                else if (total > 21)\n                {\n                    Console.WriteLine(\"Not the right time to play this game\u00a0:)\");\n                    break;\n                }\n\n                currentPlayer = SwapPlayer(currentPlayer);\n            }\n        }\n\n        public static bool CheckIfCanWin(int total)\n        {\n            bool result = false;\n            if (total == 18)\n            {\n                result = true;\n            }\n            return result;\n        }\n\n        public static int CompMove(int total)\n        {\n            int choice = 0;\n\n            if (CheckIfCanWin(total))\n            {\n                choice = 21 - total;\n            }\n            else\n            {\n                choice = new Random().Next(1,4);\n            }\n\n            return choice;\n        }\n\n        public static string RandomPLayerSelect()\n        {\n            string[] players = new string[] { computerPlayer, humanPlayer };\n            var random = new Random().Next(0,2);\n            return players[random];\n        }\n\n        public static void Main(string[] args)\n        {\n            \n            Console.WriteLine(\"Welcome to 21 game \\n\");\n            Console.WriteLine(@\"21 is a two player game. \nThe game is played by choosing a number.\n1, 2, or 3 to be added a total sum. \\n\nThe game is won by the player reaches exactly 21. \\n\" );            \n            Console.WriteLine(\"Choose your number: (1, 2 or 3)\");\n\n            PlayGame();\n        }\n    }\n}\n"}
{"id": 78855, "name": "21 game", "source": "Translate Fortran to Java: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 78856, "name": "21 game", "source": "Translate Fortran to Java: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class TwentyOneGame {\n\n    public static void main(String[] args) {\n        new TwentyOneGame().run(true, 21, new int[] {1, 2, 3});\n    }\n    \n    public void run(boolean computerPlay, int max, int[] valid) {\n        String comma = \"\";\n        for ( int i = 0 ; i < valid.length ; i++ ) {\n            comma += valid[i];\n            if ( i < valid.length - 2 && valid.length >= 3 ) {\n                comma += \", \";\n            }\n            if ( i == valid.length - 2 ) {\n                comma += \" or \";\n            }\n        }\n        System.out.printf(\"The %d game.%nEach player chooses to add %s to a running total.%n\" + \n                \"The player whose turn it is when the total reaches %d will win the game.%n\" + \n                \"Winner of the game starts the next game.  Enter q to quit.%n%n\", max, comma, max);\n        int cGames = 0;\n        int hGames = 0;\n        boolean anotherGame = true;\n        try (Scanner scanner = new Scanner(System.in);) {\n            while ( anotherGame ) {\n                Random r = new Random();\n                int round = 0;\n                int total = 0;\n                System.out.printf(\"Start game %d%n\", hGames + cGames + 1);\n                DONE:\n                    while ( true ) {\n                        round++;\n                        System.out.printf(\"ROUND %d:%n%n\", round);\n                        for ( int play = 0 ; play < 2 ; play++ ) {\n                            if ( computerPlay ) {\n                                int guess = 0;\n                                \n                                for ( int test : valid ) {\n                                    if ( total + test == max ) {\n                                        guess = test;\n                                        break;\n                                    }\n                                }\n                                \n                                if ( guess == 0 ) {\n                                    for ( int test : valid ) {\n                                        if ( total + test >= max ) {\n                                            guess = test;\n                                            break;\n                                        }\n                                    }\n                                }\n                                if ( guess == 0 ) {\n                                    guess = valid[r.nextInt(valid.length)];\n                                }\n                                total += guess;\n                                System.out.printf(\"The computer chooses %d%n\", guess);\n                                System.out.printf(\"Running total is now %d%n%n\", total);\n                                if ( total >= max ) {\n                                    break DONE;\n                                }\n                            }\n                            else {\n                                while ( true ) {\n                                    System.out.printf(\"Your choice among %s: \", comma);\n                                    String line = scanner.nextLine();\n                                    if ( line.matches(\"^[qQ].*\") ) {\n                                        System.out.printf(\"Computer wins %d game%s, human wins %d game%s.  One game incomplete.%nQuitting.%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                                        return;\n                                    }\n                                    try {\n                                        int input = Integer.parseInt(line);\n                                        boolean inputOk = false;\n                                        for ( int test : valid ) {\n                                            if ( input == test ) {\n                                                inputOk = true;\n                                                break;\n                                            }\n                                        }\n                                        if ( inputOk ) {\n                                            total += input;\n                                            System.out.printf(\"Running total is now %d%n%n\", total);\n                                            if ( total >= max ) {\n                                                break DONE;\n                                            }\n                                            break;\n                                        }\n                                        else {\n                                            System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                        }\n                                    }\n                                    catch (NumberFormatException e) {\n                                        System.out.printf(\"Invalid input - must be a number among %s.  Try again.%n\", comma);\n                                    }\n                                }\n                            }\n                            computerPlay = !computerPlay;\n                        }\n                    }\n                String win;\n                if ( computerPlay ) {\n                    win = \"Computer wins!!\";\n                    cGames++;\n                }\n                else {\n                    win = \"You win and probably had help from another computer!!\";\n                    hGames++;\n                }\n                System.out.printf(\"%s%n\", win);\n                System.out.printf(\"Computer wins %d game%s, human wins %d game%s%n%n\", cGames, cGames == 1 ? \"\" : \"s\", hGames, hGames == 1 ? \"\" : \"s\");\n                while ( true ) {\n                    System.out.printf(\"Another game (y/n)? \");\n                    String line = scanner.nextLine();\n                    if ( line.matches(\"^[yY]$\") ) {\n                        \n                        System.out.printf(\"%n\");\n                        break;\n                    }\n                    else if ( line.matches(\"^[nN]$\") ) {\n                        anotherGame = false;\n                        System.out.printf(\"Quitting.%n\");\n                        break;\n                    }\n                    else {\n                        System.out.printf(\"Invalid input - must be a y or n.  Try again.%n\");\n                    }\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 78857, "name": "21 game", "source": "Translate Fortran to Python: \n\nsubroutine ai\n  common itotal, igoal\n  if (itotal .lt. igoal) then\n    move = 1\n    do i = 1, 3\n      if (mod(itotal + i - 1 , 4) .eq. 0) then\n        move = i\n      end if\n    end do\n    do i = 1, 3\n      if (itotal + i .eq. igoal) then\n        move = i\n      end if\n    end do\n    print *, \"      ai  \", itotal + move, \" = \", itotal, \" + \", move\n    itotal = itotal + move\n    if (itotal .eq. igoal) then\n      print *, \"\"\n      print *, \"the winner is ai\"\n      print *, \"\"\n    end if\n  end if\nend subroutine ai\n\nsubroutine human\n  common itotal, igoal\n  print *, \"\"\n  do while (.true.)\n    if (itotal + 1 .eq. igoal) then\n      print *, \"enter 1 (or 0 to exit): \"\n    else if (itotal + 2 .eq. igoal) then\n      print *, \"enter 1 or 2 (or 0 to exit): \"\n    else\n      print *, \"enter 1 or 2 or 3 (or 0 to exit)\"\n    end if\n    read(*,*) move\n    if (move .eq. 0) then\n      stop\n    else if (move .ge. 1 .and. move .le. 3 .and. move + itotal .le. igoal) then\n      print *, \"   human  \", itotal + move, \" = \", itotal, \" + \", move\n      itotal = itotal + move\n      if (itotal .eq. igoal) then\n        print *, \"\"\n        print *, \"the winner is human\"\n        print *, \"\"\n      end if\n      return\n    else\n      print *, \"a bad choice\"\n    end if\n  end do\nend subroutine human\n\nprogram main\n  common itotal, igoal\n  print *,\"game 21 - an example in fortran iv language for rosseta code.\"\n  print *,\"\"\n  print *,\"21 is a two player game, the game is played by choosing a number\"\n  print *,\"(1, 2, or 3) to be added to the running total. the game is won\"\n  print *,\"by the player whose chosen number causes the running total to reach\"\n  print *,\"exactly 21. the running total starts at zero.\"\n  print *,\"\"\n  i = irand(1)\n  igoal = 21\n  do while(.true.)\n    print *, \"---- new game ----\"\n    print *, \"\"\n    print *, \"the running total is currently zero.\"\n    print *, \"\"\n    itotal = 0\n    if (mod(irand(0), 2) .eq. 0) then\n      print *, \"the first move is ai move.\"\n      call ai\n    else\n      print *, \"the first move is human move.\"\n    end if\n    print *, \"\"\n    do while(itotal .lt. igoal)\n      call human\n      call ai\n    end do\nend do\nend program main\n", "target": "from random import randint\ndef start():\n\tgame_count=0\n\tprint(\"Enter q to quit at any time.\\nThe computer will choose first.\\nRunning total is now {}\".format(game_count))\n\troundno=1\n\twhile game_count<21:\n\t\tprint(\"\\nROUND {}: \\n\".format(roundno))\n\t\tt = select_count(game_count)\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, commiserations, the computer has won!\")\n\t\t\treturn 0\n\t\tt = request_count()\n\t\tif not t:\n\t\t\tprint('OK,quitting the game')\n\t\t\treturn -1\n\t\tgame_count = game_count+t\n\t\tprint(\"Running total is now {}\\n\".format(game_count))\n\t\tif game_count>=21:\n\t\t\tprint(\"So, congratulations, you've won!\")\n\t\t\treturn 1\n\t\troundno+=1\n\ndef select_count(game_count):\n\t\n\tif game_count<18:\n\t\tt= randint(1,3)\n\telse:\n\t\tt = 21-game_count\n\tprint(\"The computer chooses {}\".format(t))\n\treturn t\n\ndef request_count():\n\t\n\tt=\"\"\n\twhile True:\n\t\ttry:\n\t\t\tt = raw_input('Your choice 1 to 3\u00a0:')\n\t\t\tif int(t) in [1,2,3]:\n\t\t\t\treturn int(t)\n\t\t\telse:\n\t\t\t\tprint(\"Out of range, try again\")\n\t\texcept:\n\t\t\tif t==\"q\":\n\t\t\t\treturn None\n\t\t\telse:\n\t\t\t\tprint(\"Invalid Entry, try again\")\n\nc=0\nm=0\nr=True\nwhile r:\n\to = start()\n\tif o==-1:\n\t\tbreak\n\telse:\n\t\tc+=1 if o==0 else 0\n\t\tm+=1 if o==1 else 0\n\tprint(\"Computer wins {0} game, human wins {1} games\".format(c,m))\n\tt = raw_input(\"Another game?(press y to continue):\")\n\tr = (t==\"y\")\n"}
{"id": 79279, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to C#:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79280, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to C#:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main()\n        {\n            List<BigInteger> candidates = new List<BigInteger>(new BigInteger[] { 1000, 100000, 10000000, 10000000000, 1000000000000000 });\n            candidates.Add(BigInteger.Parse(\"100000000000000000000\"));\n\n            foreach (BigInteger candidate in candidates)\n            {\n                BigInteger c = candidate - 1;\n                BigInteger answer3 = GetSumOfNumbersDivisibleByN(c, 3);\n                BigInteger answer5 = GetSumOfNumbersDivisibleByN(c, 5);\n                BigInteger answer15 = GetSumOfNumbersDivisibleByN(c, 15);\n\n                Console.WriteLine(\"The sum of numbers divisible by 3 or 5 between 1 and {0} is {1}\", c, answer3 + answer5 - answer15);\n            }\n\n            Console.ReadKey(true);\n        }\n\n        private static BigInteger GetSumOfNumbersDivisibleByN(BigInteger candidate, uint n)\n        {\n            BigInteger largest = candidate;\n            while (largest % n > 0)\n                largest--;\n            BigInteger totalCount = (largest / n);\n            BigInteger pairCount = totalCount / 2;\n            bool unpairedNumberOnFoldLine = (totalCount % 2 == 1);\n            BigInteger pairSum = largest + n;\n            return pairCount * pairSum + (unpairedNumberOnFoldLine ? pairSum / 2 : 0);\n        }\n\n    }\n}\n"}
{"id": 79286, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Java:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79287, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Java:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "class SumMultiples {\n\tpublic static long getSum(long n) {\n\t\tlong sum = 0;\n\t\tfor (int i = 3; i < n; i++) {\n\t\t\tif (i % 3 == 0 || i % 5 == 0) sum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(getSum(1000));\n\t}\n}\n"}
{"id": 79288, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Python:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79289, "name": "Sum multiples of 3 and 5", "source": "Translate Fortran to Python:       INTEGER*8 FUNCTION SUMI(N)\t\nCalculates as per the young Gauss: N*(N + 1)/2 = 1 + 2 + 3 + ... + N.\n       INTEGER*8 N\t\n        IF (MOD(N,2).EQ.0) THEN\t\n          SUMI = N/2*(N + 1)\t\t\n         ELSE\t\t\t\n          SUMI = (N + 1)/2*N\t\t\n        END IF\t\t\t\n      END FUNCTION SUMI\t\t\n\n      INTEGER*8 FUNCTION SUMF(N,F)\t\n       INTEGER*8 N,F\t\t\n       INTEGER*8 L\t\t\n       INTEGER*8 SUMI\t\t\n        L = (N - 1)/F\t\t\n        SUMF = F*SUMI(L)\t\n      END FUNCTION SUMF\t\t\n\n      INTEGER*8 FUNCTION SUMBFI(N)\t\n       INTEGER*8 N\t\n       INTEGER*8 I,S\t\n        S = 0\t\t\n        DO I = 3,N - 1\t\n          IF (MOD(I,3).EQ.0 .OR. MOD(I,5).EQ.0) S = S + I\t\n        END DO\t\t\n        SUMBFI = S\t\t\n      END FUNCTION SUMBFI\t\n\n      INTEGER*8 SUMF,SUMBFI\t\n      INTEGER*8 N\t\n      WRITE (6,*) \"Sum multiples of 3 and 5 up to N\"\n   10 WRITE (6,11)\t\t\n   11 FORMAT (\"Specify N: \",$)\t\n      READ (5,*) N\t\t\n      IF (N.LE.0) STOP\t\t\n      WRITE (6,*) \"By Gauss:\",SUMF(N,3) + SUMF(N,5) - SUMF(N,15)\n      WRITE (6,*) \"BFI sum\u00a0:\",SUMBFI(N)\t\t\n      GO TO 10\t\t\t\n      END\t\n", "target": "def sum35a(n):\n    'Direct count'\n    \n    return sum(x for x in range(n) if x%3==0 or x%5==0)\n\ndef sum35b(n): \n    \"Count all the 3's; all the 5's; minus double-counted 3*5's\"\n    \n    return sum(range(3, n, 3)) + sum(range(5, n, 5)) - sum(range(15, n, 15))\n    \ndef sum35c(n):\n    'Sum the arithmetic progressions: sum3 + sum5 - sum15'\n    consts = (3, 5, 15)\n    \n    divs = [(n-1) // c for c in consts]\n    sums = [d*c*(1+d)/2 for d,c in zip(divs, consts)]\n    return sums[0] + sums[1] - sums[2]\n\n\nfor n in range(1001):\n    sa, sb, sc = sum35a(n), sum35b(n), sum35c(n)\n    assert sa == sb == sc  \n\nprint('For n = %7i -> %i\\n' % (n, sc))\n\n\nfor p in range(7):\n    print('For n = %7i -> %i' % (10**p, sum35c(10**p)))\n\n\np = 20\nprint('\\nFor n = %20i -> %i' % (10**p, sum35c(10**p)))\n"}
{"id": 79732, "name": "Pascal's triangle", "source": "Translate Fortran to C#: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "using System;\n\nnamespace RosettaCode {\n\n    class PascalsTriangle {\n\n        public static void CreateTriangle(int n) {\n            if (n > 0) {\n                for (int i = 0; i < n; i++) {\n                    int c = 1;\n                    Console.Write(\" \".PadLeft(2 * (n - 1 - i)));\n                    for (int k = 0; k <= i; k++) {\n                        Console.Write(\"{0}\", c.ToString().PadLeft(3));\n                        c = c * (i - k) / (k + 1);\n                    }\n                    Console.WriteLine();\n                }\n            }\n        }\n\n        public static void Main() {\n            CreateTriangle(8);\n        }\n    }\n}\n"}
{"id": 79735, "name": "Pascal's triangle", "source": "Translate Fortran to Java: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "import java.util.ArrayList;\n...\npublic static void genPyrN(int rows){\n\tif(rows < 0) return;\n\t\n\tArrayList<Integer> last = new ArrayList<Integer>();\n\tlast.add(1);\n\tSystem.out.println(last);\n\tfor(int i= 1;i <= rows;++i){\n\t\t\n\t\tArrayList<Integer> thisRow= new ArrayList<Integer>();\n\t\tthisRow.add(last.get(0)); \n\t\tfor(int j= 1;j < i;++j){\n\t\t\t\n\t\t\tthisRow.add(last.get(j - 1) + last.get(j));\n\t\t}\n\t\tthisRow.add(last.get(0)); \n\t\tlast= thisRow;\n\t\tSystem.out.println(thisRow);\n\t}\n}\n"}
{"id": 79736, "name": "Pascal's triangle", "source": "Translate Fortran to Python: PROGRAM Pascals_Triangle\n\n  CALL Print_Triangle(8)\n\nEND PROGRAM Pascals_Triangle\n\nSUBROUTINE Print_Triangle(n)\n\n  IMPLICIT NONE\n  INTEGER, INTENT(IN) :: n\n  INTEGER :: c, i, j, k, spaces\n\n  DO i = 0, n-1\n     c = 1\n     spaces = 3 * (n - 1 - i)\n     DO j = 1, spaces\n        WRITE(*,\"(A)\", ADVANCE=\"NO\") \" \"\n     END DO\n     DO k = 0, i\n        WRITE(*,\"(I6)\", ADVANCE=\"NO\") c\n        c = c * (i - k) / (k + 1)\n     END DO\n     WRITE(*,*)\n  END DO\n\nEND SUBROUTINE Print_Triangle\n", "target": "def pascal(n):\n   \n   row = [1]\n   k = [0]\n   for x in range(max(n,0)):\n      print row\n      row=[l+r for l,r in zip(row+k,k+row)]\n   return n>=1\n"}
{"id": 80017, "name": "Logical operations", "source": "Translate Fortran to C#:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "using System;\n\nnamespace LogicalOperations\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            bool a = true, b = false;\n            Console.WriteLine(\"a and b is {0}\", a && b);\n            Console.WriteLine(\"a or b is {0}\", a || b);\n            Console.WriteLine(\"Not a is {0}\", !a);\n            Console.WriteLine(\"a exclusive-or b is {0}\", a ^ b);\n        }\n    }\n}\n"}
{"id": 80020, "name": "Logical operations", "source": "Translate Fortran to Java:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "boolean a = true;\nboolean b = false;\nSystem.Debug('a AND b: ' + (a && b));\nSystem.Debug('a OR b: ' + (a || b));\nSystem.Debug('NOT a: ' + (!a));\nSystem.Debug('a XOR b: ' + (a ^ b));\n"}
{"id": 80021, "name": "Logical operations", "source": "Translate Fortran to Python:        SUBROUTINE PRNLOG(A, B)\n       LOGICAL A, B\n       PRINT *, 'a and b is ', A .AND. B\n       PRINT *, 'a or b is ', A .OR. B\n       PRINT *, 'not a is ', .NOT. A\n       \nC       You did not ask, but the following logical operators are also standard\nC       since ANSI FORTRAN 66 \nC       =======================================================================\n       \nC       This yields the same results as .EQ., but has lower operator precedence\nC       and only works with LOGICAL operands:\n       PRINT *, 'a equivalent to b is ', A .EQV. B\n       \nC       This yields the same results as .NE., but has lower operator precedence\nC       and only works with LOGICAL operands (this operation is also commonly\nC       called \"exclusive or\"):\n       PRINT *, 'a not equivalent to b is ', A .NEQV. B\n       END\n", "target": "def logic(a, b):\n    print('a and b:', a and b)\n    print('a or b:', a or b)\n    print('not a:', not a)\n"}
{"id": 80345, "name": "Perfect shuffle", "source": "Translate Fortran to C#: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80346, "name": "Perfect shuffle", "source": "Translate Fortran to C#: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class PerfectShuffle\n{\n    static void Main()\n    {\n        foreach (int input in new [] {8, 24, 52, 100, 1020, 1024, 10000}) {\n            int[] numbers = Enumerable.Range(1, input).ToArray();\n            Console.WriteLine($\"{input} cards: {ShuffleThrough(numbers).Count()}\");\n        }\n\n        IEnumerable<T[]> ShuffleThrough<T>(T[] original) {\n            T[] copy = (T[])original.Clone();\n            do {\n                yield return copy = Shuffle(copy);\n            } while (!Enumerable.SequenceEqual(original, copy));\n        }\n    }\n\n    public static T[] Shuffle<T>(T[] array) {\n        if (array.Length % 2 != 0) throw new ArgumentException(\"Length must be even.\");\n        int half = array.Length / 2;\n        T[] result = new T[array.Length];\n        for (int t = 0, l = 0, r = half; l < half; t+=2, l++, r++) {\n            result[t] = array[l];\n            result[t+1] = array[r];\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 80352, "name": "Perfect shuffle", "source": "Translate Fortran to Java: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80353, "name": "Perfect shuffle", "source": "Translate Fortran to Java: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PerfectShuffle {\n\n    public static void main(String[] args) {\n        int[] sizes = {8, 24, 52, 100, 1020, 1024, 10_000};\n        for (int size : sizes)\n            System.out.printf(\"%5d\u00a0: %5d%n\", size, perfectShuffle(size));\n    }\n\n    static int perfectShuffle(int size) {\n        if (size % 2 != 0)\n            throw new IllegalArgumentException(\"size must be even\");\n\n        int half = size / 2;\n        int[] a = IntStream.range(0, size).toArray();\n        int[] original = a.clone();\n        int[] aa = new int[size];\n\n        for (int count = 1; true; count++) {\n            System.arraycopy(a, 0, aa, 0, size);\n\n            for (int i = 0; i < half; i++) {\n                a[2 * i] = aa[i];\n                a[2 * i + 1] = aa[i + half];\n            }\n\n            if (Arrays.equals(a, original))\n                return count;\n        }\n    }\n}\n"}
{"id": 80354, "name": "Perfect shuffle", "source": "Translate Fortran to Python: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80355, "name": "Perfect shuffle", "source": "Translate Fortran to Python: MODULE PERFECT_SHUFFLE\n     IMPLICIT NONE\n\n     CONTAINS\n\n     \n     FUNCTION SHUFFLE(NUM_ARR)\n          INTEGER, DIMENSION(:), INTENT(IN) :: NUM_ARR\n          INTEGER, DIMENSION(SIZE(NUM_ARR)) :: SHUFFLE\n          INTEGER :: I, IDX\n\n          IF (MOD(SIZE(NUM_ARR), 2) .NE. 0) THEN\n              WRITE(*,*) \"ERROR: SIZE OF DECK MUST BE EVEN NUMBER\"\n              CALL EXIT(1)\n          END IF\n\n          IDX = 1\n\n          DO I=1, SIZE(NUM_ARR)/2\n              SHUFFLE(IDX) = NUM_ARR(I)\n              SHUFFLE(IDX+1) = NUM_ARR(SIZE(NUM_ARR)/2+I)\n              IDX = IDX + 2\n          END DO\n\n    END FUNCTION SHUFFLE\n\n    \n    FUNCTION COMPARE_ARRAYS(ARRAY_1, ARRAY_2)\n        INTEGER, DIMENSION(:) :: ARRAY_1, ARRAY_2\n        LOGICAL :: COMPARE_ARRAYS\n        INTEGER :: I\n\n        DO I=1,SIZE(ARRAY_1)\n            IF (ARRAY_1(I) .NE. ARRAY_2(I)) THEN\n                COMPARE_ARRAYS = .FALSE.\n                RETURN\n            END IF\n        END DO\n\n        COMPARE_ARRAYS = .TRUE.\n    END FUNCTION COMPARE_ARRAYS\n\n    \n    FUNCTION GEN_DECK(DECK_SIZE)\n        INTEGER, INTENT(IN) :: DECK_SIZE\n        INTEGER, DIMENSION(DECK_SIZE) :: GEN_DECK\n        INTEGER :: I\n\n        GEN_DECK = (/(I, I=1,DECK_SIZE)/)\n    END FUNCTION GEN_DECK\nEND MODULE PERFECT_SHUFFLE\n\n\n\nPROGRAM DEMO_PERFECT_SHUFFLE\n    USE PERFECT_SHUFFLE\n    IMPLICIT NONE\n\n    INTEGER, PARAMETER, DIMENSION(7) :: DECK_SIZES = (/8, 24, 52, 100, 1020, 1024, 10000/)\n    INTEGER, DIMENSION(:), ALLOCATABLE :: DECK, SHUFFLED\n    INTEGER :: I, COUNTER\n\n    WRITE(*,'(A, A, A)') \"input (deck size)\", \" | \", \"output (number of shuffles required)\"\n    WRITE(*,*) REPEAT(\"-\", 55)\n\n    DO I=1, SIZE(DECK_SIZES)\n        IF (I .GT. 1) THEN\n            DEALLOCATE(DECK)\n            DEALLOCATE(SHUFFLED)\n        END IF\n        ALLOCATE(DECK(DECK_SIZES(I)))\n        ALLOCATE(SHUFFLED(DECK_SIZES(I)))\n        DECK = GEN_DECK(DECK_SIZES(I))\n        SHUFFLED = SHUFFLE(DECK)\n        COUNTER = 1\n        DO WHILE (.NOT. COMPARE_ARRAYS(DECK, SHUFFLED))\n            SHUFFLED = SHUFFLE(SHUFFLED)\n            COUNTER = COUNTER + 1\n        END DO\n\n        WRITE(*,'(I17, A, I35)') DECK_SIZES(I), \" | \", COUNTER\n   END DO\nEND PROGRAM DEMO_PERFECT_SHUFFLE\n", "target": "import doctest\nimport random\n\n\ndef flatten(lst):\n    \n    return [i for sublst in lst for i in sublst]\n\ndef magic_shuffle(deck):\n    \n    half = len(deck) // 2 \n    return flatten(zip(deck[:half], deck[half:]))\n\ndef after_how_many_is_equal(shuffle_type,start,end):\n    \n\n    start = shuffle_type(start)\n    counter = 1\n    while start != end:\n        start = shuffle_type(start)\n        counter += 1\n    return counter\n\ndef main():\n    doctest.testmod()\n\n    print(\"Length of the deck of cards | Perfect shuffles needed to obtain the same deck back\")\n    for length in (8, 24, 52, 100, 1020, 1024, 10000):\n        deck = list(range(length))\n        shuffles_needed = after_how_many_is_equal(magic_shuffle,deck,deck)\n        print(\"{} | {}\".format(length,shuffles_needed))\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 80628, "name": "Abstract type", "source": "Translate Fortran to C#:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "abstract class Class1\n{\n   public abstract void method1();\n\n   public int method2()\n   {\n      return 0;\n   }\n}\n"}
{"id": 80632, "name": "Abstract type", "source": "Translate Fortran to Java:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "public abstract class Abs {\n    public abstract int method1(double value);\n    protected abstract int method2(String name);\n    int add(int a, int b) {\n        return a + b;\n    }\n}\n"}
{"id": 80633, "name": "Abstract type", "source": "Translate Fortran to Python:  \n   \n   type, abstract :: TFigure\n      real(rdp) :: area\n   contains\n      \n      procedure(calculate_area), deferred, pass :: calculate_area\n   end type TFigure\n   \n   abstract interface\n      function  calculate_area(this)\n         import TFigure \n         implicit none\n         class(TFigure) :: this\n         real(rdp) :: calculate_area\n      end function calculate_area\n   end interface\n", "target": "class BaseQueue(object):\n    \n    def __init__(self):\n        self.contents = list()\n        raise NotImplementedError\n    def Enqueue(self, item):\n        raise NotImplementedError\n    def Dequeue(self):\n        raise NotImplementedError\n    def Print_Contents(self):\n        for i in self.contents:\n            print i,\n"}
{"id": 80858, "name": "Conway's Game of Life", "source": "Translate Fortran to C#:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "using System;\nusing System.Text;\nusing System.Threading;\n \nnamespace ConwaysGameOfLife\n{\n    \n    class Program\n    {\n        \n        private const int DELAY = 50;\n \n        \n        private const ConsoleColor DEAD_COLOR = ConsoleColor.White;\n        private const ConsoleColor LIVE_COLOR = ConsoleColor.Black;\n \n        \n        private const ConsoleColor EXTRA_COLOR = ConsoleColor.Gray;\n \n        private const char EMPTY_BLOCK_CHAR = ' ';\n        private const char FULL_BLOCK_CHAR = '\\u2588';\n \n        \n        private static bool[,] board;\n \n        \n        private static int width = 32;\n        private static int height = 32;\n \n        \n        private static bool loopEdges = true;\n \n \n        static void Main(string[] args)\n        {\n            \n            initializeDemoBoard();\n \n            initializeConsole();\n \n            \n            while (!Console.KeyAvailable || Console.ReadKey(true).Key != ConsoleKey.Escape) {\n                Program.drawBoard();\n                Program.updateBoard();\n \n                \n                Thread.Sleep(DELAY);\n            }\n        }\n \n        \n        private static void initializeConsole()\n        {\n            Console.BackgroundColor = EXTRA_COLOR;\n            Console.Clear();\n \n            Console.CursorVisible = false;\n \n            \n            \n            int width = Math.Max(Program.width, 8) * 2 + 1;\n            int height = Math.Max(Program.height, 8) + 1;\n            Console.SetWindowSize(width, height);\n            Console.SetBufferSize(width, height);\n \n            Console.BackgroundColor = DEAD_COLOR;\n            Console.ForegroundColor = LIVE_COLOR;\n        }\n \n        \n        private static void initializeRandomBoard()\n        {\n            var random = new Random();\n \n            Program.board = new bool[Program.width, Program.height];\n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    \n                    Program.board[x, y] = random.Next(2) == 0;\n                }\n            }\n        }\n \n        \n        private static void initializeDemoBoard()\n        {\n            Program.width = 3;\n            Program.height = 3;\n \n            Program.loopEdges = false;\n \n            Program.board = new bool[3, 3];\n            Program.board[1, 0] = true;\n            Program.board[1, 1] = true;\n            Program.board[1, 2] = true;\n        }\n \n        \n        private static void drawBoard()\n        {\n            \n            var builder = new StringBuilder();\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    char c = Program.board[x, y] ? FULL_BLOCK_CHAR : EMPTY_BLOCK_CHAR;\n \n                    \n                    builder.Append(c);\n                    builder.Append(c);\n                }\n                builder.Append('\\n');\n            }\n \n            \n            Console.SetCursorPosition(0, 0);\n            Console.Write (builder.ToString());\n        }\n \n        \n        private static void updateBoard()\n        {\n            \n            bool[,] newBoard = new bool[Program.width, Program.height];\n \n            for (var y = 0; y < Program.height; y++) {\n                for (var x = 0; x < Program.width; x++) {\n                    var n = countLiveNeighbors(x, y);\n                    var c = Program.board[x, y];\n \n                    \n                    \n                    newBoard[x, y] = c && (n == 2 || n == 3) || !c && n == 3;\n                }\n            }\n \n            \n            Program.board = newBoard;\n        }\n \n        \n        private static int countLiveNeighbors(int x, int y)\n        {\n            \n            int value = 0;\n \n            \n            for (var j = -1; j <= 1; j++) {\n                \n                if (!Program.loopEdges && y + j < 0 || y + j >= Program.height) {\n                    continue;\n                }\n \n                \n                int k = (y + j + Program.height) % Program.height;\n \n                for (var i = -1; i <= 1; i++) {\n                    \n                    if (!Program.loopEdges && x + i < 0 || x + i >= Program.width) {\n                        continue;\n                    }\n \n                    \n                    int h = (x + i + Program.width) % Program.width;\n \n                    \n                    value += Program.board[h, k] ? 1 : 0;\n                }\n            }\n \n            \n            return value - (Program.board[x, y] ? 1 : 0);\n        }\n    }\n}\n"}
{"id": 80862, "name": "Conway's Game of Life", "source": "Translate Fortran to Java:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "public class GameOfLife{\n\tpublic static void main(String[] args){\n\t\tString[] dish= {\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",\n\t\t\t\t\"_#_\",};\n\t\tint gens= 3;\n\t\tfor(int i= 0;i < gens;i++){\n\t\t\tSystem.out.println(\"Generation \" + i + \":\");\n\t\t\tprint(dish);\n\t\t\tdish= life(dish);\n\t\t}\n\t}\n\n\tpublic static String[] life(String[] dish){\n\t\tString[] newGen= new String[dish.length];\n\t\tfor(int row= 0;row < dish.length;row++){\n\t\t\tnewGen[row]= \"\";\n\t\t\tfor(int i= 0;i < dish[row].length();i++){\n\t\t\t\tString above= \"\";\n\t\t\t\tString same= \"\";\n\t\t\t\tString below= \"\";\n\t\t\t\tif(i == 0){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i, i + 2);\n\t\t\t\t}else if(i == dish[row].length() - 1){\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 1);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 1);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tabove= (row == 0) ? null : dish[row - 1].substring(i - 1,\n\t\t\t\t\t\t\t\t\ti + 2);\n\t\t\t\t\tsame= dish[row].substring(i - 1, i)\n\t\t\t\t\t\t\t\t\t+ dish[row].substring(i + 1, i + 2);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tbelow= (row == dish.length - 1) ? null : dish[row + 1]\n\t\t\t\t\t\t\t\t\t.substring(i - 1, i + 2);\n\t\t\t\t}\n\t\t\t\tint neighbors= getNeighbors(above, same, below);\n\t\t\t\tif(neighbors < 2 || neighbors > 3){\n\t\t\t\t\tnewGen[row]+= \"_\";\n\t\t\t\t}else if(neighbors == 3){\n\t\t\t\t\tnewGen[row]+= \"#\";\n\t\t\t\t}else{\n\t\t\t\t\tnewGen[row]+= dish[row].charAt(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newGen;\n\t}\n\n\tpublic static int getNeighbors(String above, String same, String below){\n\t\tint ans= 0;\n\t\tif(above != null){\n\t\t\tfor(char x: above.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\tfor(char x: same.toCharArray()){\n\t\t\tif(x == '#') ans++;\n\t\t}\n\t\tif(below != null){\n\t\t\tfor(char x: below.toCharArray()){\n\t\t\t\tif(x == '#') ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static void print(String[] dish){\n\t\tfor(String s: dish){\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}\n"}
{"id": 80863, "name": "Conway's Game of Life", "source": "Translate Fortran to Python:  PROGRAM LIFE_2D\n   IMPLICIT NONE\n \n   INTEGER, PARAMETER :: gridsize = 10\n   LOGICAL :: cells(0:gridsize+1,0:gridsize+1) = .FALSE.\n   INTEGER :: i, j, generation=0\n   REAL :: rnums(gridsize,gridsize)\n \n \n \n \n \n \n    cells(3:5,3:5) = .TRUE. ; cells(6:8,6:8) = .TRUE.                      \n \n \n \n   \n   CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   DO generation = 1, 8\n      CALL NextgenV2(cells)\n      CALL Drawgen(cells(1:gridsize, 1:gridsize), generation)\n   END DO\n \n CONTAINS\n \n   SUBROUTINE Drawgen(cells, gen)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER, INTENT(IN) :: gen\n \n     WRITE(*, \"(A,I0)\") \"Generation \", gen \n     DO i = 1, SIZE(cells,1)\n        DO j = 1, SIZE(cells,2)\n           IF (cells(i,j)) THEN\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \"#\"\n           ELSE\n              WRITE(*, \"(A)\", ADVANCE = \"NO\") \" \"\n           END IF\n        END DO\n        WRITE(*,*)\n     END DO\n     WRITE(*,*)\n   END SUBROUTINE Drawgen\n \n  SUBROUTINE Nextgen(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(0:,0:)\n     LOGICAL :: buffer(0:SIZE(cells, 1)-1, 0:SIZE(cells, 2)-1)\n     INTEGER :: neighbours, i, j\n   \n     buffer = cells   \n     DO j = 1, SIZE(cells, 2)-2\n        DO i = 1, SIZE(cells, 1)-2\n          if(buffer(i, j)) then\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1)) - 1\n          else\n            neighbours = sum(count(buffer(i-1:i+1, j-1:j+1), 1))\n          end if\n  \n          SELECT CASE(neighbours)\n            CASE (0:1, 4:8)\n               cells(i,j) = .FALSE.\n  \n            CASE (2)\n               \n  \n            CASE (3)\n               cells(i,j) = .TRUE.\n          END SELECT\n          \n        END DO\n     END DO\n  END SUBROUTINE Nextgen\n\n\n\n\n\n\n\n\n  PURE SUBROUTINE NextgenV2(cells)\n     LOGICAL, INTENT(IN OUT) :: cells(:,:)\n     INTEGER(KIND=1) :: buffer(1:SIZE(cells, 1)-2,1:SIZE(cells, 2)-2)\n     INTEGER :: gridsize, i, j\n     \n     gridsize=SIZE(cells, 1)\n     buffer=0\n     \n     DO j=-1, 1\n        DO i=-1,1\n           IF(i==0 .AND. j==0) CYCLE\n           WHERE(cells(i+2:gridsize-i-1,j+2:gridsize-j-1)) buffer=buffer+1\n        END DO\n     END DO\n\n     WHERE(buffer<2 .or. buffer>3) cells(2:gridsize-1,2:gridsize-1) = .FALSE.\n     WHERE(buffer==3) cells(2:gridsize-1,2:gridsize-1) = .TRUE.\n  END SUBROUTINE NextgenV2\n\n END PROGRAM LIFE_2D\n", "target": "cell_size = 10\nsample = 10 \nplay = False   \nlast_cell = 0\n\ndef setup():\n    global grid, next_grid, rows, cols\n    size(800, 500)\n\n    rows = height / cell_size\n    cols = width / cell_size\n    grid = empty_grid()\n    next_grid = empty_grid()\n    randomize_grid()\n\n    println(\"Press 'space' to start/stop\")\n    println(\"'e' to clear all cells\")\n    println(\"'b' demonstrate 'blinker'\")\n    println(\"'g' demonstrate glider\")\n    println(\"'r' to randomize grid\")\n    println(\"'+' and '-' to change speed\")\n\ndef draw():\n    background(0)\n    for i in range(cols):\n        x = i * cell_size\n        for j in range(rows):\n            y = j * cell_size\n            current_state = grid[i][j]\n            fill(255)\n            noStroke()\n            if current_state:\n                rect(x, y, cell_size, cell_size)\n            if play:\n                ngbs_alive = calc_ngbs_alive(i, j)\n                result = rule(current_state, ngbs_alive)\n                next_grid[i][j] = result\n                \n    if play and frameCount % sample == 0 and not mousePressed:\n        step()\n\ndef rule(current, ngbs):\n    \n    if ngbs < 2 or ngbs > 3:\n        return 0  \n    elif ngbs == 3:\n        return 1  \n    else:\n        return current  \n\ndef calc_ngbs_alive(i, j):\n    NEIGHBOURS = ((-1, 00), (01, 00),  \n                  (-1, -1), (00, -1),\n                  (01, -1), (-1, 01),\n                  (00, 01), (01, 01))\n    alive = 0\n    for iv, jv in NEIGHBOURS:\n        alive += grid[(i + iv) % cols][(j + jv) % rows]\n    return alive\n\ndef empty_grid():\n    grid = []\n    for _ in range(cols):\n        grid.append([0] * rows)\n    return grid\n\ndef randomize_grid():\n    from random import choice\n    for i in range(cols):\n        for j in range(rows):\n            grid[i][j] = choice((0, 1))\n\ndef step():\n    global grid, next_grid\n    grid = next_grid\n    next_grid = empty_grid()\n\ndef keyReleased():\n    global grid, play, sample\n    if key == \"e\":\n        grid = empty_grid()\n    if key == \"r\":\n        randomize_grid()\n    if key == \"g\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 0, 1]       \n         grid[12][10:13] = [1, 1, 1]       \n    if key == \"b\":\n         grid[10][10:13] = [0, 1, 0]       \n         grid[11][10:13] = [0, 1, 0]       \n         grid[12][10:13] = [0, 1, 0]               \n    if key == \" \":\n        play = not play \n    if  str(key) in '+=':\n        sample = max(sample - 1, 1);\n    if key == '-':\n        sample += 1\n\ndef mousePressed():\n    paint()\n    \ndef mouseDragged():\n    paint()\n\ndef paint():\n    global last_cell\n    i, j = mouseX // cell_size, mouseY // cell_size\n    p = j * cols + i\n    if p != last_cell:\n        last_cell = p\n        grid[i][j] = (1, 0)[grid[i][j]]\n"}
{"id": 81529, "name": "Compile-time calculation", "source": "Translate Fortran to C#:  program test\n\n   implicit none\n   integer,parameter :: t = 10*9*8*7*6*5*4*3*2  \n\n   write(*,*) t  \n\n end program test\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81530, "name": "Compile-time calculation", "source": "Translate Fortran to C#:  program test\n\n   implicit none\n   integer,parameter :: t = 10*9*8*7*6*5*4*3*2  \n\n   write(*,*) t  \n\n end program test\n", "target": "using System;\n\npublic static class Program\n{\n    public const int FACTORIAL_10 = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1;\n    static void Main()\n    {\n        Console.WriteLine(FACTORIAL_10);\n    }\n}\n"}
{"id": 81910, "name": "Gaussian elimination", "source": "Translate Fortran to C#:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 81911, "name": "Gaussian elimination", "source": "Translate Fortran to C#:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal void ElimPartial(Vector B)\n        {\n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                SwapRows(diag, max_row);\n                B.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                    this[diag, col] *= invd;\n                B[diag] *= invd;\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < cols; col++)\n                            this[row, col] -= d * this[diag, col];\n                        B[row] -= d * B[diag];\n                    }\n                }\n            }\n        }\n        \n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 81916, "name": "Gaussian elimination", "source": "Translate Fortran to Java:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 81917, "name": "Gaussian elimination", "source": "Translate Fortran to Java:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "import java.util.Locale;\n\npublic class GaussianElimination {\n    public static double solve(double[][] a, double[][] b) {\n        if (a == null || b == null || a.length == 0 || b.length == 0) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n        \n        int n = b.length, p = b[0].length;\n        if (a.length != n || a[0].length != n) {\n            throw new IllegalArgumentException(\"Invalid dimensions\");\n        }\n\n        double det = 1.0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int k = i;\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(a[j][i]) > Math.abs(a[k][i])) {\n                    k = j;\n                }\n            }\n            \n            if (k != i) {\n                det = -det;\n                \n                for (int j = i; j < n; j++) {\n                    double s = a[i][j];\n                    a[i][j] = a[k][j];\n                    a[k][j] = s;\n                }\n\n                for (int j = 0; j < p; j++) {\n                    double s = b[i][j];\n                    b[i][j] = b[k][j];\n                    b[k][j] = s;\n                }\n            }\n            \n            for (int j = i + 1; j < n; j++) {\n                double s = a[j][i] / a[i][i];\n                for (k = i + 1; k < n; k++) {\n                    a[j][k] -= s * a[i][k];\n                }\n                \n                for (k = 0; k < p; k++) {\n                    b[j][k] -= s * b[i][k];\n                }\n            }\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                double s = a[i][j];\n                for (int k = 0; k < p; k++) {\n                    b[i][k] -= s * b[j][k];\n                }\n            }\n            double s = a[i][i];\n            det *= s;\n            for (int k = 0; k < p; k++) {\n                b[i][k] /= s;\n            }\n        }\n        \n        return det;\n    }\n    \n    public static void main(String[] args) {\n        double[][] a = new double[][] {{4.0, 1.0, 0.0, 0.0, 0.0},\n                                       {1.0, 4.0, 1.0, 0.0, 0.0},\n                                       {0.0, 1.0, 4.0, 1.0, 0.0},\n                                       {0.0, 0.0, 1.0, 4.0, 1.0},\n                                       {0.0, 0.0, 0.0, 1.0, 4.0}};\n\n        double[][] b = new double[][] {{1.0 / 2.0},\n                                       {2.0 / 3.0},\n                                       {3.0 / 4.0},\n                                       {4.0 / 5.0},\n                                       {5.0 / 6.0}};\n                                       \n        double[] x = {39.0 / 400.0,\n                      11.0 / 100.0,\n                      31.0 / 240.0,\n                      37.0 / 300.0,\n                      71.0 / 400.0};\n                                       \n        System.out.println(\"det: \" + solve(a, b));\n        \n\n        for (int i = 0; i < 5; i++) {\n            System.out.printf(Locale.US, \"%12.8f %12.4e\\n\", b[i][0], b[i][0] - x[i]);\n        }\n    }\n}\n"}
{"id": 81918, "name": "Gaussian elimination", "source": "Translate Fortran to Python:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 81919, "name": "Gaussian elimination", "source": "Translate Fortran to Python:         program ge\n\n          real, allocatable :: a(:,:),b(:)\n          a = reshape(                             &\n          [1.0, 1.00, 1.00,  1.00,   1.00,   1.00, &\n           0.0, 0.63, 1.26,  1.88,   2.51,   3.14, &\n           0.0, 0.39, 1.58,  3.55,   6.32,   9.87, &\n           0.0, 0.25, 1.98,  6.70,  15.88,  31.01, &\n           0.0, 0.16, 2.49, 12.62,  39.90,  97.41, &\n           0.0, 0.10, 3.13, 23.80, 100.28, 306.02], [6,6] )\n          b = [-0.01, 0.61, 0.91, 0.99, 0.60, 0.02]\n          print'(f15.7)',solve_wbs(ge_wpp(a,b))\n\n        contains\n  \n          function solve_wbs(u) result(x) \n            real                 :: u(:,:)\n            integer              :: i,n\n            real   , allocatable :: x(:)\n            n = size(u,1)\n            allocate(x(n))\n            forall (i=n:1:-1) x(i) = ( u(i,n+1) - sum(u(i,i+1:n)*x(i+1:n)) ) / u(i,i)\n          end function\n\n          function  ge_wpp(a,b) result(u) \n            real                 :: a(:,:),b(:),upi\n            integer              :: i,j,n,p\n            real   , allocatable :: u(:,:)\n            n = size(a,1)\n            u = reshape( [a,b], [n,n+1] )\n            do j=1,n\n              p = maxloc(abs(u(j:n,j)),1) + j-1 \n              if (p /= j) u([p,j],j) = u([j,p],j)\n              u(j+1:,j) = u(j+1:,j)/u(j,j)\n              do i=j+1,n+1\n                upi = u(p,i)\n                if (p /= j) u([p,j],i) = u([j,p],i)\n                u(j+1:n,i) = u(j+1:n,i) - upi*u(j+1:n,j)\n              end do\n            end do\n          end function\n\n        end program\n", "target": "\n\n\nimport copy\nfrom fractions import Fraction\n\ndef gauss(a, b):\n    a = copy.deepcopy(a)\n    b = copy.deepcopy(b)\n    n = len(a)\n    p = len(b[0])\n    det = 1\n    for i in range(n - 1):\n        k = i\n        for j in range(i + 1, n):\n            if abs(a[j][i]) > abs(a[k][i]):\n                k = j\n        if k != i:\n            a[i], a[k] = a[k], a[i]\n            b[i], b[k] = b[k], b[i]\n            det = -det\n            \n        for j in range(i + 1, n):\n            t = a[j][i]/a[i][i]\n            for k in range(i + 1, n):\n                a[j][k] -= t*a[i][k]\n            for k in range(p):\n                b[j][k] -= t*b[i][k]\n                \n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            t = a[i][j]\n            for k in range(p):\n                b[i][k] -= t*b[j][k]\n        t = 1/a[i][i]\n        det *= a[i][i]\n        for j in range(p):\n            b[i][j] *= t\n    return det, b\n\ndef zeromat(p, q):\n    return [[0]*q for i in range(p)]\n\ndef matmul(a, b):\n    n, p = len(a), len(a[0])\n    p1, q = len(b), len(b[0])\n    if p != p1:\n        raise ValueError(\"Incompatible dimensions\")\n    c = zeromat(n, q)\n    for i in range(n):\n        for j in range(q):\n                c[i][j] = sum(a[i][k]*b[k][j] for k in range(p))\n    return c\n\n\ndef mapmat(f, a):\n    return [list(map(f, v)) for v in a]\n\ndef ratmat(a):\n    return mapmat(Fraction, a)\n\n\n\na = [[2, 9, 4], [7, 5, 3], [6, 1, 8]]\nb = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\ndet, c = gauss(a, b)\n\ndet\n-360.0\n\nc\n[[-0.10277777777777776, 0.18888888888888888, -0.019444444444444438],\n[0.10555555555555554, 0.02222222222222223, -0.061111111111111116],\n[0.0638888888888889, -0.14444444444444446, 0.14722222222222223]]\n\n\nmatmul(a, c)\n[[1.0, 0.0, 0.0], [5.551115123125783e-17, 1.0, 0.0],\n[1.1102230246251565e-16, -2.220446049250313e-16, 1.0]]\n\n\n\ndet, c = gauss(ratmat(a), ratmat(b))\n\ndet\nFraction(-360, 1)\n\nc\n[[Fraction(-37, 360), Fraction(17, 90), Fraction(-7, 360)],\n[Fraction(19, 180), Fraction(1, 45), Fraction(-11, 180)],\n[Fraction(23, 360), Fraction(-13, 90), Fraction(53, 360)]]\n\nmatmul(a, c)\n[[Fraction(1, 1), Fraction(0, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(1, 1), Fraction(0, 1)],\n[Fraction(0, 1), Fraction(0, 1), Fraction(1, 1)]]\n"}
{"id": 82617, "name": "Averages_Pythagorean means", "source": "Translate Fortran to C#: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82618, "name": "Averages_Pythagorean means", "source": "Translate Fortran to C#: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace PythMean\n{\n    static class Program\n    {\n        static void Main(string[] args) {\n            var nums = from n in Enumerable.Range(1, 10) select (double)n;\n\n            var a = nums.Average();\n            var g = nums.Gmean();\n            var h = nums.Hmean();\n\n            Console.WriteLine(\"Arithmetic mean {0}\", a);\n            Console.WriteLine(\"Geometric mean  {0}\", g);\n            Console.WriteLine(\"Harmonic mean   {0}\", h);\n\n            Debug.Assert(a >= g && g >= h);\n        }\n\n        \n        static double Gmean(this IEnumerable<double> n) {\n            return Math.Pow(n.Aggregate((s, i) => s * i), 1.0 / n.Count());\n        }\n\n        \n        static double Hmean(this IEnumerable<double> n) {\n            return n.Count() / n.Sum(i => 1.0 / i);\n        }\n    }\n}\n"}
{"id": 82623, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Java: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82624, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Java: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class PythagoreanMeans {\n    public static double arithmeticMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += number;\n        }\n        return mean / numbers.size();\n    }\n\n    public static double geometricMean(List<Double> numbers) {\n        if (numbers.isEmpty()) return Double.NaN;\n        double mean = 1.0;\n        for (Double number : numbers) {\n            mean *= number;\n        }\n        return Math.pow(mean, 1.0 / numbers.size());\n    }\n\n    public static double harmonicMean(List<Double> numbers) {\n        if (numbers.isEmpty() || numbers.contains(0.0)) return Double.NaN;\n        double mean = 0.0;\n        for (Double number : numbers) {\n            mean += (1.0 / number);\n        }\n        return numbers.size() / mean;\n    }\n\n    public static void main(String[] args) {\n        Double[] array = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n        List<Double> list = Arrays.asList(array);\n        double arithmetic = arithmeticMean(list);\n        double geometric = geometricMean(list);\n        double harmonic = harmonicMean(list);\n        System.out.format(\"A = %f  G = %f  H = %f%n\", arithmetic, geometric, harmonic);\n        System.out.format(\"A >= G is %b, G >= H is %b%n\", (arithmetic >= geometric), (geometric >= harmonic));\n    }\n}\n"}
{"id": 82625, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Python: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
{"id": 82626, "name": "Averages_Pythagorean means", "source": "Translate Fortran to Python: program Mean\n\n  real :: a(10) = (/ (i, i=1,10) /)\n  real :: amean, gmean, hmean\n\n  amean = sum(a) / size(a)\n  gmean = product(a)**(1.0/size(a))\n  hmean = size(a) / sum(1.0/a)\n\n  if ((amean < gmean) .or. (gmean < hmean)) then\n    print*, \"Error\n  else\n    print*, amean, gmean, hmean\n  end if\n\nend program Mean\n", "target": "from operator import mul\nfrom functools import reduce\n\n\ndef amean(num):\n    return sum(num) / len(num)\n\n\ndef gmean(num):\n    return reduce(mul, num, 1)**(1 / len(num))\n\n\ndef hmean(num):\n    return len(num) / sum(1 / n for n in num)\n\n\nnumbers = range(1, 11)  \na, g, h = amean(numbers), gmean(numbers), hmean(numbers)\nprint(a, g, h)\nassert a >= g >= h\n"}
